WEBVTT
Kind: subtitles
Language: zh-TW

00:00:00.000 --> 00:00:09.881
[音樂播放]

00:00:09.881 --> 00:00:14.310
大家好，Angular 社群

00:00:14.310 --> 00:00:15.673
我叫 Dylan Hunn

00:00:15.673 --> 00:00:18.740
是 Angular 框架團隊的一名軟體工程師

00:00:18.740 --> 00:00:20.020
在過去的八個月裡

00:00:20.020 --> 00:00:22.430
我們一直致力於改進 Angular 表單

00:00:22.430 --> 00:00:26.480
非常高興今天能與你分享這項新功能

00:00:26.480 --> 00:00:30.115
型別化表單是 Angular 14 的一部分

00:00:30.115 --> 00:00:33.750
今天就可以開始遷移你的應用程式了

00:00:33.750 --> 00:00:35.328
在深入細節之前

00:00:35.328 --> 00:00:38.400
讓我們先了解一下響應式表單的背景知識

00:00:38.400 --> 00:00:42.556
對於建構或維護表單應用程式的人來說

00:00:42.556 --> 00:00:44.580
這可能已經很熟悉了

00:00:44.580 --> 00:00:48.466
響應式表單是在 Angular 中
建構表單的一種方式

00:00:48.380 --> 00:00:50.543
與範本驅動的表單相比

00:00:50.543 --> 00:00:57.033
它們使用 RxJS 和 Observables 提供了更
明確的資料模型和狀態管理

00:00:56.930 --> 00:00:59.150
它們並不總是正確的選擇

00:00:59.150 --> 00:01:01.791
範本驅動的表單不那麼冗長

00:01:01.791 --> 00:01:04.010
對於某些場景來說會更合適

00:01:04.010 --> 00:01:08.222
我們今天要看到的這些新型別
僅適用於響應式表單

00:01:08.130 --> 00:01:10.450
這是我們要注意的地方

00:01:10.450 --> 00:01:12.590
讓我們從一些背景開始

00:01:12.590 --> 00:01:19.722
瞭解為什麼要進行這種更改以及它如何使
大多數使用響應式表單的應用程式受益

00:01:19.620 --> 00:01:20.413
長期以來

00:01:20.413 --> 00:01:24.908
型別化表單一直是 Angular 社群中
投票最多的功能請求

00:01:24.820 --> 00:01:28.790
此外，此更改為許多未來的改進掃清了道路

00:01:28.790 --> 00:01:35.365
例如更好的控制項狀態變更事件、
更嚴格的範本型別檢查等等

00:01:35.240 --> 00:01:36.987
在設計型別化表單時

00:01:36.987 --> 00:01:39.350
我們試圖遵循一個大方向

00:01:39.350 --> 00:01:42.900
特別是，我們有四項指導原則

00:01:42.900 --> 00:01:45.650
首先，我們希望它是強型別的

00:01:45.650 --> 00:01:50.356
你應該能夠自信地修改任何複雜表單

00:01:50.356 --> 00:01:54.820
無論你的表單組或表單控制項的巢狀(Nesting)有多深

00:01:54.820 --> 00:01:58.450
其次，我們不想完全取代原有的表單

00:01:58.450 --> 00:02:03.689
我們希望擁有一個協同前行的統一生態系統

00:02:03.570 --> 00:02:06.329
第三，我們希望表單儘可能安全

00:02:06.329 --> 00:02:08.201
當你存取值或控制項時

00:02:08.201 --> 00:02:11.650
你的型別中的任何內容都不會讓人嚇一跳

00:02:11.650 --> 00:02:12.247
第四

00:02:12.247 --> 00:02:16.190
你應該能夠按照自己的步調逐步遷移

00:02:16.190 --> 00:02:20.850
哪怕你的應用程式中有很多現有的表單程式碼

00:02:20.850 --> 00:02:23.970
現在我們來考慮一個例子

00:02:23.970 --> 00:02:27.187
通常，每個表單都對應一個模式

00:02:27.187 --> 00:02:30.060
或者說你要收集的資料的形態

00:02:30.060 --> 00:02:33.030
這是代表派對的範例架構

00:02:33.030 --> 00:02:40.733
它具有內部物件（這裡是地址欄位）和
內部陣列（這裡是派對選單）

00:02:40.620 --> 00:02:44.421
沒必要總是顯式宣告你的架構

00:02:44.421 --> 00:02:49.270
但在處理複雜表單時考慮一下還是有好處的

00:02:49.270 --> 00:02:53.180
這裡我們就明確聲明瞭表單模型

00:02:53.180 --> 00:02:57.280
這是舉辦派對的相應表單

00:02:57.280 --> 00:03:04.502
它接受各方地址、選單以及你可能需要的任
何其他表單控制項的輸入

00:03:04.380 --> 00:03:10.320
以前，與這麼複雜的表單模型互動可能很危險

00:03:10.320 --> 00:03:13.380
例如，這段程式碼就包含一個微妙的錯誤

00:03:13.380 --> 00:03:19.689
place 的值為 number，在其上呼叫 substring 將在執行時崩潰

00:03:19.580 --> 00:03:21.593
現在，有了型別化表單

00:03:21.593 --> 00:03:25.821
這個錯誤在編譯時就會被你的編輯器捕獲

00:03:25.720 --> 00:03:28.660
這些新型別滲透到各種 API 中

00:03:28.660 --> 00:03:39.068
在存取表單值、獲取深層巢狀(Nesting)控制項、訂閱 Observables
等幾乎任何與表單 API 互動的點時

00:03:39.068 --> 00:03:41.174
你都會從中受益

00:03:41.050 --> 00:03:43.520
這將大大提高安全性

00:03:43.520 --> 00:03:47.810
防止簡單的拼寫錯誤和更復雜的錯誤

00:03:47.810 --> 00:03:53.223
這些型別還允許在你的編輯器中使用強大的
自動完成功能

00:03:53.110 --> 00:03:57.190
在派對錶單範例中，當存取表單的值時

00:03:57.190 --> 00:04:00.670
IDE 會建議表單的每個已知子項

00:04:00.670 --> 00:04:05.680
這有助於你自信地瀏覽最複雜的表單

00:04:05.680 --> 00:04:08.294
雖然這是一個很大的變化

00:04:08.294 --> 00:04:12.500
但它 100% 向後相容所有現有的表單程式碼

00:04:12.500 --> 00:04:15.361
當你更新到 Angular 14 時

00:04:15.361 --> 00:04:18.680
你的表單將自動排除這些新型別

00:04:18.680 --> 00:04:20.927
然後，當你準備就緒時

00:04:20.927 --> 00:04:24.410
你可以每次在一個控制項上開啟它們

00:04:24.410 --> 00:04:27.219
並按照自己的步調逐步遷移

00:04:27.220 --> 00:04:30.225
現在你已經掌握了基礎知識

00:04:30.225 --> 00:04:32.750
讓我們探索實際的型別

00:04:32.750 --> 00:04:36.760
好，剛才我們看到了一個建立派對的模式

00:04:36.760 --> 00:04:41.664
現在讓我們看一下與該派對的表單相對應的
一些實際程式碼

00:04:41.570 --> 00:04:43.348
讓我們進入範本

00:04:43.348 --> 00:04:46.810
我們將新增一個用於舉辦派對的新按鈕

00:04:46.810 --> 00:04:50.170
我們將呼叫 partyInSF 便捷函式

00:04:50.170 --> 00:04:53.460
現在我們將跳轉到相應的元件

00:04:53.460 --> 00:04:57.481
我們將新增用於舉辦派對的便捷函式

00:04:57.480 --> 00:05:00.870
我們將從所在元件存取 this.party

00:05:00.870 --> 00:05:04.020
這對應於所有參與者資料的表單組

00:05:04.020 --> 00:05:09.822
我們將呼叫此表單組的 setValue 以賦予其新值

00:05:09.690 --> 00:05:13.650
但是，請注意我們這裡忘了寫門牌號

00:05:13.650 --> 00:05:16.906
TypeScript 會警告我們這裡缺少一個鍵

00:05:16.906 --> 00:05:19.891
因為它期望當我們呼叫一個設定值時

00:05:19.891 --> 00:05:21.610
組中的所有鍵都存在

00:05:21.610 --> 00:05:23.080
好，讓我們繼續新增它

00:05:23.080 --> 00:05:25.073
請注意，在我鍵入時

00:05:25.073 --> 00:05:29.390
新的 TypeScript 型別也支援自動完成功能

00:05:29.390 --> 00:05:31.360
但是，我這裡仍然有錯誤

00:05:31.360 --> 00:05:34.240
型別系統不只是檢查缺失的屬性

00:05:34.240 --> 00:05:39.620
它還會檢查物件中的所有名稱和所有型別

00:05:39.620 --> 00:05:41.247
特別是在這裡

00:05:41.247 --> 00:05:43.639
雖然我目前有一個名為 number 的鍵

00:05:43.639 --> 00:05:45.840
但我想要的是名為 house 的鍵

00:05:45.840 --> 00:05:49.350
另一種選擇是改為對值打補丁（patch）

00:05:49.350 --> 00:05:52.819
這仍然可以保護我們免受嚴重的型別錯誤

00:05:52.819 --> 00:05:56.100
但放寬了要求我們擁有全部鍵的約束

00:05:56.100 --> 00:05:59.250
特別是，我們要有 street 鍵

00:05:59.250 --> 00:06:01.270
現在讓我們考慮另一種情況

00:06:01.270 --> 00:06:03.044
假設一位鄰居投訴了噪音

00:06:03.044 --> 00:06:05.280
我們想弄清楚是哪個鄰居投訴的

00:06:05.280 --> 00:06:08.700
那我們就可以在元件上新增一個新方法

00:06:08.700 --> 00:06:10.491
我們可以使用 get 方法

00:06:10.410 --> 00:06:15.839
get 方法接受一個字串並將自動標記
字串中的每個欄位

00:06:15.839 --> 00:06:17.950
允許我們存取內部控制項

00:06:17.850 --> 00:06:20.580
請注意型別是正確計算的

00:06:20.580 --> 00:06:23.217
在這種情況下，我們實際上又出現了錯誤

00:06:23.217 --> 00:06:26.777
那是因為我們正在嘗試用字串進行算術運算

00:06:26.700 --> 00:06:30.480
這個錯誤告訴我們應該使用 house 鍵

00:06:30.480 --> 00:06:31.740
而不是 number

00:06:31.740 --> 00:06:35.211
現在你已經近距離觀察了這些新型別

00:06:35.211 --> 00:06:38.051
讓我們深入瞭解設計細節

00:06:38.050 --> 00:06:38.535
接下來

00:06:38.535 --> 00:06:42.120
請考慮我們剛才看到的用於地址的表單組

00:06:42.120 --> 00:06:46.681
本例中 address.controls 的型別應該是什麼？

00:06:46.681 --> 00:06:47.658
另一方面

00:06:47.658 --> 00:06:51.024
address.value 的型別應該是什麼？

00:06:51.024 --> 00:06:52.870
使用型別化表單時

00:06:52.870 --> 00:06:56.888
瞭解值型別與控制項型別之間的區別很重要

00:06:56.780 --> 00:06:59.867
正如我們之前在派對範例中看到的那樣

00:06:59.867 --> 00:07:01.190
值就是資料的形態

00:07:01.190 --> 00:07:06.300
例如，在這裡，street 欄位的型別為字串

00:07:06.300 --> 00:07:09.750
另一方面，你也可以存取控制項

00:07:09.750 --> 00:07:13.197
在這裡，street 欄位是一個表單控制項

00:07:13.197 --> 00:07:15.150
其中有一個字串

00:07:15.150 --> 00:07:18.190
型別化表單大量使用控制項型別

00:07:18.190 --> 00:07:21.613
雖然你很少需要指定顯式型別

00:07:21.613 --> 00:07:23.515
但如果你這樣做

00:07:23.515 --> 00:07:26.431
你應該始終使用控制項型別

00:07:26.430 --> 00:07:30.570
另一個有趣的話題是重置控制項

00:07:30.570 --> 00:07:35.200
讓我們考慮最簡單的形式，只有一個控制項

00:07:35.200 --> 00:07:37.215
當我們考慮這個控制項時

00:07:37.215 --> 00:07:39.230
我們首先看到它包含一個字串

00:07:39.230 --> 00:07:43.130
所以我們可能期望型別是字串的表單控制項

00:07:43.130 --> 00:07:46.060
但是，有一個棘手的細節

00:07:46.060 --> 00:07:48.355
當你使用表單控制項時

00:07:48.355 --> 00:07:50.650
你可以隨時呼叫重置

00:07:50.650 --> 00:07:52.955
當發生這種情況時

00:07:52.955 --> 00:07:56.480
控制項的值將立即重置為 null

00:07:56.480 --> 00:08:01.729
這意味著你不能總是假設控制項的值是一個字串

00:08:01.610 --> 00:08:04.253
在以前的 Angular 版本中

00:08:04.253 --> 00:08:06.566
此範例會在執行時崩潰

00:08:06.566 --> 00:08:09.760
因為你無法對空值呼叫子字串

00:08:09.760 --> 00:08:14.352
Angular 14 現在可以保護你免受此類錯誤
的影響

00:08:14.352 --> 00:08:18.332
因為此範例中狗控制項的型別是字串或空值

00:08:18.230 --> 00:08:22.520
但有時，這實際上並不是你想要的行為

00:08:22.520 --> 00:08:23.401
事實上

00:08:23.401 --> 00:08:29.696
許多現有形式的應用程式並不依賴於控制項的
現有可空性

00:08:29.570 --> 00:08:31.227
在 Angular 14 中

00:08:31.227 --> 00:08:35.418
表單控制項有一個名為 nonNullable 的全新選項

00:08:35.320 --> 00:08:37.899
控制項不會重置為 null

00:08:37.899 --> 00:08:40.350
而是重置為其初始值

00:08:40.350 --> 00:08:41.508
如你所料

00:08:41.508 --> 00:08:45.110
這還會從控制項型別中刪除 null

00:08:45.110 --> 00:08:48.540
在這個例子中，我們已經完全擺脫了空值

00:08:48.540 --> 00:08:53.070
現在呼叫 substring 是完全安全的

00:08:53.070 --> 00:08:58.900
相關領域涉及禁用控制項及其對錶單值的影響

00:08:58.900 --> 00:09:00.861
對於 Angular 表單

00:09:00.861 --> 00:09:04.020
禁用的控制項不包含在表單的值中

00:09:04.020 --> 00:09:09.653
這類似於原生 HTML 表單在其控制項被禁用時
的行為方式

00:09:09.540 --> 00:09:13.650
但是，這會影響表單的型別

00:09:13.650 --> 00:09:15.342
當你呼叫 .value 時

00:09:15.342 --> 00:09:18.840
表單組中的任何鍵都可能已被禁用

00:09:18.840 --> 00:09:22.590
結果，該型別知道每個鍵都是可選的

00:09:22.590 --> 00:09:24.730
當你使用此值時

00:09:24.730 --> 00:09:31.293
型別系統會強制你處理每個鍵都可能未定義的情況

00:09:31.150 --> 00:09:34.830
在此範例中，當使用 cat.value 時

00:09:34.830 --> 00:09:38.747
cat 表單組中的所有欄位都是可選的

00:09:38.747 --> 00:09:41.240
因為它們可能已被禁用

00:09:41.240 --> 00:09:41.835
然而

00:09:41.835 --> 00:09:47.309
這並不是我們可能在表單中使用可選鍵的唯
一情況

00:09:47.190 --> 00:09:51.460
有時你希望能夠自由地從表單中刪除鍵

00:09:51.460 --> 00:09:51.992
例如

00:09:51.992 --> 00:09:56.140
這裡我們對名稱 name 呼叫 removeControl

00:09:56.140 --> 00:09:57.819
使用型別化表單

00:09:57.819 --> 00:10:01.736
我們現在可以明確指定哪些鍵是可選的

00:10:01.736 --> 00:10:03.191
哪些是必選的

00:10:03.190 --> 00:10:09.624
這允許型別系統強制我們安全地處理
可能丟失的控制項

00:10:09.490 --> 00:10:11.785
對於完全動態的表單組

00:10:11.785 --> 00:10:15.173
你希望在其中新增或刪除許多控制項

00:10:15.173 --> 00:10:20.419
我們還引入了一種名為 FormRecord 的全新
伴隨型別

00:10:20.310 --> 00:10:23.584
這裡的型別改進是廣泛而深入的

00:10:23.584 --> 00:10:26.180
還有更多值得興奮的地方

00:10:26.180 --> 00:10:33.658
你可以在 angular.io 上提供的新增
《型別表單》指南中深入閱讀它們

00:10:33.658 --> 00:10:36.191
並在下面的描述中連結

00:10:36.070 --> 00:10:40.448
我們對 Angular 14 和型別化表單的未來
感到非常興奮

00:10:40.360 --> 00:10:46.221
我們希望你和我們一樣對這個專案和
整個表單套件的未來感到興奮

00:10:46.120 --> 00:10:48.430
請點贊和訂閱，感謝你的收看

00:10:48.430 --> 00:10:49.180
下次見

00:10:49.180 --> 00:10:52.230
[音樂播放]
