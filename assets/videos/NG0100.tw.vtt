WEBVTT
Kind: subtitles
Language: zh-TW

00:00.480 --> 00:03.000
ExpressionChangedAfterItHasBeenCheckedError.

00:03.000 --> 00:08.720
如果你的程式碼在執行完變更檢測
並建構好檢視之後又修改了某個值，就會遇到本錯誤

00:08.720 --> 00:12.480
你只會在開發模式下看到本錯誤
因為 Angular 會執行一次額外的

00:12.480 --> 00:16.480
變更檢測來捕獲此類錯誤
此類錯誤會導致古怪的 UI 行為

00:16.480 --> 00:21.520
這次額外的檢查可以確保應用已進入穩定態
對資料的所有更新都已經反映到了檢視上

00:21.520 --> 00:25.499
有很多原因都可能導致檢視處於不一致狀態

00:25.499 --> 00:30.960
比如某些程式碼在 AfterViewInit 鉤子中更新了檢視
或變更檢測觸發器自身進入了無限迴圈

00:30.960 --> 00:35.369
比如某個被繫結的方法每次都返回不同的值

00:35.369 --> 00:38.212
或者某個子元件修改了其父元件/父指令上的繫結

00:38.212 --> 00:41.331
我們來看一個簡單的問題復現及其解決方案

00:41.331 --> 00:45.120
然後，我們仔細看一下 Angular 的變更檢測，以便理解

00:45.120 --> 00:49.600
為什麼會發生本錯誤，以及它為何如此重要
這裡是我們正在使用的 AppComponent 範本

00:49.600 --> 00:54.480
ngIf 指令帶有一個布林值 loading
在模型（也就是我們的元件 TypeScript 程式碼）中

00:54.480 --> 01:00.000
我們給了它一個預設值 true
然後，在 AfterViewInit 鉤子中

01:00.000 --> 01:03.120
當載入完成時，我們把它的值翻轉為 false
但是當我們執行此程式碼時，會看到報錯：

01:03.120 --> 01:08.240
ExpressionChangedAfterItHasBeenCheckedError:
Previous value: false, Current value: true.

01:08.240 --> 01:12.480
在更復雜的應用中，錯誤的源頭可能沒這麼清晰

01:12.480 --> 01:16.320
但是你始終可以假設，它對範本中的繫結做了點什麼

01:16.320 --> 01:20.560
在呼叫堆疊追蹤中，你會發現一個連結
它指向導致本錯誤的元件範本的原始碼對映

01:20.560 --> 01:24.480
並且它直接把我們帶到了導致此問題的程式碼行

01:24.480 --> 01:29.440
也就是我們繫結到 loading 屬性的 ngIf 陳述式
本錯誤在試圖告訴我們

01:29.440 --> 01:34.000
這個 loading 屬性的值在變更檢測迴圈完成之後發生了變化

01:34.000 --> 01:37.120
但是在這個例子中我們的程式碼到底錯在哪裡呢？
簡短的答案是我們正在使用錯誤的

01:37.120 --> 01:39.680
生命週期鉤子
如果我們把程式碼從

01:39.680 --> 01:44.160
AfterViewInit 移到 OnInit 中，本錯誤就消失了
這些就恢復正常了

01:44.160 --> 01:48.560
換句話說，如果你發現自己正在 AfterViewInit 中修改值

01:48.560 --> 01:53.280
就可以簡單地把它移到 OnInit 或元件建構函式中來修復它

01:53.280 --> 01:58.240
現在，我們已經明白使用了錯誤的生命週期鉤子
並且可以透過重構來修復它

01:58.240 --> 02:03.040
但要想真正理解其原因，我們就要快速回顧一下
Angular 中變更檢測的工作原理

02:03.040 --> 02:06.880
變更檢測的目標，是讓模型（TypeScript 程式碼）與

02:06.880 --> 02:10.880
範本（HTML）保持同步
它實現這一點的方式，是透過

02:10.880 --> 02:15.520
在元件樹中自頂向下查詢資料變更
首先它檢查父元件，然後是子元件

02:15.520 --> 02:19.840
然後是二級子元件，以此類推。但是如果我們在
父元件完成變更檢查之後再修改某個繫結

02:19.840 --> 02:24.560
Angular 就會丟擲本錯誤
現在，我們有了一個簡化的

02:24.560 --> 02:30.000
Angular 生命週期分解圖

02:30.000 --> 02:33.920
首先它像此範本中的 ngIf 指令一樣修改這些繫結

02:33.920 --> 02:37.600
然後，它執行 OnInit 生命週期鉤子
修改 DOM，然後執行子元件的變更檢測

02:37.600 --> 02:42.000
要注意，這裡的最後一步是 AfterViewInit

02:42.000 --> 02:44.880
更重要的是它執行在變更檢測之後

02:44.880 --> 02:48.480
基本上，這裡執行的所有程式碼
都不應該嘗試更新其檢視

02:48.480 --> 02:53.600
這就是本例子中問題的根源
把它重構到 OnInit 中對於初始值是非常合適的

02:53.600 --> 02:57.840
但是如果這沒能修復本錯誤
那可能是因為其它原因導致了本錯誤

02:57.840 --> 03:02.560
那就要用其它方式來修復它
在此元件中，我們正在用 ViewChild
從 DOM 樹中捕獲某個元素

03:02.560 --> 03:06.320
但是此元素在呼叫完 AfterViewInit
鉤子之前是不可用的

03:06.320 --> 03:10.080
但是我們卻不能在得到此 ViewChild 元素之前

03:10.080 --> 03:13.040
更新元件的狀態，這下該怎麼辦呢？

03:13.040 --> 03:16.720
如果我們不能重構到 ngOnInit 中
我們還有另外一些選擇

03:16.720 --> 03:21.440
你在 StackOverflow 答案中經常看到的方法之一
就是進行非同步更新

03:21.440 --> 03:25.120
當我們進行非同步更新時，它會推到下一次變更檢測週期中進行

03:25.120 --> 03:29.440
這樣就會防止發生錯誤
我們可以把它包裹進一個延遲為 0 的 setTimeout 中

03:29.440 --> 03:34.320
來把它變成非同步的
這樣就會把此更新推到 JavaScript
事件迴圈的下一個宏任務佇列中

03:34.320 --> 03:39.440
另外，我可以還可以使用一個立即解析的 Promise，然後在其

03:39.440 --> 03:44.000
回呼(Callback)中執行此更新。這段程式碼會達到同樣的效果
但是有一些微妙的差異：

03:44.000 --> 03:48.880
它會執行在瀏覽器事件迴圈的當前迭代結束前的
微任務佇列中

03:48.880 --> 03:52.400
進行非同步更新可以奏效，但是它非常隱晦

03:52.400 --> 03:57.440
只應該把它作為最後的應急措施
它無法說清楚為什麼我們要寫這段非同步程式碼

03:57.440 --> 04:01.920
除非你能理解 Angular 變更檢測和瀏覽器事件迴圈中的
某些細微差異

04:01.920 --> 04:06.480
幸運的是，Angular 為我們提供了另一種
更直接、更明顯的方式來觸發變更檢測

04:06.480 --> 04:11.680
我們可以透過在元件的建構函式中注入
ChangeDetectorRef 來手動觸發它

04:11.680 --> 04:16.320
然後我們就可以呼叫 detectChanges() 方法
來手動執行變更檢測

04:16.320 --> 04:20.080
這會要求 Angular 檢查此檢視及其子檢視
在這個例子中，這會通知它們

04:20.080 --> 04:24.240
我們的 loading 狀態已經變了
這樣就給了我們另一種方式以解決本錯誤

04:24.240 --> 04:28.560
你還可能以一種完全不同的方式遇到本錯誤
如果你有一個方法（通常是一個 getter）

04:28.560 --> 04:33.520
該方法會返回不可預測的值
這樣就會導致變更檢測進入無限迴圈

04:33.520 --> 04:37.200
比如，我們元件中的這個 getter 方法會返回隨機數

04:37.200 --> 04:40.400
如果我們試圖在範本中使用這個值
那麼每當 Angular 進行變更檢測時

04:40.400 --> 04:43.280
都會得到一個不同的值
這種情況下的解決方案是

04:43.280 --> 04:47.440
讓該方法基於當前元件的狀態返回一個確定的值

04:47.440 --> 04:51.120
換句話說，各種 getter 都應該是從元件狀態衍生出來的

04:51.120 --> 04:54.800
而不能是那些不斷變化的值，如時間戳或隨機數

04:54.800 --> 05:00.240
現在，我們來看一個更復雜的例子
這個例子中我們同時有父元件和子元件

05:00.240 --> 05:05.040
父元件 AppComponent 包含 loading 狀態
就像以前的例子中一樣

05:05.040 --> 05:08.560
但是我們不在父元件中進行修改，而是改為

05:08.560 --> 05:12.880
從子元件中使用自訂事件進行修改
在子元件 ItemComponent 中

05:12.880 --> 05:17.760
我們使用 @Output 裝飾器和 EventEmitter
來建立一個自訂事件

05:17.760 --> 05:21.680
接著，在 ngOnInit 期間，我們以 true 值發出一個事件

05:22.240 --> 05:26.560
然後，回到 AppComponent 的範本中
我們繼續並宣告 ItemComponent

05:26.560 --> 05:29.440
當自訂事件觸發時
我們把 loading 值設定為 false

05:29.440 --> 05:34.080
最終的結果是我們有一個子元件
它在父元件的變更檢測執行完之後修改了父元件

05:34.080 --> 05:38.080
這時候就會發生本錯誤

05:38.080 --> 05:42.880
這個例子的潛在解決方案之一
是把 loading 狀態移到子元件中

05:42.880 --> 05:47.040
如果這樣行不通，你可以考慮
把此狀態移到一個共享服務中

05:47.040 --> 05:49.332
而該服務可以注入到多個元件中

05:49.332 --> 05:51.440
在結束之前，我們複述一下重點

05:51.440 --> 05:56.960
出現 ExpressionChangedAfterItHasBeenCheckedError
是因為範本中的某個值

05:56.960 --> 06:01.040
在變更檢測完成之後又被修改了
先找到在呼叫堆疊追蹤中給出的範本來排錯

06:01.040 --> 06:04.720
從那裡，你可以分析程式碼來決定到底是

06:04.720 --> 06:08.640
哪個值被修改了，並且使用本影片中涵蓋的方法之一來解決它

06:08.640 --> 06:13.520
比如把它重構到 OnInit 鉤子中、
手動使用 ChangeDetectorRef、

06:13.520 --> 06:18.080
讓 getter 返回確定的值
或者把修改變成非同步的，作為最後的應急手段

06:18.080 --> 06:23.200
參考 Angular 官方文件，以瞭解更多詳情和範例
