WEBVTT
Kind: subtitles
Language: zh-TW

00:00.720 --> 00:04.480
NullInjectorError: No provider\h
for the injectable class.\h

00:04.480 --> 00:07.360
當你嘗試注入一個服務，卻沒有宣告對應的提供者時
就會遇到本錯誤

00:07.360 --> 00:12.000
換句話說，你的程式碼嘗試使用某個依賴

00:12.000 --> 00:17.120
但是 Angular 卻無法找到或注入那個依賴

00:17.120 --> 00:21.520
因為目前沒有任何提供者指向它
但所謂的“提供者”到底是什麼呢？

00:21.520 --> 00:26.400
你可以把它看一個藥物的處方，這個“處方”就是提供者

00:26.400 --> 00:31.200
而這個藥物就是用於注入的服務。本錯誤告訴我們的是

00:31.200 --> 00:36.720
我們正試圖使用一種沒有處方的藥物
可以用兩種方式解決此問題：

00:36.720 --> 00:42.320
@Injectable 裝飾器，或者在 ngModule 的 providers 陣列中
無論哪種方式，提供者都由三部分主要資訊構成

00:42.320 --> 00:46.560
首先，它需要知道在哪裡讓這個類可用

00:46.560 --> 00:50.480
比如應用的根模組或特性模組

00:50.480 --> 00:55.840
其次，它需要一個令牌（Token），以便在依賴注入體系中定位那個類

00:55.840 --> 01:01.280
這裡的令牌是一個帶有裝飾器的類別的型別
在多數情況下，此令牌和你要提供的類是同一個

01:01.280 --> 01:06.080
不過，你還可以提供第三部分資訊，比如

01:06.080 --> 01:12.160
用 useClass 來提供完全不同的一個類別，或者用 useValue 來提供一個原始值

01:12.160 --> 01:16.080
讓我們看一組常見的範例及其快速修復方式

01:16.080 --> 01:20.000
然後我們會深入看一下注入器和提供者，以便在更基礎的層面上

01:20.000 --> 01:24.880
理解為什麼會發生此錯誤
在我們的程式碼中，有一個帶有 @Injectable 裝飾器的服務

01:24.880 --> 01:30.240
但目前，該服務還沒有在應用內的任何 ngModule 中提供

01:30.240 --> 01:34.480
當我們試圖在 AppComponent 的建構函式中中注入它時

01:34.480 --> 01:39.840
就會導致 NullInjectorError。此錯誤資訊指出了出錯的類

01:39.840 --> 01:44.160
現在，我們有兩種主要的方式解決此問題
如果我們要在整個應用範圍內提供這個類

01:44.160 --> 01:49.760
可以使用 providedIn: 'root' 選項。它會提供一個全域單例

01:49.760 --> 01:54.320
此單例可以用於應用中的任何地方，並消除本錯誤

01:54.320 --> 01:59.520
不過，這可能並不總是最合適的解決方案
某些情況下，更有效的方式是把某個服務侷限在某個特性模組內部

01:59.520 --> 02:04.880
這可以透過把某個 ngModule 類作為 providedIn 選項的值來實現

02:04.880 --> 02:09.760
這樣就讓我們可以從應用的主 JS 套件中排除這部分程式碼，按需延遲載入

02:09.760 --> 02:14.800
這可以提升載入效能。當你有一個要在獨立模組中書踹死的服務時，這很好

02:14.800 --> 02:20.160
但是如果該服務被多個延遲載入模組使用時怎麼辦呢？

02:20.160 --> 02:25.600
這種情況下，你可能希望每個模組都為本服務建立它自己的例項

02:25.600 --> 02:30.240
這可以透過 providedIn: 'any' 選項來實現

02:30.240 --> 02:35.600
這種方式下，服務不是單例的，而是為每個模組建立一個例項

02:35.600 --> 02:40.560
還有一個選項是 providedIn: 'platform'

02:40.560 --> 02:46.160
它適用於那些要在同一個頁面中使用多個 Angular 應用的專案
比如透過 Angular Elements 實現的 Web Components

02:46.160 --> 02:50.640
在同一個頁面中的所有 Angular 應用中可用

02:51.200 --> 02:54.240
總之，一共有四種不同的方式來提供某個服務

02:54.240 --> 02:57.440
'root' 會為整個 Angular 應用例項化一個單例

02:57.440 --> 03:00.880
“模組類”會單獨為那個模組提供一個單例

03:00.880 --> 03:04.000
'any' 會為每個注入它的模組提供一個例項

03:04.000 --> 03:07.760
而 'platform' 會為多個 Angular 應用提供一個單例

03:08.320 --> 03:13.600
另外，你還可以在 ngModule 裝飾器中直接提供某個服務

03:13.600 --> 03:18.000
只要匯入你要提供的服務
然後把它加到 ngModule 裝飾器的 providers 陣列中就可以了

03:18.000 --> 03:22.880
這種模式也會建立一個提供者，不過通常不建議使用這種方式

03:22.880 --> 03:27.520
因為它會讓這些程式碼在沒有任何地方注入它的時候，難以搖樹最佳化掉

03:27.520 --> 03:32.960
很多情況下，你可能遇到來自第三方依賴或

03:32.960 --> 03:38.640
比如，如果在 AppComponent 中匯入 HTTP Client，然後

03:38.640 --> 03:43.680
把它注入為建構函式中的一個依賴項，同樣會丟擲一個錯誤

03:43.680 --> 03:48.080
但是你可能想不通為什麼 Angular 內建的東西還會沒有提供者

03:48.080 --> 03:53.280
這是因為只有極少數服務才內建到了 Angular 核心中
其它的一切幾乎都拆到了自己的模組中

03:53.280 --> 03:59.200
這意味著要使用 HTTP Client，我們就要

03:59.200 --> 04:04.560
在依賴它的模組（AppModule）中匯入其對應的 ngModule

04:04.560 --> 04:09.520
我們可以透過把它加入到 AppModule 的 imports 陣列中來實現
現在，我們知道了如何修復此錯誤，接下來我們談談注入器

04:09.520 --> 04:14.960
當 Angular 啟動時，它會建立一個全應用級注入器

04:14.960 --> 04:20.320
它的職責是建立和管理依賴，它會維護一個提供者的集合

04:20.320 --> 04:26.320
每個提供者具有一個令牌或類別的型別
它會告訴 Angular 去哪裡尋找要注入的值

04:26.320 --> 04:30.720
大多數情況下，提供者是透過 @Injectable 裝飾器來建立的

04:30.720 --> 04:35.120
比如當某個元件的建構函式中參考了這個類別的時候

04:35.120 --> 04:40.400
注入器就會使用此提供者來尋找該類別的現有例項，或者按需例項化一個新的

04:40.400 --> 04:44.640
每個依賴項都需要至少一個提供者，否則就會丟擲 NullInjectorError

04:44.640 --> 04:49.520
如果沒有提供者，它就不能正常工作。我們來回顧一下

04:49.520 --> 04:54.320
當你遇到 NullInjectorError 時
它表示某個要注入的服務沒有必要的提供者

04:54.320 --> 04:59.680
第一步是找到那個導致錯誤的類別。如果它是你自己的 @Injectable 類之一

04:59.680 --> 05:04.640
你可以在應用的根或者某個 ngModule 中提供它

05:04.640 --> 05:08.960
如果它和某個第三方依賴有關，可能是你忘了匯入某個 ngModule

05:08.960 --> 05:14.080
你要找出那個服務是在哪裡提供的，然後匯入對應的 ngModule

05:14.080 --> 05:19.920
欲知詳情和範例，請閱讀Angular官方文件的“依賴注入”指南
