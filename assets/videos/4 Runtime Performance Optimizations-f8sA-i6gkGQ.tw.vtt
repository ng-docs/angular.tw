WEBVTT
Kind: subtitles
Language: zh-TW

00:00:00.000 --> 00:00:01.390
MINKO GECHEV： 大家好

00:00:01.390 --> 00:00:02.670
我是 Minko Gechev

00:00:02.670 --> 00:00:05.490
我在谷歌做 Angular 開發

00:00:05.490 --> 00:00:06.067
這幾年

00:00:06.067 --> 00:00:08.705
我分析了數百個 Angular 應用程式

00:00:08.705 --> 00:00:15.034
而且我注意到大多數效能方面的挑戰都有
幾種典型的模式

00:00:14.902 --> 00:00:18.495
今天，我們將研究這些模式

00:00:18.495 --> 00:00:21.340
並學習如何解決它們

00:00:21.340 --> 00:00:22.343
在本影片中

00:00:22.343 --> 00:00:25.810
你將首先學習如何使用 Angular DevTools

00:00:25.810 --> 00:00:26.381
之後

00:00:26.381 --> 00:00:31.864
我們將識別幾種導致效能退化的模式
並學習如何解決它們

00:00:31.750 --> 00:00:32.429
為此

00:00:32.429 --> 00:00:37.450
我們將使用一個典型業務應用的簡單原型

00:00:37.450 --> 00:00:41.290
在 UI 的最頂部，我們有一個柱狀圖

00:00:41.290 --> 00:00:42.738
在這個圖表下方

00:00:42.738 --> 00:00:48.531
我們有兩份來自銷售和研發部門的員工名單

00:00:48.400 --> 00:00:54.784
每個員工都有一個姓名和一個
經過繁重計算的與其關聯的數值

00:00:54.670 --> 00:00:56.771
在這些列表中的任何一個

00:00:56.771 --> 00:00:58.690
我們都可以查詢新員工

00:00:58.690 --> 00:01:01.142
正如你將在程式碼中所見到的那樣

00:01:01.142 --> 00:01:03.230
還有用來實現主要功能的基礎設施

00:01:03.230 --> 00:01:07.660
但為簡單起見，它不是 UI 的一部分

00:01:07.660 --> 00:01:13.289
還記得我提到過每個員工的數值都要經過繁重
計算嗎？

00:01:13.289 --> 00:01:14.880
為了簡單起見

00:01:14.880 --> 00:01:18.673
我用斐波那契函式模擬了這個計算

00:01:18.550 --> 00:01:19.388
請注意

00:01:19.388 --> 00:01:24.413
我們已經實現了一個非常低效的斐波那契版本

00:01:24.413 --> 00:01:32.549
因此即使是很小的效能問題也會對我們將要
探索的範例產生顯著的可見影響

00:01:32.310 --> 00:01:38.989
只用兩個元件實現整個應用程式
EmployeeListComponent

00:01:38.989 --> 00:01:46.439
它包含相應部門的員工列表並有一個用於輸
入新員工的文字輸入框

00:01:46.439 --> 00:01:48.751
以及 AppComponent

00:01:48.751 --> 00:01:56.586
它會渲染 EmployeeListComponent 的
兩個列表例項和頂部的柱狀圖

00:01:56.330 --> 00:01:58.515
在我們轉到效能退化模式之前

00:01:58.515 --> 00:02:04.265
讓我們看看如何使用 Angular DevTools
分析應用程式

00:02:04.150 --> 00:02:07.494
Angular DevTools 是一個
Chrome DevTools 擴充

00:02:07.494 --> 00:02:09.893
你可以從 Chrome 應用商店安裝它

00:02:09.820 --> 00:02:14.359
它允許你在元件資源管理器中預覽
應用程式的結構

00:02:14.260 --> 00:02:17.290
對於本影片，我們將主要使用 Profiler

00:02:17.290 --> 00:02:20.950
要開始分析應用程式，請單擊“記錄”按鈕

00:02:20.950 --> 00:02:24.904
當 Angular 在你的應用程式中執行變更檢
測時

00:02:24.904 --> 00:02:30.974
你會看到與 DevTools 時間軸中出現的各個
變更檢測週期相對應的柱狀圖

00:02:30.790 --> 00:02:33.106
當我們從時間軸中選擇幀時

00:02:33.106 --> 00:02:37.182
我們可以預覽我們在各個元件上
花費了多少時間

00:02:37.090 --> 00:02:37.681
在這裡

00:02:37.681 --> 00:02:44.014
我們在 MatFormField 和 EmployeeListComponent
中花費了大部分的變更檢測呼叫

00:02:43.930 --> 00:02:51.752
DevTools 允許我們以不同的格式預覽
Profiler 的輸出：柱狀圖、樹圖和火焰圖

00:02:51.640 --> 00:02:55.840
火焰圖提供了元件樹的分層檢視

00:02:55.840 --> 00:02:57.699
當我們點選一個特定的元件時

00:02:57.699 --> 00:03:00.584
我們可以看到 Angular 在它上面花費了
多少時間

00:03:00.520 --> 00:03:01.168
例如

00:03:01.168 --> 00:03:08.949
我們花了大約 0.1 毫秒來檢測 EmployeeListComponent
中的變化

00:03:08.820 --> 00:03:12.721
由於我們的應用程式沒有複雜的巢狀(Nesting)結構

00:03:12.721 --> 00:03:15.990
因此我們將使用預設的柱狀圖檢視

00:03:15.990 --> 00:03:18.360
現在讓我們逐個看看這些模式

00:03:18.360 --> 00:03:21.420
我們將描述問題的原因

00:03:21.420 --> 00:03:26.370
你將學習如何識別它並解決它

00:03:26.370 --> 00:03:30.390
我們要研究的第一個模式是 Zone 汙染

00:03:30.390 --> 00:03:36.429
讓我們回到應用程式並開始使用 Angular DevTools
的 Profiler 進行記錄

00:03:36.340 --> 00:03:40.245
如果我們開始與應用程式中的柱狀圖互動

00:03:40.245 --> 00:03:44.150
我們會看到我們觸發了多個變更檢測週期

00:03:44.150 --> 00:03:47.000
每個週期都需要相當長的時間

00:03:47.000 --> 00:03:50.115
如果我們探索變更檢測週期

00:03:50.115 --> 00:03:56.844
我們將看到變更檢測的來源是
mouseup 和 mousemove 事件

00:03:56.720 --> 00:04:00.370
每個迴圈需要超過 740 毫秒

00:04:00.370 --> 00:04:04.160
這會顯著降低瀏覽器的幀率

00:04:04.160 --> 00:04:10.857
我們大部分時間都花在了 EmployeeListComponent
的兩個例項上

00:04:10.857 --> 00:04:14.943
其中每次檢查花費的時間超過了 360 毫秒

00:04:14.830 --> 00:04:17.320
現在讓我們來解決這個問題

00:04:17.320 --> 00:04:22.416
app.component 範本的開頭是我們渲染
柱狀圖的 div 容器

00:04:22.320 --> 00:04:32.632
我們透過呼叫 Plotly 圖表庫的新繪圖方法
在 app.component 的 ngOnInit
生命週期掛鉤上初始化 Ng 中的圖表

00:04:32.430 --> 00:04:38.511
我們傳遞 DOM 容器的 ID 和我們要渲染的資料

00:04:38.370 --> 00:04:43.628
鑑於我們在 Profiler 中獲得的
mouseup 和 mousemove 事件

00:04:43.628 --> 00:04:50.388
這意味著 Plotly 的初始化邏輯可能正在將
這些 EventListener 新增到柱狀圖

00:04:50.200 --> 00:04:52.475
Plotly 提供了一個獨立的函式庫

00:04:52.475 --> 00:04:54.400
不需要與 Angular 互動

00:04:54.400 --> 00:04:59.560
我們可以在 Angular Zone 之外執行
初始化邏輯

00:04:59.560 --> 00:05:03.040
以防止呼叫冗餘的變更檢測週期

00:05:02.920 --> 00:05:08.489
讓我們轉到 app.component 的建構函式並
注入 Ng Zone

00:05:08.380 --> 00:05:18.947
我們可以回到圖表的初始化邏輯和我們傳遞
給 runOutsideAngular 的回呼(Callback)內部

00:05:18.810 --> 00:05:23.147
當我們返回應用程式並啟動 Profiler 時

00:05:23.147 --> 00:05:29.007
我們會看到與柱狀圖中的條形的互動不再觸
發變更檢測

00:05:28.890 --> 00:05:33.762
當 Angular Zone 包裝觸發
冗餘變更檢測週期的回呼(Callback)時

00:05:33.762 --> 00:05:35.850
就會出現 Zone 汙染模式

00:05:35.750 --> 00:05:43.678
當我們執行使用 requestAnimationFrame、setTimeout
或 addEventListener 的初始化邏輯時

00:05:43.678 --> 00:05:44.905
就會汙染 Zone

00:05:44.810 --> 00:05:51.088
我們可以透過在 Profiler 輸出中尋找意外
的變更檢測週期來識別問題

00:05:50.990 --> 00:05:52.520
在大多數情況下

00:05:52.520 --> 00:05:56.090
我發現原因是 requestAnimationFrame

00:05:56.090 --> 00:05:58.050
解決方案通常非常簡單

00:05:58.050 --> 00:06:02.980
你需要做的就是將初始化邏輯移出
Angular Zone

00:06:02.870 --> 00:06:07.855
我們將研究的以下模式是越界變更檢測

00:06:07.855 --> 00:06:11.640
讓我們回到應用程式並輸入一個新員工

00:06:11.640 --> 00:06:14.210
請注意，可以體驗到延遲很嚴重

00:06:14.210 --> 00:06:16.082
當我們開始分析時

00:06:16.082 --> 00:06:22.030
我們注意到我們輸入的每個字元都會觸發兩
個變更檢測週期

00:06:21.920 --> 00:06:25.052
第一個在 Input 事件上

00:06:25.052 --> 00:06:27.900
第二個在 keydown 上

00:06:27.900 --> 00:06:29.414
對於這兩個事件

00:06:29.414 --> 00:06:36.481
我們花費了 380 多毫秒來檢測 EmployeeListComponent
的兩個例項中的變化

00:06:36.380 --> 00:06:37.364
請注意

00:06:37.364 --> 00:06:41.720
雖然我們只輸入了銷售部門的輸入

00:06:41.720 --> 00:06:44.671
但我們也檢查了研發部門

00:06:44.670 --> 00:06:50.644
由於鍵入這些輸入只會更改銷售部門內的視
圖狀態

00:06:50.644 --> 00:06:54.670
因此檢測研發部門的變更是多餘的

00:06:54.540 --> 00:06:56.130
讓我們解決這個問題

00:06:56.130 --> 00:06:56.697
為此

00:06:56.697 --> 00:07:03.384
我們將 EmployeeListComponents 的
變更檢測策略改為 OnPush

00:07:03.270 --> 00:07:04.591
使用 OnPush

00:07:04.591 --> 00:07:09.656
當我們基於 @Input 檢查傳入具有新值的
輸入時

00:07:09.656 --> 00:07:13.070
Angular 將觸發元件內的變更檢測

00:07:12.960 --> 00:07:18.872
我們將使用 immutable.js 中的不可變列表
來防止陣列參考發生變化

00:07:18.872 --> 00:07:21.256
並確保高效的資料共享結構

00:07:21.160 --> 00:07:26.511
讓我們首先將銷售和研發部門陣列更改為不
可變列表

00:07:26.400 --> 00:07:27.021
之後

00:07:27.021 --> 00:07:33.732
我們將更新 app.component 中
Add 和 Remove 方法的簽名

00:07:33.732 --> 00:07:37.833
以便它們可以接受不可變的員工列表

00:07:37.710 --> 00:07:38.393
接下來

00:07:38.393 --> 00:07:48.157
我們需要確保分配這兩個方法產生的結果以
更新本地參考並將它們沿元件樹向下傳遞給
EmployeeListComponent

00:07:48.060 --> 00:07:51.890
我們需要賦值，因為我們不能改變列表

00:07:51.890 --> 00:07:56.590
相反，Immutabe.js 會建立新的

00:07:56.590 --> 00:08:01.668
由於我們現在將不可變列表傳遞給 EmployeeListComponent

00:08:01.668 --> 00:08:04.830
因此我們需要更新其資料輸入的型別

00:08:04.830 --> 00:08:08.238
不可變列表具有大小而不是長度屬性

00:08:08.238 --> 00:08:15.673
因此我們需要更新範本中的屬性存取並將 changeDetection
策略設定為 OnPush

00:08:15.570 --> 00:08:18.192
現在，讓我們回到應用程式

00:08:18.192 --> 00:08:22.890
請注意，現在輸入新員工的速度快了一點點

00:08:22.890 --> 00:08:25.630
雖然它仍然很慢

00:08:25.630 --> 00:08:26.860
讓我們解決這個問題

00:08:26.860 --> 00:08:31.562
我們將它做作為越界變更檢測重構的一部分

00:08:31.450 --> 00:08:33.455
當我們開始輸入時

00:08:33.455 --> 00:08:36.640
Angular 會定期執行變更檢測

00:08:36.640 --> 00:08:46.096
它檢查整個 EmployeeListComponent 並對每個員工
執行兩次繁重計算 —— 在 input 和 keypress 事件時

00:08:46.096 --> 00:08:48.685
哪怕沒有任何值發生變化

00:08:48.460 --> 00:08:54.930
發生這種情況是因為在輸入中鍵入會觸發
繞過 OnPush 變更檢測策略的事件

00:08:54.835 --> 00:08:59.771
當具有 OnPush 變更檢測策略的元件內的
事件發生時

00:08:59.771 --> 00:09:02.548
Angular 將檢測該元件的變化

00:09:02.548 --> 00:09:04.913
即使它沒有收到新的輸入

00:09:04.810 --> 00:09:09.731
這裡的問題是我們只是在更改輸入的本地狀態

00:09:09.731 --> 00:09:12.129
而不是更新單個員工

00:09:12.129 --> 00:09:17.050
這意味著完全跳過他們的更改方向是安全的

00:09:17.050 --> 00:09:20.860
為了提高效能，我們將重構元件樹

00:09:20.860 --> 00:09:21.419
目前

00:09:21.419 --> 00:09:26.672
app 元件渲染了 EmployeeListComponent 的
兩個例項

00:09:26.560 --> 00:09:27.944
在本節的最後

00:09:27.944 --> 00:09:35.077
EmployeeListComponent 將使用 NameInputComponent
獲取新員工的姓名

00:09:35.077 --> 00:09:38.697
並使用 ListComponent 渲染員工列表

00:09:38.590 --> 00:09:42.442
我們將為列表元件使用 OnPush 變更檢測策略

00:09:42.350 --> 00:09:44.528
因此，透過這種方式

00:09:44.528 --> 00:09:53.241
兄弟元件 NameInputComponent 中發生的
事件將不會觸發對員工的任何冗餘計算

00:09:53.120 --> 00:10:01.887
讓我們首先進入 EmployeeListComponent
的目錄並建立 name-input.component 和 list.component

00:10:01.790 --> 00:10:02.814
下一步

00:10:02.814 --> 00:10:10.543
我們可以將輸入欄位從 employee-list.component
提取到 name-input.component 的範本中

00:10:10.450 --> 00:10:18.536
我們還可以移動相應的樣式、label 屬性和 handleKey
方法並複製輸出

00:10:18.410 --> 00:10:21.145
我們還要刪除 OnInit 生命週期鉤子

00:10:21.145 --> 00:10:38.999
我們可以在 employee-list.component 的
範本中使用 name-input.component

00:10:38.999 --> 00:10:45.375
下一步處理應用程式的輸出屬性

00:10:45.120 --> 00:10:55.658
現在讓我們將範本的其餘 mat-list 部分
移至 ListComponent

00:10:55.470 --> 00:11:02.526
我們還應該拿出計算方法並刪除 OnInit
生命週期掛鉤實現

00:11:02.526 --> 00:11:05.270
因為我們根本不使用它

00:11:05.140 --> 00:11:10.565
接下來，讓我們移動斐波那契函式

00:11:10.565 --> 00:11:18.480
我們現在可以移動資料輸入了

00:11:18.480 --> 00:11:20.970
最後，我們可以複製刪除輸出

00:11:20.970 --> 00:11:29.883
為了確保 UI 看起來清晰

00:11:29.883 --> 00:11:50.808
我們可以將與列表視覺化關聯的樣式移動到
列表元件的樣式

00:11:50.420 --> 00:11:51.828
最後

00:11:51.828 --> 00:12:07.592
我們可以將 list.components 的變更檢測
策略設定為 OnPush

00:12:07.310 --> 00:12:12.481
讓我們使用 employee-list.components
範本中的 list.component

00:12:12.481 --> 00:12:14.939
傳遞相應的輸入並刪除輸出屬性

00:12:14.855 --> 00:12:20.071
當你返回應用程式時

00:12:20.071 --> 00:12:29.130
請注意打字型驗已經沒有任何明顯的延遲了

00:12:29.130 --> 00:12:30.230
回顧一下

00:12:30.230 --> 00:12:38.299
當僅影響特定元件的本地狀態的操作觸發組
件的不相關部分的變更檢測時

00:12:38.299 --> 00:12:40.622
就會出現這類效能問題

00:12:40.500 --> 00:12:50.475
我們可以透過檢查 Profiler 的輸出並找到
不應受特定互動影響的元件來識別問題

00:12:50.340 --> 00:12:52.252
為了解決這個問題

00:12:52.252 --> 00:12:56.638
我們可以隔離觸發頻繁本地狀態更改的元件

00:12:56.638 --> 00:13:02.373
並將具有昂貴的變更檢測檢查的元件設定為
使用 OnPush 的

00:13:02.260 --> 00:13:10.042
我們要看的第三種模式是參考透明表示式的
重新計算

00:13:09.880 --> 00:13:13.280
如果我們在範本中有一個表示式

00:13:13.280 --> 00:13:17.149
當它的引數不變時就可以用它的值替代它

00:13:17.149 --> 00:13:19.611
我們就認為它是參考透明的

00:13:19.610 --> 00:13:24.957
這意味著我們不必在變更檢測週期之間
重新計算表示式

00:13:24.957 --> 00:13:27.417
除非它們的輸入發生變化

00:13:27.310 --> 00:13:30.370
讓我們回到應用程式並新增一名員工

00:13:30.370 --> 00:13:31.000
請注意

00:13:31.000 --> 00:13:35.950
我們得到了一個由 keydown 事件觸發的
相當昂貴的變更檢測週期

00:13:35.860 --> 00:13:38.656
我們降低了瀏覽器的幀率

00:13:38.656 --> 00:13:44.491
Angular 將大部分變更檢測週期都花在了
列表元件中

00:13:44.370 --> 00:13:47.833
當我們將新員工新增到 Sales 列表時

00:13:47.833 --> 00:13:50.787
我們呼叫了 app 元件的 add 方法

00:13:50.787 --> 00:13:53.130
這會建立一個不可變列表

00:13:53.130 --> 00:13:58.755
不可變列表將新的不可變列表傳遞給 ListComponent

00:13:58.755 --> 00:14:00.550
觸發其變更檢測

00:14:00.550 --> 00:14:06.409
Angular 遍歷各個員工並重新計算他們的
數值

00:14:06.409 --> 00:14:08.673
即使他們沒有改變

00:14:08.540 --> 00:14:14.310
理想情況下，你只想計算新員工的價值

00:14:14.310 --> 00:14:19.411
我們可以透過一點重構來提高應用程式的效能

00:14:19.290 --> 00:14:22.498
我們可以建立一個名為 calculate 的新管道

00:14:22.420 --> 00:14:27.798
讓我們匯入管道裝飾器並將管道名稱設定為
“calculate”

00:14:27.798 --> 00:14:28.616
在這裡

00:14:28.616 --> 00:14:32.241
我們明確寫出此管道對於讀來說是“純的”

00:14:32.241 --> 00:14:34.696
雖然這是屬性的預設值

00:14:34.580 --> 00:14:35.268
下一步

00:14:35.268 --> 00:14:38.219
我們可以實現 CalculatePipe 類

00:14:38.219 --> 00:14:42.448
新增一個轉換方法並實現 PipeTransform
介面

00:14:42.350 --> 00:14:55.021
現在讓我們移動 Fibonacci 實現並從 ListComponent
中刪除冗餘的計算方法

00:14:54.840 --> 00:15:07.801
讓我們將 CalculatePipe 新增到 employee-list.module
中的宣告中

00:15:07.595 --> 00:15:08.998
最後

00:15:08.998 --> 00:15:25.551
我們需要更新 ListComponent 的範本以使
用管道而不是方法呼叫

00:15:25.270 --> 00:15:25.737
請注意

00:15:25.737 --> 00:15:28.937
現在我們可以在沒有任何明顯延遲的情況下
新增員工

00:15:28.870 --> 00:15:30.435
回顧一下

00:15:30.435 --> 00:15:38.261
當 Angular 重複地重新計算相同的
範本表示式時

00:15:38.261 --> 00:15:43.305
即使它們僅依賴於值不變的引數

00:15:43.305 --> 00:15:45.914
也會出現此問題

00:15:45.740 --> 00:15:55.707
我們可以透過注意到變更檢測週期與我們在 UI
中所做的更改不成比例的時間來識別
Angular DevTools 的問題

00:15:55.510 --> 00:16:03.759
解決方案通常涉及將計算移動到純管道或透過記憶快取它

00:16:03.600 --> 00:16:08.700
我們要看的最後一個模式是大型元件樹

00:16:08.700 --> 00:16:13.352
即使我們優化了每個元件並且不執行冗餘計算

00:16:13.352 --> 00:16:16.121
如果我們有數千個元件例項

00:16:16.121 --> 00:16:18.890
我們仍然可以觀察到丟幀

00:16:18.780 --> 00:16:22.159
為了展示我們如何在這種情況下提高效能

00:16:22.159 --> 00:16:24.990
我在每個列表中添加了幾百名員工

00:16:24.990 --> 00:16:27.538
當我們新增一名新員工時

00:16:27.538 --> 00:16:33.410
我們注意到檢測 ListComponent 的變化需
要超過 25 毫秒

00:16:33.410 --> 00:16:34.850
這會導致丟幀

00:16:34.740 --> 00:16:40.350
提高大型元件樹的效能的關鍵是讓元件樹更小

00:16:40.350 --> 00:16:46.020
標準技術是按需渲染，例如虛擬化或分頁

00:16:46.020 --> 00:16:47.752
出於我們的目的

00:16:47.752 --> 00:16:52.140
我們將使用 Angular CDK 的虛擬滾動元件

00:16:52.140 --> 00:16:54.800
在 ListComponent 的範本中

00:16:54.800 --> 00:17:00.630
我們將使用專案大小等於 50 的 cdk_virtual_scroll_viewport

00:17:00.630 --> 00:17:03.537
我們還將新增 CSS 類“Viewport”

00:17:03.537 --> 00:17:06.780
以便我們可以設定此元件的樣式

00:17:06.780 --> 00:17:09.288
我們將使用 cdkVirtualFor

00:17:09.288 --> 00:17:12.599
而不是在 mat-list 項中使用 ngFor

00:17:12.599 --> 00:17:18.079
我們還將容器的高度設定為 800 畫素

00:17:18.079 --> 00:17:21.240
就這樣

00:17:21.240 --> 00:17:23.755
現在，當我們新增一個新專案時

00:17:23.755 --> 00:17:28.245
ListComponent 中的更改部分花費的時間是
以前的 1/5

00:17:28.155 --> 00:17:29.265
請記住

00:17:29.265 --> 00:17:36.242
即使你擁有高度最佳化的元件並渲染了數千個元件

00:17:36.242 --> 00:17:43.537
它們的範本組合在變更檢測期間仍然可能非常昂貴

00:17:43.220 --> 00:17:48.445
如果你發現許多元件只佔用
整個變更檢測週期的一小部分

00:17:48.445 --> 00:17:54.273
或者當有一個元件具有非常大的檢視需要
花費大量時間來檢查時

00:17:54.273 --> 00:17:57.790
你可以在 DevTools 中識別此問題

00:17:57.590 --> 00:18:03.152
該解決方案涉及元件的按需渲染以修剪元件樹

00:18:03.020 --> 00:18:05.300
這就是我今天要給你講的全部內容

00:18:05.300 --> 00:18:09.968
我們首先了解了使用 Angular DevTools 的
基礎知識

00:18:09.968 --> 00:18:11.427
重點關注分析器

00:18:11.330 --> 00:18:12.006
之後

00:18:12.006 --> 00:18:27.681
我們探索了四種可以幫助你識別和解決常見
效能問題的模式 —— Zone 汙染、越界、
變更檢測、參考透明表示式的重新計算和大型元件樹

00:18:27.410 --> 00:18:29.460
非常感謝你觀看此影片

00:18:29.460 --> 00:18:32.350
回見，祝編碼愉快
