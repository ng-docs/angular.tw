{"id":"guide/http-test-requests","title":"HTTP client - Test requests","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-test-requests.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"http-client---test-requests\" translation-result=\"on\">HTTP 客戶端 - 測試請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-client---test-requests\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">HTTP client - Test requests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-client---test-requests\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">如同所有的外部依賴一樣，你必須把 HTTP 後端也 Mock 掉，以便你的測試可以模擬這種與後端的互動。<code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing</code> 函式庫能讓這種 Mock 工作變得直截了當。</p><p translation-origin=\"off\">As for any external dependency, you must mock the HTTP backend so your tests can simulate interaction with a remote server.\nThe <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing</code> library makes it straightforward to set up such mocking.</p>\n\n<h2 id=\"http-testing-library\" translation-result=\"on\">HTTP 測試庫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-testing-library\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">HTTP testing library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#http-testing-library\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 的 HTTP 測試函式庫是專為其中的測試模式而設計的。在這種模式下，會首先在應用中執行程式碼併發起請求。然後，這個測試會期待發起或未發起過某個請求，並針對這些請求進行斷言，最終對每個所預期的請求進行重新整理（flush）來對這些請求提供響應。</p><p translation-origin=\"off\">Angular's HTTP testing library is designed for a pattern of testing in which the app executes code and makes requests first.\nThe test then expects that certain requests have or have not been made, performs assertions against those requests, and finally provides responses by \"flushing\" each expected request.</p>\n\n<p translation-result=\"on\">最終，測試可能會驗證這個應用不曾發起過非預期的請求。</p><p translation-origin=\"off\">At the end, tests can verify that the app made no unexpected requests.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你可以到線上程式設計環境中執行<live-example stackblitz=\"specs\">這些範例測試</live-example>。</p><p translation-origin=\"off\">You can run <live-example stackblitz=\"specs\">these sample tests</live-example> in a live coding environment.</p>\n\n<p translation-result=\"on\">本章所講的這些測試位於 <code>src/testing/http-client.spec.ts</code> 中。在 <code>src/app/heroes/heroes.service.spec.ts</code> 中還有一些測試，用於測試那些呼叫了 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的資料服務。</p><p translation-origin=\"off\">The tests described in this guide are in <code>src/testing/http-client.spec.ts</code>.\nThere are also tests of an application data service that call <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> in <code>src/app/heroes/heroes.service.spec.ts</code>.</p>\n\n</div>\n<h2 id=\"setup-for-testing\" translation-result=\"on\">搭建測試環境<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#setup-for-testing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Setup for testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#setup-for-testing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要開始測試那些透過 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 發起的請求，就要匯入 <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> 模組和模擬控制器（<code><a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a></code>）以及你測試所需的其他符號。</p><p translation-origin=\"off\">To begin testing calls to <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>, import the <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> and the mocking controller, <code><a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a></code>, along with the other symbols your tests require.</p>\n\n<code-example header=\"app/testing/http-client.spec.ts (imports)\" path=\"http/src/testing/http-client.spec.ts\" region=\"imports\">\n// Http testing module and mocking controller\nimport { <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>, <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing';\n\n// Other imports\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>, <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n\n</code-example>\n<p translation-result=\"on\">然後把 <code>HTTPClientTestingModule</code> 新增到 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 中，並繼續設定<em>被測服務</em>。</p><p translation-origin=\"off\">Then add the <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> to the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> and continue with the setup of the <em>service-under-test</em>.</p>\n\n<code-example header=\"app/testing/http-client.spec.ts(setup)\" path=\"http/src/testing/http-client.spec.ts\" region=\"setup\">\ndescribe('<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> testing', () =&gt; {\n  let httpClient: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>;\n  let httpTestingController: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({\n      imports: [ <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a> ]\n    });\n\n    // <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> the <a href=\"api/common/http\" class=\"code-anchor\">http</a> service and test controller for each test\n    httpClient = TestBed.inject(<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>);\n    httpTestingController = TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>);\n  });\n  /// Tests begin ///\n});\n\n</code-example>\n<p translation-result=\"on\">現在，在測試中發起的這些請求會發給這些測試用的後端（testing backend），而不是標準的後端。</p><p translation-origin=\"off\">Now requests made in the course of your tests hit the testing backend instead of the normal backend.</p>\n\n<p translation-result=\"on\">這種設定還會呼叫 <code>TestBed.inject()</code>，來獲取注入的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務和模擬控制器，以便在測試期間參考它們。</p><p translation-origin=\"off\">This setup also calls <code>TestBed.inject()</code> to inject the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service and the mocking controller so they can be referenced during the tests.</p>\n\n<h2 id=\"expect-and-answer-requests\" translation-result=\"on\">期待並回答請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#expect-and-answer-requests\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Expect and answer requests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#expect-and-answer-requests\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">現在，你就可以編寫測試，等待 GET 請求並給出模擬響應。</p><p translation-origin=\"off\">Now you can write a test that expects a GET Request to occur and provides a mock response.</p>\n\n<code-example header=\"app/testing/http-client.spec.ts (HttpClient.get)\" path=\"http/src/testing/http-client.spec.ts\" region=\"get-test\">\nit('can test HttpClient.get', () =&gt; {\n  const testData: <a href=\"api/router/Data\" class=\"code-anchor\">Data</a> = {name: 'Test <a href=\"api/router/Data\" class=\"code-anchor\">Data</a>'};\n\n  // Make an HTTP GET request\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>&gt;(testUrl)\n    .subscribe(data =&gt;\n      // When observable resolves, result should match test data\n      expect(data).toEqual(testData)\n    );\n\n  // The following `expectOne()` will match the request's URL.\n  // If no requests or <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> requests matched that URL\n  // `expectOne()` would throw.\n  const req = httpTestingController.expectOne('/data');\n\n  // Assert that the request is a GET.\n  expect(req.request.method).toEqual('GET');\n\n  // Respond with mock data, causing Observable to resolve.\n  // Subscribe callback asserts that correct data was returned.\n  req.flush(testData);\n\n  // Finally, assert that there are no outstanding requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<p translation-result=\"on\">最後一步，驗證沒有發起過預期之外的請求，足夠通用，因此你可以把它移到 <code>afterEach()</code> 中：</p><p translation-origin=\"off\">The last step, verifying that no requests remain outstanding, is common enough for you to move it into an <code>afterEach()</code> step:</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"afterEach\">\nafterEach(() =&gt; {\n  // After every test, assert that there are no more pending requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<h3 id=\"custom-request-expectations\" translation-result=\"on\">自訂對請求的預期<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#custom-request-expectations\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Custom request expectations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#custom-request-expectations\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果僅根據 URL 匹配還不夠，你還可以自行實現匹配函式。比如，你可以驗證外發的請求是否帶有某個認證頭：</p><p translation-origin=\"off\">If matching by URL isn't sufficient, it's possible to implement your own matching function.\nFor example, you could look for an outgoing request that has an authorization header:</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"predicate\">\n// Expect one request with an authorization header\nconst req = httpTestingController.expectOne(\n  request =&gt; request.headers.has('Authorization')\n);\n\n</code-example>\n<p translation-result=\"on\">像前面的 <code>expectOne()</code> 測試一樣，如果零或兩個以上的請求滿足了這個斷言，它就會丟擲例外。</p><p translation-origin=\"off\">As with the previous <code>expectOne()</code>, the test fails if 0 or 2+ requests satisfy this predicate.</p>\n\n<h3 id=\"handle-more-than-one-request\" translation-result=\"on\">處理多個請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#handle-more-than-one-request\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Handle more than one request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#handle-more-than-one-request\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你需要在測試中對重複的請求進行響應，可以使用 <code>match()</code> API 來代替 <code>expectOne()</code>，它的引數不變，但會返回一個與這些請求相匹配的陣列。一旦返回，這些請求就會從將來要匹配的列表中移除，你要自己驗證和重新整理（flush）它。</p><p translation-origin=\"off\">If you need to respond to duplicate requests in your test, use the <code>match()</code> API instead of <code>expectOne()</code>.\nIt takes the same arguments but returns an array of matching requests.\nOnce returned, these requests are removed from future matching and you are responsible for flushing and verifying them.</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"multi-request\">\n// get all pending requests that match the given URL\nconst requests = httpTestingController.match(testUrl);\nexpect(requests.length).toEqual(3);\n\n// Respond to each request with different results\nrequests[0].flush([]);\nrequests[1].flush([testData[0]]);\nrequests[2].flush(testData);\n\n</code-example>\n<h2 id=\"test-for-errors\" translation-result=\"on\">對報錯進行測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#test-for-errors\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Test for errors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-test-requests#test-for-errors\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你還要測試應用對於 HTTP 請求失敗時的防護。</p><p translation-origin=\"off\">You should test the app's defenses against HTTP requests that fail.</p>\n\n<p translation-result=\"on\">呼叫 <code>request.flush()</code> 並傳入一個錯誤資訊，如下所示。</p><p translation-origin=\"off\">Call <code>request.flush()</code> with an error message, as seen in the following example.</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"404\">\nit('can test for 404 error', () =&gt; {\n  const emsg = 'deliberate 404 error';\n\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>[]&gt;(testUrl).subscribe({\n    next: () =&gt; fail('should have failed with the 404 error'),\n    error: (error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) =&gt; {\n      expect(error.status).withContext('status').toEqual(404);\n      expect(error.error).withContext('message').toEqual(emsg);\n    },\n  });\n\n  const req = httpTestingController.expectOne(testUrl);\n\n  // Respond with mock error\n  req.flush(emsg, { status: 404, statusText: 'Not Found' });\n});\n\n</code-example>\n<p translation-result=\"on\">另外，還可以用 <code>ProgressEvent</code> 來呼叫 <code>request.error()</code>。</p><p translation-origin=\"off\">Alternatively, call <code>request.error()</code> with a <code>ProgressEvent</code>.</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"network-error\">\nit('can test for network error', done =&gt; {\n  // Create mock ProgressEvent with type `error`, raised when something goes wrong\n  // at network level. e.g. Connection timeout, DNS error, offline, etc.\n  const mockError = new ProgressEvent('error');\n\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>[]&gt;(testUrl).subscribe({\n    next: () =&gt; fail('should have failed with the network error'),\n    error: (error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) =&gt; {\n      expect(error.error).toBe(mockError);\n      done();\n    },\n  });\n\n  const req = httpTestingController.expectOne(testUrl);\n\n  // Respond with mock error\n  req.error(mockError);\n});\n\n</code-example>\n\n  <div class=\"reviewed\">最後複查時間：11/14/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse\n - api/common/http/testing/HttpClientTestingModule\n - api/common/http/testing/HttpTestingController\n - api/core/Inject\n - api/core/testing/TestBed\n - api/forms/SelectMultipleControlValueAccessor\n - api/router/Data\n - guide/http-test-requests#custom-request-expectations\n - guide/http-test-requests#expect-and-answer-requests\n - guide/http-test-requests#handle-more-than-one-request\n - guide/http-test-requests#http-client---test-requests\n - guide/http-test-requests#http-testing-library\n - guide/http-test-requests#http-客戶端---測試請求\n - guide/http-test-requests#http-測試庫\n - guide/http-test-requests#setup-for-testing\n - guide/http-test-requests#test-for-errors\n - guide/http-test-requests#處理多個請求\n - guide/http-test-requests#對報錯進行測試\n - guide/http-test-requests#搭建測試環境\n - guide/http-test-requests#期待並回答請求\n - guide/http-test-requests#自訂對請求的預期\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-test-requests.md?message=docs%3A%20請簡述你的修改...\n-->"}