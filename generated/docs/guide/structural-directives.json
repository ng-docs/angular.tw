{"id":"guide/structural-directives","title":"Structural directives","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/structural-directives.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"structural-directives\" translation-result=\"on\">結構型指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#structural-directives\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Structural directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#structural-directives\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本指南是關於結構指令的，並提供了有關此類指令的工作方式、Angular 如何解釋它們的速記語法以及如何新增範本保護屬性以捕獲範本型別錯誤的概念資訊。</p><p translation-origin=\"off\">This guide is about structural directives and provides conceptual information on how such directives work, how Angular interprets their shorthand syntax, and how to add template guard properties to catch template type errors.</p>\n\n<p translation-result=\"on\">結構指令是透過新增和刪除 DOM 元素來更改 DOM 佈局的指令。</p><p translation-origin=\"off\">Structural directives are directives which change the DOM layout by adding and removing DOM elements.</p>\n\n<p translation-result=\"on\">Angular 提供了一組內建的結構指令（例如 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 、 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 、 <code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> 等），在所有 Angular 專案中通用。有關更多資訊，請參閱<a href=\"guide/built-in-directives\">內建指令</a>。</p><p translation-origin=\"off\">Angular provides a set of built-in structural directives (such as <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>, <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code>, <code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> and others) which are commonly used in all Angular projects. For more information see <a href=\"guide/built-in-directives\">Built-in directives</a>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">對於本頁面介紹的範例應用程式，請參閱<live-example name=\"structural-directives\"></live-example>.</p><p translation-origin=\"off\">For the example application that this page describes, see the <live-example name=\"structural-directives\"></live-example>.</p>\n\n</div>\n<p><a id=\"shorthand\"></a>\n<a id=\"asterisk\"></a></p>\n<h2 id=\"structural-directive-shorthand\" translation-result=\"on\">結構型指令簡寫形式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#structural-directive-shorthand\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Structural directive shorthand<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#structural-directive-shorthand\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">應用結構指令時，它們通常以星號 <code>*</code> 為字首，例如 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>。本約定是 Angular 解釋並轉換為更長形式的速記。Angular 會將結構指令前面的星號轉換為圍繞宿主元素及其後代的 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code>。</p><p translation-origin=\"off\">When structural directives are applied they generally are prefixed by an asterisk, <code>*</code>,  such as <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>. This convention is shorthand that Angular interprets and converts into a longer form.\nAngular transforms the asterisk in front of a structural directive into an <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> that surrounds the host element and its descendants.</p>\n\n<p translation-result=\"on\">例如，讓我們採取以下程式碼，如果 <code>hero</code> 存在，則使用 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 來顯示英雄的名字：</p><p translation-origin=\"off\">For example, let's take the following code which uses an <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> to display the hero's name if <code>hero</code> exists:</p>\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (asterisk)\" region=\"asterisk\">\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\" class=\"name\"&gt;{{hero.name}}&lt;/div&gt;\n\n</code-example>\n<p translation-result=\"on\">Angular 建立一個 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> 元素，並將 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 指令應用於它，在那裡它成為方括號中的屬性繫結 <code>[<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]</code>。然後，<code>&lt;div&gt;</code> 的其餘部分（包括其 class 屬性）會在 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> 中移動：</p><p translation-origin=\"off\">Angular creates an <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> element and applies the <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> directive onto it where it becomes a property binding in square brackets, <code>[<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]</code>. The rest of the <code>&lt;div&gt;</code>, including its class attribute, is then moved inside the <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code>:</p>\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (ngif-template)\" region=\"ngif-template\">\n&lt;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"hero\"&gt;\n  &lt;div class=\"name\"&gt;{{hero.name}}&lt;/div&gt;\n&lt;/ng-template&gt;\n\n</code-example>\n<p translation-result=\"on\">請注意，Angular 實際上並沒有建立真正的 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> 元素，而是僅渲染 <code>&lt;div&gt;</code> 元素。</p><p translation-origin=\"off\">Note that Angular does not actually create a real <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> element, but instead only renders the <code>&lt;div&gt;</code> element.</p>\n\n<code-example language=\"html\">\n&lt;div _ngcontent-c0&gt;Mr. Nice&lt;/div&gt;\n</code-example>\n<p translation-result=\"on\"><code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 中的星號的簡寫形式與非簡寫的 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> 形式進行比較：</p><p translation-origin=\"off\">The following example compares the shorthand use of the asterisk in <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> with the longhand <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> form:</p>\n\n<code-example path=\"structural-directives/src/app/app.component.html\" header=\"src/app/app.component.html (inside-ngfor)\" region=\"inside-ngfor\">\n&lt;div\n  *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; let i=index; let odd=odd; trackBy: trackById\"\n  [class.odd]=\"odd\"&gt;\n  ({{i}}) {{hero.name}}\n&lt;/div&gt;\n\n&lt;ng-template <a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a> let-hero [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"heroes\"\n  let-i=\"index\" let-odd=\"odd\" [ngForTrackBy]=\"trackById\"&gt;\n  &lt;div [class.odd]=\"odd\"&gt;\n    ({{i}}) {{hero.name}}\n  &lt;/div&gt;\n&lt;/ng-template&gt;\n\n</code-example>\n<p translation-result=\"on\">在這裡，與 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 結構指令相關的所有內容都被移動到 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code>。元素上的所有其他繫結和屬性都適用於 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> 中的 <code>&lt;div&gt;</code> 元素。當元素在 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> 中移動時，宿主元素上的其他修飾符（除了 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 字串）會保持在原位。在此範例中，<code>[class.odd]=\"odd\"</code> 保留在 <code>&lt;div&gt;</code> 上。</p><p translation-origin=\"off\">Here, everything related to the <code><a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> structural directive is moved to the <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code>.\nAll other bindings and attributes on the element apply to the <code>&lt;div&gt;</code> element within the <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code>.\nOther modifiers on the host element, in addition to the <code><a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> string, remain in place as the element moves inside the <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code>.\nIn this example, the <code>[class.odd]=\"odd\"</code> stays on the <code>&lt;div&gt;</code>.</p>\n\n<p translation-result=\"on\"><code>let</code> 關鍵字會宣告一個範本輸入變數，你可以在範本中參考該變數。在這個例子中，是 <code>hero</code>、<code>i</code> 和 <code>odd</code>。解析器將 <code>let hero</code>、<code>let i</code> 和 <code>let odd</code> 轉換為名為 <code>let-hero</code>、<code>let-i</code> 和 <code>let-odd</code> 的變數。<code>let-i</code> 和 <code>let-odd</code> 變數變為 <code>let i=index</code> 和 <code>let odd=odd</code>。Angular 會將 <code>i</code> 和 <code>odd</code> 設定為上下文中 <code>index</code> 和 <code>odd</code> 屬性的當前值。</p><p translation-origin=\"off\">The <code>let</code> keyword declares a template input variable that you can reference within the template.\nThe input variables in this example are <code>hero</code>, <code>i</code>, and <code>odd</code>.\nThe parser translates <code>let hero</code>, <code>let i</code>, and <code>let odd</code> into variables named <code>let-hero</code>, <code>let-i</code>, and <code>let-odd</code>.\nThe <code>let-i</code> and <code>let-odd</code> variables become <code>let i=index</code> and <code>let odd=odd</code>.\nAngular sets <code>i</code> and <code>odd</code> to the current value of the context's <code>index</code> and <code>odd</code> properties.</p>\n\n<p translation-result=\"on\">解析器將 PascalCase 應用於所有指令，並以指令的屬性名稱為字首，例如 ngFor。例如，<code><a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 輸入屬性 <code>of</code> 和 <code>trackBy</code> 對映到 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a></code> 和 <code>ngForTrackBy</code>。</p><p translation-origin=\"off\">The parser applies PascalCase to all directives and prefixes them with the directive's attribute name, such as ngFor.\nFor example, the <code><a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> input properties, <code>of</code> and <code>trackBy</code>, map to <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a></code> and <code>ngForTrackBy</code>.</p>\n\n<p translation-result=\"on\">當 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code> 指令遍歷列表時，它會設定和重置其自己的上下文物件的屬性。這些屬性可以包括但不限於 <code>index</code> 、 <code>odd</code> 和名為 <code>$implicit</code> 的特殊屬性。</p><p translation-origin=\"off\">As the <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code> directive loops through the list, it sets and resets properties of its own context object.\nThese properties can include, but aren't limited to, <code>index</code>, <code>odd</code>, and a special property\nnamed <code>$implicit</code>.</p>\n\n<p translation-result=\"on\">Angular 會將 <code>let-hero</code> 設定為上下文的 <code>$implicit</code> 屬性的值，<code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code> 已經將其初始化為當前正在迭代的英雄。</p><p translation-origin=\"off\">Angular sets <code>let-hero</code> to the value of the context's <code>$implicit</code> property, which <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code> has initialized with the hero for the current iteration.</p>\n\n<p translation-result=\"on\">有關更多資訊，請參見 <a href=\"api/common/NgForOf\" title=\"API：NgFor\">NgFor API</a> 和 <a href=\"api/common/NgForOf\">NgForOf API</a> 文件。</p><p translation-origin=\"off\">For more information, see the <a href=\"api/common/NgFor\" title=\"API: NgFor\">NgFor API</a> and <a href=\"api/common/NgForOf\">NgForOf API</a> documentation.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">請注意，Angular 的 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> 元素定義了一個預設不渲染任何內容的範本，如果你只是在 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> 中包裝元素而不應用結構指令，則不會渲染這些元素。</p><p translation-origin=\"off\">Note that Angular's <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> element defines a template that doesn't render anything by default, if you just wrap elements in an <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> without applying a structural directive those elements will not be rendered.</p>\n\n<p translation-result=\"on\">有關更多資訊，請參閱<a href=\"api/core/ng-template\">ng-template API</a>文件。</p><p translation-origin=\"off\">For more information, see the <a href=\"api/core/ng-template\">ng-template API</a> documentation.</p>\n\n</div>\n<p><a id=\"one-per-element\"></a></p>\n<h2 id=\"one-structural-directive-per-element\" translation-result=\"on\">每個元素一個結構指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#one-structural-directive-per-element\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">One structural directive per element<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#one-structural-directive-per-element\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">重複一個 HTML 塊是一個很常見的使用案例，但前提是在特定條件為真時。一種直觀的方法是將 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 和 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 放在同一個元素上。但是，由於 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 和 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 都是結構指令，因此編譯器會將其視為錯誤。你只能將一個 <em> 結構 </em> 指令應用於一個元素。</p><p translation-origin=\"off\">It's a quite common use-case to repeat a block of HTML but only when a particular condition is true. An intuitive way to do that is to put both an <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> and an <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> on the same element. However, since both <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> and <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> are structural directives, this would be treated as an error by the compiler. You may apply only one <em>structural</em> directive to an element.</p>\n\n<p translation-result=\"on\">原因是簡單。結構指令可以用宿主元素及其後代做複雜的事情。</p><p translation-origin=\"off\">The reason is simplicity. Structural directives can do complex things with the host element and its descendants.</p>\n\n<p translation-result=\"on\">當兩個指令都聲稱使用了同一個宿主元素時，哪一個應該優先？</p><p translation-origin=\"off\">When two directives lay claim to the same host element, which one should take precedence?</p>\n\n<p translation-result=\"on\">哪個應該先走，<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 或 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code> ？ <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 可以取消 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code> 的效果嗎？如果是這樣（看起來應該是這樣），Angular 應該如何概括其他結構指令的取消能力？</p><p translation-origin=\"off\">Which should go first, the <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> or the <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>? Can the <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> cancel the effect of the <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>?\nIf so (and it seems like it should be so), how should Angular generalize the ability to cancel for other structural directives?</p>\n\n<p translation-result=\"on\">這些問題沒有簡單的答案。禁止多個結構指令使它們沒有實際意義。這個使用案例有一個簡單的解決方案：將 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 放在包裝 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 元素的容器元素上。一個或兩個元素可以是 <code><a href=\"api/core/ng-container\" class=\"code-anchor\">&lt;ng-container&gt;</a></code>，以便不會產生額外的 DOM 元素。</p><p translation-origin=\"off\">There are no easy answers to these questions. Prohibiting multiple structural directives makes them moot.\nThere's an easy solution for this use case: put the <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> on a container element that wraps the <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> element. One or both elements can be an <code><a href=\"api/core/ng-container\" class=\"code-anchor\">&lt;ng-container&gt;</a></code> so that no extra DOM elements are generated.</p>\n\n<p><a id=\"unless\"></a></p>\n<h2 id=\"creating-a-structural-directive\" translation-result=\"on\">建立結構型指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#creating-a-structural-directive\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Creating a structural directive<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#creating-a-structural-directive\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本節將指導你建立 <code>UnlessDirective</code> 以及如何設定 <code>condition</code> 值。<code>UnlessDirective</code> 與 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 相反，並且 <code>condition</code> 值可以設定為 <code>true</code> 或 <code>false</code>。<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 為 <code>true</code> 時顯示範本內容；而 <code>UnlessDirective</code> 在這個條件為 <code>false</code> 時顯示內容。</p><p translation-origin=\"off\">This section guides you through creating an <code>UnlessDirective</code> and how to set <code>condition</code> values.\nThe <code>UnlessDirective</code> does the opposite of <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>, and <code>condition</code> values can be set to <code>true</code> or <code>false</code>.\n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> displays the template content when the condition is <code>true</code>.\n<code>UnlessDirective</code> displays the content when the condition is <code>false</code>.</p>\n\n<p translation-result=\"on\">以下是應用於 p 元素的 <code>UnlessDirective</code> 選擇器 <code>appUnless</code> 當 <code>condition</code> 為 <code>false</code>，瀏覽器將顯示該句子。</p><p translation-origin=\"off\">Following is the <code>UnlessDirective</code> selector, <code>appUnless</code>, applied to the paragraph element.\nWhen <code>condition</code> is <code>false</code>, the browser displays the sentence.</p>\n\n<code-example header=\"src/app/app.component.html (appUnless-1)\" path=\"structural-directives/src/app/app.component.html\" region=\"appUnless-1\">\n&lt;p *appUnless=\"condition\"&gt;Show this sentence unless the condition is true.&lt;/p&gt;\n\n</code-example>\n<ol>\n<li>\n<p translation-result=\"on\">使用 Angular CLI，執行以下命令，其中 <code>unless</code> 是偽指令的名稱：</p><p translation-origin=\"off\">Using the Angular CLI, run the following command, where <code>unless</code> is the name of the directive:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate directive unless\n\n</code-example>\n<p translation-result=\"on\">Angular 會建立指令類，並指定 CSS 選擇器 <code>appUnless</code>，它會在範本中標識指令。</p><p translation-origin=\"off\">Angular creates the directive class and specifies the CSS selector, <code>appUnless</code>, that identifies the directive in a template.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">匯入 <code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>、<code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> 和 <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code>。</p><p translation-origin=\"off\">Import <code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code>, <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code>, and <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code>.</p>\n\n<code-example header=\"src/app/unless.directive.ts (skeleton)\" path=\"structural-directives/src/app/unless.directive.ts\" region=\"skeleton\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>, <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[appUnless]'})\nexport class UnlessDirective {\n}\n\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">在指令的建構函式中將 <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> 和 <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> 注入成私有變數。</p><p translation-origin=\"off\">Inject <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> and <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> in the directive constructor as private variables.</p>\n\n<code-example header=\"src/app/unless.directive.ts (ctor)\" path=\"structural-directives/src/app/unless.directive.ts\" region=\"ctor\">\nconstructor(\n  private templateRef: <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>&lt;any&gt;,\n  private viewContainer: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) { }\n\n</code-example>\n<p translation-result=\"on\"><code>UnlessDirective</code> 會透過 Angular 產生的 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> 建立一個<a href=\"api/core/EmbeddedViewRef\" title=\"API：EmbeddedViewRef\">嵌入的檢視</a>，然後將該檢視插入到該指令的原始 <code>&lt;p&gt;</code> 宿主元素緊後面的<a href=\"api/core/ViewContainerRef\" title=\"API：ViewContainerRef\">檢視容器</a>中。</p><p translation-origin=\"off\">The <code>UnlessDirective</code> creates an <a href=\"api/core/EmbeddedViewRef\" title=\"API: EmbeddedViewRef\">embedded view</a> from the Angular-generated <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> and inserts that view in a <a href=\"api/core/ViewContainerRef\" title=\"API: ViewContainerRef\">view container</a> adjacent to the directive's original <code>&lt;p&gt;</code> host element.</p>\n\n<p translation-result=\"on\"><a href=\"api/core/TemplateRef\" title=\"API：TemplateRef\"><code>TemplateRef</code></a>可幫助你獲取 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> 的內容，而 <a href=\"api/core/ViewContainerRef\" title=\"API：ViewContainerRef\"><code>ViewContainerRef</code></a> 可以存取檢視容器。</p><p translation-origin=\"off\"><a href=\"api/core/TemplateRef\" title=\"API: TemplateRef\"><code>TemplateRef</code></a> helps you get to the <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> contents and <a href=\"api/core/ViewContainerRef\" title=\"API: ViewContainerRef\"><code>ViewContainerRef</code></a> accesses the view container.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">新增一個帶 setter 的 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 屬性 <code>appUnless</code>。</p><p translation-origin=\"off\">Add an <code>appUnless</code> <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> property with a setter.</p>\n\n<code-example header=\"src/app/unless.directive.ts (set)\" path=\"structural-directives/src/app/unless.directive.ts\" region=\"set\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() set appUnless(condition: boolean) {\n  if (!condition &amp;&amp; !this.hasView) {\n    this.viewContainer.createEmbeddedView(this.templateRef);\n    this.hasView = true;\n  } else if (condition &amp;&amp; this.hasView) {\n    this.viewContainer.clear();\n    this.hasView = false;\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">每當條件的值更改時，Angular 都會設定 <code>appUnless</code> 屬性。</p><p translation-origin=\"off\">Angular sets the <code>appUnless</code> property whenever the value of the condition changes.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">如果條件是假值，並且 Angular 以前尚未建立檢視，則此 setter 會導致檢視容器從範本創建出嵌入式檢視。</p><p translation-origin=\"off\">If the condition is falsy and Angular hasn't created the view previously, the setter causes the view container to create the embedded view from the template</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果條件為真值，並且當前正顯示著檢視，則此 setter 會清除容器，這會導致銷燬該檢視。</p><p translation-origin=\"off\">If the condition is truthy and the view is currently displayed, the setter clears the container, which disposes of the view</p>\n\n</li>\n</ul>\n</li>\n</ol>\n<p translation-result=\"on\">完整的指令如下：</p><p translation-origin=\"off\">The complete directive is as follows:</p>\n\n<code-example header=\"src/app/unless.directive.ts (excerpt)\" path=\"structural-directives/src/app/unless.directive.ts\" region=\"no-docs\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>, <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a> } from '@angular/core';\n\n/**\n * Add the template content to the DOM unless the condition is true.\n */\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[appUnless]'})\nexport class UnlessDirective {\n  private hasView = false;\n\n  constructor(\n    private templateRef: <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>&lt;any&gt;,\n    private viewContainer: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) { }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() set appUnless(condition: boolean) {\n    if (!condition &amp;&amp; !this.hasView) {\n      this.viewContainer.createEmbeddedView(this.templateRef);\n      this.hasView = true;\n    } else if (condition &amp;&amp; this.hasView) {\n      this.viewContainer.clear();\n      this.hasView = false;\n    }\n  }\n}\n\n\n</code-example>\n<h3 id=\"testing-the-directive\" translation-result=\"on\">測試指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#testing-the-directive\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Testing the directive<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#testing-the-directive\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在本節中，你將更新你的應用程式，以測試 <code>UnlessDirective</code>。</p><p translation-origin=\"off\">In this section, you'll update your application to test the <code>UnlessDirective</code>.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">新增一個 <code>condition</code> 設定為 <code>false</code> 的 <code>AppComponent</code>。</p><p translation-origin=\"off\">Add a <code>condition</code> set to <code>false</code> in the <code>AppComponent</code>.</p>\n\n<code-example header=\"src/app/app.component.ts (excerpt)\" path=\"structural-directives/src/app/app.component.ts\" region=\"condition\">\ncondition = false;\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">更新範本以使用指令。這裡，<code>*appUnless</code> 位於兩個具有相反 <code>condition</code> 的 <code>&lt;p&gt;</code> 標記上，一個為 <code>true</code>，一個為 <code>false</code>。</p><p translation-origin=\"off\">Update the template to use the directive.\nHere, <code>*appUnless</code> is on two <code>&lt;p&gt;</code> tags with opposite <code>condition</code> values, one <code>true</code> and one <code>false</code>.</p>\n\n<code-example header=\"src/app/app.component.html (appUnless)\" path=\"structural-directives/src/app/app.component.html\" region=\"appUnless\">\n&lt;p *appUnless=\"condition\" class=\"unless a\"&gt;\n  (A) This paragraph is displayed because the condition is false.\n&lt;/p&gt;\n\n&lt;p *appUnless=\"!condition\" class=\"unless b\"&gt;\n  (B) Although the condition is true,\n  this paragraph is displayed because appUnless is set to false.\n&lt;/p&gt;\n\n</code-example>\n<p translation-result=\"on\">星號是將 <code>appUnless</code> 標記為結構型指令的簡寫形式。如果 <code>condition</code> 是假值，則會讓頂部段落 A，而底部段落 B 消失。當 <code>condition</code> 為真時，頂部段落 A 消失，而底部段落 B 出現。</p><p translation-origin=\"off\">The asterisk is shorthand that marks <code>appUnless</code> as a structural directive.\nWhen the <code>condition</code> is falsy, the top (A) paragraph appears and the bottom (B) paragraph disappears.\nWhen the <code>condition</code> is truthy, the top (A) paragraph disappears and the bottom (B) paragraph appears.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">要在瀏覽器中更改並顯示 <code>condition</code> 的值，請新增一段標記程式碼以顯示狀態和按鈕。</p><p translation-origin=\"off\">To change and display the value of <code>condition</code> in the browser, add markup that displays the status and a button.</p>\n\n<code-example header=\"src/app/app.component.html\" path=\"structural-directives/src/app/app.component.html\" region=\"toggle-info\">\n&lt;p&gt;\n  The condition is currently\n  &lt;span [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{ 'a': !condition, 'b': condition, 'unless': true }\"&gt;{{condition}}&lt;/span&gt;.\n  &lt;button\n    type=\"button\"\n    (click)=\"condition = !condition\"\n    [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] = \"{ 'a': condition, 'b': !condition }\" &gt;\n    Toggle condition to {{condition ? 'false' : 'true'}}\n  &lt;/button&gt;\n&lt;/p&gt;\n\n</code-example>\n</li>\n</ol>\n<p translation-result=\"on\">要驗證指令是否有效，請單擊按鈕以更改 <code>condition</code> 的值。</p><p translation-origin=\"off\">To verify that the directive works, click the button to change the value of <code>condition</code>.</p>\n\n<div class=\"lightbox\">\n<img alt=\"UnlessDirective in action\" src=\"generated/images/guide/structural-directives/unless-anim.gif\" width=\"524\" height=\"100\">\n</div>\n<h2 id=\"structural-directive-syntax-reference\" translation-result=\"on\">結構型指令語法參考<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#structural-directive-syntax-reference\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Structural directive syntax reference<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#structural-directive-syntax-reference\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">當你編寫自己的結構型指令時，請使用以下語法：</p><p translation-origin=\"off\">When you write your own structural directives, use the following syntax:</p>\n\n<code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\">\n\n*:prefix=\"( :let | :expression ) (';' | ',')? ( :let | :as | :keyExp )*\"\n\n</code-example>\n<p translation-result=\"on\">下表描述了結構型指令語法的每個部分：</p><p translation-origin=\"off\">The following tables describe each portion of the structural directive grammar:</p>\n\n<code-tabs>\n    <code-pane format=\"typescript\" header=\"as\" hidecopy=\"\" language=\"typescript\"> as = :export \"as\" :local \";\"? </code-pane>\n    <code-pane format=\"typescript\" header=\"keyExp\" hidecopy=\"\" language=\"typescript\"> keyExp = :key \":\"? :expression (\"as\" :local)? \";\"? </code-pane>\n    <code-pane format=\"typescript\" header=\"let\" hidecopy=\"\" language=\"typescript\"> let = \"let\" :local \"=\" :export \";\"? </code-pane>\n</code-tabs>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">關鍵字</nt-wrapper><nt-wrapper translation-origin=\"off\">Keyword</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>prefix</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">HTML 屬性的鍵名</nt-wrapper><nt-wrapper translation-origin=\"off\">HTML attribute key</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>key</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">HTML 屬性的鍵名</nt-wrapper><nt-wrapper translation-origin=\"off\">HTML attribute key</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>local</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在範本中使用的區域變數名</nt-wrapper><nt-wrapper translation-origin=\"off\">Local variable name used in the template</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>export</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">該指令以特定名稱匯出的值</nt-wrapper><nt-wrapper translation-origin=\"off\">Value exported by the directive under a given name</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>expression</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">標準 Angular 表示式</nt-wrapper><nt-wrapper translation-origin=\"off\">Standard Angular expression</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<h3 id=\"how-angular-translates-shorthand\" translation-result=\"on\">Angular 如何翻譯簡寫形式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#how-angular-translates-shorthand\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">How Angular translates shorthand<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#how-angular-translates-shorthand\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 會將結構型指令的簡寫形式轉換為普通的繫結語法，如下所示：</p><p translation-origin=\"off\">Angular translates structural directive shorthand into the normal binding syntax as follows:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">簡寫形式</nt-wrapper><nt-wrapper translation-origin=\"off\">Shorthand</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">翻譯結果</nt-wrapper><nt-wrapper translation-origin=\"off\">Translation</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><code>prefix</code> 和裸 <code>expression</code></nt-wrapper><nt-wrapper translation-origin=\"off\"><code>prefix</code> and naked <code>expression</code></nt-wrapper></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> [prefix]=\"expression\" </code-example></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>keyExp</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> [prefixKey] \"expression\" (let-prefixKey=\"export\") </code-example> <div class=\"alert is-helpful\"> <strong>注意</strong>: <br> <code>prefix</code> 被加到了 <code>key</code> 上</div></nt-wrapper><nt-wrapper translation-origin=\"off\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> [prefixKey] \"expression\" (let-prefixKey=\"export\") </code-example> <div class=\"alert is-helpful\"> <strong>NOTE</strong>: <br> The <code>prefix</code> is added to the <code>key</code> </div></nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>keyExp</code></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> [prefixKey] \"expression\" (let-prefixKey=\"export\") </code-example></td>\n</tr>\n<tr>\n<td align=\"left\"><code>let</code></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> let-local=\"export\" </code-example></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"shorthand-examples\" translation-result=\"on\">簡寫形式範例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#shorthand-examples\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Shorthand examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#shorthand-examples\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">下表提供了一些簡寫形式範例：</p><p translation-origin=\"off\">The following table provides shorthand examples:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">簡寫形式</nt-wrapper><nt-wrapper translation-origin=\"off\">Shorthand</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">Angular 如何解釋此語法</nt-wrapper><nt-wrapper translation-origin=\"off\">How Angular interprets the syntax</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let item of [1,2,3]\" </code-example></td>\n<td align=\"left\"><code-example format=\"html\" hidecopy=\"\" language=\"html\"> &lt;ng-template <a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a> \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let-item \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"[1,2,3]\"&gt; </code-example></td>\n</tr>\n<tr>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let item of [1,2,3] as items; \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trackBy: myTrack; index as i\" </code-example></td>\n<td align=\"left\"><code-example format=\"html\" hidecopy=\"\" language=\"html\"> &lt;ng-template <a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a> \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let-item \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>]=\"[1,2,3]\" \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let-items=\"<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngForOf</a>\" \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ngForTrackBy]=\"myTrack\" \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let-i=\"index\"&gt; </code-example></td>\n</tr>\n<tr>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"exp\" </code-example></td>\n<td align=\"left\"><code-example format=\"html\" hidecopy=\"\" language=\"html\"> &lt;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"exp\"&gt; </code-example></td>\n</tr>\n<tr>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"exp as value\" </code-example></td>\n<td align=\"left\"><code-example format=\"html\" hidecopy=\"\" language=\"html\"> &lt;ng-template [<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>]=\"exp\" \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let-value=\"<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>\"&gt; </code-example></td>\n</tr>\n</tbody>\n</table>\n<p><a id=\"directive-type-checks\"></a></p>\n<!--todo: To do follow up PR: move this section to a more general location because it also applies to attribute directives. -->\n<h2 id=\"improving-template-type-checking-for-custom-directives\" translation-result=\"on\">改進自訂指令的範本型別檢查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#improving-template-type-checking-for-custom-directives\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Improving template type checking for custom directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#improving-template-type-checking-for-custom-directives\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以透過將範本守衛屬性新增到指令定義中來改進自訂指令的範本型別檢查。這些屬性可幫助 Angular 的範本型別檢查器在編譯時發現範本中的錯誤，從而避免執行時錯誤。這些屬性如下：</p><p translation-origin=\"off\">You can improve template type checking for custom directives by adding template guard properties to your directive definition.\nThese properties help the Angular template type checker find mistakes in the template at compile time, which can avoid runtime errors.\nThese properties are as follows:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>ngTemplateGuard_(someInputProperty)</code> 屬性使你可以為範本中的輸入表示式指定更準確的型別。</p><p translation-origin=\"off\">A property <code>ngTemplateGuard_(someInputProperty)</code> lets you specify a more accurate type for an input expression within the template</p>\n\n</li>\n<li>\n<p translation-result=\"on\">靜態屬性 <code>ngTemplateContextGuard</code> 聲明瞭範本上下文的型別。</p><p translation-origin=\"off\">The <code>ngTemplateContextGuard</code> static property declares the type of the template context</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">本節提供了兩種型別守衛的範例。欲知詳情，請參見<a href=\"guide/template-typecheck\" title=\"範本型別檢查指南\">範本型別檢查</a>。</p><p translation-origin=\"off\">This section provides examples of both kinds of type-guard property.\nFor more information, see <a href=\"guide/template-typecheck\" title=\"Template type-checking guide\">Template type checking</a>.</p>\n\n<p><a id=\"narrowing-input-types\"></a></p>\n<h3 id=\"making-in-template-type-requirements-more-specific-with-template-guards\" translation-result=\"on\">使用範本守衛使範本中的型別要求更具體<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#making-in-template-type-requirements-more-specific-with-template-guards\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Making in-template type requirements more specific with template guards<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#making-in-template-type-requirements-more-specific-with-template-guards\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">範本中的結構型指令會根據輸入表示式來控制是否要在執行時渲染該範本。為了幫助編譯器捕獲範本型別中的錯誤，你應該儘可能詳細地指定範本內指令的輸入表示式所期待的型別。</p><p translation-origin=\"off\">A structural directive in a template controls whether that template is rendered at run time, based on its input expression.\nTo help the compiler catch template type errors, you should specify as closely as possible the required type of a directive's input expression when it occurs inside the template.</p>\n\n<p translation-result=\"on\">型別保護函式會將輸入表示式的預期型別縮小為可能在執行時傳遞給範本內指令的型別的子集。你可以提供這樣的功能來幫助型別檢查器在編譯時為表示式推斷正確的型別。</p><p translation-origin=\"off\">A type guard function narrows the expected type of an input expression to a subset of types that might be passed to the directive within the template at run time.\nYou can provide such a function to help the type-checker infer the proper type for the expression at compile time.</p>\n\n<p translation-result=\"on\">比如，<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 的實現使用型別窄化來確保只有當 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 的輸入表示式為真時，範本才會被例項化。為了提供具體的型別要求，<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 指令定義了一個<a href=\"api/common/NgIf#static-properties\">靜態屬性 <code>ngTemplateGuard_ngIf: 'binding'</code></a>。這裡的 <code>binding</code> 值是一種常見的型別窄化的例子，它會對輸入表示式進行求值，以滿足型別要求。</p><p translation-origin=\"off\">For example, the <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> implementation uses type-narrowing to ensure that the template is only instantiated if the input expression to <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> is truthy.\nTo provide the specific type requirement, the <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> directive defines a <a href=\"api/common/NgIf#static-properties\">static property <code>ngTemplateGuard_ngIf: 'binding'</code></a>.\nThe <code>binding</code> value is a special case for a common kind of type-narrowing where the input expression is evaluated in order to satisfy the type requirement.</p>\n\n<p translation-result=\"on\">要為範本中指令的輸入表示式提供更具體的型別，請在指令中新增 <code>ngTemplateGuard_xx</code> 屬性，其中靜態屬性名稱 <code>xx</code> 就是 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 欄位的名字。該屬性的值可以是基於其返回型別的常規型別窄化函式，也可以是字串，比如 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 中的 <code>\"binding\"</code>。</p><p translation-origin=\"off\">To provide a more specific type for an input expression to a directive within the template, add an <code>ngTemplateGuard_xx</code> property to the directive, where the suffix to the static property name, <code>xx</code>, is the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> field name.\nThe value of the property can be either a general type-narrowing function based on its return type, or the string <code>\"binding\"</code>, as in the case of <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>.</p>\n\n<p translation-result=\"on\">比如，考慮以下結構型指令，該指令以範本表示式的結果作為輸入：</p><p translation-origin=\"off\">For example, consider the following structural directive that takes the result of a template expression as an input:</p>\n\n<code-tabs linenums=\"true\">\n  <code-pane header=\"src/app/if-loaded.directive.ts\" path=\"structural-directives/src/app/if-loaded.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>, <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a> } from '@angular/core';\n\nimport { Loaded, LoadingState } from './loading-state';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[appIfLoaded]' })\nexport class IfLoadedDirective&lt;T&gt; {\n  private isViewCreated = false;\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appIfLoaded') set state(state: LoadingState&lt;T&gt;) {\n    if (!this.isViewCreated &amp;&amp; state.type === 'loaded') {\n      this.viewContainerRef.createEmbeddedView(this.templateRef);\n      this.isViewCreated = true;\n    } else if (this.isViewCreated &amp;&amp; state.type !== 'loaded') {\n      this.viewContainerRef.clear();\n      this.isViewCreated = false;\n    }\n  }\n\n  constructor(\n    private readonly viewContainerRef: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>,\n    private readonly templateRef: <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>&lt;unknown&gt;\n  ) {}\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngTemplateGuard_appIfLoaded&lt;T&gt;(\n    dir: IfLoadedDirective&lt;T&gt;,\n    state: LoadingState&lt;T&gt;\n  ): state is Loaded&lt;T&gt; {\n    return true;\n  }\n}\n\n\n</code-pane>\n  <code-pane header=\"src/app/loading-state.ts\" path=\"structural-directives/src/app/loading-state.ts\">\nexport type Loaded&lt;T&gt; = { type: 'loaded', data: T };\n\nexport type Loading = { type: 'loading' };\n\nexport type LoadingState&lt;T&gt; = Loaded&lt;T&gt; | Loading;\n\n\n</code-pane>\n  <code-pane header=\"src/app/hero.component.ts\" path=\"structural-directives/src/app/hero.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { LoadingState } from './loading-state';\nimport { Hero, heroes } from './hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: `\n    &lt;button (click)=\"onLoadHero()\"&gt;Load Hero&lt;/button&gt;\n    &lt;p *appIfLoaded=\"heroLoadingState\"&gt;{{ heroLoadingState.data | json }}&lt;/p&gt;\n  `,\n})\nexport class HeroComponent {\n  heroLoadingState: LoadingState&lt;Hero&gt; = { type: 'loading' };\n\n  onLoadHero(): void {\n    this.heroLoadingState = { type: 'loaded', data: heroes[0] };\n  }\n}\n\n\n</code-pane>\n</code-tabs>\n<p translation-result=\"on\">在這個例子中，<code>LoadingState&lt;T&gt;</code> 型別允許兩個狀態之一，<code>Loaded&lt;T&gt;</code> 或 <code>Loading</code>。用作指令的 <code>state</code> 輸入（別名為 <code>appIfLoaded</code>）的表示式是寬泛的傘形型別 <code>LoadingState</code>，因為還不知道此時的載入狀態是什麼。</p><p translation-origin=\"off\">In this example, the <code>LoadingState&lt;T&gt;</code> type permits either of two states, <code>Loaded&lt;T&gt;</code> or <code>Loading</code>.\nThe expression used as the directive's <code>state</code> input (aliased as <code>appIfLoaded</code>) is of the umbrella type <code>LoadingState</code>, as it's unknown what the loading state is at that point.</p>\n\n<p translation-result=\"on\"><code>IfLoadedDirective</code> 定義聲明瞭靜態欄位 <code>ngTemplateGuard_appIfLoaded</code>，以表示其窄化行為。在 <code>AppComponent</code> 範本中，<code>*appIfLoaded</code> 結構型指令只有當實際的 <code>state</code> 是 <code>Loaded&lt;Person&gt;</code> 型別時，才會渲染該範本。型別守護允許型別檢查器推斷出範本中可接受的 <code>state</code> 型別是 <code>Loaded&lt;T&gt;</code>，並進一步推斷出 <code>T</code> 必須是一個 <code>Hero</code> 的例項。</p><p translation-origin=\"off\">The <code>IfLoadedDirective</code> definition declares the static field <code>ngTemplateGuard_appIfLoaded</code>, which expresses the narrowing behavior.\nWithin the <code>AppComponent</code> template, the <code>*appIfLoaded</code> structural directive should render this template only when <code>state</code> is actually <code>Loaded&lt;Hero&gt;</code>.\nThe type guard lets the type checker infer that the acceptable type of <code>state</code> within the template is a <code>Loaded&lt;T&gt;</code>, and further infer that <code>T</code> must be an instance of <code>Hero</code>.</p>\n\n<p><a id=\"narrowing-context-type\"></a></p>\n<h3 id=\"typing-the-directives-context\" translation-result=\"on\">為指令的上下文指定型別<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#typing-the-directives-context\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Typing the directive's context<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#typing-the-directives-context\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你的結構型指令要為例項化的範本提供一個上下文，可以透過提供靜態的 <code>ngTemplateContextGuard</code> 函式在範本中給它提供合適的型別。下面的程式碼片段展示了該函式的一個例子。</p><p translation-origin=\"off\">If your structural directive provides a context to the instantiated template, you can properly type it inside the template by providing a static <code>ngTemplateContextGuard</code> function.\nThe following snippet shows an example of such a function.</p>\n\n<code-tabs linenums=\"true\">\n  <code-pane header=\"src/app/trigonometry.directive.ts\" path=\"structural-directives/src/app/trigonometry.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>, <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[appTrigonometry]' })\nexport class TrigonometryDirective {\n  private isViewCreated = false;\n  private readonly context = new TrigonometryContext();\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appTrigonometry') set angle(angleInDegrees: number) {\n    const angleInRadians = toRadians(angleInDegrees);\n    this.context.sin = Math.sin(angleInRadians);\n    this.context.cos = Math.cos(angleInRadians);\n    this.context.tan = Math.tan(angleInRadians);\n\n    if (!this.isViewCreated) {\n      this.viewContainerRef.createEmbeddedView(this.templateRef, this.context);\n      this.isViewCreated = true;\n    }\n  }\n\n  constructor(\n    private readonly viewContainerRef: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>,\n    private readonly templateRef: <a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a>&lt;TrigonometryContext&gt;\n  ) {}\n\n  // Make sure the template checker knows the type of the context with which the\n  // template of this directive will be rendered\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngTemplateContextGuard(\n    directive: TrigonometryDirective,\n    context: unknown\n  ): context is TrigonometryContext {\n    return true;\n  }\n}\n\nclass TrigonometryContext {\n  sin = 0;\n  cos = 0;\n  tan = 0;\n}\n\nfunction toRadians(degrees: number): number {\n  return degrees * (Math.PI / 180);\n}\n\n\n</code-pane>\n  <code-pane header=\"src/app/app.component.html (appTrigonometry)\" path=\"structural-directives/src/app/app.component.html\" region=\"appTrigonometry\">\n&lt;ul *appTrigonometry=\"30; sin as s; cos as c; tan as t\"&gt;\n  &lt;li&gt;sin(30°): {{ s }}&lt;/li&gt;\n  &lt;li&gt;cos(30°): {{ c }}&lt;/li&gt;\n  &lt;li&gt;tan(30°): {{ t }}&lt;/li&gt;\n&lt;/ul&gt;\n\n</code-pane>\n</code-tabs>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/common\n - api/common/CommonModule\n - api/common/NgFor\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/NgSwitch\n - api/core/ng-container\n - api/core/ng-template\n - guide/ajs-quick-reference\n - guide/aot-compiler\n - guide/architecture-components\n - guide/binding-overview\n - guide/bootstrapping\n - guide/built-in-directives\n - guide/example-apps-list\n - guide/glossary\n - guide/template-reference-variables\n - guide/template-statements\n - guide/template-typecheck\n - guide/understanding-template-expr-overview\n - start\n-->\n<!-- links from this doc:\n - api/common/NgClass\n - api/common/NgFor\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/NgIf#static-properties\n - api/common/NgSwitch\n - api/core/Component\n - api/core/Directive\n - api/core/EmbeddedViewRef\n - api/core/Input\n - api/core/TemplateRef\n - api/core/ViewContainerRef\n - api/core/ng-container\n - api/core/ng-template\n - api/upgrade/static\n - guide/built-in-directives\n - guide/structural-directives#angular-如何翻譯簡寫形式\n - guide/structural-directives#creating-a-structural-directive\n - guide/structural-directives#how-angular-translates-shorthand\n - guide/structural-directives#improving-template-type-checking-for-custom-directives\n - guide/structural-directives#making-in-template-type-requirements-more-specific-with-template-guards\n - guide/structural-directives#one-structural-directive-per-element\n - guide/structural-directives#shorthand-examples\n - guide/structural-directives#structural-directive-shorthand\n - guide/structural-directives#structural-directive-syntax-reference\n - guide/structural-directives#structural-directives\n - guide/structural-directives#testing-the-directive\n - guide/structural-directives#typing-the-directives-context\n - guide/structural-directives#為指令的上下文指定型別\n - guide/structural-directives#使用範本守衛使範本中的型別要求更具體\n - guide/structural-directives#建立結構型指令\n - guide/structural-directives#改進自訂指令的範本型別檢查\n - guide/structural-directives#每個元素一個結構指令\n - guide/structural-directives#測試指令\n - guide/structural-directives#簡寫形式範例\n - guide/structural-directives#結構型指令\n - guide/structural-directives#結構型指令簡寫形式\n - guide/structural-directives#結構型指令語法參考\n - guide/template-typecheck\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/structural-directives.md?message=docs%3A%20請簡述你的修改...\n-->"}