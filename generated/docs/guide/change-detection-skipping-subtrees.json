{"id":"guide/change-detection-skipping-subtrees","title":"Skipping component subtrees","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/change-detection-skipping-subtrees.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"skipping-component-subtrees\" translation-result=\"on\">跳過元件子樹<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#skipping-component-subtrees\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Skipping component subtrees<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#skipping-component-subtrees\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">預設情況下，JavaScript 會使用你可以從多個不同元件參考的可變資料結構。Angular 會在你的整個元件樹上執行變更檢測，以確保資料結構的最新狀態反映在 DOM 中。</p><p translation-origin=\"off\">JavaScript, by default, uses mutable data structures that you can reference from multiple different components. Angular runs change detection over your entire component tree to make sure that the most up-to-date state of your data structures is reflected in the DOM.</p>\n\n<p translation-result=\"on\">對於大多數應用程式，變更檢測都足夠快。但是，當應用程式有特別大的元件樹時，在整個應用程式中執行變更檢測可能會導致效能問題。你可以透過將變更檢測配置為僅在元件樹的子集上執行來解決這個問題。</p><p translation-origin=\"off\">Change detection is sufficiently fast for most applications. However, when an application has an especially large component tree, running change detection across the whole application can cause performance issues. You can address this by configuring change detection to only run on a subset of the component tree.</p>\n\n<p translation-result=\"on\">如果你確信應用程式的一部分不受狀態更改的影響，可以用 <a href=\"/api/core/ChangeDetectionStrategy\">OnPush</a> 跳過整個元件子樹中的變更檢測。</p><p translation-origin=\"off\">If you are confident that a part of the application is not affected by a state change, you can use <a href=\"/api/core/ChangeDetectionStrategy\">OnPush</a> to skip change detection in an entire component subtree.</p>\n\n<h2 id=\"using-onpush\" translation-result=\"on\">使用 <code>OnPush</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#using-onpush\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Using <code>OnPush</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#using-onpush\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">OnPush 變更檢測會指示 Angular 僅在以下情況下為元件子樹執行變更檢測：</p><p translation-origin=\"off\">OnPush change detection instructs Angular to run change detection for a component subtree <strong>only</strong> when:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">子樹的根元件接收到作為範本繫結的結果的新輸入。Angular 將輸入的當前值和過去值使用 <code>==</code> 進行比較</p><p translation-origin=\"off\">The root component of the subtree receives new inputs as the result of a template binding. Angular compares the current and past value of the input with <code>==</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">Angular 在本子樹的根元件或它的任何子元件（而不管其是否使用 OnPush 變更檢測方式）中處理使用 OnPush 變更檢測策略的元件中的事件（比如事件繫結、輸出繫結或 <code>@<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a></code>）時</p><p translation-origin=\"off\">Angular handles an event <em>(for example using event binding, output binding, or <code>@<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a></code> )</em> in the subtree's root component or any of its children whether they are using OnPush change detection or not.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">你可以在 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 裝飾器中將元件的變更檢測策略設定為 <code>OnPush</code>：</p><p translation-origin=\"off\">You can set the change detection strategy of a component to <code>OnPush</code> in the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> decorator:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/core/ChangeDetectionStrategy\" class=\"code-anchor\">ChangeDetectionStrategy</a>, <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  changeDetection: <a href=\"api/core/ChangeDetectionStrategy#OnPush\" class=\"code-anchor\">ChangeDetectionStrategy.OnPush</a>,\n})\nexport class MyComponent {}\n</code-example>\n<h2 id=\"common-change-detection-scenarios\" translation-result=\"on\">常見的變更檢測場景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#common-change-detection-scenarios\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Common change detection scenarios<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#common-change-detection-scenarios\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本節展示了幾種常見的變更檢測場景，以說明 Angular 的行為。</p><p translation-origin=\"off\">This section examines several common change detection scenarios to illustrate Angular's behavior.</p>\n\n<h2 id=\"an-event-is-handled-by-a-component-with-default-change-detection\" translation-result=\"on\">事件由具有預設變更檢測的元件處理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-default-change-detection\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">An event is handled by a component with default change detection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-default-change-detection\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果 Angular 在沒有 <code>OnPush</code> 策略的情況下處理元件中的事件，則框架會在整個元件樹上執行變更檢測。Angular 將跳過具有 <code>OnPush</code> 策略的元件的後代元件子樹，如果該元件沒有收到新輸入的話。</p><p translation-origin=\"off\">If Angular handles an event within a component without <code>OnPush</code> strategy, the framework executes change detection on the entire component tree. Angular will skip descendant component subtrees with roots using <code>OnPush</code>, which have not received new inputs.</p>\n\n<p translation-result=\"on\">比如，如果我們將 <code>MainComponent</code> 的變更檢測策略設定為 <code>OnPush</code>，並且使用者與具有根 <code>MainComponent</code> 的子樹外的元件互動，Angular 將檢查下圖中的所有綠色元件（<code>AppComponent</code> 、 <code>HeaderComponent</code> 、 <code>SearchComponent</code> 、 <code>ButtonComponent</code>），除非 <code>MainComponent</code> 接收到了新的輸入：</p><p translation-origin=\"off\">As an example, if we set the change detection strategy of <code>MainComponent</code> to <code>OnPush</code> and the user interacts with a component outside the subtree with root <code>MainComponent</code>, Angular will check all the green components from the diagram below (<code>AppComponent</code>, <code>HeaderComponent</code>, <code>SearchComponent</code>, <code>ButtonComponent</code>) unless <code>MainComponent</code> receives new inputs:</p>\n\n<div class=\"lightbox\">\n  <img alt=\"Change detection propagation from non-OnPush component\" src=\"generated/images/guide/change-detection/event-trigger.svg\" width=\"741\" height=\"261\">\n</div>\n<h2 id=\"an-event-is-handled-by-a-component-with-onpush\" translation-result=\"on\">事件由具有 OnPush 的元件處理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-onpush\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">An event is handled by a component with OnPush<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-onpush\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果 Angular 使用 OnPush 策略處理元件中的事件，則框架將在整個元件樹中執行變更檢測。Angular 將忽略以具有 OnPush 策略的元件為根的元件子樹（如果這個根元件尚未接收到新輸入並且在處理此事件的元件外部）。</p><p translation-origin=\"off\">If Angular handles an event within a component with OnPush strategy, the framework will execute change detection within the entire component tree. Angular will ignore component subtrees with roots using OnPush, which have not received new inputs and are outside the component which handled the event.</p>\n\n<p translation-result=\"on\">比如，如果 Angular 處理 <code>MainComponent</code> 中的事件，則框架將在整個元件樹中執行變更檢測。Angular 將忽略具有根 <code>LoginComponent</code> 的子樹，因為該元件具有 <code>OnPush</code> 策略並且此事件發生在其範圍之外。</p><p translation-origin=\"off\">As an example, if Angular handles an event within <code>MainComponent</code>, the framework will run change detection in the entire component tree. Angular will ignore the subtree with root <code>LoginComponent</code> because it has <code>OnPush</code> and the event happened outside of its scope.</p>\n\n<div class=\"lightbox\">\n  <img alt=\"Change detection propagation from OnPush component\" src=\"generated/images/guide/change-detection/on-push-trigger.svg\" width=\"611\" height=\"261\">\n</div>\n<h2 id=\"an-event-is-handled-by-a-descendant-of-a-component-with-onpush\" translation-result=\"on\">事件由具有 OnPush 的元件的後代處理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-descendant-of-a-component-with-onpush\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">An event is handled by a descendant of a component with OnPush<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-descendant-of-a-component-with-onpush\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果 Angular 使用 OnPush 處理元件中的事件，則框架將在整個元件樹中執行變更檢測，包括元件的祖先。</p><p translation-origin=\"off\">If Angular handles an event in a component with OnPush, the framework will execute change detection in the entire component tree, including the component’s ancestors.</p>\n\n<p translation-result=\"on\">比如，在下圖中，Angular 會處理使用 OnPush 的 <code>LoginComponent</code> 中的事件。Angular 將在整個元件子樹中呼叫變更檢測，包括 <code>MainComponent</code>（<code>LoginComponent</code> 的父級），儘管 <code>MainComponent</code> 也有 <code>OnPush</code>。Angular 也會檢查 <code>MainComponent</code>，因為 <code>LoginComponent</code> 是其檢視的一部分。</p><p translation-origin=\"off\">As an example, in the diagram below, Angular handles an event in <code>LoginComponent</code> which uses OnPush. Angular will invoke change detection in the entire component subtree including <code>MainComponent</code> (<code>LoginComponent</code>’s parent), even though <code>MainComponent</code> has <code>OnPush</code> as well. Angular checks <code>MainComponent</code> as well because <code>LoginComponent</code> is part of its view.</p>\n\n<div class=\"lightbox\">\n  <img alt=\"Change detection propagation from nested OnPush component\" src=\"generated/images/guide/change-detection/leaf-trigger.svg\" width=\"611\" height=\"381\">\n</div>\n<h2 id=\"new-inputs-to-component-with-onpush\" translation-result=\"on\">具有 OnPush 策略的元件的新輸入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#new-inputs-to-component-with-onpush\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">New inputs to component with OnPush<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#new-inputs-to-component-with-onpush\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 將在具有 <code>OnPush</code> 策略的子元件中執行變更檢測，將 input 屬性設定為範本繫結的結果。</p><p translation-origin=\"off\">Angular will run change detection within a child component with <code>OnPush</code> when setting an input property as result of a template binding.</p>\n\n<p translation-result=\"on\">比如，在下圖中，<code>AppComponent</code> 會將新輸入傳遞給 <code>MainComponent</code>，它具有 <code>OnPush</code> 策略。Angular 將在 <code>MainComponent</code> 中執行變更檢測，但不會在同樣具有 <code>OnPush</code> 策略的 <code>LoginComponent</code> 中執行變更檢測，除非它也接收到新的輸入。</p><p translation-origin=\"off\">For example, in the diagram below, <code>AppComponent</code> passes a new input to <code>MainComponent</code>, which has <code>OnPush</code>. Angular will run change detection in <code>MainComponent</code> but will not run change detection in <code>LoginComponent</code>, which also has <code>OnPush</code>, unless it receives new inputs as well.</p>\n\n<div class=\"lightbox\">\n  <img alt=\"Change detection propagation with OnPush component that receives new inputs\" src=\"generated/images/guide/change-detection/on-push-input.svg\" width=\"611\" height=\"261\">\n</div>\n<h2 id=\"edge-cases\" translation-result=\"on\">邊緣情況<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#edge-cases\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Edge cases<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-skipping-subtrees#edge-cases\"><i class=\"material-icons\">link</i></a></h2>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>修改 TypeScript 程式碼中的輸入屬性</strong>。當你使用 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 或 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 等 API 來獲取對 TypeScript 中元件的參考並手動修改 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 屬性時，Angular 將不會自動為 OnPush 元件執行變更檢測。如果你需要 Angular 執行變更檢測，你可以在你的元件中注入 <code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code> 並呼叫 <code>changeDetectorRef.markForCheck()</code> 來告訴 Angular 為其安排一次變更檢測。</p><p translation-origin=\"off\"><strong>Modifying input properties in TypeScript code</strong>. When you use an API like <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> or <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> to get a reference to a component in TypeScript and manually modify an <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> property, Angular will not automatically run change detection for OnPush components. If you need Angular to run change detection, you can inject <code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code> in your component and call <code>changeDetectorRef.markForCheck()</code> to tell Angular to schedule a change detection.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>修改物件參考</strong>。如果輸入接收到可變物件作為值，並且你修改了物件內容但參考沒變，則 Angular 將不會呼叫變更檢測。這是預期的行為，因為輸入的前一個值和當前值都指向了同一個參考。</p><p translation-origin=\"off\"><strong>Modifying object references</strong>. In case an input receives a mutable object as value and you modify the object but preserve the reference, Angular will not invoke change detection. That’s the expected behavior because the previous and the current value of the input point to the same reference.</p>\n\n</li>\n</ul>\n\n  <div class=\"reviewed\">最後複查時間：5/4/2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/core/ChangeDetectionStrategy\n - api/core/ChangeDetectionStrategy\n - api/core/ChangeDetectionStrategy#OnPush\n - api/core/ChangeDetectorRef\n - api/core/Component\n - api/core/ContentChild\n - api/core/HostListener\n - api/core/Input\n - api/core/ViewChild\n - guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-default-change-detection\n - guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-component-with-onpush\n - guide/change-detection-skipping-subtrees#an-event-is-handled-by-a-descendant-of-a-component-with-onpush\n - guide/change-detection-skipping-subtrees#common-change-detection-scenarios\n - guide/change-detection-skipping-subtrees#edge-cases\n - guide/change-detection-skipping-subtrees#new-inputs-to-component-with-onpush\n - guide/change-detection-skipping-subtrees#skipping-component-subtrees\n - guide/change-detection-skipping-subtrees#using-onpush\n - guide/change-detection-skipping-subtrees#事件由具有-onpush-的元件處理\n - guide/change-detection-skipping-subtrees#事件由具有-onpush-的元件的後代處理\n - guide/change-detection-skipping-subtrees#事件由具有預設變更檢測的元件處理\n - guide/change-detection-skipping-subtrees#使用-onpush\n - guide/change-detection-skipping-subtrees#具有-onpush-策略的元件的新輸入\n - guide/change-detection-skipping-subtrees#常見的變更檢測場景\n - guide/change-detection-skipping-subtrees#跳過元件子樹\n - guide/change-detection-skipping-subtrees#邊緣情況\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/change-detection-skipping-subtrees.md?message=docs%3A%20請簡述你的修改...\n-->"}