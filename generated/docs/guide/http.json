{"id":"guide/http","title":"Communicating with backend services using HTTP","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"communicating-with-backend-services-using-http\" translation-result=\"on\">使用 HTTP 與後端服務進行通訊<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#communicating-with-backend-services-using-http\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Communicating with backend services using HTTP<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#communicating-with-backend-services-using-http\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">大多數前端應用都要透過 HTTP 協議與伺服器通訊，才能下載或上傳資料並存取其它後端服務。Angular 給應用提供了一個 HTTP 客戶端 API，也就是 <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a></code> 中的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務類別。</p><p translation-origin=\"off\">Most front-end applications need to communicate with a server over the HTTP protocol, to download or upload data and access other back-end services.\nAngular provides a client HTTP API for Angular applications, the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service class in <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a></code>.</p>\n\n<p translation-result=\"on\">HTTP 客戶端服務提供了以下主要功能。</p><p translation-origin=\"off\">The HTTP client service offers the following major features.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">請求<a href=\"guide/http#typed-response\">型別化響應物件</a>的能力</p><p translation-origin=\"off\">The ability to request <a href=\"guide/http#typed-response\">typed response objects</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\">簡化的<a href=\"guide/http#error-handling\">錯誤處理</a></p><p translation-origin=\"off\">Streamlined <a href=\"guide/http#error-handling\">error handling</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/http#testing-requests\">可測試</a>性特性</p><p translation-origin=\"off\"><a href=\"guide/http#testing-requests\">Testability</a> features</p>\n\n</li>\n<li>\n<p translation-result=\"on\">請求和響應<a href=\"guide/http#intercepting-requests-and-responses\">攔截</a></p><p translation-origin=\"off\">Request and response <a href=\"guide/http#intercepting-requests-and-responses\">interception</a></p>\n\n</li>\n</ul>\n<h2 id=\"prerequisites\" translation-result=\"on\">前提條件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#prerequisites\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Prerequisites<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在使用 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> 之前，你應該對下列內容有基本的瞭解：</p><p translation-origin=\"off\">Before working with the <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>, you should have a basic understanding of the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">TypeScript 程式設計</p><p translation-origin=\"off\">TypeScript programming</p>\n\n</li>\n<li>\n<p translation-result=\"on\">HTTP 協議的用法</p><p translation-origin=\"off\">Usage of the HTTP protocol</p>\n\n</li>\n<li>\n<p translation-result=\"on\">Angular 的應用設計基礎，就像<a href=\"guide/architecture\">Angular 基本概念</a>中描述的那樣</p><p translation-origin=\"off\">Angular application-design fundamentals, as described in <a href=\"guide/architecture\">Angular Concepts</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\">Observable 相關技術和運運算元。參閱<a href=\"guide/observables\">可觀察物件</a>部分。</p><p translation-origin=\"off\">Observable techniques and operators.\nSee the <a href=\"guide/observables\">Observables</a> guide.</p>\n\n</li>\n</ul>\n<h2 id=\"setup-for-server-communication\" translation-result=\"on\">伺服器通訊的準備工作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#setup-for-server-communication\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Setup for server communication<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#setup-for-server-communication\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要想使用 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>，就要先匯入 Angular 的 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>。大多數應用都會在根模組 <code>AppModule</code> 中匯入它。</p><p translation-origin=\"off\">Before you can use <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>, you need to import the Angular <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>.\nMost apps do so in the root <code>AppModule</code>.</p>\n\n<code-example header=\"app/app.module.ts (excerpt)\" path=\"http/src/app/app.module.ts\" region=\"sketch\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    // import <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> after BrowserModule.\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n  declarations: [\n    AppComponent,\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n</code-example>\n<p translation-result=\"on\">然後，你可以把 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務注入成一個應用類別的依賴項，如下面的 <code>ConfigService</code> 例子所示。</p><p translation-origin=\"off\">You can then inject the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service as a dependency of an application class, as shown in the following <code>ConfigService</code> example.</p>\n\n<code-example header=\"app/config/config.service.ts (excerpt)\" path=\"http/src/app/config/config.service.ts\" region=\"proto\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class ConfigService {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n}\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務為所有工作都使用了<a href=\"guide/glossary#observable\" title=\"可觀察的定義\">可觀察物件</a>。你必須匯入範例程式碼片段中出現的 RxJS 可觀察物件和運運算元。比如 <code>ConfigService</code> 中的這些匯入就很典型。</p><p translation-origin=\"off\">The <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service makes use of <a href=\"guide/glossary#observable\" title=\"Observable definition\">observables</a> for all transactions.\nYou must import the RxJS observable and operator symbols that appear in the example snippets.\nThese <code>ConfigService</code> imports are typical.</p>\n\n<code-example header=\"app/config/config.service.ts (RxJS imports)\" path=\"http/src/app/config/config.service.ts\" region=\"rxjs-imports\">\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, retry } from 'rxjs/operators';\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你可以執行本指南隨附的<live-example></live-example>。</p><p translation-origin=\"off\">You can run the <live-example></live-example> that accompanies this guide.</p>\n\n<p translation-result=\"on\">範例應用不需要資料伺服器。它依賴於 <a href=\"https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\">Angular 的 <em>in-memory-web-api</em></a>，該模組替換了 <em>HttpClient</em> 模組的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>。這個替代服務模擬了 REST 後端的行為。</p><p translation-origin=\"off\">The sample app does not require a data server.\nIt relies on the <a href=\"https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\">Angular <em>in-memory-web-api</em></a>, which replaces the <em>HttpClient</em> module's <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>.\nThe replacement service simulates the behavior of a REST-like backend.</p>\n\n<p translation-result=\"on\">檢視 <code>AppModule</code> 中的 <em>imports</em>，就能瞭解它是如何配置的。</p><p translation-origin=\"off\">Look at the <code>AppModule</code> <em>imports</em> to see how it is configured.</p>\n\n</div>\n<h2 id=\"requesting-data-from-a-server\" translation-result=\"on\">從伺服器請求資料<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#requesting-data-from-a-server\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Requesting data from a server<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#requesting-data-from-a-server\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用 <a href=\"api/common/http/HttpClient#get\"><code>HttpClient.get()</code></a> 方法從伺服器獲取資料。該非同步方法會發送一個 HTTP 請求，並返回一個 Observable，它會在收到響應時發出所請求到的資料。返回的型別取決於你呼叫時傳入的 <code>observe</code> 和 <code>responseType</code> 引數。</p><p translation-origin=\"off\">Use the <a href=\"api/common/http/HttpClient#get\"><code>HttpClient.get()</code></a> method to fetch data from a server.\nThe asynchronous method sends an HTTP request, and returns an Observable that emits the requested data when the response is received.\nThe return type varies based on the <code>observe</code> and <code>responseType</code> values that you pass to the call.</p>\n\n<p translation-result=\"on\"><code>get()</code> 方法有兩個引數。要獲取的端點 URL，以及一個可以用來配置請求的<em>選項</em>物件。</p><p translation-origin=\"off\">The <code>get()</code> method takes two arguments; the endpoint URL from which to fetch, and an <em>options</em> object that is used to configure the request.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  headers?: <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> | {[header: string]: string | string[]},\n  observe?: 'body' | 'events' | 'response',\n  params?: <a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a>|{[param: string]: string | number | boolean | ReadonlyArray&lt;string | number | boolean&gt;},\n  reportProgress?: boolean,\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  withCredentials?: boolean,\n}\n\n</code-example>\n<p translation-result=\"on\">這些重要的選項包括 <em>observe</em> 和 <em>responseType</em> 屬性。</p><p translation-origin=\"off\">Important options include the <em>observe</em> and <em>responseType</em> properties.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><em>observe</em> 選項用於指定要返回的響應內容。</p><p translation-origin=\"off\">The <em>observe</em> option specifies how much of the response to return</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><em>responseType</em> 選項指定返回資料的格式。</p><p translation-origin=\"off\">The <em>responseType</em> option specifies the format in which to return data</p>\n\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">可以用 <code>options</code> 物件來配置傳出請求的各個方面。比如，在<a href=\"guide/http#adding-headers\">新增標頭時</a>，該服務使用 <code>headers</code> 選項屬性設定預設標頭。</p><p translation-origin=\"off\">Use the <code>options</code> object to configure various other aspects of an outgoing request.\nIn <a href=\"guide/http#adding-headers\">Adding headers</a>, for example, the service set the default headers using the <code>headers</code> option property.</p>\n\n<p translation-result=\"on\">使用 <code>params</code> 屬性可以配置帶有<a href=\"guide/http#url-params\">HTTP URL 引數</a>的請求，“ <code>reportProgress</code> 選項可以在傳輸大量資料時<a href=\"guide/http#report-progress\">監聽進度事件</a>。</p><p translation-origin=\"off\">Use the <code>params</code> property to configure a request with <a href=\"guide/http#url-params\">HTTP URL parameters</a>, and the <code>reportProgress</code> option to <a href=\"guide/http#report-progress\">listen for progress events</a> when transferring large amounts of data.</p>\n\n</div>\n<p translation-result=\"on\">應用經常會從伺服器請求 JSON 資料。在 <code>ConfigService</code> 例子中，該應用需要伺服器 <code>config.json</code> 上的一個配置檔案來指定資源的 URL。</p><p translation-origin=\"off\">Applications often request JSON data from a server.\nIn the <code>ConfigService</code> example, the app needs a configuration file on the server, <code>config.json</code>, that specifies resource URLs.</p>\n\n<code-example header=\"assets/config.json\" path=\"http/src/assets/config.json\">\n{\n  \"heroesUrl\": \"api/heroes\",\n  \"textfile\": \"assets/textfile.txt\",\n  \"date\": \"2020-01-29\"\n}\n\n\n</code-example>\n<p translation-result=\"on\">要獲取這類資料，<code>get()</code> 呼叫需要以下幾個選項：<code>{observe: 'body', responseType: 'json'}</code>。這些是這些選項的預設值，所以下面的例子不會傳遞 options 物件。後面幾節展示了一些額外的選項。</p><p translation-origin=\"off\">To fetch this kind of data, the <code>get()</code> call needs the following options: <code>{observe: 'body', responseType: 'json'}</code>.\nThese are the default values for those options, so the following examples do not pass the options object.\nLater sections show some of the additional option possibilities.</p>\n\n<p><a id=\"config-service\"></a></p>\n<p translation-result=\"on\">這個例子符合透過定義一個可複用的可<a href=\"guide/glossary#service\" title=\"服務定義\">注入服務</a>來執行資料處理功能來建立可伸縮解決方案的最佳實踐。除了提取資料外，該服務還可以對資料進行後處理，新增錯誤處理，並新增重試邏輯。</p><p translation-origin=\"off\">The example conforms to the best practices for creating scalable solutions by defining a re-usable <a href=\"guide/glossary#service\" title=\"service definition\">injectable service</a> to perform the data-handling functionality.\nIn addition to fetching data, the service can post-process the data, add error handling, and add retry logic.</p>\n\n<p translation-result=\"on\"><code>ConfigService</code> 使用 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法獲取這個檔案。</p><p translation-origin=\"off\">The <code>ConfigService</code> fetches this file using the <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> method.</p>\n\n<code-example header=\"app/config/config.service.ts (getConfig v.1)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_1\">\nconfigUrl = 'assets/config.json';\n\ngetConfig() {\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<p translation-result=\"on\"><code>ConfigComponent</code> 注入了 <code>ConfigService</code> 並呼叫了 <code>getConfig</code> 服務方法。</p><p translation-origin=\"off\">The <code>ConfigComponent</code> injects the <code>ConfigService</code> and calls the <code>getConfig</code> service method.</p>\n\n<p translation-result=\"on\">由於該服務方法返回了一個 <code>Observable</code> 配置資料，該元件會<em>訂閱</em>該方法的返回值。訂閱回呼(Callback)只會對後處理進行最少量的處理。它會把資料欄位複製到元件的 <code>config</code> 物件中，該物件在元件範本中是資料繫結的，用於顯示。</p><p translation-origin=\"off\">Because the service method returns an <code>Observable</code> of configuration data, the component <em>subscribes</em> to the method's return value.\nThe subscription callback performs minimal post-processing.\nIt copies the data fields into the component's <code>config</code> object, which is data-bound in the component template for display.</p>\n\n<code-example header=\"app/config/config.component.ts (showConfig v.1)\" path=\"http/src/app/config/config.component.ts\" region=\"v1\">\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe((data: Config) =&gt; this.config = {\n        heroesUrl: data.heroesUrl,\n        textfile:  data.textfile,\n        date: data.date,\n    });\n}\n\n</code-example>\n<p><a id=\"always-subscribe\"></a></p>\n<h3 id=\"starting-the-request\" translation-result=\"on\">啟動請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#starting-the-request\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Starting the request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#starting-the-request\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">對於所有 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法，在你在方法返回的 Observable 上呼叫 <code>subscribe()</code> 之前，該方法都不會開始其 HTTP 請求。</p><p translation-origin=\"off\">For all <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> methods, the method doesn't begin its HTTP request until you call <code>subscribe()</code> on the observable the method returns.</p>\n\n<p translation-result=\"on\">這適用於 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的<em>所有方法</em>。</p><p translation-origin=\"off\">This is true for <em>all</em> <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> <em>methods</em>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">當元件被銷燬時，你應該總是取消訂閱 Observable。</p><p translation-origin=\"off\">You should always unsubscribe from an observable when a component is destroyed.</p>\n\n</div>\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的所有方法返回的可觀察物件都設計為<em>冷的</em>。HTTP 請求的執行都是<em>延期執行的</em>，讓你可以用 <code>tap</code> 和 <code>catchError</code> 這樣的運運算元來在實際執行 HTTP 請求之前，先對這個可觀察物件進行擴充。</p><p translation-origin=\"off\">All observables returned from <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> methods are <em>cold</em> by design.\nExecution of the HTTP request is <em>deferred</em>, letting you extend the observable with additional operations such as  <code>tap</code> and <code>catchError</code> before anything actually happens.</p>\n\n<p translation-result=\"on\">呼叫 <code>subscribe()</code> 會觸發此 Observable 的執行，並導致 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 合成 HTTP 請求並將其傳送到伺服器。</p><p translation-origin=\"off\">Calling <code>subscribe()</code> triggers execution of the observable and causes <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> to compose and send the HTTP request to the server.</p>\n\n<p translation-result=\"on\">可以把這些 Observable 看做實際 HTTP 請求的<em>藍圖</em>。</p><p translation-origin=\"off\">Think of these observables as <em>blueprints</em> for actual HTTP requests.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">事實上，每個 <code>subscribe()</code> 都會啟動 observable 的一次單獨的、獨立的執行。訂閱兩次就會導致兩次 HTTP 請求。</p><p translation-origin=\"off\">In fact, each <code>subscribe()</code> initiates a separate, independent execution of the observable.\nSubscribing twice results in two HTTP requests.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst req = http.get&lt;Heroes&gt;('/api/heroes');\n// 0 requests made - .subscribe() not called.\nreq.subscribe();\n// 1 request made.\nreq.subscribe();\n// 2 requests made.\n\n</code-example>\n</div>\n<p><a id=\"typed-response\"></a></p>\n<h3 id=\"requesting-a-typed-response\" translation-result=\"on\">請求輸入一個類別型的響應<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#requesting-a-typed-response\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Requesting a typed response<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#requesting-a-typed-response\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">可以構造自己的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 請求來宣告響應物件的型別，以便讓輸出更容易、更明確。所指定的響應型別會在編譯時充當型別斷言。</p><p translation-origin=\"off\">Structure your <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> request to declare the type of the response object, to make consuming the output easier and more obvious.\nSpecifying the response type acts as a type assertion at compile time.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">指定響應型別是為了告訴 TypeScript 應該將響應視為給定型別的宣告。這是一個編譯期檢查，不能保證伺服器的響應一定是這種型別的物件。伺服器有責任確保返回伺服器 API 所指定的型別。</p><p translation-origin=\"off\">Specifying the response type is a declaration to TypeScript that it should treat your response as being of the given type.\nThis is a build-time check and doesn't guarantee that the server actually responds with an object of this type.\nIt is up to the server to ensure that the type specified by the server API is returned.</p>\n\n</div>\n<p translation-result=\"on\">要指定響應物件型別，首先要定義一個具有必需屬性的介面。這裡要使用介面而不是類，因為響應物件是普通物件，無法自動轉換成類別的例項。</p><p translation-origin=\"off\">To specify the response object type, first define an interface with the required properties.\nUse an interface rather than a class, because the response is a plain object that cannot be automatically converted to an instance of a class.</p>\n\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"config-interface\">\nexport interface Config {\n  heroesUrl: string;\n  textfile: string;\n  date: any;\n}\n\n</code-example>\n<p translation-result=\"on\">接下來，在伺服器中把該介面指定為 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 呼叫的型別引數。</p><p translation-origin=\"off\">Next, specify that interface as the <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> call's type parameter in the service.</p>\n\n<code-example header=\"app/config/config.service.ts (getConfig v.2)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_2\">\ngetConfig() {\n  // now returns an Observable of Config\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">當你將一個介面作為型別引數傳給 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法時，要使用 <a href=\"guide/rx-library#operators\">RxJS 的 <code>map</code> 運運算元</a>來根據 UI 的需要變換響應資料。然後就可以將轉換後的資料傳給 <a href=\"api/common/AsyncPipe\">async 管道</a>了。</p><p translation-origin=\"off\">When you pass an interface as a type parameter to the <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> method, use the <a href=\"guide/rx-library#operators\">RxJS <code>map</code> operator</a> to transform the response data as needed by the UI.\nYou can then pass the transformed data to the <a href=\"api/common/AsyncPipe\">async pipe</a>.</p>\n\n</div>\n<p translation-result=\"on\">修改後的元件方法，其回呼(Callback)函式中獲取一個帶型別的物件，它易於使用，且消費起來更安全：</p><p translation-origin=\"off\">The callback in the updated component method receives a typed data object, which is easier and safer to consume:</p>\n\n<code-example header=\"app/config/config.component.ts (showConfig v.2)\" path=\"http/src/app/config/config.component.ts\" region=\"v2\">\nconfig: Config | undefined;\n\nshowConfig() {\n  this.configService.getConfig()\n    // clone the data object, using its known Config shape\n    .subscribe((data: Config) =&gt; this.config = { ...data });\n}\n\n</code-example>\n<p translation-result=\"on\">要存取介面中定義的屬性，必須將從 JSON 獲得的普通物件顯式轉換為所需的響應型別。比如，以下 <code>subscribe</code> 回呼(Callback)會將 <code>data</code> 作為物件接收，然後進行型別轉換以存取屬性。</p><p translation-origin=\"off\">To access properties that are defined in an interface, you must explicitly convert the plain object you get from the JSON to the required response type.\nFor example, the following <code>subscribe</code> callback receives <code>data</code> as an Object, and then type-casts it in order to access the properties.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n.subscribe(data =&gt; this.config = {\n  heroesUrl: (data as any).heroesUrl,\n  textfile:  (data as any).textfile,\n});\n\n</code-example>\n<p><a id=\"string-union-types\"></a></p>\n<div class=\"callout is-important\">\n<header ng-should-translate=\"\" translation-result=\"on\"><code>observe</code> 和 <code>response</code> 的型別</header><header ng-should-translate=\"\" translation-origin=\"off\"><code>observe</code> and <code>response</code> types</header>\n\n<p translation-result=\"on\"><code>observe</code> 和 <code>response</code> 選項的型別是<em>字串的聯合型別</em>，而不是普通的字串。</p><p translation-origin=\"off\">The types of the <code>observe</code> and <code>response</code> options are <em>string unions</em>, rather than plain strings.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  …\n  observe?: 'body' | 'events' | 'response',\n  …\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  …\n}\n\n</code-example>\n<p translation-result=\"on\">這會引起混亂。比如：</p><p translation-origin=\"off\">This can cause confusion.\nFor example:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n// this works\nclient.get('/foo', {responseType: 'text'})\n\n// but this does NOT work\nconst options = {\n  responseType: 'text',\n};\nclient.get('/foo', options)\n\n</code-example>\n<p translation-result=\"on\">在第二種情況下，TypeScript 會把 <code>options</code> 的型別推斷為 <code>{responseType: string}</code>。該型別的 <code>HttpClient.get</code> 太寬泛，無法傳給 <code>HttpClient.get</code>，它希望 <code>responseType</code> 的型別是<em>特定的</em>字串之一。而 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 就是以這種方式顯式輸入的，因此編譯器可以根據你提供的選項報告正確的返回型別。</p><p translation-origin=\"off\">In the second case, TypeScript infers the type of <code>options</code> to be <code>{responseType: string}</code>.\nThe type is too wide to pass to <code>HttpClient.get</code> which is expecting the type of <code>responseType</code> to be one of the <em>specific</em> strings.\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> is typed explicitly this way so that the compiler can report the correct return type based on the options you provided.</p>\n\n<p translation-result=\"on\">使用 <code>as const</code>，可以讓 TypeScript 知道你並不是真的要使用字面字串型別：</p><p translation-origin=\"off\">Use <code>as const</code> to let TypeScript know that you really do mean to use a constant string type:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst options = {\n  responseType: 'text' as const,\n};\nclient.get('/foo', options);\n\n</code-example>\n</div>\n<h3 id=\"reading-the-full-response\" translation-result=\"on\">讀取完整的回應內文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#reading-the-full-response\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Reading the full response<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#reading-the-full-response\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在前面的例子中，對 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 的呼叫沒有指定任何選項。預設情況下，它返回了回應內文中包含的 JSON 資料。</p><p translation-origin=\"off\">In the previous example, the call to <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> did not specify any options.\nBy default, it returned the JSON data contained in the response body.</p>\n\n<p translation-result=\"on\">你可能還需要關於這次對話的更多資訊。比如，有時候伺服器會返回一個特殊的回應標頭或狀態碼，來指出某些在應用的工作流程中很重要的條件。</p><p translation-origin=\"off\">You might need more information about the transaction than is contained in the response body.\nSometimes servers return special headers or status codes to indicate certain conditions that are important to the application workflow.</p>\n\n<p translation-result=\"on\">可以用 <code>get()</code> 方法的 <code>observe</code> 選項來告訴 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>，你想要完整的響應物件：</p><p translation-origin=\"off\">Tell <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> that you want the full response with the <code>observe</code> option of the <code>get()</code> method:</p>\n\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"getConfigResponse\">\ngetConfigResponse(): Observable&lt;<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;&gt; {\n  return this.http.get&lt;Config&gt;(\n    this.configUrl, { observe: 'response' });\n}\n\n</code-example>\n<p translation-result=\"on\">現在，<code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 會返回一個 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 型別的 <code>Observable</code>，而不只是 JSON 資料。</p><p translation-origin=\"off\">Now <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> returns an <code>Observable</code> of type <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> rather than just the JSON data contained in the body.</p>\n\n<p translation-result=\"on\">該元件的 <code>showConfigResponse()</code> 方法會像顯示配置資料一樣顯示回應標頭：</p><p translation-origin=\"off\">The component's <code>showConfigResponse()</code> method displays the response headers as well as the configuration:</p>\n\n<code-example header=\"app/config/config.component.ts (showConfigResponse)\" path=\"http/src/app/config/config.component.ts\" region=\"showConfigResponse\">\nshowConfigResponse() {\n  this.configService.getConfigResponse()\n    // resp is of type `<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;`\n    .subscribe(resp =&gt; {\n      // display its headers\n      const keys = resp.headers.keys();\n      this.headers = keys.map(key =&gt;\n        `${key}: ${resp.headers.get(key)}`);\n\n      // access the body directly, which is typed as `Config`.\n      this.config = { ...resp.body! };\n    });\n}\n\n</code-example>\n<p translation-result=\"on\">如你所見，該響應物件具有一個帶有正確型別的 <code>body</code> 屬性。</p><p translation-origin=\"off\">As you can see, the response object has a <code>body</code> property of the correct type.</p>\n\n<h3 id=\"making-a-jsonp-request\" translation-result=\"on\">發起 JSONP 請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#making-a-jsonp-request\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Making a JSONP request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#making-a-jsonp-request\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當伺服器不支援 <a href=\"https://developer.mozilla.org/docs/Web/HTTP/CORS\">CORS 協議</a>時，應用程式可以使用 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 跨域發出 <a href=\"https://en.wikipedia.org/wiki/JSONP\">JSONP</a> 請求。</p><p translation-origin=\"off\">Apps can use the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> to make <a href=\"https://en.wikipedia.org/wiki/JSONP\">JSONP</a> requests across domains when a server doesn't support <a href=\"https://developer.mozilla.org/docs/Web/HTTP/CORS\">CORS protocol</a>.</p>\n\n<p translation-result=\"on\">Angular 的 JSONP 請求會返回一個 <code>Observable</code>。遵循訂閱可觀察物件變數的模式，並在使用 <a href=\"api/common/AsyncPipe\">async 管道</a>管理結果之前，使用 RxJS <code>map</code> 運運算元轉換響應。</p><p translation-origin=\"off\">Angular JSONP requests return an <code>Observable</code>.\nFollow the pattern for subscribing to observables and use the RxJS <code>map</code> operator to transform the response before using the <a href=\"api/common/AsyncPipe\">async pipe</a> to manage the results.</p>\n\n<p translation-result=\"on\">在 Angular 中，透過在 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>imports</code> 中包含 <code><a href=\"api/common/http/HttpClientJsonpModule\" class=\"code-anchor\">HttpClientJsonpModule</a></code> 來使用 JSONP。在以下範例中，<code>searchHeroes()</code> 方法使用 JSONP 請求來查詢名稱包含搜尋詞的英雄。</p><p translation-origin=\"off\">In Angular, use JSONP by including <code><a href=\"api/common/http/HttpClientJsonpModule\" class=\"code-anchor\">HttpClientJsonpModule</a></code> in the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> imports.\nIn the following example, the <code>searchHeroes()</code> method uses a JSONP request to query for heroes whose names contain the search term.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n/* GET heroes whose name contains search term */\nsearchHeroes(term: string): Observable {\n  term = term.trim();\n\n  const heroesURL = `${this.heroesURL}?${term}`;\n  return this.http.jsonp(heroesUrl, 'callback').pipe(\n      catchError(this.handleError('searchHeroes', [])) // then handle the error\n    );\n}\n\n</code-example>\n<p translation-result=\"on\">該請求將 <code>heroesURL</code> 作為第一個引數，並將回呼(Callback)函式名稱作為第二個引數。響應被包裝在回呼(Callback)函式中，該函式接受 JSONP 方法返回的可觀察物件，並將它們透過管道傳給錯誤處理程式。</p><p translation-origin=\"off\">This request passes the <code>heroesURL</code> as the first parameter and the callback function name as the second parameter.\nThe response is wrapped in the callback function, which takes the observables returned by the JSONP method and pipes them through to the error handler.</p>\n\n<h3 id=\"requesting-non-json-data\" translation-result=\"on\">請求非 JSON 資料<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#requesting-non-json-data\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Requesting non-JSON data<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#requesting-non-json-data\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">不是所有的 API 都會返回 JSON 資料。在下面這個例子中，<code>DownloaderService</code> 中的方法會從伺服器讀取文字檔案，並把檔案的內容記錄下來，然後把這些內容使用 <code>Observable&lt;string&gt;</code> 的形式返回給呼叫者。</p><p translation-origin=\"off\">Not all APIs return JSON data.\nIn this next example, a <code>DownloaderService</code> method reads a text file from the server and logs the file contents, before returning those contents to the caller as an <code>Observable&lt;string&gt;</code>.</p>\n\n<code-example header=\"app/downloader/downloader.service.ts (getTextFile)\" linenums=\"false\" path=\"http/src/app/downloader/downloader.service.ts\" region=\"getTextFile\">\ngetTextFile(filename: string) {\n  // The Observable returned by get() is of type Observable&lt;string&gt;\n  // because a text response was specified.\n  // There's no need to pass a &lt;string&gt; type parameter to get().\n  return this.http.get(filename, {responseType: 'text'})\n    .pipe(\n      tap( // Log the result or error\n      {\n        next: (data) =&gt; this.log(filename, data),\n        error: (error) =&gt; this.logError(filename, error)\n      }\n      )\n    );\n}\n\n</code-example>\n<p translation-result=\"on\">這裡的 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 返回字串而不是預設的 JSON 物件，因為它的 <code>responseType</code> 選項是 <code>'text'</code>。</p><p translation-origin=\"off\"><code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> returns a string rather than the default JSON because of the <code>responseType</code> option.</p>\n\n<p translation-result=\"on\">RxJS 的 <code>tap</code> 運運算元使程式碼可以檢查透過可觀察物件的成功值和錯誤值，而不會干擾它們。</p><p translation-origin=\"off\">The RxJS <code>tap</code> operator lets the code inspect both success and error values passing through the observable without disturbing them.</p>\n\n<p translation-result=\"on\">在 <code>DownloaderComponent</code> 中的 <code>download()</code> 方法透過訂閱這個服務中的方法來發起一次請求。</p><p translation-origin=\"off\">A <code>download()</code> method in the <code>DownloaderComponent</code> initiates the request by subscribing to the service method.</p>\n\n<code-example header=\"app/downloader/downloader.component.ts (download)\" linenums=\"false\" path=\"http/src/app/downloader/downloader.component.ts\" region=\"download\">\ndownload() {\n  this.downloaderService.getTextFile('assets/textfile.txt')\n    .subscribe(results =&gt; this.contents = results);\n}\n\n</code-example>\n<p><a id=\"error-handling\"></a></p>\n<h2 id=\"handling-request-errors\" translation-result=\"on\">處理請求錯誤<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#handling-request-errors\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Handling request errors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#handling-request-errors\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果請求在伺服器上失敗了，那麼 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 就會返回一個<em>錯誤</em>物件而不是一個成功的響應物件。</p><p translation-origin=\"off\">If the request fails on the server, <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> returns an <em>error</em> object instead of a successful response.</p>\n\n<p translation-result=\"on\">執行伺服器請求的同一個服務中也應該執行錯誤檢查、解釋和解析。</p><p translation-origin=\"off\">The same service that performs your server transactions should also perform error inspection, interpretation, and resolution.</p>\n\n<p translation-result=\"on\">發生錯誤時，你可以獲取失敗的詳細資訊，以便通知你的使用者。在某些情況下，你也可以自動<a href=\"guide/http#retry\">重試該請求</a>。</p><p translation-origin=\"off\">When an error occurs, you can obtain details of what failed in order to inform your user.\nIn some cases, you might also automatically <a href=\"guide/http#retry\">retry the request</a>.</p>\n\n<p><a id=\"error-details\"></a></p>\n<h3 id=\"getting-error-details\" translation-result=\"on\">獲取錯誤詳情<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#getting-error-details\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Getting error details<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#getting-error-details\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當資料存取失敗時，應用會給使用者提供有用的反饋。原始的錯誤物件作為反饋並不是特別有用。除了檢測到錯誤已經發生之外，還需要獲取錯誤詳細資訊並使用這些細節來撰寫使用者友好的響應。</p><p translation-origin=\"off\">An app should give the user useful feedback when data access fails.\nA raw error object is not particularly useful as feedback.\nIn addition to detecting that an error has occurred, you need to get error details and use those details to compose a user-friendly response.</p>\n\n<p translation-result=\"on\">可能會出現兩種型別的錯誤。</p><p translation-origin=\"off\">Two types of errors can occur.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">伺服器端可能會拒絕該請求，並返回狀態碼為 404 或 500 的 HTTP <em>響應</em>物件。這些是錯誤<em>響應</em>。</p><p translation-origin=\"off\">The server backend might reject the request, returning an HTTP response with a status code such as 404 or 500.\nThese are error <em>responses</em>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">客戶端也可能出現問題，比如網路錯誤會讓請求無法成功完成，或者 RxJS 運運算元也會丟擲例外。這些錯誤的 <code>status</code> 為 <code>0</code>，並且其 <code>error</code> 屬性包含一個 <code>ProgressEvent</code> 物件，此物件的 <code>type</code> 屬性可以提供更詳細的資訊。</p><p translation-origin=\"off\">Something could go wrong on the client-side such as a network error that prevents the request from completing successfully or an exception thrown in an RxJS operator.\nThese errors have <code>status</code> set to <code>0</code> and the <code>error</code> property contains a <code>ProgressEvent</code> object, whose <code>type</code> might provide further information.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 在其 <code><a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a></code> 中會捕獲兩種錯誤。可以檢查這個響應是否存在錯誤。</p><p translation-origin=\"off\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> captures both kinds of errors in its <code><a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a></code>.\nInspect that response to identify the error's cause.</p>\n\n<p translation-result=\"on\">下面的例子在之前定義的 <a href=\"guide/http#config-service\" title=\"ConfigService 已定義\">ConfigService</a> 中定義了一個錯誤處理程式。</p><p translation-origin=\"off\">The following example defines an error handler in the previously defined <a href=\"guide/http#config-service\" title=\"ConfigService defined\">ConfigService</a>.</p>\n\n<code-example header=\"app/config/config.service.ts (handleError)\" path=\"http/src/app/config/config.service.ts\" region=\"handleError\">\nprivate handleError(error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) {\n  if (error.status === 0) {\n    // A client-side or network error occurred. Handle it accordingly.\n    console.error('An error occurred:', error.error);\n  } else {\n    // The backend returned an unsuccessful response code.\n    // The response body may contain clues as to what went wrong.\n    console.error(\n      `Backend returned code ${error.status}, body was: `, error.error);\n  }\n  // Return an observable with a user-facing error message.\n  return throwError(() =&gt; new Error('Something bad happened; please try again later.'));\n}\n\n</code-example>\n<p translation-result=\"on\">該處理程式會返回一個帶有使用者友好的錯誤資訊的 RxJS <code>ErrorObservable</code>。下列程式碼修改了 <code>getConfig()</code> 方法，它使用一個<a href=\"guide/pipes\" title=\"管道指南\">管道</a>把 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 呼叫返回的所有 Observable 傳送給錯誤處理器。</p><p translation-origin=\"off\">The handler returns an RxJS <code>ErrorObservable</code> with a user-friendly error message.\nThe following code updates the <code>getConfig()</code> method, using a <a href=\"guide/pipes\" title=\"Pipes guide\">pipe</a> to send all observables returned by the <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> call to the error handler.</p>\n\n<code-example header=\"app/config/config.service.ts (getConfig v.3 with error handler)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_3\">\ngetConfig() {\n  return this.http.get&lt;Config&gt;(this.configUrl)\n    .pipe(\n      catchError(this.handleError)\n    );\n}\n\n</code-example>\n<p><a id=\"retry\"></a></p>\n<h3 id=\"retrying-a-failed-request\" translation-result=\"on\">重試失敗的請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#retrying-a-failed-request\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Retrying a failed request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#retrying-a-failed-request\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">有時候，錯誤只是臨時性的，只要重試就可能會自動消失。比如，在移動端場景中可能會遇到網路中斷的情況，只要重試一下就能拿到正確的結果。</p><p translation-origin=\"off\">Sometimes the error is transient and goes away automatically if you try again.\nFor example, network interruptions are common in mobile scenarios, and trying again can produce a successful result.</p>\n\n<p translation-result=\"on\"><a href=\"guide/rx-library\">RxJS 庫</a>提供了幾個<em>重試</em>運運算元。比如，<code>retry()</code> 運運算元會自動重新訂閱一個失敗的 <code>Observable</code> 幾次。<em>重新訂閱</em> <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法會導致它重新發出 HTTP 請求。</p><p translation-origin=\"off\">The <a href=\"guide/rx-library\">RxJS library</a> offers several <em>retry</em> operators.\nFor example, the <code>retry()</code> operator automatically re-subscribes to a failed <code>Observable</code> a specified number of times.\n<em>Re-subscribing</em> to the result of an <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> method call has the effect of reissuing the HTTP request.</p>\n\n<p translation-result=\"on\">下面的例子示範瞭如何在把一個失敗的請求傳給錯誤處理程式之前，先透過管道傳給 <code>retry()</code> 運運算元。</p><p translation-origin=\"off\">The following example shows how to pipe a failed request to the <code>retry()</code> operator before passing it to the error handler.</p>\n\n<code-example header=\"app/config/config.service.ts (getConfig with retry)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig\">\ngetConfig() {\n  return this.http.get&lt;Config&gt;(this.configUrl)\n    .pipe(\n      retry(3), // retry a failed request up to 3 times\n      catchError(this.handleError) // then handle the error\n    );\n}\n\n</code-example>\n<h2 id=\"sending-data-to-a-server\" translation-result=\"on\">把資料傳送到伺服器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#sending-data-to-a-server\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Sending data to a server<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#sending-data-to-a-server\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">除了從伺服器獲取資料外，<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 還支援其它一些 HTTP 方法，比如 PUT，POST 和 DELETE，你可以用它們來修改遠端資料。</p><p translation-origin=\"off\">In addition to fetching data from a server, <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> supports other HTTP methods such as PUT, POST, and DELETE, which you can use to modify the remote data.</p>\n\n<p translation-result=\"on\">本指南中的這個範例應用包括一個簡略版本的《英雄之旅》，它會獲取英雄資料，並允許使用者新增、刪除和修改它們。下面幾節在 <code>HeroesService</code> 範例中展示了資料更新方法的一些例子。</p><p translation-origin=\"off\">The sample app for this guide includes an abridged version of the \"Tour of Heroes\" example that fetches heroes and enables users to add, delete, and update them.\nThe following sections show examples of the data-update methods from the sample's <code>HeroesService</code>.</p>\n\n<h3 id=\"making-a-post-request\" translation-result=\"on\">發起一個 POST 請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#making-a-post-request\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Making a POST request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#making-a-post-request\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">應用經常在提交表單時透過 POST 請求向伺服器傳送資料。下面這個例子中，<code>HeroesService</code> 在向資料庫新增英雄時發起了一個 HTTP POST 請求。</p><p translation-origin=\"off\">Apps often send data to a server with a POST request when submitting a form.\nIn the following example, the <code>HeroesService</code> makes an HTTP POST request when adding a hero to the database.</p>\n\n<code-example header=\"app/heroes/heroes.service.ts (addHero)\" path=\"http/src/app/heroes/heroes.service.ts\" region=\"addHero\">\n/** POST: add a new hero to the database */\naddHero(hero: Hero): Observable&lt;Hero&gt; {\n  return this.http.post&lt;Hero&gt;(this.heroesUrl, hero, httpOptions)\n    .pipe(\n      catchError(this.handleError('addHero', hero))\n    );\n}\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient#post\" class=\"code-anchor\">HttpClient.post()</a></code> 方法像 <code>get()</code> 一樣也有型別引數，可以用它來指出你期望伺服器返回特定型別的資料。該方法需要一個資源 URL 和兩個額外的引數：</p><p translation-origin=\"off\">The <code><a href=\"api/common/http/HttpClient#post\" class=\"code-anchor\">HttpClient.post()</a></code> method is similar to <code>get()</code> in that it has a type parameter, which you can use to specify that you expect the server to return data of a given type.\nThe method takes a resource URL and two additional parameters:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">引數</nt-wrapper><nt-wrapper translation-origin=\"off\">Parameter</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\">body</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">要在請求正文中 POST 的資料。</nt-wrapper><nt-wrapper translation-origin=\"off\">The data to POST in the body of the request.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\">options</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">一個包含方法選項的物件，在這裡，它用來<a href=\"guide/http#adding-headers\">指定必要的請求頭</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">An object containing method options which, in this case, <a href=\"guide/http#adding-headers\">specify required headers</a>.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">這個例子捕獲了<a href=\"guide/http#error-details\">前面所講的</a>錯誤。</p><p translation-origin=\"off\">The example catches errors as <a href=\"guide/http#error-details\">described above</a>.</p>\n\n<p translation-result=\"on\"><code>HeroesComponent</code> 透過訂閱該服務方法返回的 <code>Observable</code> 發起了一次實際的 <code>POST</code> 操作。</p><p translation-origin=\"off\">The <code>HeroesComponent</code> initiates the actual POST operation by subscribing to the <code>Observable</code> returned by this service method.</p>\n\n<code-example header=\"app/heroes/heroes.component.ts (addHero)\" path=\"http/src/app/heroes/heroes.component.ts\" region=\"add-hero-subscribe\">\nthis.heroesService\n  .addHero(newHero)\n  .subscribe(hero =&gt; this.heroes.push(hero));\n\n</code-example>\n<p translation-result=\"on\">當伺服器成功做出響應時，會帶有這個新建立的英雄，然後該元件就會把這個英雄新增到正在顯示的 <code>heroes</code> 列表中。</p><p translation-origin=\"off\">When the server responds successfully with the newly added hero, the component adds that hero to the displayed <code>heroes</code> list.</p>\n\n<h3 id=\"making-a-delete-request\" translation-result=\"on\">發起 <code>DELETE</code> 請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#making-a-delete-request\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Making a DELETE request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#making-a-delete-request\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">該應用可以把英雄的 ID 傳給 <code>HttpClient.delete</code> 方法的請求 URL 來刪除一個英雄。</p><p translation-origin=\"off\">This application deletes a hero with the <code>HttpClient.delete</code> method by passing the hero's ID in the request URL.</p>\n\n<code-example header=\"app/heroes/heroes.service.ts (deleteHero)\" path=\"http/src/app/heroes/heroes.service.ts\" region=\"deleteHero\">\n/** DELETE: delete the hero from the server */\ndeleteHero(id: number): Observable&lt;unknown&gt; {\n  const url = `${this.heroesUrl}/${id}`; // DELETE api/heroes/42\n  return this.http.delete(url, httpOptions)\n    .pipe(\n      catchError(this.handleError('deleteHero'))\n    );\n}\n\n</code-example>\n<p translation-result=\"on\">當 <code>HeroesComponent</code> 訂閱了該服務方法返回的 <code>Observable</code> 時，就會發起一次實際的 <code>DELETE</code> 操作。</p><p translation-origin=\"off\">The <code>HeroesComponent</code> initiates the actual DELETE operation by subscribing to the <code>Observable</code> returned by this service method.</p>\n\n<code-example header=\"app/heroes/heroes.component.ts (deleteHero)\" path=\"http/src/app/heroes/heroes.component.ts\" region=\"delete-hero-subscribe\">\nthis.heroesService\n  .deleteHero(hero.id)\n  .subscribe();\n\n</code-example>\n<p translation-result=\"on\">該元件不會等待刪除操作的結果，所以它的 subscribe（訂閱）中沒有回呼(Callback)函式。不過就算你不關心結果，也仍然要訂閱它。呼叫 <code>subscribe()</code> 方法會<strong>執行</strong>這個可觀察物件，這時才會真的發起 DELETE 請求。</p><p translation-origin=\"off\">The component isn't expecting a result from the delete operation, so it subscribes without a callback.\nEven though you are not using the result, you still have to subscribe.\nCalling the <code>subscribe()</code> method <em>executes</em> the observable, which is what initiates the DELETE request.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">你必須呼叫 <code>subscribe()</code>，否則什麼都不會發生。僅僅呼叫 <code>HeroesService.deleteHero()</code> 是不會發起 DELETE 請求的。</p><p translation-origin=\"off\">You must call <code>subscribe()</code> or nothing happens.\nJust calling <code>HeroesService.deleteHero()</code> does not initiate the DELETE request.</p>\n\n</div>\n<code-example path=\"http/src/app/heroes/heroes.component.ts\" region=\"delete-hero-no-subscribe\">\n// oops ... subscribe() is missing so nothing happens\nthis.heroesService.deleteHero(hero.id);\n\n</code-example>\n<h3 id=\"making-a-put-request\" translation-result=\"on\">發起 PUT 請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#making-a-put-request\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Making a PUT request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#making-a-put-request\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">應用可以使用 HttpClient 服務傳送 PUT 請求。下面的 <code>HeroesService</code> 範例（就像 POST 範例一樣）用一個修改過的資料替換了該資源。</p><p translation-origin=\"off\">An app can send PUT requests using the HTTP client service.\nThe following <code>HeroesService</code> example, like the POST example, replaces a resource with updated data.</p>\n\n<code-example header=\"app/heroes/heroes.service.ts (updateHero)\" path=\"http/src/app/heroes/heroes.service.ts\" region=\"updateHero\">\n/** PUT: update the hero on the server. Returns the updated hero upon success. */\nupdateHero(hero: Hero): Observable&lt;Hero&gt; {\n  return this.http.put&lt;Hero&gt;(this.heroesUrl, hero, httpOptions)\n    .pipe(\n      catchError(this.handleError('updateHero', hero))\n    );\n}\n\n</code-example>\n<p translation-result=\"on\">對於所有返回可觀察物件的 HTTP 方法，呼叫者（<code>HeroesComponent.update()</code>）<a href=\"guide/http#always-subscribe\" title=\"為什麼你要訂閱？\">必須 <code>subscribe()</code></a> 從 <code><a href=\"api/common/http/HttpClient#put\" class=\"code-anchor\">HttpClient.put()</a></code> 返回的可觀察物件，才會真的發起請求。</p><p translation-origin=\"off\">As for any of the HTTP methods that return an observable, the caller, <code>HeroesComponent.update()</code> <a href=\"guide/http#always-subscribe\" title=\"Why you must always subscribe.\">must <code>subscribe()</code></a> to the observable returned from the <code><a href=\"api/common/http/HttpClient#put\" class=\"code-anchor\">HttpClient.put()</a></code> in order to initiate the request.</p>\n\n<h3 id=\"adding-and-updating-headers\" translation-result=\"on\">新增和更新請求頭<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#adding-and-updating-headers\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Adding and updating headers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#adding-and-updating-headers\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">很多伺服器都需要額外的頭來執行儲存操作。比如，伺服器可能需要一個授權令牌，或者需要 <code>Content-Type</code> 頭來顯式宣告請求體的 MIME 型別。</p><p translation-origin=\"off\">Many servers require extra headers for save operations.\nFor example, a server might require an authorization token, or \"Content-Type\" header to explicitly declare the MIME type of the request body.</p>\n\n<h5 id=\"adding-headers\" translation-result=\"on\">新增請求頭<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#adding-headers\"><i class=\"material-icons\">link</i></a></h5><h5 translation-origin=\"off\">Adding headers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#adding-headers\"><i class=\"material-icons\">link</i></a></h5>\n\n<p translation-result=\"on\"><code>HeroesService</code> 在一個 <code>httpOptions</code> 物件中定義了這樣的頭，它們被傳給每個 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的儲存型方法。</p><p translation-origin=\"off\">The <code>HeroesService</code> defines such headers in an <code>httpOptions</code> object that are passed to every <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> save method.</p>\n\n<code-example header=\"app/heroes/heroes.service.ts (httpOptions)\" path=\"http/src/app/heroes/heroes.service.ts\" region=\"http-options\">\nimport { <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nconst httpOptions = {\n  headers: new <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a>({\n    'Content-Type':  'application/json',\n    Authorization: 'my-auth-token'\n  })\n};\n\n</code-example>\n<h5 id=\"updating-headers\" translation-result=\"on\">更新請求頭<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#updating-headers\"><i class=\"material-icons\">link</i></a></h5><h5 translation-origin=\"off\">Updating headers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#updating-headers\"><i class=\"material-icons\">link</i></a></h5>\n\n<p translation-result=\"on\">你不能直接修改前面的選項物件中的 <code><a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a></code> 請求頭，因為 <code><a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a></code> 類別的例項是不可變物件。請改用 <code>set()</code> 方法，以返回當前例項應用了新更改之後的副本。</p><p translation-origin=\"off\">You can't directly modify the existing headers within the previous options\nobject because instances of the <code><a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a></code> class are immutable.\nUse the <code>set()</code> method instead, to return a clone of the current instance with the new changes applied.</p>\n\n<p translation-result=\"on\">下面的例子示範了當舊令牌過期時，可以在發起下一個請求之前更新授權頭。</p><p translation-origin=\"off\">The following example shows how, when an old token expires, you can update the authorization header before making the next request.</p>\n\n<code-example linenums=\"false\" path=\"http/src/app/heroes/heroes.service.ts\" region=\"update-headers\">\nhttpOptions.headers =\n  httpOptions.headers.set('Authorization', 'my-new-auth-token');\n\n</code-example>\n<p><a id=\"url-params\"></a></p>\n<h2 id=\"configuring-http-url-parameters\" translation-result=\"on\">配置 HTTP URL 引數<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#configuring-http-url-parameters\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Configuring HTTP URL parameters<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#configuring-http-url-parameters\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用 <code><a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a></code> 類和 <code>params</code> 選項在你的 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 中新增 URL 查詢字串。</p><p translation-origin=\"off\">Use the <code><a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a></code> class with the <code>params</code> request option to add URL query strings in your <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code>.</p>\n\n<p translation-result=\"on\">下面的例子中，<code>searchHeroes()</code> 方法用於查詢名字中包含搜尋詞的英雄。</p><p translation-origin=\"off\">The following example, the <code>searchHeroes()</code> method queries for heroes whose names contain the search term.</p>\n\n<p translation-result=\"on\">首先匯入 <code><a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a></code> 類別。</p><p translation-origin=\"off\">Start by importing <code><a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a></code> class.</p>\n\n<code-example hidecopy=\"\" language=\"typescript\">\n\nimport {<a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a>} from \"@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>\";\n\n</code-example>\n<code-example linenums=\"false\" path=\"http/src/app/heroes/heroes.service.ts\" region=\"searchHeroes\">\n/* GET heroes whose name contains search term */\nsearchHeroes(term: string): Observable&lt;Hero[]&gt; {\n  term = term.trim();\n\n  // Add safe, URL encoded search parameter if there is a search term\n  const options = term ?\n   { params: new <a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a>().set('name', term) } : {};\n\n  return this.http.get&lt;Hero[]&gt;(this.heroesUrl, options)\n    .pipe(\n      catchError(this.handleError&lt;Hero[]&gt;('searchHeroes', []))\n    );\n}\n\n</code-example>\n<p translation-result=\"on\">如果有搜尋詞，程式碼會用進行過 URL 編碼的搜尋引數來構造一個 options 物件。比如，如果搜尋詞是 \"cat\"，那麼 GET 請求的 URL 就是 <code>api/heroes?name=cat</code>。</p><p translation-origin=\"off\">If there is a search term, the code constructs an options object with an HTML URL-encoded search parameter.\nIf the term is \"cat\", for example, the GET request URL would be <code>api/heroes?name=cat</code>.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a></code> 是不可變物件。如果需要更新選項，請保留 <code>.set()</code> 方法的返回值。</p><p translation-origin=\"off\">The <code><a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a></code> object is immutable.\nIf you need to update the options, save the returned value of the <code>.set()</code> method.</p>\n\n<p translation-result=\"on\">你也可以使用 <code>fromString</code> 變數從查詢字串中直接建立 HTTP 引數：</p><p translation-origin=\"off\">You can also create HTTP parameters directly from a query string by using the <code>fromString</code> variable:</p>\n\n<code-example hidecopy=\"\" language=\"typescript\">\n\nconst params = new <a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a>({fromString: 'name=foo'});\n\n</code-example>\n<p><a id=\"intercepting-requests-and-responses\"></a></p>\n<h2 id=\"intercepting-requests-and-responses\" translation-result=\"on\">攔截請求和響應<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#intercepting-requests-and-responses\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Intercepting requests and responses<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#intercepting-requests-and-responses\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">藉助攔截機制，你可以宣告一些<em>攔截器</em>，它們可以檢查並轉換從應用中發給伺服器的 HTTP 請求。這些攔截器還可以在返回應用的途中檢查和轉換來自伺服器的響應。多個攔截器構成了請求/響應處理器的<em>雙向</em>連結串列。</p><p translation-origin=\"off\">With interception, you declare <em>interceptors</em> that inspect and transform HTTP requests from your application to a server.\nThe same interceptors can also inspect and transform a server's responses on their way back to the application.\nMultiple interceptors form a <em>forward-and-backward</em> chain of request/response handlers.</p>\n\n<p translation-result=\"on\">攔截器可以用一種常規的、標準的方式對每一次 HTTP 的請求/響應任務執行從認證到記日誌等很多種<em>隱含</em>任務。</p><p translation-origin=\"off\">Interceptors can perform a variety of  <em>implicit</em> tasks, from authentication to logging, in a routine, standard way, for every HTTP request/response.</p>\n\n<p translation-result=\"on\">如果沒有攔截機制，那麼開發人員將不得不對每次 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 呼叫<em>顯式</em>實現這些任務。</p><p translation-origin=\"off\">Without interception, developers would have to implement these tasks <em>explicitly</em> for each <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> method call.</p>\n\n<h3 id=\"write-an-interceptor\" translation-result=\"on\">編寫攔截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#write-an-interceptor\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Write an interceptor<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#write-an-interceptor\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要實現攔截器，就要實現一個實現了 <code><a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a></code> 介面中的 <code>intercept()</code> 方法的類別。</p><p translation-origin=\"off\">To implement an interceptor, declare a class that implements the <code>intercept()</code> method of the <code><a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a></code> interface.</p>\n\n<p translation-result=\"on\">這裡是一個什麼也不做的 <code>noop</code> 攔截器，它只會不做任何修改的傳遞這個請求。</p><p translation-origin=\"off\">Here is a do-nothing <code>noop</code> interceptor that passes the request through without touching it:</p>\n\n<code-example header=\"app/http-interceptors/noop-interceptor.ts\" path=\"http/src/app/http-interceptors/noop-interceptor.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport {\n  <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>, <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a>, <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>, <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>\n} from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { Observable } from 'rxjs';\n\n/** Pass untouched request through to the next request handler. */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class NoopInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>):\n    Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    return next.handle(req);\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\"><code>intercept</code> 方法會把請求轉換成一個最終返回 HTTP 回應內文的 <code>Observable</code>。在這個場景中，每個攔截器都完全能自己處理這個請求。</p><p translation-origin=\"off\">The <code>intercept</code> method transforms a request into an <code>Observable</code> that eventually returns the HTTP response.\nIn this sense, each interceptor is fully capable of handling the request entirely by itself.</p>\n\n<p translation-result=\"on\">大多數攔截器攔截都會在傳入時檢查請求，然後把潛在的請求轉發給 <code>next</code> 物件的 <code>handle()</code> 方法，而 <code>next</code> 物件實現了 <a href=\"api/common/http/HttpHandler\"><code>HttpHandler</code></a> 介面。</p><p translation-origin=\"off\">Most interceptors inspect the request on the way in and forward the potentially altered request to the <code>handle()</code> method of the <code>next</code> object which implements the <a href=\"api/common/http/HttpHandler\"><code>HttpHandler</code></a> interface.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nexport abstract class <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a> {\n  abstract handle(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt;;\n}\n\n</code-example>\n<p translation-result=\"on\">像 <code>intercept()</code> 一樣，<code>handle()</code> 方法也會把 HTTP 請求轉換成 <a href=\"guide/http#interceptor-events\"><code>HttpEvents</code></a> 組成的 <code>Observable</code>，它最終包含的是來自伺服器的響應。\n<code>intercept()</code> 函式可以檢查這個可觀察物件，並在把它返回給呼叫者之前修改它。</p><p translation-origin=\"off\">Like <code>intercept()</code>, the <code>handle()</code> method transforms an HTTP request into an <code>Observable</code> of <a href=\"guide/http#interceptor-events\"><code>HttpEvents</code></a> which ultimately include the server's response.\nThe <code>intercept()</code> method could inspect that observable and alter it before returning it to the caller.</p>\n\n<p translation-result=\"on\">這個 <code>no-op</code> 攔截器，會使用原始的請求呼叫 <code>next.handle()</code>，並返回它返回的可觀察物件，而不做任何後續處理。</p><p translation-origin=\"off\">This <code>no-op</code> interceptor calls <code>next.handle()</code> with the original request and returns the observable without doing a thing.</p>\n\n<h3 id=\"the-next-object\" translation-result=\"on\"><code>next</code> 物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#the-next-object\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">The <code>next</code> object<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#the-next-object\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>next</code> 物件表示攔截器連結串列中的下一個攔截器。這個連結串列中的最後一個 <code>next</code> 物件就是 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的後端處理器（backend handler），它會把請求發給伺服器，並接收伺服器的響應。</p><p translation-origin=\"off\">The <code>next</code> object represents the next interceptor in the chain of interceptors.\nThe final <code>next</code> in the chain is the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> backend handler that sends the request to the server and receives the server's response.</p>\n\n<p translation-result=\"on\">大多數的攔截器都會呼叫 <code>next.handle()</code>，以便這個請求流能走到下一個攔截器，並最終傳給後端處理器。\n攔截器也<em>可以</em>不呼叫 <code>next.handle()</code>，使這個鏈路短路，並返回一個帶有人工構造出來的伺服器響應的 <a href=\"guide/http#caching\">自己的 <code>Observable</code></a>。</p><p translation-origin=\"off\">Most interceptors call <code>next.handle()</code> so that the request flows through to the next interceptor and, eventually, the backend handler.\nAn interceptor <em>could</em> skip calling <code>next.handle()</code>, short-circuit the chain, and <a href=\"guide/http#caching\">return its own <code>Observable</code></a> with an artificial server response.</p>\n\n<p translation-result=\"on\">這是一種常見的中介軟體模式，在像 Express.js 這樣的框架中也會找到它。</p><p translation-origin=\"off\">This is a common middleware pattern found in frameworks such as Express.js.</p>\n\n<h3 id=\"provide-the-interceptor\" translation-result=\"on\">提供這個攔截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#provide-the-interceptor\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Provide the interceptor<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#provide-the-interceptor\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">這個 <code>NoopInterceptor</code> 就是一個由 Angular <a href=\"guide/dependency-injection\">依賴注入 (DI)</a>系統管理的服務。像其它服務一樣，你也必須先提供這個攔截器類，應用才能使用它。</p><p translation-origin=\"off\">The <code>NoopInterceptor</code> is a service managed by Angular's <a href=\"guide/dependency-injection\">dependency injection (DI)</a> system.\nLike other services, you must provide the interceptor class before the app can use it.</p>\n\n<p translation-result=\"on\">由於攔截器是 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務的（可選）依賴，所以你必須在提供 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的同一個（或其各級父注入器）注入器中提供這些攔截器。那些在 DI 建立完 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> <em>之後</em>再提供的攔截器將會被忽略。</p><p translation-origin=\"off\">Because interceptors are optional dependencies of the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service, you must provide them in the same injector or a parent of the injector that provides <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>.\nInterceptors provided <em>after</em> DI creates the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> are ignored.</p>\n\n<p translation-result=\"on\">由於在 <code>AppModule</code> 中匯入了 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，導致本應用在其根注入器中提供了 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>。所以你也同樣要在 <code>AppModule</code> 中提供這些攔截器。</p><p translation-origin=\"off\">This app provides <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> in the app's root injector, as a side effect of importing the <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> in <code>AppModule</code>.\nYou should provide interceptors in <code>AppModule</code> as well.</p>\n\n<p translation-result=\"on\">在從 <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a></code> 中匯入了 <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> 注入令牌之後，編寫如下的 <code>NoopInterceptor</code> 提供者註冊陳述式：</p><p translation-origin=\"off\">After importing the <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> injection token from <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a></code>, write the <code>NoopInterceptor</code> provider like this:</p>\n\n<code-example path=\"http/src/app/http-interceptors/index.ts\" region=\"noop-provider\">\n{ provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: NoopInterceptor, multi: true },\n\n</code-example>\n<p translation-result=\"on\">注意 <code>multi: true</code> 選項。這個必須的選項會告訴 Angular <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> 是一個<em>多重提供者</em>的令牌，表示它會注入一個多值的陣列，而不是單一的值。</p><p translation-origin=\"off\">Notice the <code>multi: true</code> option.\nThis required setting tells Angular that <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> is a token for a <em>multiprovider</em> that injects an array of values, rather than a single value.</p>\n\n<p translation-result=\"on\">你<em>也可以</em>直接把這個提供者新增到 <code>AppModule</code> 中的提供者陣列中，不過那樣會非常囉嗦。況且，你將來還會用這種方式建立更多的攔截器並提供它們。\n你還要<a href=\"guide/http#interceptor-order\">特別注意提供這些攔截器的順序</a>。</p><p translation-origin=\"off\">You <em>could</em> add this provider directly to the providers array of the <code>AppModule</code>.\nHowever, it's rather verbose and there's a good chance that you'll create more interceptors and provide them in the same way.\nYou must also pay <a href=\"guide/http#interceptor-order\">close attention to the order</a> in which you provide these interceptors.</p>\n\n<p translation-result=\"on\">認真考慮建立一個封裝桶（barrel）檔案，用於把所有攔截器都收集起來，一起提供給 <code>httpInterceptorProviders</code> 陣列，可以先從這個 <code>NoopInterceptor</code> 開始。</p><p translation-origin=\"off\">Consider creating a \"barrel\" file that gathers all the interceptor providers into an <code>httpInterceptorProviders</code> array, starting with this first one, the <code>NoopInterceptor</code>.</p>\n\n<code-example header=\"app/http-interceptors/index.ts\" path=\"http/src/app/http-interceptors/index.ts\" region=\"interceptor-providers\">\n/* \"Barrel\" of Http Interceptors */\nimport { <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { NoopInterceptor } from './noop-interceptor';\n\n/** Http interceptor providers in outside-in order */\nexport const httpInterceptorProviders = [\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: NoopInterceptor, multi: true },\n];\n\n</code-example>\n<p translation-result=\"on\">然後匯入它，並把它加到 <code>AppModule</code> 的 <code>providers array</code> 中，就像這樣：</p><p translation-origin=\"off\">Then import and add it to the <code>AppModule</code> <code>providers array</code> like this:</p>\n\n<code-example header=\"app/app.module.ts (interceptor providers)\" path=\"http/src/app/app.module.ts\" region=\"interceptor-providers\">\nproviders: [\n  httpInterceptorProviders\n],\n\n</code-example>\n<p translation-result=\"on\">當你再建立新的攔截器時，就同樣把它們新增到 <code>httpInterceptorProviders</code> 陣列中，而不用再修改 <code>AppModule</code>。</p><p translation-origin=\"off\">As you create new interceptors, add them to the <code>httpInterceptorProviders</code> array and you won't have to revisit the <code>AppModule</code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">在完整版的範例程式碼中還有更多的攔截器。</p><p translation-origin=\"off\">There are many more interceptors in the complete sample code.</p>\n\n</div>\n<h3 id=\"interceptor-order\" translation-result=\"on\">攔截器的順序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#interceptor-order\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Interceptor order<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#interceptor-order\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 會按你提供攔截器的順序應用它們。比如，考慮一個場景：你想處理 HTTP 請求的身份驗證並記錄它們，然後再將它們傳送到伺服器。要完成此任務，你可以提供 <code>AuthInterceptor</code> 服務，然後提供 <code>LoggingInterceptor</code> 服務。發出的請求將從 <code>AuthInterceptor</code> 到 <code>LoggingInterceptor</code>。這些請求的響應則沿相反的方向流動，從 <code>LoggingInterceptor</code> 回到 <code>AuthInterceptor</code>。以下是該過程的直觀表示：</p><p translation-origin=\"off\">Angular applies interceptors in the order that you provide them.\nFor example, consider a situation in which you want to handle the authentication of your HTTP requests and log them before sending them to a server.\nTo accomplish this task, you could provide an <code>AuthInterceptor</code> service and then a <code>LoggingInterceptor</code> service.\nOutgoing requests would flow from the <code>AuthInterceptor</code> to the <code>LoggingInterceptor</code>.\nResponses from these requests would flow in the other direction, from <code>LoggingInterceptor</code> back to <code>AuthInterceptor</code>.\nThe following is a visual representation of the process:</p>\n\n<div class=\"lightbox\">\n<img alt=\"Interceptor in order of HttpClient, AuthInterceptor, AuthInterceptor, HttpBackend, Server, and back in opposite order to show the two-way flow\" src=\"generated/images/guide/http/interceptor-order.svg\" width=\"300\" height=\"522\">\n</div>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">該過程中的最後一個攔截器始終是處理與伺服器通訊的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 服務。</p><p translation-origin=\"off\">The last interceptor in the process is always the <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> that handles communication with the server.</p>\n\n</div>\n<p translation-result=\"on\">以後你就再也不能修改這些順序或移除某些攔截器了。如果你需要動態啟用或禁用某個攔截器，那就要在那個攔截器中自行實現這個功能。</p><p translation-origin=\"off\">You cannot change the order or remove interceptors later.\nIf you need to enable and disable an interceptor dynamically, you'll have to build that capability into the interceptor itself.</p>\n\n<p><a id=\"interceptor-events\"></a></p>\n<h3 id=\"handling-interceptor-events\" translation-result=\"on\">處理攔截器事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#handling-interceptor-events\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Handling interceptor events<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#handling-interceptor-events\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">大多數 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法都會返回 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;any&gt;</code> 型的可觀察物件。<code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 類本身就是一個事件，它的型別是 <code><a href=\"api/common/http/HttpEventType#Response\" class=\"code-anchor\">HttpEventType.Response</a></code>。但是，單個 HTTP 請求可以產生其它型別的多個事件，包括報告上傳和下載進度的事件。<code>HttpInterceptor.intercept()</code> 和 <code>HttpHandler.handle()</code> 會返回 <code><a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;</code> 型的可觀察物件。</p><p translation-origin=\"off\">Most <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> methods return observables of <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;any&gt;</code>.\nThe <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> class itself is actually an event, whose type is <code><a href=\"api/common/http/HttpEventType#Response\" class=\"code-anchor\">HttpEventType.Response</a></code>.\nA single HTTP request can, however, generate multiple events of other types, including upload and download progress events.\nThe methods <code>HttpInterceptor.intercept()</code> and <code>HttpHandler.handle()</code> return observables of <code><a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;</code>.</p>\n\n<p translation-result=\"on\">很多攔截器只關心發出的請求，而對 <code>next.handle()</code> 返回的事件流不會做任何修改。但是，有些攔截器需要檢查並修改 <code>next.handle()</code> 的響應。上述做法就可以在流中看到所有這些事件。</p><p translation-origin=\"off\">Many interceptors are only concerned with the outgoing request and return the event stream from <code>next.handle()</code> without modifying it.\nSome interceptors, however, need to examine and modify the response from <code>next.handle()</code>; these operations can see all of these events in the stream.</p>\n\n<p><a id=\"immutability\"></a></p>\n<p translation-result=\"on\">雖然攔截器有能力改變請求和響應，但 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 和 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 例項的屬性卻是隻讀（<code>readonly</code>）的，\n因此讓它們基本上是不可變的。</p><p translation-result=\"on\">有充足的理由把它們做成不可變物件：應用可能會重試傳送很多次請求之後才能成功，這就意味著這個攔截器連結串列可能會多次重複處理同一個請求。如果攔截器可以修改原始的請求物件，那麼重試階段的操作就會從修改過的請求開始，而不是原始請求。而這種不可變性，可以確保這些攔截器在每次重試時看到的都是同樣的原始請求。</p><p translation-origin=\"off\">Although interceptors are capable of modifying requests and responses, the <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> and <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> instance properties are <code>readonly</code>, rendering them largely immutable.\nThey are immutable for a good reason:\nAn app might retry a request several times before it succeeds, which means that the interceptor chain can re-process the same request multiple times.\nIf an interceptor could modify the original request object, the re-tried operation would start from the modified request rather than the original.\nImmutability ensures that interceptors see the same request for each try.</p>\n\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你的攔截器應該在沒有任何修改的情況下返回每一個事件，除非它有令人信服的理由去做。</p><p translation-origin=\"off\">Your interceptor should return every event without modification unless it has a compelling reason to do otherwise.</p>\n\n</div>\n<p translation-result=\"on\">TypeScript 會阻止你設定 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 的唯讀屬性。</p><p translation-origin=\"off\">TypeScript prevents you from setting <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> read-only properties.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\n// Typescript disallows the following assignment because req.url is readonly\nreq.url = req.url.replace('<a href=\"api/common/http\" class=\"code-anchor\">http</a>://', 'https://');\n\n</code-example>\n<p translation-result=\"on\">如果你必須修改一個請求，先把它複製一份，修改這個複製體後再把它傳給 <code>next.handle()</code>。你可以在一步中複製並修改此請求，例子如下。</p><p translation-origin=\"off\">If you must alter a request, clone it first and modify the clone before passing it to <code>next.handle()</code>.\nYou can clone and modify the request in a single step, as shown in the following example.</p>\n\n<code-example header=\"app/http-interceptors/ensure-https-interceptor.ts (excerpt)\" path=\"http/src/app/http-interceptors/ensure-https-interceptor.ts\" region=\"excerpt\">\n// clone request and replace '<a href=\"api/common/http\" class=\"code-anchor\">http</a>://' with 'https://' at the same time\nconst secureReq = req.clone({\n  url: req.url.replace('<a href=\"api/common/http\" class=\"code-anchor\">http</a>://', 'https://')\n});\n// send the cloned, \"secure\" request to the next handler.\nreturn next.handle(secureReq);\n\n</code-example>\n<p translation-result=\"on\">這個 <code>clone()</code> 方法的雜湊型引數允許你在複製出複製體的同時改變該請求的某些特定屬性。</p><p translation-origin=\"off\">The <code>clone()</code> method's hash argument lets you mutate specific properties of the request while copying the others.</p>\n\n<h4 id=\"modifying-a-request-body\" translation-result=\"on\">修改請求體<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#modifying-a-request-body\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Modifying a request body<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#modifying-a-request-body\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code>readonly</code> 這種賦值保護，無法防範深修改（修改子物件的屬性），也不能防範你修改請求體物件中的屬性。</p><p translation-origin=\"off\">The <code>readonly</code> assignment guard can't prevent deep updates and, in particular, it can't prevent you from modifying a property of a request body object.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nreq.body.name = req.body.name.trim(); // bad idea!\n\n</code-example>\n<p translation-result=\"on\">如果必須修改請求體，請執行以下步驟。</p><p translation-origin=\"off\">If you must modify the request body, follow these steps.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">複製請求體並在副本中進行修改。</p><p translation-origin=\"off\">Copy the body and make your change in the copy.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">使用 <code>clone()</code> 方法複製這個請求物件。</p><p translation-origin=\"off\">Clone the request object, using its <code>clone()</code> method.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">用修改過的副本替換被複製的請求體。</p><p translation-origin=\"off\">Replace the clone's body with the modified copy.</p>\n\n</li>\n</ol>\n<code-example header=\"app/http-interceptors/trim-name-interceptor.ts (excerpt)\" path=\"http/src/app/http-interceptors/trim-name-interceptor.ts\" region=\"excerpt\">\n// copy the body and trim whitespace from the name property\nconst newBody = { ...body, name: body.name.trim() };\n// clone request and set its body\nconst newReq = req.clone({ body: newBody });\n// send the cloned request to the next handler.\nreturn next.handle(newReq);\n\n</code-example>\n<h4 id=\"clearing-the-request-body-in-a-clone\" translation-result=\"on\">複製時清除請求體<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#clearing-the-request-body-in-a-clone\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Clearing the request body in a clone<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#clearing-the-request-body-in-a-clone\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">有時，你需要清除請求體而不是替換它。為此，請將複製後的請求體設定為 <code>null</code>。</p><p translation-origin=\"off\">Sometimes you need to clear the request body rather than replace it.\nTo do this, set the cloned request body to <code>null</code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>提示</strong>：<br>\n如果你把複製後的請求體設為 <code>undefined</code>，那麼 Angular 會認為你想讓請求體保持原樣。</p><p translation-origin=\"off\"><strong>TIP</strong>: <br>\nIf you set the cloned request body to <code>undefined</code>, Angular assumes you intend to leave the body as is.</p>\n\n</div>\n<code-example format=\"javascript\" language=\"javascript\">\n\nnewReq = req.clone({ … }); // body not mentioned =&gt; preserve original body\nnewReq = req.clone({ body: undefined }); // preserve original body\nnewReq = req.clone({ body: null }); // clear the body\n\n</code-example>\n<h2 id=\"http-interceptor-use-cases\" translation-result=\"on\">HTTP 攔截器使用案例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#http-interceptor-use-cases\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Http interceptor use-cases<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#http-interceptor-use-cases\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">以下是攔截器的一些常見用法。</p><p translation-origin=\"off\">Following are a number of common uses for interceptors.</p>\n\n<h3 id=\"setting-default-headers\" translation-result=\"on\">設定預設請求頭<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#setting-default-headers\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Setting default headers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#setting-default-headers\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">應用通常會使用攔截器來設定外發請求的預設請求頭。</p><p translation-origin=\"off\">Apps often use an interceptor to set default headers on outgoing requests.</p>\n\n<p translation-result=\"on\">該範例應用具有一個 <code>AuthService</code>，它會產生一個認證令牌。在這裡，<code>AuthInterceptor</code> 會注入該服務以獲取令牌，並對每一個外發的請求新增一個帶有該令牌的認證頭：</p><p translation-origin=\"off\">The sample app has an <code>AuthService</code> that produces an authorization token.\nHere is its <code>AuthInterceptor</code> that injects that service to get the token and adds an authorization header with that token to every outgoing request:</p>\n\n<code-example header=\"app/http-interceptors/auth-interceptor.ts\" path=\"http/src/app/http-interceptors/auth-interceptor.ts\">\nimport { AuthService } from '../auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class AuthInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n\n  constructor(private auth: AuthService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // Get the auth token from the service.\n    const authToken = this.auth.getAuthorizationToken();\n\n    // Clone the request and replace the original headers with\n    // cloned headers, updated with the authorization.\n    const authReq = req.clone({\n      headers: req.headers.set('Authorization', authToken)\n    });\n\n    // send cloned request with header to the next handler.\n    return next.handle(authReq);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">這種在複製請求的同時設定新請求頭的操作太常見了，因此它還有一個快捷方式 <code>setHeaders</code>：</p><p translation-origin=\"off\">The practice of cloning a request to set new headers is so common that there's a <code>setHeaders</code> shortcut for it:</p>\n\n<code-example path=\"http/src/app/http-interceptors/auth-interceptor.ts\" region=\"set-header-shortcut\">\n// Clone the request and set the new header in one step.\nconst authReq = req.clone({ setHeaders: { Authorization: authToken } });\n\n</code-example>\n<p translation-result=\"on\">這種可以修改頭的攔截器可以用於很多不同的操作，比如：</p><p translation-origin=\"off\">An interceptor that alters headers can be used for a number of different operations, including:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">認證 / 授權</p><p translation-origin=\"off\">Authentication/authorization</p>\n\n</li>\n<li>\n<p translation-result=\"on\">控制快取行為。比如 <code>If-Modified-Since</code></p><p translation-origin=\"off\">Caching behavior; for example, <code>If-Modified-Since</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">XSRF 防護</p><p translation-origin=\"off\">XSRF protection</p>\n\n</li>\n</ul>\n<h3 id=\"logging-request-and-response-pairs\" translation-result=\"on\">記錄請求與響應對<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#logging-request-and-response-pairs\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Logging request and response pairs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#logging-request-and-response-pairs\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">因為攔截器可以<em>同時</em>處理請求和響應，所以它們也可以對整個 HTTP 操作執行計時和記錄日誌等任務。</p><p translation-origin=\"off\">Because interceptors can process the request and response <em>together</em>, they can perform tasks such as timing and logging an entire HTTP operation.</p>\n\n<p translation-result=\"on\">考慮下面這個 <code>LoggingInterceptor</code>，它捕獲請求的發起時間、響應的接收時間，並使用注入的 <code>MessageService</code> 來發送總共花費的時間。</p><p translation-origin=\"off\">Consider the following <code>LoggingInterceptor</code>, which captures the time of the request,\nthe time of the response, and logs the outcome with the elapsed time\nwith the injected <code>MessageService</code>.</p>\n\n<code-example header=\"app/http-interceptors/logging-interceptor.ts)\" path=\"http/src/app/http-interceptors/logging-interceptor.ts\" region=\"excerpt\">\nimport { finalize, tap } from 'rxjs/operators';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class LoggingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private messenger: MessageService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    const started = Date.now();\n    let ok: string;\n\n    // extend server response observable with logging\n    return next.handle(req)\n      .pipe(\n        tap({\n          // Succeeds when there is a response; ignore other events\n          next: (event) =&gt; (ok = event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a> ? 'succeeded' : ''),\n          // Operation failed; error is an <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>\n          error: (error) =&gt; (ok = 'failed')\n        }),\n        // Log when response observable either completes or errors\n        finalize(() =&gt; {\n          const elapsed = Date.now() - started;\n          const msg = `${req.method} \"${req.urlWithParams}\"\n             ${ok} in ${elapsed} ms.`;\n          this.messenger.add(msg);\n        })\n      );\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">RxJS 的 <code>tap</code> 運運算元會捕獲請求成功了還是失敗了。RxJS 的 <code>finalize</code> 運運算元無論在返回成功還是失敗時都會呼叫，然後把結果彙報給 <code>MessageService</code>。</p><p translation-origin=\"off\">The RxJS <code>tap</code> operator captures whether the request succeeded or failed.\nThe RxJS <code>finalize</code> operator is called when the response observable either returns an error or completes and reports the outcome to the <code>MessageService</code>.</p>\n\n<p translation-result=\"on\">在這個可觀察物件的流中，無論是 <code>tap</code> 還是 <code>finalize</code> 接觸過的值，都會照常傳送給呼叫者。</p><p translation-origin=\"off\">Neither <code>tap</code> nor <code>finalize</code> touch the values of the observable stream returned to the caller.</p>\n\n<p><a id=\"custom-json-parser\"></a></p>\n<h3 id=\"custom-json-parsing\" translation-result=\"on\">自訂 JSON 解析<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#custom-json-parsing\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Custom JSON parsing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#custom-json-parsing\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">攔截器可用來以自訂實現替換內建的 JSON 解析。</p><p translation-origin=\"off\">Interceptors can be used to replace the built-in JSON parsing with a custom implementation.</p>\n\n<p translation-result=\"on\">以下範例中的 <code>CustomJsonInterceptor</code> 示範瞭如何實現此目的。如果截獲的請求期望一個 <code>'json'</code> 響應，則將 <code>responseType</code> 更改為 <code>'text'</code> 以禁用內建的 JSON 解析。然後，透過注入的 <code>JsonParser</code> 解析響應。</p><p translation-origin=\"off\">The <code>CustomJsonInterceptor</code> in the following example demonstrates how to achieve this.\nIf the intercepted request expects a <code>'json'</code> response, the <code>responseType</code> is changed to <code>'text'</code> to disable the built-in JSON parsing.\nThen the response is parsed via the injected <code>JsonParser</code>.</p>\n\n<code-example header=\"app/http-interceptors/custom-json-interceptor.ts\" path=\"http/src/app/http-interceptors/custom-json-interceptor.ts\" region=\"custom-json-interceptor\">\n// The JsonParser class acts as a base class for custom parsers and as the DI token.\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport abstract class JsonParser {\n  abstract parse(text: string): any;\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CustomJsonInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private jsonParser: JsonParser) {}\n\n  intercept(httpRequest: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    if (httpRequest.responseType === 'json') {\n      // If the expected response type is JSON then handle it here.\n      return this.handleJsonResponse(httpRequest, next);\n    } else {\n      return next.handle(httpRequest);\n    }\n  }\n\n  private handleJsonResponse(httpRequest: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // Override the responseType to disable the default JSON parsing.\n    httpRequest = httpRequest.clone({responseType: 'text'});\n    // Handle the response using the custom parser.\n    return next.handle(httpRequest).pipe(map(event =&gt; this.parseJsonResponse(event)));\n  }\n\n  private parseJsonResponse(event: <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;) {\n    if (event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a> &amp;&amp; typeof event.body === 'string') {\n      return event.clone({body: this.jsonParser.parse(event.body)});\n    } else {\n      return event;\n    }\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">然後，你可以實現自己的自訂 <code>JsonParser</code>。這是一個具有特殊日期接收器的自訂 JsonParser。</p><p translation-origin=\"off\">You can then implement your own custom <code>JsonParser</code>.\nHere is a custom JsonParser that has a special date reviver.</p>\n\n<code-example header=\"app/http-interceptors/custom-json-interceptor.ts\" path=\"http/src/app/http-interceptors/custom-json-interceptor.ts\" region=\"custom-json-parser\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CustomJsonParser implements JsonParser {\n  parse(text: string): any {\n    return JSON.parse(text, dateReviver);\n  }\n}\n\nfunction dateReviver(key: string, value: any) {\n  /* . . . */\n}\n\n</code-example>\n<p translation-result=\"on\">你提供 <code>CustomParser</code> 以及 <code>CustomJsonInterceptor</code>。</p><p translation-origin=\"off\">You provide the <code>CustomParser</code> along with the <code>CustomJsonInterceptor</code>.</p>\n\n<code-example header=\"app/http-interceptors/index.ts\" path=\"http/src/app/http-interceptors/index.ts\" region=\"custom-json-interceptor\">\n{ provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: CustomJsonInterceptor, multi: true },\n{ provide: JsonParser, useClass: CustomJsonParser },\n\n</code-example>\n<p><a id=\"caching\"></a></p>\n<h3 id=\"caching-requests\" translation-result=\"on\">用攔截器實現快取<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#caching-requests\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Caching requests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#caching-requests\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">攔截器還可以自行處理這些請求，而不用轉發給 <code>next.handle()</code>。</p><p translation-origin=\"off\">Interceptors can handle requests by themselves, without forwarding to <code>next.handle()</code>.</p>\n\n<p translation-result=\"on\">比如，你可能會想快取某些請求和響應，以便提升效能。你可以把這種快取操作委託給某個攔截器，而不破壞你現有的各個資料服務。</p><p translation-origin=\"off\">For example, you might decide to cache certain requests and responses to improve performance.\nYou can delegate caching to an interceptor without disturbing your existing data services.</p>\n\n<p translation-result=\"on\">下例中的 <code>CachingInterceptor</code> 示範了這種方法。</p><p translation-origin=\"off\">The <code>CachingInterceptor</code> in the following example demonstrates this approach.</p>\n\n<code-example header=\"app/http-interceptors/caching-interceptor.ts)\" path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"v1\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CachingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private cache: RequestCache) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // continue if not cacheable.\n    if (!isCacheable(req)) { return next.handle(req); }\n\n    const cachedResponse = this.cache.get(req);\n    return cachedResponse ?\n      of(cachedResponse) : sendRequest(req, next, this.cache);\n  }\n}\n\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\"><code>isCacheable()</code> 函式用於決定該請求是否允許快取。在這個例子中，只有發到包搜尋 API 的 GET 請求才是可以快取的。</p><p translation-origin=\"off\">The <code>isCacheable()</code> function determines if the request is cacheable.\nIn this sample, only GET requests to the package search API are cacheable.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果該請求是不可快取的，該攔截器會把該請求轉發給連結串列中的下一個處理器</p><p translation-origin=\"off\">If the request is not cacheable, the interceptor forwards the request to the next handler in the chain</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果可快取的請求在快取中找到了，該攔截器就會透過 <code>of()</code> 函式返回一個已快取的回應內文的<em>可觀察物件</em>，然後繞過 <code>next</code> 處理器（以及所有其它下游攔截器）</p><p translation-origin=\"off\">If a cacheable request is found in the cache, the interceptor returns an <code>of()</code> <em>observable</em> with the cached response, by-passing the <code>next</code> handler and all other interceptors downstream</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果可快取的請求不在快取中，程式碼會呼叫 <code>sendRequest()</code>。這個函式會把請求轉發給 <code>next.handle()</code>，它會最終呼叫伺服器並返回來自伺服器的響應物件。</p><p translation-origin=\"off\">If a cacheable request is not in cache, the code calls <code>sendRequest()</code>.\nThis function forwards the request to <code>next.handle()</code> which ultimately calls the server and returns the server's response.</p>\n\n</li>\n</ul>\n<p><a id=\"send-request\"></a></p>\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"send-request\">\n/**\n * Get server response observable by sending request to `next()`.\n * Will add the response to the cache on the way out.\n */\nfunction sendRequest(\n  req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;,\n  next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>,\n  cache: RequestCache): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n  return next.handle(req).pipe(\n    tap(event =&gt; {\n      // There may be other events besides the response.\n      if (event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>) {\n        cache.put(req, event); // Update the cache.\n      }\n    })\n  );\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">注意 <code>sendRequest()</code> 是如何在返回應用程式的過程中攔截響應的。該方法透過 <code>tap()</code> 運運算元來管理響應物件，該運運算元的回呼(Callback)函式會把該響應物件新增到快取中。</p><p translation-origin=\"off\">Notice how <code>sendRequest()</code> intercepts the response on its way back to the application.\nThis method pipes the response through the <code>tap()</code> operator, whose callback adds the response to the cache.</p>\n\n<p translation-result=\"on\">然後，原始的響應會透過這些攔截器鏈，原封不動的回到伺服器的呼叫者那裡。</p><p translation-origin=\"off\">The original response continues untouched back up through the chain of interceptors to the application caller.</p>\n\n<p translation-result=\"on\">資料服務，比如 <code>PackageSearchService</code>，並不知道它們收到的某些 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 請求實際上是從快取的請求中返回來的。</p><p translation-origin=\"off\">Data services, such as <code>PackageSearchService</code>, are unaware that some of their <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> requests actually return cached responses.</p>\n\n</div>\n<p><a id=\"cache-refresh\"></a></p>\n<h3 id=\"using-interceptors-to-request-multiple-values\" translation-result=\"on\">用攔截器來請求多個值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#using-interceptors-to-request-multiple-values\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Using interceptors to request multiple values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#using-interceptors-to-request-multiple-values\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法通常會返回一個可觀察物件，它會發出一個值（資料或錯誤）。攔截器可以把它改成一個可以發出<a href=\"guide/observables\">多個值</a>的可觀察物件。</p><p translation-origin=\"off\">The <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> method normally returns an observable that emits a single value, either the data or an error.\nAn interceptor can change this to an observable that emits <a href=\"guide/observables\">multiple values</a>.</p>\n\n<p translation-result=\"on\">修改後的 <code>CachingInterceptor</code> 版本可以返回一個立即發出所快取響應的可觀察物件，然後把請求傳送到包搜尋 API，然後把修改過的搜尋結果重新發出一次。</p><p translation-origin=\"off\">The following revised version of the <code>CachingInterceptor</code> optionally returns an observable that immediately emits the cached response, sends the request on to the package search API, and emits again later with the updated search results.</p>\n\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"intercept-refresh\">\n// cache-then-refresh\nif (req.headers.get('x-refresh')) {\n  const results$ = sendRequest(req, next, this.cache);\n  return cachedResponse ?\n    results$.pipe( startWith(cachedResponse) ) :\n    results$;\n}\n// cache-or-fetch\nreturn cachedResponse ?\n  of(cachedResponse) : sendRequest(req, next, this.cache);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><em>cache-then-refresh</em> 選項是由一個自訂的 <code>x-refresh</code> 請求頭觸發的。</p><p translation-origin=\"off\">The <em>cache-then-refresh</em> option is triggered by the presence of a custom <code>x-refresh</code> header.</p>\n\n<p translation-result=\"on\"><code>PackageSearchComponent</code> 中的一個檢查框會切換 <code>withRefresh</code> 標識，它是 <code>PackageSearchService.search()</code> 的引數之一。<code>search()</code> 方法建立了自訂的 <code>x-refresh</code> 頭，並在呼叫 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 前把它新增到請求裡。</p><p translation-origin=\"off\">A checkbox on the <code>PackageSearchComponent</code> toggles a <code>withRefresh</code> flag, which is one of the arguments to <code>PackageSearchService.search()</code>.\nThat <code>search()</code> method creates the custom <code>x-refresh</code> header and adds it to the request before calling <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code>.</p>\n\n</div>\n<p translation-result=\"on\">修改後的 <code>CachingInterceptor</code> 會發起一個伺服器請求，而不管有沒有快取的值。\n就像 <a href=\"guide/http#send-request\">前面</a> 的 <code>sendRequest()</code> 方法一樣進行訂閱。\n在訂閱 <code>results$</code> 可觀察物件時，就會發起這個請求。</p><p translation-origin=\"off\">The revised <code>CachingInterceptor</code> sets up a server request whether there's a cached value or not, using the same <code>sendRequest()</code> method described <a href=\"guide/http#send-request\">above</a>.\nThe <code>results$</code> observable makes the request when subscribed.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">如果沒有快取值，攔截器直接返回 <code>results$</code>。</p><p translation-origin=\"off\">If there's no cached value, the interceptor returns <code>results$</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果有快取的值，這些程式碼就會把快取的響應加入到 <code>result$</code> 的<em>管道</em>中。這會產生一個重組後的 Observable，它會發出兩次響應，故此訂閱者將會看到一個包含這兩個響應的序列。</p><p translation-origin=\"off\">If there is a cached value, the code <em>pipes</em> the cached response onto <code>results$</code>. This produces a recomposed observable that emits two responses, so subscribers will see a sequence of these two responses:</p>\n\n</li>\n</ul>\n<ul>\n<li>\n<p translation-result=\"on\">立即發出的已快取的響應</p><p translation-origin=\"off\">The cached response that's emitted immediately</p>\n\n</li>\n<li>\n<p translation-result=\"on\">稍後發出來自伺服器的響應</p><p translation-origin=\"off\">The response from the server, that's emitted later</p>\n\n</li>\n</ul>\n<p><a id=\"report-progress\"></a></p>\n<h2 id=\"tracking-and-showing-request-progress\" translation-result=\"on\">追蹤和顯示請求進度<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#tracking-and-showing-request-progress\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Tracking and showing request progress<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#tracking-and-showing-request-progress\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">應用程式有時會傳輸大量資料，而這些傳輸可能要花很長時間。檔案上傳就是典型的例子。你可以透過提供關於此類傳輸的進度反饋，為使用者提供更好的體驗。</p><p translation-origin=\"off\">Sometimes applications transfer large amounts of data and those transfers can take a long time.\nFile uploads are a typical example.\nYou can give the users a better experience by providing feedback on the progress of such transfers.</p>\n\n<p translation-result=\"on\">要想發出一個帶有進度事件的請求，你可以建立一個 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 例項，並把 <code>reportProgress</code> 選項設定為 true 來啟用對進度事件的追蹤。</p><p translation-origin=\"off\">To make a request with progress events enabled, create an instance of <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> with the <code>reportProgress</code> option set true to enable tracking of progress events.</p>\n\n<code-example header=\"app/uploader/uploader.service.ts (upload request)\" path=\"http/src/app/uploader/uploader.service.ts\" region=\"upload-request\">\nconst req = new <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>('POST', '/upload/file', file, {\n  reportProgress: true\n});\n\n</code-example>\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><strong>提示</strong>：<br>\n每個進度事件都會觸發變更檢測，所以只有當需要在 UI 上報告進度時，你才應該開啟它們。</p><p translation-origin=\"off\"><strong>TIP</strong>: <br>\nEvery progress event triggers change detection, so only turn them on if you need to report progress in the UI.</p>\n\n<p translation-result=\"on\">當 <a href=\"api/common/http/HttpClient#request\"><code>HttpClient.request()</code></a> 和 HTTP 方法一起使用時，可以用 <a href=\"api/common/http/HttpClient#request\"><code>observe: 'events'</code></a> 來檢視所有事件，包括傳輸的進度。</p><p translation-origin=\"off\">When using <a href=\"api/common/http/HttpClient#request\"><code>HttpClient.request()</code></a> with an HTTP method, configure the method with <a href=\"api/common/http/HttpClient#request\"><code>observe: 'events'</code></a> to see all events, including the progress of transfers.</p>\n\n</div>\n<p translation-result=\"on\">接下來，把這個請求物件傳給 <code><a href=\"api/common/http/HttpClient#request\" class=\"code-anchor\">HttpClient.request()</a></code> 方法，該方法返回一個 <code>HttpEvents</code> 的 <code>Observable</code>（與 <a href=\"guide/http#interceptor-events\">攔截器</a> 部分處理過的事件相同）。</p><p translation-origin=\"off\">Next, pass this request object to the <code><a href=\"api/common/http/HttpClient#request\" class=\"code-anchor\">HttpClient.request()</a></code> method, which returns an <code>Observable</code> of <code>HttpEvents</code> (the same events processed by <a href=\"guide/http#interceptor-events\">interceptors</a>).</p>\n\n<code-example header=\"app/uploader/uploader.service.ts (upload body)\" path=\"http/src/app/uploader/uploader.service.ts\" region=\"upload-body\">\n// The `HttpClient.request` API produces a raw event stream\n// which includes start (sent), progress, and response events.\nreturn this.http.request(req).pipe(\n  map(event =&gt; this.getEventMessage(event, file)),\n  tap(message =&gt; this.showProgress(message)),\n  last(), // return last (completed) message to caller\n  catchError(this.handleError(file))\n);\n\n</code-example>\n<p translation-result=\"on\"><code>getEventMessage</code> 方法解釋了事件流中每種型別的 <code><a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a></code>。</p><p translation-origin=\"off\">The <code>getEventMessage</code> method interprets each type of <code><a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a></code> in the event stream.</p>\n\n<code-example header=\"app/uploader/uploader.service.ts (getEventMessage)\" path=\"http/src/app/uploader/uploader.service.ts\" region=\"getEventMessage\">\n/** Return distinct message for sent, upload progress, &amp; response events */\nprivate getEventMessage(event: <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;, file: File) {\n  switch (event.type) {\n    case <a href=\"api/common/http/HttpEventType#Sent\" class=\"code-anchor\">HttpEventType.Sent</a>:\n      return `Uploading file \"${file.name}\" of size ${file.size}.`;\n\n    case <a href=\"api/common/http/HttpEventType#UploadProgress\" class=\"code-anchor\">HttpEventType.UploadProgress</a>:\n      // Compute and show the % done:\n      const percentDone = event.total ? Math.round(100 * event.loaded / event.total) : 0;\n      return `File \"${file.name}\" is ${percentDone}% uploaded.`;\n\n    case <a href=\"api/common/http/HttpEventType#Response\" class=\"code-anchor\">HttpEventType.Response</a>:\n      return `File \"${file.name}\" was completely uploaded!`;\n\n    default:\n      return `File \"${file.name}\" surprising upload event: ${event.type}.`;\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">本指南中的範例應用中沒有用來接受上傳檔案的伺服器。<code>app/http-interceptors/upload-interceptor.ts</code> 的 <code>UploadInterceptor</code> 透過返回一個模擬這些事件的可觀察物件來攔截和短路上傳請求。</p><p translation-origin=\"off\">The sample app for this guide doesn't have a server that accepts uploaded files.\nThe <code>UploadInterceptor</code> in <code>app/http-interceptors/upload-interceptor.ts</code> intercepts and short-circuits upload requests by returning an observable of simulated events.</p>\n\n</div>\n<h2 id=\"optimizing-server-interaction-with-debouncing\" translation-result=\"on\">透過防抖來最佳化與伺服器的互動<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#optimizing-server-interaction-with-debouncing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Optimizing server interaction with debouncing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#optimizing-server-interaction-with-debouncing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果你需要發一個 HTTP 請求來響應使用者的輸入，那麼每次按鍵就傳送一個請求的效率顯然不高。最好等使用者停止輸入後再發送請求。這種技術叫做防抖。</p><p translation-origin=\"off\">If you need to make an HTTP request in response to user input, it's not efficient to send a request for every keystroke.\nIt's better to wait until the user stops typing and then send a request.\nThis technique is known as debouncing.</p>\n\n<p translation-result=\"on\">考慮下面這個範本，它讓使用者輸入一個搜尋詞來按名字查詢套件。當用戶在搜尋框中輸入名字時，<code>PackageSearchComponent</code> 就會把這個根據名字搜尋套件的請求發給包搜尋 API。</p><p translation-origin=\"off\">Consider the following template, which lets a user enter a search term to find a package by name.\nWhen the user enters a name in a search-box, the <code>PackageSearchComponent</code> sends a search request for a package with that name to the package search API.</p>\n\n<code-example header=\"app/package-search/package-search.component.html (search)\" path=\"http/src/app/package-search/package-search.component.html\" region=\"search\">\n&lt;input type=\"text\" (keyup)=\"search(getValue($event))\" id=\"name\" placeholder=\"Search\"/&gt;\n\n&lt;ul&gt;\n  &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let package of packages$ | async\"&gt;\n    &lt;strong&gt;{{package.name}} v.{{package.version}}&lt;/strong&gt; -\n    &lt;em&gt;{{package.description}}&lt;/em&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n<p translation-result=\"on\">在這裡，<code>keyup</code> 事件繫結會將每個按鍵都發送到元件的 <code>search()</code> 方法。</p><p translation-origin=\"off\">Here, the <code>keyup</code> event binding sends every keystroke to the component's <code>search()</code> method.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><code>$event.target</code> 的型別在範本中只是 <code>EventTarget</code>，而在 <code>getValue()</code> 方法中，目標會轉換成 <code>HTMLInputElement</code> 型別，以允許對它的 <code>value</code> 屬性進行型別安全的存取。</p><p translation-origin=\"off\">The type of <code>$event.target</code> is only <code>EventTarget</code> in the template.\nIn the <code>getValue()</code> method, the target is cast to an <code>HTMLInputElement</code> to let type-safe have access to its <code>value</code> property.</p>\n\n<code-example path=\"http/src/app/package-search/package-search.component.ts\" region=\"getValue\">\ngetValue(event: <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>): string {\n  return (event.target as HTMLInputElement).value;\n}\n\n</code-example>\n</div>\n<p translation-result=\"on\">下面的程式碼片段使用 RxJS 的運運算元為這個輸入實現了防抖。</p><p translation-origin=\"off\">The following snippet implements debouncing for this input using RxJS operators.</p>\n\n<code-example header=\"app/package-search/package-search.component.ts (excerpt)\" path=\"http/src/app/package-search/package-search.component.ts\" region=\"debounce\">\nwithRefresh = false;\npackages$!: Observable&lt;NpmPackageInfo[]&gt;;\nprivate searchText$ = new Subject&lt;string&gt;();\n\nsearch(packageName: string) {\n  this.searchText$.next(packageName);\n}\n\nngOnInit() {\n  this.packages$ = this.searchText$.pipe(\n    debounceTime(500),\n    distinctUntilChanged(),\n    switchMap(packageName =&gt;\n      this.searchService.search(packageName, this.withRefresh))\n  );\n}\n\nconstructor(private searchService: PackageSearchService) { }\n\n\n</code-example>\n<p translation-result=\"on\"><code>searchText$</code> 是來自使用者的搜尋框值的序列。它被定義為 RxJS <code>Subject</code> 型別，這意味著它是一個多播 <code>Observable</code>，它還可以透過呼叫 <code>next(value)</code> 來自行發出值，就像在 <code>search()</code> 方法中一樣。</p><p translation-origin=\"off\">The <code>searchText$</code> is the sequence of search-box values coming from the user.\nIt's defined as an RxJS <code>Subject</code>, which means it is a multicasting <code>Observable</code> that can also emit values for itself by calling <code>next(value)</code>, as happens in the <code>search()</code> method.</p>\n\n<p translation-result=\"on\">除了把每個 <code>searchText</code> 的值都直接轉發給 <code>PackageSearchService</code> 之外，<code>ngOnInit()</code> 中的程式碼還透過下列三個運運算元對這些搜尋值進行<em>管道</em>處理，以便只有當它是一個新值並且使用者已經停止輸入時，要搜尋的值才會抵達該服務。</p><p translation-origin=\"off\">Rather than forward every <code>searchText</code> value directly to the injected <code>PackageSearchService</code>, the code in <code>ngOnInit()</code> pipes search values through three operators, so that a search value reaches the service only if it's a new value and the user stopped typing.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">RxJS 運運算元</nt-wrapper><nt-wrapper translation-origin=\"off\">RxJS operators</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>debounceTime(500)</code>⁠</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">等待使用者停止輸入，本例中為 1/2 秒。</nt-wrapper><nt-wrapper translation-origin=\"off\">Wait for the user to stop typing, which is 1/2 second in this case.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>distinctUntilChanged()</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">等待搜尋文字發生變化。</nt-wrapper><nt-wrapper translation-origin=\"off\">Wait until the search text changes.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>switchMap()</code>⁠</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">將搜尋請求傳送到服務。</nt-wrapper><nt-wrapper translation-origin=\"off\">Send the search request to the service.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">這些程式碼把 <code>packages$</code> 設定成了使用搜索結果組合出的 <code>Observable</code> 物件。範本中使用 <a href=\"api/common/AsyncPipe\">AsyncPipe</a> 訂閱了 <code>packages$</code>，一旦搜尋結果的值發回來了，就顯示這些搜尋結果。</p><p translation-origin=\"off\">The code sets <code>packages$</code> to this re-composed <code>Observable</code> of search results.\nThe template subscribes to <code>packages$</code> with the <a href=\"api/common/AsyncPipe\">AsyncPipe</a> and displays search results as they arrive.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">關於 <code>withRefresh</code> 選項的更多資訊，請參閱<a href=\"guide/http#cache-refresh\">使用攔截器來請求多個值</a>。</p><p translation-origin=\"off\">See <a href=\"guide/http#cache-refresh\">Using interceptors to request multiple values</a> for more about the <code>withRefresh</code> option.</p>\n\n</div>\n<h3 id=\"using-the-switchmap-operator\" translation-result=\"on\">使用 <code>switchMap()</code> 運運算元<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#using-the-switchmap-operator\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Using the <code>switchMap()</code> operator<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#using-the-switchmap-operator\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>switchMap()</code> 運運算元接受一個返回 <code>Observable</code> 的函式型引數。在這個例子中，<code>PackageSearchService.search</code> 像其它資料服務方法那樣返回一個 <code>Observable</code>。如果先前的搜尋請求仍在<em>進行中</em>（如網路連線不良），它將取消該請求併發送新的請求。</p><p translation-origin=\"off\">The <code>switchMap()</code> operator takes a function argument that returns an <code>Observable</code>.\nIn the example, <code>PackageSearchService.search</code> returns an <code>Observable</code>, as other data service methods do.\nIf a previous search request is still in-flight, such as when the network connection is poor, the operator cancels that request and sends a new one.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n<code>switchMap()</code> 會按照原始的請求順序返回這些服務的響應，而不用關心伺服器實際上是以亂序返回的它們。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\n<code>switchMap()</code> returns service responses in their original request order, even if the server returns them out of order.</p>\n\n</div>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果你覺得將來會複用這些防抖邏輯，可以把它移到單獨的工具函式中，或者移到 <code>PackageSearchService</code> 中。</p><p translation-origin=\"off\">If you think you'll reuse this debouncing logic, consider moving it to a utility function or into the <code>PackageSearchService</code> itself.</p>\n\n</div>\n<h2 id=\"security-xsrf-protection\" translation-result=\"on\">安全：XSRF 防護<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#security-xsrf-protection\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Security: XSRF protection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#security-xsrf-protection\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery\">跨站請求偽造（XSRF 或 CSRF）</a>是一個攻擊技術，它能讓攻擊者假冒一個已認證的使用者在你的網站上執行未知的操作。<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 支援一種<a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token\">通用的機制</a>來防範 XSRF 攻擊。當執行 HTTP 請求時，一個攔截器會從 cookie 中讀取 XSRF 標記（預設名字為 <code>XSRF-TOKEN</code>），並且把它設定為一個 HTTP 頭 <code>X-XSRF-TOKEN</code>，由於只有執行在你自己的域名下的程式碼才能讀取這個 cookie，因此後端可以確認這個 HTTP 請求真的來自你的客戶端應用，而不是攻擊者。</p><p translation-origin=\"off\"><a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery\">Cross-Site Request Forgery (XSRF or CSRF)</a> is an attack technique by which the attacker can trick an authenticated user into unknowingly executing actions on your website.\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> supports a <a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token\">common mechanism</a> used to prevent XSRF attacks.\nWhen performing HTTP requests, an interceptor reads a token from a cookie, by default <code>XSRF-TOKEN</code>, and sets it as an HTTP header, <code>X-XSRF-TOKEN</code>.\nBecause only code that runs on your domain could read the cookie, the backend can be certain that the HTTP request came from your client application and not an attacker.</p>\n\n<p translation-result=\"on\">預設情況下，攔截器會在所有的修改型請求中（比如 POST 等）把這個請求頭髮送給使用相對 URL 的請求。但不會在 GET/HEAD 請求中傳送，也不會發送給使用絕對 URL 的請求。</p><p translation-origin=\"off\">By default, an interceptor sends this header on all mutating requests (such as POST)\nto relative URLs, but not on GET/HEAD requests or on requests with an absolute URL.</p>\n\n<p translation-result=\"on\">要獲得這種優點，你的伺服器需要在頁面載入或首個 GET 請求中把一個名叫 <code>XSRF-TOKEN</code> 的標記寫入可被 JavaScript 讀到的會話 cookie 中。而在後續的請求中，伺服器可以驗證這個 cookie 是否與 HTTP 頭 <code>X-XSRF-TOKEN</code> 的值一致，以確保只有執行在你自己域名下的程式碼才能發起這個請求。這個標記必須對每個使用者都是唯一的，並且必須能被伺服器驗證，因此不能由客戶端自己產生標記。把這個標記設定為你的站點認證資訊並且加了鹽（salt）的摘要，以提升安全性。</p><p translation-origin=\"off\">To take advantage of this, your server needs to set a token in a JavaScript readable session cookie called <code>XSRF-TOKEN</code> on either the page load or the first GET request.\nOn subsequent requests the server can verify that the cookie matches the <code>X-XSRF-TOKEN</code> HTTP header, and therefore be sure that only code running on your domain could have sent the request.\nThe token must be unique for each user and must be verifiable by the server; this prevents the client from making up its own tokens.\nSet the token to a digest of your site's authentication cookie with a salt for added security.</p>\n\n<p translation-result=\"on\">為了防止多個 Angular 應用共享同一個域名或子域時出現衝突，要給每個應用分配一個唯一的 cookie 名稱。</p><p translation-origin=\"off\">To prevent collisions in environments where multiple Angular apps share the same domain or subdomain, give each application a unique cookie name.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><em><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 支援的只是 XSRF 防護方案的客戶端這一半。</em> 你的後端服務必須配置為給頁面設定 cookie，並且要驗證請求頭，以確保全都是合法的請求。如果不這麼做，就會導致 Angular 的預設防護措施失效。</p><p translation-origin=\"off\"><em><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> supports only the client half of the XSRF protection scheme.</em>\nYour backend service must be configured to set the cookie for your page, and to verify that the header is present on all eligible requests.\nFailing to do so renders Angular's default protection ineffective.</p>\n\n</div>\n<h3 id=\"configuring-custom-cookieheader-names\" translation-result=\"on\">配置自訂 cookie/header 名稱<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#configuring-custom-cookieheader-names\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Configuring custom cookie/header names<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#configuring-custom-cookieheader-names\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你的後端服務中對 XSRF 標記的 cookie 或頭使用了不一樣的名字，就要使用 <code><a href=\"api/common/http/HttpClientXsrfModule#withOptions\" class=\"code-anchor\">HttpClientXsrfModule.withOptions()</a></code> 來覆蓋掉預設值。</p><p translation-origin=\"off\">If your backend service uses different names for the XSRF token cookie or header, use <code><a href=\"api/common/http/HttpClientXsrfModule#withOptions\" class=\"code-anchor\">HttpClientXsrfModule.withOptions()</a></code> to override the defaults.</p>\n\n<code-example path=\"http/src/app/app.module.ts\" region=\"xsrf\">\nimports: [\n  <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  HttpClientXsrfModule.withOptions({\n    cookieName: 'My-Xsrf-Cookie',\n    headerName: 'My-Xsrf-Header',\n  }),\n],\n\n</code-example>\n<p><a id=\"testing-requests\"></a></p>\n<h2 id=\"testing-http-requests\" translation-result=\"on\">測試 HTTP 請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#testing-http-requests\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Testing HTTP requests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#testing-http-requests\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如同所有的外部依賴一樣，你必須把 HTTP 後端也 Mock 掉，以便你的測試可以模擬這種與後端的互動。<code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing</code> 庫能讓這種 Mock 工作變得直截了當。</p><p translation-origin=\"off\">As for any external dependency, you must mock the HTTP backend so your tests can simulate interaction with a remote server.\nThe <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing</code> library makes it straightforward to set up such mocking.</p>\n\n<p translation-result=\"on\">Angular 的 HTTP 測試函式庫是專為其中的測試模式而設計的。在這種模式下，會首先在應用中執行程式碼併發起請求。然後，這個測試會期待發起或未發起過某個請求，並針對這些請求進行斷言，最終對每個所預期的請求進行重新整理（flush）來對這些請求提供響應。</p><p translation-origin=\"off\">Angular's HTTP testing library is designed for a pattern of testing in which the app executes code and makes requests first.\nThe test then expects that certain requests have or have not been made, performs assertions against those requests, and finally provides responses by \"flushing\" each expected request.</p>\n\n<p translation-result=\"on\">最終，測試可能會驗證這個應用不曾發起過非預期的請求。</p><p translation-origin=\"off\">At the end, tests can verify that the app made no unexpected requests.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你可以到線上程式設計環境中執行<live-example stackblitz=\"specs\">這些範例測試</live-example>。</p><p translation-origin=\"off\">You can run <live-example stackblitz=\"specs\">these sample tests</live-example> in a live coding environment.</p>\n\n<p translation-result=\"on\">本章所講的這些測試位於 <code>src/testing/http-client.spec.ts</code> 中。在 <code>src/app/heroes/heroes.service.spec.ts</code> 中還有一些測試，用於測試那些呼叫了 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的資料服務。</p><p translation-origin=\"off\">The tests described in this guide are in <code>src/testing/http-client.spec.ts</code>.\nThere are also tests of an application data service that call <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> in <code>src/app/heroes/heroes.service.spec.ts</code>.</p>\n\n</div>\n<h3 id=\"setup-for-testing\" translation-result=\"on\">搭建測試環境<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#setup-for-testing\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Setup for testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#setup-for-testing\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要開始測試那些透過 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 發起的請求，就要匯入 <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> 模組和模擬控制器（<code><a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a></code>）以及你測試所需的其他符號。</p><p translation-origin=\"off\">To begin testing calls to <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>, import the <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> and the mocking controller, <code><a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a></code>, along with the other symbols your tests require.</p>\n\n<code-example header=\"app/testing/http-client.spec.ts (imports)\" path=\"http/src/testing/http-client.spec.ts\" region=\"imports\">\n// Http testing module and mocking controller\nimport { <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>, <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing';\n\n// Other imports\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>, <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n\n</code-example>\n<p translation-result=\"on\">然後把 <code>HTTPClientTestingModule</code> 新增到 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 中，並繼續設定<em>被測服務</em>。</p><p translation-origin=\"off\">Then add the <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> to the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> and continue with the setup of the <em>service-under-test</em>.</p>\n\n<code-example header=\"app/testing/http-client.spec.ts(setup)\" path=\"http/src/testing/http-client.spec.ts\" region=\"setup\">\ndescribe('<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> testing', () =&gt; {\n  let httpClient: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>;\n  let httpTestingController: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({\n      imports: [ <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a> ]\n    });\n\n    // <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> the <a href=\"api/common/http\" class=\"code-anchor\">http</a> service and test controller for each test\n    httpClient = TestBed.inject(<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>);\n    httpTestingController = TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>);\n  });\n  /// Tests begin ///\n});\n\n</code-example>\n<p translation-result=\"on\">現在，在測試中發起的這些請求會發給這些測試用的後端（testing backend），而不是標準的後端。</p><p translation-origin=\"off\">Now requests made in the course of your tests hit the testing backend instead of the normal backend.</p>\n\n<p translation-result=\"on\">這種設定還會呼叫 <code>TestBed.inject()</code>，來獲取注入的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務和模擬控制器，以便在測試期間參考它們。</p><p translation-origin=\"off\">This setup also calls <code>TestBed.inject()</code> to inject the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service and the mocking controller so they can be referenced during the tests.</p>\n\n<h3 id=\"expecting-and-answering-requests\" translation-result=\"on\">期待並回復請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#expecting-and-answering-requests\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Expecting and answering requests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#expecting-and-answering-requests\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">現在，你就可以編寫測試，等待 GET 請求並給出模擬響應。</p><p translation-origin=\"off\">Now you can write a test that expects a GET Request to occur and provides a mock response.</p>\n\n<code-example header=\"app/testing/http-client.spec.ts (HttpClient.get)\" path=\"http/src/testing/http-client.spec.ts\" region=\"get-test\">\nit('can test HttpClient.get', () =&gt; {\n  const testData: <a href=\"api/router/Data\" class=\"code-anchor\">Data</a> = {name: 'Test <a href=\"api/router/Data\" class=\"code-anchor\">Data</a>'};\n\n  // Make an HTTP GET request\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>&gt;(testUrl)\n    .subscribe(data =&gt;\n      // When observable resolves, result should match test data\n      expect(data).toEqual(testData)\n    );\n\n  // The following `expectOne()` will match the request's URL.\n  // If no requests or <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> requests matched that URL\n  // `expectOne()` would throw.\n  const req = httpTestingController.expectOne('/data');\n\n  // Assert that the request is a GET.\n  expect(req.request.method).toEqual('GET');\n\n  // Respond with mock data, causing Observable to resolve.\n  // Subscribe callback asserts that correct data was returned.\n  req.flush(testData);\n\n  // Finally, assert that there are no outstanding requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<p translation-result=\"on\">最後一步，驗證沒有發起過預期之外的請求，足夠通用，因此你可以把它移到 <code>afterEach()</code> 中：</p><p translation-origin=\"off\">The last step, verifying that no requests remain outstanding, is common enough for you to move it into an <code>afterEach()</code> step:</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"afterEach\">\nafterEach(() =&gt; {\n  // After every test, assert that there are no more pending requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<h4 id=\"custom-request-expectations\" translation-result=\"on\">自訂對請求的預期<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#custom-request-expectations\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Custom request expectations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#custom-request-expectations\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">如果僅根據 URL 匹配還不夠，你還可以自行實現匹配函式。比如，你可以驗證外發的請求是否帶有某個認證頭：</p><p translation-origin=\"off\">If matching by URL isn't sufficient, it's possible to implement your own matching function.\nFor example, you could look for an outgoing request that has an authorization header:</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"predicate\">\n// Expect one request with an authorization header\nconst req = httpTestingController.expectOne(\n  request =&gt; request.headers.has('Authorization')\n);\n\n</code-example>\n<p translation-result=\"on\">像前面的 <code>expectOne()</code> 測試一樣，如果零或兩個以上的請求滿足了這個斷言，它就會丟擲例外。</p><p translation-origin=\"off\">As with the previous <code>expectOne()</code>, the test fails if 0 or 2+ requests satisfy this predicate.</p>\n\n<h4 id=\"handling-more-than-one-request\" translation-result=\"on\">處理一個以上的請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#handling-more-than-one-request\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Handling more than one request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#handling-more-than-one-request\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">如果你需要在測試中對重複的請求進行響應，可以使用 <code>match()</code> API 來代替 <code>expectOne()</code>，它的引數不變，但會返回一個與這些請求相匹配的陣列。一旦返回，這些請求就會從將來要匹配的列表中移除，你要自己驗證和重新整理（flush）它。</p><p translation-origin=\"off\">If you need to respond to duplicate requests in your test, use the <code>match()</code> API instead of <code>expectOne()</code>.\nIt takes the same arguments but returns an array of matching requests.\nOnce returned, these requests are removed from future matching and you are responsible for flushing and verifying them.</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"multi-request\">\n// get all pending requests that match the given URL\nconst requests = httpTestingController.match(testUrl);\nexpect(requests.length).toEqual(3);\n\n// Respond to each request with different results\nrequests[0].flush([]);\nrequests[1].flush([testData[0]]);\nrequests[2].flush(testData);\n\n</code-example>\n<h3 id=\"testing-for-errors\" translation-result=\"on\">測試對錯誤的預期<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#testing-for-errors\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Testing for errors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#testing-for-errors\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你還要測試應用對於 HTTP 請求失敗時的防護。</p><p translation-origin=\"off\">You should test the app's defenses against HTTP requests that fail.</p>\n\n<p translation-result=\"on\">呼叫 <code>request.flush()</code> 並傳入一個錯誤資訊，如下所示。</p><p translation-origin=\"off\">Call <code>request.flush()</code> with an error message, as seen in the following example.</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"404\">\nit('can test for 404 error', () =&gt; {\n  const emsg = 'deliberate 404 error';\n\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>[]&gt;(testUrl).subscribe({\n    next: () =&gt; fail('should have failed with the 404 error'),\n    error: (error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) =&gt; {\n      expect(error.status).withContext('status').toEqual(404);\n      expect(error.error).withContext('message').toEqual(emsg);\n    },\n  });\n\n  const req = httpTestingController.expectOne(testUrl);\n\n  // Respond with mock error\n  req.flush(emsg, { status: 404, statusText: 'Not Found' });\n});\n\n</code-example>\n<p translation-result=\"on\">另外，還可以用 <code>ProgressEvent</code> 來呼叫 <code>request.error()</code>。</p><p translation-origin=\"off\">Alternatively, call <code>request.error()</code> with a <code>ProgressEvent</code>.</p>\n\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"network-error\">\nit('can test for network error', done =&gt; {\n  // Create mock ProgressEvent with type `error`, raised when something goes wrong\n  // at network level. e.g. Connection timeout, DNS error, offline, etc.\n  const mockError = new ProgressEvent('error');\n\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>[]&gt;(testUrl).subscribe({\n    next: () =&gt; fail('should have failed with the network error'),\n    error: (error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) =&gt; {\n      expect(error.error).toBe(mockError);\n      done();\n    },\n  });\n\n  const req = httpTestingController.expectOne(testUrl);\n\n  // Respond with mock error\n  req.error(mockError);\n});\n\n</code-example>\n<h2 id=\"passing-metadata-to-interceptors\" translation-result=\"on\">將元資料傳遞給攔截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#passing-metadata-to-interceptors\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Passing metadata to interceptors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#passing-metadata-to-interceptors\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">許多攔截器都需要進行配置或從配置中受益。考慮一個重試失敗請求的攔截器。預設情況下，攔截器可能會重試請求三次，但是對於特別容易出錯或敏感的請求，你可能要改寫這個重試次數。</p><p translation-origin=\"off\">Many interceptors require or benefit from configuration.\nConsider an interceptor that retries failed requests.\nBy default, the interceptor might retry a request three times, but you might want to override this retry count for particularly error-prone or sensitive requests.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 請求包含一個<em>上下文</em>，該上下文可以攜帶有關請求的元資料。該上下文可供攔截器讀取或修改，儘管傳送請求時它並不會傳輸到後端伺服器。這允許應用程式或其他攔截器使用配置引數來標記這些請求，比如重試請求的次數。</p><p translation-origin=\"off\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> requests contain a <em>context</em> that can carry metadata about the request.\nThis context is available for interceptors to read or modify, though it is not transmitted to the backend server when the request is sent.\nThis lets applications or other interceptors tag requests with configuration parameters, such as how many times to retry a request.</p>\n\n<h3 id=\"creating-a-context-token\" translation-result=\"on\">建立上下文令牌<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#creating-a-context-token\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Creating a context token<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#creating-a-context-token\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code> 用於在上下文中儲存和檢索值。你可以用 <code>new</code> 運算子建立上下文令牌，如以下例所示：</p><p translation-origin=\"off\">Angular stores and retrieves a value in the context using an <code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code>.\nYou can create a context token using the <code>new</code> operator, as in the following example:</p>\n\n<code-example header=\"creating a context token\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"context-token\">\nexport const RETRY_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 3);\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code> 建立期間傳遞的 lambda 函式 <code>() =&gt; 3</code> 有兩個用途：</p><p translation-origin=\"off\">The lambda function <code>() =&gt; 3</code> passed during the creation of the <code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code> serves two purposes:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">它允許 TypeScript 推斷此令牌的型別：<code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>&lt;number&gt;</code>。這個請求上下文是型別安全的 —— 從請求上下文中讀取令牌將返回適當型別的值。</p><p translation-origin=\"off\">It lets TypeScript infer the type of this token:\n<code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>&lt;number&gt;</code>\nThe request context is type-safe —reading a token from a request's context returns a value of the appropriate type.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它會設定令牌的預設值。如果尚未為此令牌設定其他值，那麼這就是請求上下文返回的值。使用預設值可以避免檢查是否已設定了特定值。</p><p translation-origin=\"off\">It sets the default value for the token.\nThis is the value that the request context returns if no other value was set for this token.\nUsing a default value avoids the need to check if a particular value is set.</p>\n\n</li>\n</ol>\n<h3 id=\"setting-context-values-when-making-a-request\" translation-result=\"on\">在發起請求時設定上下文值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#setting-context-values-when-making-a-request\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Setting context values when making a request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#setting-context-values-when-making-a-request\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">發出請求時，你可以提供一個 <code><a href=\"api/common/http/HttpContext\" class=\"code-anchor\">HttpContext</a></code> 例項，在該例項中你已經設定了一些上下文值。</p><p translation-origin=\"off\">When making a request, you can provide an <code><a href=\"api/common/http/HttpContext\" class=\"code-anchor\">HttpContext</a></code> instance, in which you have already set the context values.</p>\n\n<code-example header=\"setting context values\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"set-context\">\nthis.httpClient\n    .get('/data/feed', {\n      context: new <a href=\"api/common/http/HttpContext\" class=\"code-anchor\">HttpContext</a>().set(RETRY_COUNT, 5),\n    })\n    .subscribe(results =&gt; {/* ... */});\n\n</code-example>\n<h3 id=\"reading-context-values-in-an-interceptor\" translation-result=\"on\">在攔截器中讀取上下文值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#reading-context-values-in-an-interceptor\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Reading context values in an interceptor<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#reading-context-values-in-an-interceptor\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpContext#get\" class=\"code-anchor\">HttpContext.get()</a></code> 在給定請求的上下文中讀取令牌的值。如果尚未顯式設定令牌的值，則 Angular 將返回標記中指定的預設值。</p><p translation-origin=\"off\">Within an interceptor, you can read the value of a token in a given request's context with <code><a href=\"api/common/http/HttpContext#get\" class=\"code-anchor\">HttpContext.get()</a></code>.\nIf you have not explicitly set a value for the token, Angular returns the default value specified in the token.</p>\n\n<code-example header=\"reading context values in an interceptor\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"reading-context\">\nimport {retry} from 'rxjs';\n\nexport class RetryInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    const retryCount = req.context.get(RETRY_COUNT);\n\n    return next.handle(req).pipe(\n        // Retry the request a configurable number of times.\n        retry(retryCount),\n    );\n  }\n}\n\n</code-example>\n<h3 id=\"contexts-are-mutable\" translation-result=\"on\">上下文是可變的（Mutable）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#contexts-are-mutable\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Contexts are mutable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#contexts-are-mutable\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">與 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 例項的大多數其他方面不同，請求上下文是可變的，並且在請求的其他不可變轉換過程中仍然存在。這允許攔截器透過此上下文協調來操作。比如，<code>RetryInterceptor</code> 範例可以使用第二個上下文令牌來追蹤在執行給定請求期間發生過多少錯誤：</p><p translation-origin=\"off\">Unlike most other aspects of <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> instances, the request context is mutable and persists across other immutable transformations of the request.\nThis lets interceptors coordinate operations through the context.\nFor instance, the <code>RetryInterceptor</code> example could use a second context token to track how many errors occur during the execution of a given request:</p>\n\n<code-example header=\"coordinating operations through the context\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"mutable-context\">\nimport {retry, tap} from 'rxjs/operators';\nexport const RETRY_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 3);\nexport const ERROR_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 0);\n\nexport class RetryInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    const retryCount = req.context.get(RETRY_COUNT);\n\n    return next.handle(req).pipe(\n        tap({\n              // An error has occurred, so increment this request's ERROR_COUNT.\n             error: () =&gt; req.context.set(ERROR_COUNT, req.context.get(ERROR_COUNT) + 1)\n            }),\n        // Retry the request a configurable number of times.\n        retry(retryCount),\n    );\n  }\n}\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpHandlerFn\n - api/common/http/HttpInterceptor\n - guide/architecture-next-steps\n - guide/developer-guide-overview\n - guide/docs-style-guide\n - guide/example-apps-list\n - guide/npm-packages\n - guide/pipes\n - guide/security\n - guide/testing-components-scenarios\n - guide/testing-services\n - guide/what-is-angular\n - start/start-data\n - tutorial/tour-of-heroes/toh-pt4\n-->\n<!-- links from this doc:\n - api/common/AsyncPipe\n - api/common/NgFor\n - api/common/http\n - api/common/http/HTTP_INTERCEPTORS\n - api/common/http/HttpBackend\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpClient#post\n - api/common/http/HttpClient#put\n - api/common/http/HttpClient#request\n - api/common/http/HttpClientJsonpModule\n - api/common/http/HttpClientModule\n - api/common/http/HttpClientXsrfModule#withOptions\n - api/common/http/HttpContext\n - api/common/http/HttpContext#get\n - api/common/http/HttpContextToken\n - api/common/http/HttpErrorResponse\n - api/common/http/HttpEvent\n - api/common/http/HttpEventType#Response\n - api/common/http/HttpEventType#Sent\n - api/common/http/HttpEventType#UploadProgress\n - api/common/http/HttpHandler\n - api/common/http/HttpHeaders\n - api/common/http/HttpInterceptor\n - api/common/http/HttpParams\n - api/common/http/HttpRequest\n - api/common/http/HttpResponse\n - api/common/http/testing/HttpClientTestingModule\n - api/common/http/testing/HttpTestingController\n - api/core/Inject\n - api/core/Injectable\n - api/core/NgModule\n - api/core/testing/TestBed\n - api/forms/SelectMultipleControlValueAccessor\n - api/platform-browser/BrowserModule\n - api/router/Data\n - api/router/Event\n - guide/architecture\n - guide/dependency-injection\n - guide/glossary#observable\n - guide/glossary#service\n - guide/http#adding-and-updating-headers\n - guide/http#adding-headers\n - guide/http#always-subscribe\n - guide/http#cache-refresh\n - guide/http#caching\n - guide/http#caching-requests\n - guide/http#clearing-the-request-body-in-a-clone\n - guide/http#communicating-with-backend-services-using-http\n - guide/http#config-service\n - guide/http#configuring-custom-cookieheader-names\n - guide/http#configuring-http-url-parameters\n - guide/http#contexts-are-mutable\n - guide/http#creating-a-context-token\n - guide/http#custom-json-parsing\n - guide/http#custom-request-expectations\n - guide/http#error-details\n - guide/http#error-handling\n - guide/http#expecting-and-answering-requests\n - guide/http#getting-error-details\n - guide/http#handling-interceptor-events\n - guide/http#handling-more-than-one-request\n - guide/http#handling-request-errors\n - guide/http#http-interceptor-use-cases\n - guide/http#http-攔截器使用案例\n - guide/http#intercepting-requests-and-responses\n - guide/http#interceptor-events\n - guide/http#interceptor-order\n - guide/http#logging-request-and-response-pairs\n - guide/http#making-a-delete-request\n - guide/http#making-a-jsonp-request\n - guide/http#making-a-post-request\n - guide/http#making-a-put-request\n - guide/http#modifying-a-request-body\n - guide/http#next-物件\n - guide/http#optimizing-server-interaction-with-debouncing\n - guide/http#passing-metadata-to-interceptors\n - guide/http#prerequisites\n - guide/http#provide-the-interceptor\n - guide/http#reading-context-values-in-an-interceptor\n - guide/http#reading-the-full-response\n - guide/http#report-progress\n - guide/http#requesting-a-typed-response\n - guide/http#requesting-data-from-a-server\n - guide/http#requesting-non-json-data\n - guide/http#retry\n - guide/http#retrying-a-failed-request\n - guide/http#security-xsrf-protection\n - guide/http#send-request\n - guide/http#sending-data-to-a-server\n - guide/http#setting-context-values-when-making-a-request\n - guide/http#setting-default-headers\n - guide/http#setup-for-server-communication\n - guide/http#setup-for-testing\n - guide/http#starting-the-request\n - guide/http#testing-for-errors\n - guide/http#testing-http-requests\n - guide/http#testing-requests\n - guide/http#the-next-object\n - guide/http#tracking-and-showing-request-progress\n - guide/http#typed-response\n - guide/http#updating-headers\n - guide/http#url-params\n - guide/http#using-interceptors-to-request-multiple-values\n - guide/http#using-the-switchmap-operator\n - guide/http#write-an-interceptor\n - guide/http#上下文是可變的mutable\n - guide/http#從伺服器請求資料\n - guide/http#使用-http-與後端服務進行通訊\n - guide/http#使用-switchmap-運運算元\n - guide/http#修改請求體\n - guide/http#複製時清除請求體\n - guide/http#建立上下文令牌\n - guide/http#前提條件\n - guide/http#發起-delete-請求\n - guide/http#發起-jsonp-請求\n - guide/http#發起-put-請求\n - guide/http#發起一個-post-請求\n - guide/http#啟動請求\n - guide/http#在發起請求時設定上下文值\n - guide/http#在攔截器中讀取上下文值\n - guide/http#處理一個以上的請求\n - guide/http#處理攔截器事件\n - guide/http#處理請求錯誤\n - guide/http#安全xsrf-防護\n - guide/http#將元資料傳遞給攔截器\n - guide/http#把資料傳送到伺服器\n - guide/http#攔截器的順序\n - guide/http#攔截請求和響應\n - guide/http#提供這個攔截器\n - guide/http#搭建測試環境\n - guide/http#更新請求頭\n - guide/http#伺服器通訊的準備工作\n - guide/http#期待並回復請求\n - guide/http#測試-http-請求\n - guide/http#測試對錯誤的預期\n - guide/http#新增和更新請求頭\n - guide/http#新增請求頭\n - guide/http#用攔截器實現快取\n - guide/http#用攔截器來請求多個值\n - guide/http#編寫攔截器\n - guide/http#自訂-json-解析\n - guide/http#自訂對請求的預期\n - guide/http#獲取錯誤詳情\n - guide/http#記錄請求與響應對\n - guide/http#設定預設請求頭\n - guide/http#請求輸入一個類別型的響應\n - guide/http#請求非-json-資料\n - guide/http#讀取完整的回應內文\n - guide/http#追蹤和顯示請求進度\n - guide/http#透過防抖來最佳化與伺服器的互動\n - guide/http#配置-http-url-引數\n - guide/http#配置自訂-cookieheader-名稱\n - guide/http#重試失敗的請求\n - guide/observables\n - guide/pipes\n - guide/rx-library\n - guide/rx-library#operators\n - https://developer.mozilla.org/docs/Web/HTTP/CORS\n - https://en.wikipedia.org/wiki/Cross-site_request_forgery\n - https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token\n - https://en.wikipedia.org/wiki/JSONP\n - https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http.md?message=docs%3A%20請簡述你的修改...\n-->"}