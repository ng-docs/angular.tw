{"id":"guide/router-tutorial-toh","title":"Router tutorial: tour of heroes","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/router-tutorial-toh.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <p><a id=\"router-tutorial\"></a></p>\n<h1 id=\"router-tutorial-tour-of-heroes\" translation-result=\"on\">路由器課程：英雄之旅<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#router-tutorial-tour-of-heroes\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Router tutorial: tour of heroes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#router-tutorial-tour-of-heroes\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本課程提供了關於 Angular 路由器的概要性概述。在本課程中，你將基於基本的路由器配置來探索諸如子路由、路由引數、延遲載入 NgModule、路由守衛和預載入資料等功能，以改善使用者體驗。</p><p translation-origin=\"off\">This tutorial provides an extensive overview of the Angular router.\nIn this tutorial, you build upon a basic router configuration to explore features such as child routes, route parameters, lazy load NgModules, guard routes, and preloading data to improve the user experience.</p>\n\n<p translation-result=\"on\">有關該應用最終版本的有效範例，請參閱<live-example name=\"router\"></live-example>。</p><p translation-origin=\"off\">For a working example of the final version of the app, see the <live-example name=\"router\"></live-example>.</p>\n\n<p><a id=\"router-tutorial-objectives\"></a></p>\n<h2 id=\"objectives\" translation-result=\"on\">目標<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#objectives\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Objectives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#objectives\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本指南描述了一個多頁路由範例應用程式的開發過程。在此過程中，它重點介紹了路由器的關鍵特性，比如：</p><p translation-origin=\"off\">This guide describes development of a multi-page routed sample application.\nAlong the way, it highlights key features of the router such as:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">將應用程式功能組織到模組中</p><p translation-origin=\"off\">Organizing the application features into modules</p>\n\n</li>\n<li>\n<p translation-result=\"on\">導航到元件（從 <em>Heroes</em> 連結導航到“英雄列表”）</p><p translation-origin=\"off\">Navigating to a component (<em>Heroes</em> link to \"Heroes List\")</p>\n\n</li>\n<li>\n<p translation-result=\"on\">包括一個路由引數（在路由到“英雄詳細資訊”時傳入英雄的 <code>id</code>）</p><p translation-origin=\"off\">Including a route parameter (passing the Hero <code>id</code> while routing to the \"Hero Detail\")</p>\n\n</li>\n<li>\n<p translation-result=\"on\">子路由（<em>危機中心</em>特性區有自己的路由）</p><p translation-origin=\"off\">Child routes (the <em>Crisis Center</em> has its own routes)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>canActivate</code> 守衛（檢查路由存取）</p><p translation-origin=\"off\">The <code>canActivate</code> guard (checking route access)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>canActivateChild</code> 守衛（檢查子路由存取）</p><p translation-origin=\"off\">The <code>canActivateChild</code> guard (checking child route access)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>canDeactivate</code> 守衛（在放棄未儲存的更改之前請求許可）</p><p translation-origin=\"off\">The <code>canDeactivate</code> guard (ask permission to discard unsaved changes)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>resolve</code> 守衛（預先獲取路由資料）。</p><p translation-origin=\"off\">The <code>resolve</code> guard (pre-fetching route data)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">延遲載入 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code></p><p translation-origin=\"off\">Lazy loading an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>canMatch</code> 守衛（在載入功能模組的檔案之前檢查）</p><p translation-origin=\"off\">The <code>canMatch</code> guard (check before loading feature module assets)</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">本指南按照里程碑的順序進行，就像你逐步建構應用程式一樣，但這裡假定你已經熟悉 <a href=\"guide/architecture\">Angular 的</a>基本概念。關於 Angular 的一般性介紹，請參見<a href=\"start\">《入門指南》</a>。關於更深入的概述，請參見<a href=\"tutorial/tour-of-heroes\">《英雄之旅》</a>課程。</p><p translation-origin=\"off\">This guide proceeds as a sequence of milestones as if you were building the application step-by-step, but assumes you are familiar with basic <a href=\"guide/architecture\">Angular concepts</a>.\nFor a general introduction to angular, see the <a href=\"start\">Getting Started</a>.\nFor a more in-depth overview, see the <a href=\"tutorial/tour-of-heroes\">Tour of Heroes</a> tutorial.</p>\n\n<h2 id=\"prerequisites\" translation-result=\"on\">前提條件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#prerequisites\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Prerequisites<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要完成本課程，你應該對以下概念有基本的瞭解：</p><p translation-origin=\"off\">To complete this tutorial, you should have a basic understanding of the following concepts:</p>\n\n<ul>\n<li>\n<p>JavaScript</p>\n</li>\n<li>\n<p>HTML</p>\n</li>\n<li>\n<p>CSS</p>\n</li>\n<li>\n<p><a href=\"cli\">Angular CLI</a></p>\n</li>\n</ul>\n<p translation-result=\"on\">你可能會發現<a href=\"tutorial/tour-of-heroes\">《英雄之旅》課程</a>很有用，但這不是必需的。</p><p translation-origin=\"off\">You might find the <a href=\"tutorial/tour-of-heroes\">Tour of Heroes tutorial</a> helpful, but it is not required.</p>\n\n<h2 id=\"the-sample-application-in-action\" translation-result=\"on\">範例應用實戰<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#the-sample-application-in-action\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">The sample application in action<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#the-sample-application-in-action\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本課程的範例應用會幫助“英雄僱傭管理局”找到需要各位英雄去解決的危機。</p><p translation-origin=\"off\">The sample application for this tutorial helps the Hero Employment Agency find crises for heroes to solve.</p>\n\n<p translation-result=\"on\">本應用有三個主要的特性區：</p><p translation-origin=\"off\">The application has three main feature areas:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\"><em>危機中心</em>，用於維護要指派給英雄的危機列表。</p><p translation-origin=\"off\">A <em>Crisis Center</em> for maintaining the list of crises for assignment to heroes.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><em>英雄</em>特性區，用於維護管理局僱傭的英雄列表。</p><p translation-origin=\"off\">A <em>Heroes</em> area for maintaining the list of heroes employed by the agency.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><em>管理</em>特性區會管理危機和英雄的列表。</p><p translation-origin=\"off\">An <em>Admin</em> area to manage the list of crises and heroes.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">點選<live-example name=\"router\" title=\"英雄職介中心的現場演練\">到線上例子的連結</live-example>試用一下。</p><p translation-origin=\"off\">Try it by clicking on this <live-example name=\"router\" title=\"Hero Employment Agency Live Example\">live example link</live-example>.</p>\n\n<p translation-result=\"on\">該應用會渲染出一排導航按鈕和和一個<em>英雄列表</em>檢視。</p><p translation-origin=\"off\">The application renders with a row of navigation buttons and the <em>Heroes</em> view with its list of heroes.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Example application with a row of navigation buttons and a list of heroes\" src=\"generated/images/guide/router/hero-list.gif\" width=\"400\" height=\"512\">\n</div>\n<p translation-result=\"on\">選擇其中之一，該應用就會把你帶到此英雄的編輯頁面。</p><p translation-origin=\"off\">Select one hero and the application takes you to a hero editing screen.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Detail view of hero with additional information, input, and back button\" src=\"generated/images/guide/router/hero-detail.png\" width=\"400\" height=\"278\">\n</div>\n<p translation-result=\"on\">修改完名字，再點選“後退”按鈕，應用又回到了英雄列表頁，其中顯示的英雄名已經變了。注意，對名字的修改會立即生效。</p><p translation-origin=\"off\">Alter the name.\nClick the \"Back\" button and the application returns to the heroes list which displays the changed hero name.\nNotice that the name change took effect immediately.</p>\n\n<p translation-result=\"on\">另外你也可以點選瀏覽器本身的後退按鈕（而不是應用中的 “Back” 按鈕），這也同樣會回到英雄列表頁。在 Angular 應用中導航也會和標準的 Web 導航一樣更新瀏覽器中的歷史。</p><p translation-origin=\"off\">Had you clicked the browser's back button instead of the application's \"Back\" button, the application would have returned you to the heroes list as well.\nAngular application navigation updates the browser history as normal web navigation does.</p>\n\n<p translation-result=\"on\">現在，點選<em>危機中心</em>連結，前往<em>危機</em>列表頁。</p><p translation-origin=\"off\">Now click the <em>Crisis Center</em> link for a list of ongoing crises.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Crisis Center list of crises\" src=\"generated/images/guide/router/crisis-center-list.gif\" width=\"391\" height=\"240\">\n</div>\n<p translation-result=\"on\">選擇其中之一，該應用就會把你帶到此危機的編輯頁面。<em>危機詳情</em>是當前頁的子元件，就在列表的緊下方。</p><p translation-origin=\"off\">Select a crisis and the application takes you to a crisis editing screen.\nThe <em>Crisis Detail</em> appears in a child component on the same page, beneath the list.</p>\n\n<p translation-result=\"on\">修改危機的名稱。注意，危機列表中的相應名稱<strong>並沒有</strong>修改。</p><p translation-origin=\"off\">Alter the name of a crisis.\nNotice that the corresponding name in the crisis list does <em>not</em> change.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Crisis Center detail of a crisis with data, an input, and save and cancel buttons.\" src=\"generated/images/guide/router/crisis-center-detail.gif\" width=\"388\" height=\"378\">\n</div>\n<p translation-result=\"on\">這和<em>英雄詳情</em>頁略有不同。<em>英雄詳情</em>會立即儲存你所做的更改。而<em>危機詳情</em>頁中，你的更改都是臨時的 —— 除非按“儲存”按鈕儲存它們，或者按“取消”按鈕放棄它們。這兩個按鈕都會導航回<em>危機中心</em>，顯示危機列表。</p><p translation-origin=\"off\">Unlike <em>Hero Detail</em>, which updates as you type, <em>Crisis Detail</em> changes are temporary until you either save or discard them by pressing the \"Save\" or \"Cancel\" buttons.\nBoth buttons navigate back to the <em>Crisis Center</em> and its list of crises.</p>\n\n<p translation-result=\"on\">單擊瀏覽器後退按鈕或 “Heroes” 連結，可以啟用一個對話方塊。</p><p translation-origin=\"off\">Click the browser back button or the \"Heroes\" link to activate a dialog.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Alert that asks user to confirm discarding changes\" src=\"generated/images/guide/router/confirm-dialog.png\" width=\"250\" height=\"101\">\n</div>\n<p translation-result=\"on\">你可以回答“確定”以放棄這些更改，或者回答“取消”來繼續編輯。</p><p translation-origin=\"off\">You can say \"OK\" and lose your changes or click \"Cancel\" and continue editing.</p>\n\n<p translation-result=\"on\">這種行為的幕後是路由器的 <code>canDeactivate</code> 守衛。該守衛讓你有機會進行清理工作或在離開當前檢視之前請求使用者的許可。</p><p translation-origin=\"off\">Behind this behavior is the router's <code>canDeactivate</code> guard.\nThe guard gives you a chance to clean up or ask the user's permission before navigating away from the current view.</p>\n\n<p translation-result=\"on\"><code>Admin</code> 和 <code>Login</code> 按鈕用於示範路由器的其它能力，本章稍後的部分會講解它們。</p><p translation-origin=\"off\">The <code>Admin</code> and <code>Login</code> buttons illustrate other router capabilities covered later in the guide.</p>\n\n<p><a id=\"getting-started\"></a></p>\n<h2 id=\"milestone-1-getting-started\" translation-result=\"on\">里程碑 1：起步<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-1-getting-started\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Milestone 1: Getting started<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-1-getting-started\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">開始本應用的一個簡版，它在兩個空路由之間導航。</p><p translation-origin=\"off\">Begin with a basic version of the application that navigates between two empty views.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Animated image of application with a Crisis Center button and a Heroes button. The pointer clicks each button to show a view for each.\" src=\"generated/images/guide/router/router-1-anim.gif\" width=\"320\" height=\"128\">\n</div>\n<p><a id=\"import\"></a></p>\n<h3 id=\"create-a-sample-application\" translation-result=\"on\">建立一個範例應用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#create-a-sample-application\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Create a sample application<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#create-a-sample-application\"><i class=\"material-icons\">link</i></a></h3>\n\n<ol>\n<li>\n<p translation-result=\"on\">建立一個新的 Angular 專案 <em>angular-router-tour-of-heroes</em>。</p><p translation-origin=\"off\">Create a new Angular project, <em>angular-router-tour-of-heroes</em>.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n ng new angular-router-tour-of-heroes\n</code-example>\n<p translation-result=\"on\">當系統提示 <code>Would you like to add Angular routing?</code> 時，選擇 <code>N</code>。</p><p translation-origin=\"off\">When prompted with <code>Would you like to add Angular routing?</code>, select <code>N</code>.</p>\n\n<p translation-result=\"on\">當系統提示 <code>Which stylesheet format would you like to use?</code> 時，選擇 <code>CSS</code>。</p><p translation-origin=\"off\">When prompted with <code>Which stylesheet format would you like to use?</code>, select <code>CSS</code>.</p>\n\n<p translation-result=\"on\">片刻之後，一個新專案 <code>angular-router-tour-of-heroes</code> 已準備就緒。</p><p translation-origin=\"off\">After a few moments, a new project, <code>angular-router-tour-of-heroes</code>, is ready.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">從你的終端，導航到 <code>angular-router-tour-of-heroes</code> 目錄。</p><p translation-origin=\"off\">From your terminal, navigate to the <code>angular-router-tour-of-heroes</code> directory.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">執行 <code>ng serve</code> 來驗證新應用是否正常執行。</p><p translation-origin=\"off\">Verify that your new application runs as expected by running the <code>ng serve</code> command.</p>\n\n<code-example language=\"sh\">\n ng serve\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">開啟瀏覽器存取 <code>http://localhost:4200</code>。</p><p translation-origin=\"off\">Open a browser to <code>http://localhost:4200</code>.</p>\n\n<p translation-result=\"on\">你會發現本應用正執行在瀏覽器中。</p><p translation-origin=\"off\">You should see the application running in your browser.</p>\n\n</li>\n</ol>\n<h3 id=\"define-routes\" translation-result=\"on\">定義路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#define-routes\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Define Routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#define-routes\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">路由器必須用“路由定義”的列表進行配置。</p><p translation-origin=\"off\">A router must be configured with a list of route definitions.</p>\n\n<p translation-result=\"on\">每個定義都被翻譯成了一個<a href=\"api/router/Route\">Route</a>物件。該物件有一個 <code>path</code> 欄位，表示該路由中的 URL 路徑部分，和一個 <code>component</code> 欄位，表示與該路由相關聯的元件。</p><p translation-origin=\"off\">Each definition translates to a <a href=\"api/router/Route\">Route</a> object which has two things: a <code>path</code>, the URL path segment for this route; and a <code>component</code>, the component associated with this route.</p>\n\n<p translation-result=\"on\">當瀏覽器的 URL 變化時或在程式碼中告訴路由器導航到一個路徑時，路由器就會翻出它用來儲存這些路由定義的登錄檔。</p><p translation-origin=\"off\">The router draws upon its registry of definitions when the browser URL changes or when application code tells the router to navigate along a route path.</p>\n\n<p translation-result=\"on\">第一個路由執行以下操作：</p><p translation-origin=\"off\">The first route does the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">當瀏覽器位址列的 URL 變化時，如果它匹配上了路徑部分 <code>/crisis-center</code>，路由器就會啟用一個 <code>CrisisListComponent</code> 的例項，並顯示它的檢視。</p><p translation-origin=\"off\">When the browser's location URL changes to match the path segment <code>/crisis-center</code>, then the router activates an instance of the <code>CrisisListComponent</code> and displays its view</p>\n\n</li>\n<li>\n<p translation-result=\"on\">當應用程式請求導航到路徑 <code>/crisis-center</code> 時，路由器啟用一個 <code>CrisisListComponent</code> 的例項，顯示它的檢視，並將該路徑更新到瀏覽器位址列和歷史。</p><p translation-origin=\"off\">When the application requests navigation to the path <code>/crisis-center</code>, the router activates an instance of <code>CrisisListComponent</code>, displays its view, and updates the browser's address location and history with the URL for that path</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">第一個配置定義了由兩個路由構成的陣列，它們用最短路徑指向了 <code>CrisisListComponent</code> 和 <code>HeroListComponent</code>。</p><p translation-origin=\"off\">The first configuration defines an array of two routes with minimal paths leading to the <code>CrisisListComponent</code> and <code>HeroListComponent</code>.</p>\n\n<p translation-result=\"on\">產生 <code>CrisisList</code> 和 <code>HeroList</code> 元件，以便路由器能夠渲染它們。</p><p translation-origin=\"off\">Generate the <code>CrisisList</code> and <code>HeroList</code> components so that the router has something to render.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component crisis-list\n\n</code-example>\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component hero-list\n\n</code-example>\n<p translation-result=\"on\">把每個元件的內容都替換成下列範例 HTML。</p><p translation-origin=\"off\">Replace the contents of each component with the following sample HTML.</p>\n\n<code-tabs>\n    <code-pane header=\"src/app/crisis-list/crisis-list.component.html\" path=\"router/src/app/crisis-list/crisis-list.component.1.html\">\n&lt;h2&gt;CRISIS CENTER&lt;/h2&gt;\n&lt;p&gt;Get your crisis here&lt;/p&gt;\n\n\n</code-pane>\n    <code-pane header=\"src/app/hero-list/hero-list.component.html\" path=\"router/src/app/hero-list/hero-list.component.1.html\" region=\"template\">\n&lt;h2&gt;HEROES&lt;/h2&gt;\n&lt;p&gt;Get your heroes here&lt;/p&gt;\n\n\n</code-pane>\n</code-tabs>\n<h3 id=\"register-router-and-routes\" translation-result=\"on\">註冊 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 和 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#註冊-router-和-routes\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Register <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> and <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#register-router-and-routes\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">為了使用 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>，你必須註冊來自 <code>@angular/router</code> 套件中的 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>。定義一個路由陣列 <code>appRoutes</code>，並把它傳給 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 方法。<code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 方法會返回一個模組，其中包含配置好的 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 服務提供者，以及路由庫所需的其它提供者。一旦啟動了應用，<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 就會根據當前的瀏覽器 URL 進行首次導航。</p><p translation-origin=\"off\">To use the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>, you must first register the <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> from the <code>@angular/router</code> package.\nDefine an array of routes, <code>appRoutes</code>, and pass them to the <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> method.\nThe <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> method returns a module that contains the configured <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> service provider, plus other providers that the routing library requires.\nOnce the application is bootstrapped, the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> performs the initial navigation based on the current browser URL.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n<code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 方法是用於註冊全應用級提供者的編碼模式。要詳細瞭解全應用級提供者，參見<a href=\"guide/singleton-services#forRoot-router\">單例服務</a> 一章。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThe <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> method is a pattern used to register application-wide providers. Read more about application-wide providers in the <a href=\"guide/singleton-services#forRoot-router\">Singleton services</a> guide.</p>\n\n</div>\n<code-example header=\"src/app/app.module.ts (first-config)\" path=\"router/src/app/app.module.1.ts\" region=\"first-config\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { AppComponent } from './app.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { HeroListComponent } from './hero-list/hero-list.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'heroes', component: HeroListComponent },\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &lt;-- debugging purposes only\n    )\n  ],\n  declarations: [\n    AppComponent,\n    HeroListComponent,\n    CrisisListComponent,\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">對於最小化的路由配置，把配置好的 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 新增到 <code>AppModule</code> 中就足夠了。但是，隨著應用的成長，你將需要<a href=\"guide/router-tutorial-toh#refactor-the-routing-configuration-into-a-routing-module\">將路由配置重構</a>到單獨的檔案中，並建立<a href=\"guide/router-tutorial-toh#routing-module\">路由模組</a>，路由模組是一種特殊的、專做路由的<strong>服務模組</strong>。</p><p translation-origin=\"off\">Adding the configured <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> to the <code>AppModule</code> is sufficient for minimal route configurations.\nHowever, as the application grows, <a href=\"guide/router-tutorial-toh#refactor-the-routing-configuration-into-a-routing-module\">refactor the routing configuration</a> into a separate file and create a <a href=\"guide/router-tutorial-toh#routing-module\">Routing Module</a>.\nA routing module is a special type of <code>Service Module</code> dedicated to routing.</p>\n\n</div>\n<p translation-result=\"on\">把 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 註冊到 <code>AppModule</code> 的 <code>imports</code> 陣列中，能讓該 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 服務在應用的任何地方都能使用。</p><p translation-origin=\"off\">Registering the <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> in the <code>AppModule</code> <code>imports</code> array makes the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> service available everywhere in the application.</p>\n\n<p><a id=\"shell\"></a></p>\n<h3 id=\"add-the-router-outlet\" translation-result=\"on\">新增路由出口<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#add-the-router-outlet\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Add the Router Outlet<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#add-the-router-outlet\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">根元件 <code>AppComponent</code> 是本應用的殼。它在頂部有一個標題、一個帶兩個連結的導覽列，在底部有一個<em>路由器出口</em>，路由器會在它所指定的位置上渲染各個元件。</p><p translation-origin=\"off\">The root <code>AppComponent</code> is the application shell.\nIt has a title, a navigation bar with two links, and a router outlet where the router renders components.</p>\n\n<div class=\"lightbox\">\n<img alt=\"A nav, made of two navigation buttons, with the first button active and its associated view displayed\" src=\"generated/images/guide/router/shell-and-outlet.gif\" width=\"581\" height=\"161\">\n</div>\n<p translation-result=\"on\">路由出口扮演一個佔位符的角色，表示路由元件將會渲染到哪裡。</p><p translation-origin=\"off\">The router outlet serves as a placeholder where the routed components are rendered.</p>\n\n<p><a id=\"shell-template\"></a></p>\n<p translation-result=\"on\">該元件所對應的範本是這樣的：</p><p translation-origin=\"off\">The corresponding component template looks like this:</p>\n\n<code-example header=\"src/app/app.component.html\" path=\"router/src/app/app.component.1.html\">\n&lt;h1&gt;Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Crisis Center&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Heroes&lt;/a&gt;\n&lt;/nav&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n</code-example>\n<p><a id=\"wildcard\"></a></p>\n<h3 id=\"define-a-wildcard-route\" translation-result=\"on\">定義萬用字元路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#define-a-wildcard-route\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Define a Wildcard route<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#define-a-wildcard-route\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你以前在應用中建立過兩個路由，一個是 <code>/crisis-center</code>，另一個是 <code>/heroes</code>。所有其它 URL 都會導致路由器丟擲錯誤，並讓應用崩潰。</p><p translation-origin=\"off\">You've created two routes in the application so far, one to <code>/crisis-center</code> and the other to <code>/heroes</code>.\nAny other URL causes the router to throw an error and crash the app.</p>\n\n<p translation-result=\"on\">可以新增一個萬用字元路由來攔截所有無效的 URL，並優雅的處理它們。\n萬用字元路由的 <code>path</code> 是兩個星號（<code>**</code>），它會匹配任何 URL。\n而當路由器匹配不上以前定義的那些路由時，它就會選擇這個萬用字元路由。\n萬用字元路由可以導航到自訂的“404 Not Found”元件，也可以<a href=\"guide/router-tutorial-toh#redirect\">重新導向</a>到一個現有路由。</p><p translation-origin=\"off\">Add a wildcard route to intercept invalid URLs and handle them gracefully.\nA wildcard route has a path consisting of two asterisks.\nIt matches every URL.\nThus, the router selects this wildcard route if it can't match a route earlier in the configuration.\nA wildcard route can navigate to a custom \"404 Not Found\" component or <a href=\"guide/router-tutorial-toh#redirect\">redirect</a> to an existing route.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">路由器會使用<a href=\"guide/router-reference#example-config\">先到先得</a>的策略來選擇路由。由於萬用字元路由是最不具體的那個，因此務必確保它是路由配置中的<em>最後一個</em>路由。</p><p translation-origin=\"off\">The router selects the route with a <a href=\"guide/router-reference#example-config\"><em>first match wins</em></a> strategy.\nBecause a wildcard route is the least specific route, place it last in the route configuration.</p>\n\n</div>\n<p translation-result=\"on\">要測試本特性，請往 <code>HeroListComponent</code> 的範本中新增一個帶 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 的按鈕，並且把它的連結設定為一個不存在的路由 <code>\"/sidekicks\"</code>。</p><p translation-origin=\"off\">To test this feature, add a button with a <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> to the <code>HeroListComponent</code> template and set the link to a non-existent route called <code>\"/sidekicks\"</code>.</p>\n\n<code-example header=\"src/app/hero-list/hero-list.component.html (excerpt)\" path=\"router/src/app/hero-list/hero-list.component.1.html\">\n&lt;h2&gt;HEROES&lt;/h2&gt;\n&lt;p&gt;Get your heroes here&lt;/p&gt;\n\n&lt;button type=\"button\" <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/sidekicks\"&gt;Go to sidekicks&lt;/button&gt;\n\n\n</code-example>\n<p translation-result=\"on\">當用戶點選該按鈕時，應用就會失敗，因為你尚未定義過 <code>\"/sidekicks\"</code> 路由。</p><p translation-origin=\"off\">The application fails if the user clicks that button because you haven't defined a <code>\"/sidekicks\"</code> route yet.</p>\n\n<p translation-result=\"on\">不要新增 <code>\"/sidekicks\"</code> 路由，而是定義一個“萬用字元”路由，讓它導航到 <code>PageNotFoundComponent</code> 元件。</p><p translation-origin=\"off\">Instead of adding the <code>\"/sidekicks\"</code> route, define a <code>wildcard</code> route and have it navigate to a <code>PageNotFoundComponent</code>.</p>\n\n<code-example header=\"src/app/app.module.ts (wildcard)\" path=\"router/src/app/app.module.1.ts\" region=\"wildcard\">\n{ path: '**', component: PageNotFoundComponent }\n\n</code-example>\n<p translation-result=\"on\">建立 <code>PageNotFoundComponent</code>，以便在使用者存取無效網址時顯示它。</p><p translation-origin=\"off\">Create the <code>PageNotFoundComponent</code> to display when users visit invalid URLs.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component page-not-found\n\n</code-example>\n<code-example header=\"src/app/page-not-found.component.html (404 component)\" path=\"router/src/app/page-not-found/page-not-found.component.html\">\n&lt;h2&gt;Page not found&lt;/h2&gt;\n\n</code-example>\n<p translation-result=\"on\">現在，當用戶存取 <code>/sidekicks</code> 或任何無效的 URL 時，瀏覽器就會顯示“Page not found”。瀏覽器的位址列仍指向無效的 URL。</p><p translation-origin=\"off\">Now when the user visits <code>/sidekicks</code>, or any other invalid URL, the browser displays \"Page not found\".\nThe browser address bar continues to point to the invalid URL.</p>\n\n<p><a id=\"redirect\"></a></p>\n<h3 id=\"set-up-redirects\" translation-result=\"on\">設定跳轉<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#set-up-redirects\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Set up redirects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#set-up-redirects\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">應用啟動時，瀏覽器位址列中的初始 URL 預設是這樣的：</p><p translation-origin=\"off\">When the application launches, the initial URL in the browser bar is by default:</p>\n\n<code-example format=\"http\" language=\"http\">\n\nlocalhost:4200\n\n</code-example>\n<p translation-result=\"on\">它不能匹配上任何硬編碼進來的路由，於是就會走到萬用字元路由中去，並且顯示 <code>PageNotFoundComponent</code>。</p><p translation-origin=\"off\">That doesn't match any of the hard-coded routes which means the router falls through to the wildcard route and displays the <code>PageNotFoundComponent</code>.</p>\n\n<p translation-result=\"on\">這個應用需要一個有效的預設路由，在這裡應該用英雄列表作為預設頁。當用戶點選\"Heroes\"連結或把 <code>localhost:4200/heroes</code> 貼上到位址列時，它應該導航到列表頁。</p><p translation-origin=\"off\">The application needs a default route to a valid page.\nThe default page for this application is the list of heroes.\nThe application should navigate there as if the user clicked the \"Heroes\" link or pasted <code>localhost:4200/heroes</code> into the address bar.</p>\n\n<p translation-result=\"on\">新增一個 <code>redirect</code> 路由，把最初的相對 URL（<code>''</code>）轉換成所需的預設路徑（<code>/heroes</code>）。</p><p translation-origin=\"off\">Add a <code>redirect</code> route that translates the initial relative URL (<code>''</code>) to the default path (<code>/heroes</code>) you want.</p>\n\n<p translation-result=\"on\">在萬用字元路由<em>上方</em>新增一個預設路由。在下方的程式碼片段中，它出現在萬用字元路由的緊上方，展示了這個里程碑的完整 <code>appRoutes</code>。</p><p translation-origin=\"off\">Add the default route somewhere <em>above</em> the wildcard route.\nIt's just above the wildcard route in the following excerpt showing the complete <code>appRoutes</code> for this milestone.</p>\n\n<code-example header=\"src/app/app-routing.module.ts (appRoutes)\" path=\"router/src/app/app-routing.module.1.ts\" region=\"appRoutes\">\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'heroes',        component: HeroListComponent },\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n</code-example>\n<p translation-result=\"on\">瀏覽器的位址列會顯示 <code>.../heroes</code>，好像你直接在那裡導航一樣。</p><p translation-origin=\"off\">The browser address bar shows <code>.../heroes</code> as if you'd navigated there directly.</p>\n\n<p translation-result=\"on\">重新導向路由需要一個 <code>pathMatch</code> 屬性，來告訴路由器如何用 URL 去匹配路由的路徑。在本應用中，路由器應該只有在<em>完整的 URL</em>等於 <code>''</code> 時才選擇 <code>HeroListComponent</code> 元件，因此要把 <code>pathMatch</code> 設定為 <code>'full'</code>。</p><p translation-origin=\"off\">A redirect route requires a <code>pathMatch</code> property to tell the router how to match a URL to the path of a route.\nIn this app, the router should select the route to the <code>HeroListComponent</code> only when the <em>entire URL</em> matches <code>''</code>, so set the <code>pathMatch</code> value to <code>'full'</code>.</p>\n\n<p><a id=\"pathmatch\"></a></p>\n<div class=\"callout is-helpful\">\n<header ng-should-translate=\"\" translation-result=\"on\">聚焦 pathMatch</header><header ng-should-translate=\"\" translation-origin=\"off\">Spotlight on pathMatch</header>\n\n<p translation-result=\"on\">從技術角度看，<code>pathMatch = 'full'</code> 會導致 URL 中<em>剩下的</em>、未匹配的部分必須等於 <code>''</code>。在這個例子中，跳轉路由在一個最上層路由中，因此<em>剩下的</em>URL 和<em>完整的</em>URL 是一樣的。</p><p translation-origin=\"off\">Technically, <code>pathMatch = 'full'</code> results in a route hit when the <em>remaining</em>, unmatched  segments of the URL match <code>''</code>.\nIn this example, the redirect is in a top level route so the <em>remaining</em> URL and the <em>entire</em> URL are the same thing.</p>\n\n<p translation-result=\"on\"><code>pathMatch</code> 的另一個可能的值是 <code>'prefix'</code>，它會告訴路由器：當<em>剩下的</em>URL 以這個跳轉路由中的 <code>prefix</code> 值開頭時，就會匹配上這個跳轉路由。但這不適用於此範例應用，因為如果 <code>pathMatch</code> 值是 <code>'prefix'</code>，那麼每個 URL 都會匹配 <code>''</code>。</p><p translation-origin=\"off\">The other possible <code>pathMatch</code> value is <code>'prefix'</code> which tells the router to match the  redirect route when the remaining URL begins with the redirect route's prefix path.\nThis doesn't apply to this sample application because if the <code>pathMatch</code> value were <code>'prefix'</code>, every URL would match <code>''</code>.</p>\n\n<p translation-result=\"on\">嘗試把它設定為 <code>'prefix'</code>，並點選 <code>Go to sidekicks</code> 按鈕。這是因為它是一個無效 URL，本應顯示“Page not found”頁。但是，你仍然在“英雄列表”頁中。在位址列中輸入一個無效的 URL，你又被路由到了 <code>/heroes</code>。<em>每一個</em> URL，無論有效與否，都會匹配上這個路由定義。</p><p translation-origin=\"off\">Try setting it to <code>'prefix'</code> and clicking the <code>Go to sidekicks</code> button.\nBecause that's a bad URL, you should see the \"Page not found\" page.\nInstead, you're still on the \"Heroes\" page.\nEnter a bad URL in the browser address bar.\nYou're instantly re-routed to <code>/heroes</code>.\nEvery URL, good or bad, that falls through to this route definition is a match.</p>\n\n<p translation-result=\"on\">預設路由應該只有在整個 URL 等於 <code>''</code> 時才重新導向到 <code>HeroListComponent</code>，別忘了把重新導向路由設定為 <code>pathMatch = 'full'</code>。</p><p translation-origin=\"off\">The default route should redirect to the <code>HeroListComponent</code> only when the entire url is <code>''</code>.\nRemember to restore the redirect to <code>pathMatch = 'full'</code>.</p>\n\n<p translation-result=\"on\">要了解更多，參見 Victor Savkin 的帖子<a href=\"https://victorsavkin.com/post/146722301646/angular-router-empty-paths-componentless-routes\">關於重新導向</a>。</p><p translation-origin=\"off\">Learn more in Victor Savkin's <a href=\"https://vsavkin.tumblr.com/post/146722301646/angular-router-empty-paths-componentless-routes\">post on redirects</a>.</p>\n\n</div>\n<h3 id=\"milestone-1-wrap-up\" translation-result=\"on\">里程碑 1 小結<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-1-wrap-up\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Milestone 1 wrap up<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-1-wrap-up\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當用戶單擊某個連結時，該範例應用可以在兩個檢視之間切換。</p><p translation-origin=\"off\">Your sample application can switch between two views when the user clicks a link.</p>\n\n<p translation-result=\"on\">里程碑 1 涵蓋了以下幾點的做法：</p><p translation-origin=\"off\">Milestone 1 covered how to do the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">載入路由庫</p><p translation-origin=\"off\">Load the router library</p>\n\n</li>\n<li>\n<p translation-result=\"on\">往殼元件的範本中新增一個導覽列，導覽列中有一些 A 標籤、<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 指令和 <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a></code> 指令</p><p translation-origin=\"off\">Add a nav bar to the shell template with anchor tags, <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code>  and <code><a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a></code> directives</p>\n\n</li>\n<li>\n<p translation-result=\"on\">往殼元件的範本中新增一個 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a></code> 指令，檢視將會被顯示在那裡</p><p translation-origin=\"off\">Add a <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a></code> to the shell template where views are displayed</p>\n\n</li>\n<li>\n<p translation-result=\"on\">用 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 配置路由器模組</p><p translation-origin=\"off\">Configure the router module with <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">設定路由器，使其合成 HTML5 模式的瀏覽器 URL</p><p translation-origin=\"off\">Set the router to compose HTML5 browser URLs</p>\n\n</li>\n<li>\n<p translation-result=\"on\">使用萬用字元路由來處理無效路由</p><p translation-origin=\"off\">Handle invalid routes with a <code>wildcard</code> route</p>\n\n</li>\n<li>\n<p translation-result=\"on\">當應用在空路徑下啟動時，導航到預設路由</p><p translation-origin=\"off\">Navigate to the default route when the application launches with an empty path</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">這個初學者應用的結構是這樣的：</p><p translation-origin=\"off\">The starter application's structure looks like this:</p>\n\n<div class=\"filetree\">\n  <div class=\"file\">\n    angular-router-tour-of-heroes\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      src\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        app\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          crisis-list\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            crisis-list.component.css\n          </div>\n          <div class=\"file\">\n            crisis-list.component.html\n          </div>\n          <div class=\"file\">\n            crisis-list.component.ts\n          </div>\n        </div>\n        <div class=\"file\">\n          hero-list\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            hero-list.component.css\n          </div>\n          <div class=\"file\">\n            hero-list.component.html\n          </div>\n          <div class=\"file\">\n            hero-list.component.ts\n          </div>\n        </div>\n        <div class=\"file\">\n          page-not-found\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            page-not-found.component.css\n          </div>\n          <div class=\"file\">\n            page-not-found.component.html\n          </div>\n          <div class=\"file\">\n            page-not-found.component.ts\n          </div>\n        </div>\n        <div class=\"file\">\n          app.component.css\n        </div>\n        <div class=\"file\">\n          app.component.html\n        </div>\n        <div class=\"file\">\n          app.component.ts\n        </div>\n        <div class=\"file\">\n          app.module.ts\n        </div>\n      </div>\n      <div class=\"file\">\n        main.ts\n      </div>\n      <div class=\"file\">\n        index.html\n      </div>\n      <div class=\"file\">\n        styles.css\n      </div>\n      <div class=\"file\">\n        tsconfig.json\n      </div>\n    </div>\n    <div class=\"file\">\n      node_modules …\n    </div>\n    <div class=\"file\">\n      package.json\n    </div>\n  </div>\n</div>\n<p translation-result=\"on\">下面是本里程碑中的檔案列表。</p><p translation-origin=\"off\">Here are the files in this milestone.</p>\n\n<code-tabs>\n    <code-pane header=\"app.component.html\" path=\"router/src/app/app.component.1.html\">\n&lt;h1&gt;Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Crisis Center&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Heroes&lt;/a&gt;\n&lt;/nav&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n</code-pane>\n    <code-pane header=\"app.module.ts\" path=\"router/src/app/app.module.1.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { AppComponent } from './app.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'heroes', component: HeroListComponent },\n\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &lt;-- debugging purposes only\n    )\n  ],\n  declarations: [\n    AppComponent,\n    HeroListComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n    <code-pane header=\"hero-list/hero-list.component.html\" path=\"router/src/app/hero-list/hero-list.component.1.html\">\n&lt;h2&gt;HEROES&lt;/h2&gt;\n&lt;p&gt;Get your heroes here&lt;/p&gt;\n\n&lt;button type=\"button\" <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/sidekicks\"&gt;Go to sidekicks&lt;/button&gt;\n\n\n</code-pane>\n    <code-pane header=\"crisis-list/crisis-list.component.html\" path=\"router/src/app/crisis-list/crisis-list.component.1.html\">\n&lt;h2&gt;CRISIS CENTER&lt;/h2&gt;\n&lt;p&gt;Get your crisis here&lt;/p&gt;\n\n\n</code-pane>\n    <code-pane header=\"page-not-found/page-not-found.component.html\" path=\"router/src/app/page-not-found/page-not-found.component.html\">\n&lt;h2&gt;Page not found&lt;/h2&gt;\n\n</code-pane>\n    <code-pane header=\"index.html\" path=\"router/src/index.html\">\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;!-- Set the base href --&gt;\n    &lt;base href=\"/\"&gt;\n    &lt;title&gt;Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&lt;/title&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;app-root&gt;&lt;/app-root&gt;\n  &lt;/body&gt;\n\n&lt;/html&gt;\n\n</code-pane>\n</code-tabs>\n<p><a id=\"routing-module\"></a></p>\n<h2 id=\"milestone-2-routing-module\" translation-result=\"on\">里程碑 2：<strong>路由模組</strong><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-2-routing-module\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Milestone 2: <em>Routing module</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-2-routing-module\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">這個里程碑會向你展示如何配置一個名叫<em>路由模組</em>的專用<em>模組</em>，它會儲存你應用的路由配置。</p><p translation-origin=\"off\">This milestone shows you how to configure a special-purpose module called a <em>Routing Module</em>, which holds your application's routing configuration.</p>\n\n<p translation-result=\"on\">路由模組有以下幾個特點：</p><p translation-origin=\"off\">The Routing Module has several characteristics:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">把路由這個關注點從其它應用類關注點中分離出去。</p><p translation-origin=\"off\">Separates routing concerns from other application concerns</p>\n\n</li>\n<li>\n<p translation-result=\"on\">測試特性模組時，可以替換或移除路由模組。</p><p translation-origin=\"off\">Provides a module to replace or remove when testing the application</p>\n\n</li>\n<li>\n<p translation-result=\"on\">為路由服務提供者（如守衛和解析器等）提供一個眾所周知的位置。</p><p translation-origin=\"off\">Provides a well-known location for routing service providers such as guards and resolvers</p>\n\n</li>\n<li>\n<p translation-result=\"on\">不要宣告元件。</p><p translation-origin=\"off\">Does not declare components</p>\n\n</li>\n</ul>\n<p><a id=\"integrate-routing\"></a></p>\n<h3 id=\"integrate-routing-with-your-app\" translation-result=\"on\">把路由整合到應用中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#integrate-routing-with-your-app\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Integrate routing with your app<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#integrate-routing-with-your-app\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">路由應用範例中預設不包含路由。要想在使用 <a href=\"cli\">Angular CLI</a> 建立專案時支援路由，請為專案或應用的每個 NgModule 設定 <code>--routing</code> 選項。當你用 CLI 命令 <a href=\"cli/new\"><code>ng new</code></a> 建立新專案或用 <a href=\"cli/generate\"><code>ng generate app</code></a> 命令建立新應用，請指定 <code>--routing</code> 選項。這會告訴 CLI 包含上 <code>@angular/router</code> 套件，並建立一個名叫 <code>app-routing.module.ts</code> 的檔案。然後你就可以在新增到專案或應用中的任何 NgModule 中使用路由功能了。</p><p translation-origin=\"off\">The sample routing application does not include routing by default.\nWhen you use the <a href=\"cli\">Angular CLI</a> to create a project that does use routing, set the <code>--routing</code> option for the project or application, and for each NgModule.\nWhen you create or initialize a new project (using the CLI <a href=\"cli/new\"><code>ng new</code></a> command) or a new application (using the <a href=\"cli/generate\"><code>ng generate app</code></a> command), specify the <code>--routing</code> option.\nThis tells the CLI to include the <code>@angular/router</code> npm package and create a file named <code>app-routing.module.ts</code>.\nYou can then use routing in any NgModule that you add to the project or application.</p>\n\n<p translation-result=\"on\">比如，可以用下列命令產生帶路由的 NgModule。</p><p translation-origin=\"off\">For example, the following command generates an NgModule that can use routing.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate module my-module --routing\n\n</code-example>\n<p translation-result=\"on\">這將建立一個名叫 <code>my-module-routing.module.ts</code> 的獨立檔案，來儲存這個 NgModule 的路由資訊。該檔案包含一個空的 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 物件，你可以使用一些指向各個元件和 NgModule 的路由來填充該物件。</p><p translation-origin=\"off\">This creates a separate file named <code>my-module-routing.module.ts</code> to store the NgModule's routes.\nThe file includes an empty <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> object that you can fill with routes to different components and NgModules.</p>\n\n<p><a id=\"routing-refactor\"></a></p>\n<h3 id=\"refactor-the-routing-configuration-into-a-routing-module\" translation-result=\"on\">將路由配置重構為路由模組<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#refactor-the-routing-configuration-into-a-routing-module\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Refactor the routing configuration into a routing module<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#refactor-the-routing-configuration-into-a-routing-module\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 <code>/app</code> 目錄下建立一個 <code>AppRouting</code> 模組，以包含路由配置。</p><p translation-origin=\"off\">Create an <code>AppRouting</code> module in the <code>/app</code> folder to contain the routing configuration.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate module app-routing --module app --flat\n\n</code-example>\n<p translation-result=\"on\">匯入 <code>CrisisListComponent</code>、<code>HeroListComponent</code> 和 <code>PageNotFoundComponent</code> 元件，就像 <code>app.module.ts</code> 中那樣。然後把 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 的匯入陳述式和路由配置以及 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 移入這個路由模組中。</p><p translation-origin=\"off\">Import the <code>CrisisListComponent</code>, <code>HeroListComponent</code>, and <code>PageNotFoundComponent</code> symbols like you did in the <code>app.module.ts</code>.\nThen move the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> imports and routing configuration, including <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code>, into this routing module.</p>\n\n<p translation-result=\"on\">把 Angular 的 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 新增到該模組的 <code>exports</code> 陣列中，以便再次匯出它。透過再次匯出 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>，那些宣告在 <code>AppModule</code> 中的元件就可以存取路由指令了，比如 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 和 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>。</p><p translation-origin=\"off\">Re-export the Angular <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> by adding it to the module <code>exports</code> array.\nBy re-exporting the <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> here, the components declared in <code>AppModule</code> have access to router directives such as <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> and <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>.</p>\n\n<p translation-result=\"on\">做完這些之後，該檔案變成了這樣。</p><p translation-origin=\"off\">After these steps, the file should look like this.</p>\n\n<code-example header=\"src/app/app-routing.module.ts\" path=\"router/src/app/app-routing.module.1.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  { path: 'heroes',        component: HeroListComponent },\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &lt;-- debugging purposes only\n    )\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n<p translation-result=\"on\">接下來，修改 <code>app.module.ts</code> 檔案，從 <code>imports</code> 陣列中移除 <code>RouterModule.forRoot</code>。</p><p translation-origin=\"off\">Next, update the <code>app.module.ts</code> file by removing <code>RouterModule.forRoot</code> in the <code>imports</code> array.</p>\n\n<code-example header=\"src/app/app.module.ts\" path=\"router/src/app/app.module.2.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport { AppRoutingModule } from './app-routing.module';\n\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    HeroListComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">稍後，本指南將向你展示如何建立<a href=\"guide/router-tutorial-toh#heroes-functionality\">多個路由模組</a>，並<a href=\"guide/router-tutorial-toh#routing-module-order\">以正確的順序</a>匯入這些路由模組。</p><p translation-origin=\"off\">Later, this guide shows you how to create <a href=\"guide/router-tutorial-toh#heroes-functionality\">multiple routing modules</a> and import those routing modules <a href=\"guide/router-tutorial-toh#routing-module-order\">in the correct order</a>.</p>\n\n</div>\n<p translation-result=\"on\">應用繼續照常執行，你可以把路由模組作為將來每個模組維護路由配置的中心位置。</p><p translation-origin=\"off\">The application continues to work just the same, and you can use <code>AppRoutingModule</code> as the central place to maintain future routing configuration.</p>\n\n<p><a id=\"why-routing-module\"></a></p>\n<h3 id=\"benefits-of-a-routing-module\" translation-result=\"on\">路由模組的優點<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#benefits-of-a-routing-module\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Benefits of a routing module<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#benefits-of-a-routing-module\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">路由模組（通常稱為 <code>AppRoutingModule</code>）代替了根範本或特性模組中的路由模組。</p><p translation-origin=\"off\">The routing module, often called the <code>AppRoutingModule</code>, replaces the routing configuration in the root or feature module.</p>\n\n<p translation-result=\"on\">這種路由模組在你的應用不斷增長，以及配置中包括了專門的守衛和解析器函式時會非常有用。</p><p translation-origin=\"off\">The routing module is helpful as your application grows and when the configuration includes specialized guard and resolver functions.</p>\n\n<p translation-result=\"on\">在配置很簡單時，一些開發者會跳過路由模組，並將路由配置直接混合在關聯模組中（比如 <code>AppModule</code>）。</p><p translation-origin=\"off\">Some developers skip the routing module when the configuration is minimal and merge the routing configuration directly into the companion module (for example, <code>AppModule</code>).</p>\n\n<p translation-result=\"on\">大多數應用都應該採用路由模組，以保持一致性。它在配置複雜時，能確保程式碼乾淨。它讓測試特性模組更加容易。它的存在讓人一眼就能看出這個模組是帶路由的。開發者可以很自然的從路由模組中查詢和擴充路由配置。</p><p translation-origin=\"off\">Most applications should implement a routing module for consistency.\nIt keeps the code clean when configuration becomes complex.\nIt makes testing the feature module easier.\nIts existence calls attention to the fact that a module is routed.\nIt is where developers expect to find and expand routing configuration.</p>\n\n<p><a id=\"heroes-feature\"></a></p>\n<h2 id=\"milestone-3-heroes-feature\" translation-result=\"on\">里程碑 3: 英雄特徵區<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-3-heroes-feature\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Milestone 3: Heroes feature<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-3-heroes-feature\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本里程碑涵蓋了以下內容：</p><p translation-origin=\"off\">This milestone covers the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">用模組把應用和路由組織為一些特性區。</p><p translation-origin=\"off\">Organizing the application and routes into feature areas using modules</p>\n\n</li>\n<li>\n<p translation-result=\"on\">命令式的從一個元件導航到另一個</p><p translation-origin=\"off\">Navigating imperatively from one component to another</p>\n\n</li>\n<li>\n<p translation-result=\"on\">透過路由傳遞必要資訊和可選資訊</p><p translation-origin=\"off\">Passing required and optional information in route parameters</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">這個範例應用在<a href=\"tutorial/tour-of-heroes/toh-pt4\" title=\"英雄指南：服務\">“英雄指南”課程</a>的“服務”部分重新建立了英雄特性區，並複用了<live-example name=\"toh-pt4\" title=\"Tour of Heroes: Services example code\"></live-example>中的大部分程式碼。</p><p translation-origin=\"off\">This sample application recreates the heroes feature in the \"Services\" section of the <a href=\"tutorial/tour-of-heroes/toh-pt4\" title=\"Tour of Heroes: Services\">Tour of Heroes tutorial</a>, and reuses much of the code from the <live-example name=\"toh-pt4\" title=\"Tour of Heroes: Services example code\"></live-example>.</p>\n\n<p translation-result=\"on\">典型的應用具有多個<em>特性區</em>，每個特性區都專注於特定的業務用途並擁有自己的資料夾。</p><p translation-origin=\"off\">A typical application has multiple feature areas, each dedicated to a particular business purpose with its own folder.</p>\n\n<p translation-result=\"on\">該部分將向你展示如何將應用重構為不同的特性模組、將它們匯入到主模組中，並在它們之間導航。</p><p translation-origin=\"off\">This section shows you how refactor the application into different feature modules, import them into the main module and navigate among them.</p>\n\n<p><a id=\"heroes-functionality\"></a></p>\n<h3 id=\"add-heroes-functionality\" translation-result=\"on\">新增英雄管理功能<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#add-heroes-functionality\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Add heroes functionality<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#add-heroes-functionality\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">遵循下列步驟：</p><p translation-origin=\"off\">Follow these steps:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">為了管理這些英雄，在 <code>heroes</code> 目錄下建立一個帶路由的 <code>HeroesModule</code>，並把它註冊到根模組 <code>AppModule</code> 中。</p><p translation-origin=\"off\">To manage the heroes, create a <code>HeroesModule</code> with routing in the heroes folder and register it with the root <code>AppModule</code>.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate module heroes/heroes --module app --flat --routing\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">把 <code>app</code> 下佔位用的 <code>hero-list</code> 目錄移到 <code>heroes</code> 目錄中。</p><p translation-origin=\"off\">Move the placeholder <code>hero-list</code> folder that's in the <code>app</code> folder into the <code>heroes</code> folder.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">從 <live-example name=\"toh-pt4\" title=\"Tour of Heroes: Services example code\">課程的 \"服務\" 部分</live-example>把 <code>heroes/heroes.component.html</code> 的內容複製到 <code>hero-list.component.html</code> 範本中。</p><p translation-origin=\"off\">Copy the contents of the <code>heroes/heroes.component.html</code> from the <live-example name=\"toh-pt4\" title=\"Tour of Heroes: Services example code\">\"Services\" tutorial</live-example> into the <code>hero-list.component.html</code> template.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">給 <code>&lt;h2&gt;</code> 加文字，改成 <code>&lt;h2&gt;HEROES&lt;/h2&gt;</code>。</p><p translation-origin=\"off\">Re-label the <code>&lt;h2&gt;</code> to <code>&lt;h2&gt;HEROES&lt;/h2&gt;</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">刪除範本底部的 <code>&lt;app-hero-detail&gt;</code> 元件。</p><p translation-origin=\"off\">Delete the <code>&lt;app-hero-detail&gt;</code> component at the bottom of the template.</p>\n\n</li>\n</ul>\n</li>\n<li>\n<p translation-result=\"on\">把現場演練中 <code>heroes/heroes.component.css</code> 檔案的內容複製到 <code>hero-list.component.css</code> 檔案中。</p><p translation-origin=\"off\">Copy the contents of the <code>heroes/heroes.component.css</code> from the live example into the <code>hero-list.component.css</code> file.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把現場演練中 <code>heroes/heroes.component.ts</code> 檔案的內容複製到 <code>hero-list.component.ts</code> 檔案中。</p><p translation-origin=\"off\">Copy the contents of the <code>heroes/heroes.component.ts</code> from the live example into the <code>hero-list.component.ts</code> file.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">把元件類別名稱改為 <code>HeroListComponent</code>。</p><p translation-origin=\"off\">Change the component class name to <code>HeroListComponent</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把 <code>selector</code> 改為 <code>app-hero-list</code>。</p><p translation-origin=\"off\">Change the <code>selector</code> to <code>app-hero-list</code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">對於路由元件來說，這些選擇器不是必須的，因為這些元件是在渲染頁面時動態插入的，不過選擇器對於在 HTML 元素樹中標記和選中它們是很有用的。</p><p translation-origin=\"off\">Selectors are not required for routed components because components are dynamically inserted when the page is rendered.\nHowever, they are useful for identifying and targeting them in your HTML element tree.</p>\n\n</div>\n</li>\n</ul>\n</li>\n<li>\n<p translation-result=\"on\">把 <code>hero-detail</code> 目錄中的 <code>hero.ts</code>、<code>hero.service.ts</code> 和 <code>mock-heroes.ts</code> 檔案複製到 <code>heroes</code> 子目錄下。</p><p translation-origin=\"off\">Copy the <code>hero-detail</code> folder, the <code>hero.ts</code>, <code>hero.service.ts</code>,  and <code>mock-heroes.ts</code> files into the <code>heroes</code> sub-folder</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把 <code>message.service.ts</code> 檔案複製到 <code>src/app</code> 目錄下。</p><p translation-origin=\"off\">Copy the <code>message.service.ts</code> into the <code>src/app</code> folder</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在 <code>hero.service.ts</code> 檔案中修改匯入 <code>message.service</code> 的相對路徑。</p><p translation-origin=\"off\">Update the relative path import to the <code>message.service</code> in the <code>hero.service.ts</code> file</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">接下來，更新 <code>HeroesModule</code> 的元資料。</p><p translation-origin=\"off\">Next, update the <code>HeroesModule</code> metadata.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">匯入 <code>HeroDetailComponent</code> 和 <code>HeroListComponent</code>，並新增到 <code>HeroesModule</code> 模組的 <code>declarations</code> 陣列中。</p><p translation-origin=\"off\">Import and add the <code>HeroDetailComponent</code> and <code>HeroListComponent</code> to the <code>declarations</code> array in the <code>HeroesModule</code>.</p>\n\n</li>\n</ul>\n<code-example header=\"src/app/heroes/heroes.module.ts\" path=\"router/src/app/heroes/heroes.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\n\nimport { HeroesRoutingModule } from './heroes-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesRoutingModule\n  ],\n  declarations: [\n    HeroListComponent,\n    HeroDetailComponent\n  ]\n})\nexport class HeroesModule {}\n\n\n</code-example>\n<p translation-result=\"on\">英雄管理部分的檔案結構如下：</p><p translation-origin=\"off\">The hero management file structure is as follows:</p>\n\n<div class=\"filetree\">\n  <div class=\"file\">\n    src/app/heroes\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      hero-detail\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          hero-detail.component.css\n        </div>\n        <div class=\"file\">\n          hero-detail.component.html\n        </div>\n        <div class=\"file\">\n          hero-detail.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      hero-list\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          hero-list.component.css\n        </div>\n        <div class=\"file\">\n          hero-list.component.html\n        </div>\n        <div class=\"file\">\n          hero-list.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      hero.service.ts\n    </div>\n    <div class=\"file\">\n      hero.ts\n    </div>\n    <div class=\"file\">\n      heroes-routing.module.ts\n    </div>\n    <div class=\"file\">\n      heroes.module.ts\n    </div>\n    <div class=\"file\">\n      mock-heroes.ts\n    </div>\n    </div>\n  </div>\n</div>\n<p><a id=\"hero-routing-requirements\"></a></p>\n<h4 id=\"hero-feature-routing-requirements\" translation-result=\"on\">英雄特性區的路由需求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#hero-feature-routing-requirements\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Hero feature routing requirements<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#hero-feature-routing-requirements\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">英雄特性區中有兩個相互協作的元件：英雄列表和英雄詳情。當你導航到列表檢視時，它會獲取英雄列表並顯示出來。當你點選一個英雄時，詳細檢視就會顯示那個特定的英雄。</p><p translation-origin=\"off\">The heroes feature has two interacting components, the hero list and the hero detail.\nWhen you navigate to list view, it gets a list of heroes and displays them.\nWhen you click on a hero, the detail view has to display that particular hero.</p>\n\n<p translation-result=\"on\">透過把所選英雄的 id 編碼進路由的 URL 中，就能告訴詳情檢視該顯示哪個英雄。</p><p translation-origin=\"off\">You tell the detail view which hero to display by including the selected hero's ID in the route URL.</p>\n\n<p translation-result=\"on\">從新位置 <code>src/app/heroes/</code> 目錄中匯入英雄相關的元件，並定義兩個“英雄管理”路由。</p><p translation-origin=\"off\">Import the hero components from their new locations in the <code>src/app/heroes/</code> folder and define the two hero routes.</p>\n\n<p translation-result=\"on\">現在，你有了 <code>Heroes</code> 模組的路由，還得在 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 中把它們註冊給<em>路由器</em>，和 <code>AppRoutingModule</code> 中的做法幾乎完全一樣，只有一項重要的差別。</p><p translation-origin=\"off\">Now that you have routes for the <code>Heroes</code> module, register them with the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> using the <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> as you did in the <code>AppRoutingModule</code>, with an important difference.</p>\n\n<p translation-result=\"on\">在 <code>AppRoutingModule</code> 中，你使用了靜態的 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 方法來註冊路由和全應用級服務提供者。在特性模組中你要改用 <code>forChild()</code> 靜態方法。</p><p translation-origin=\"off\">In the <code>AppRoutingModule</code>, you used the static <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> method to register the routes and application level service providers.\nIn a feature module you use the static <code>forChild()</code> method.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">只在根模組 <code>AppRoutingModule</code> 中呼叫 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code>（如果在 <code>AppModule</code> 中註冊應用的最上層路由，那就在 <code>AppModule</code> 中呼叫）。在其它模組中，你就必須呼叫 <code>RouterModule.forChild</code> 方法來註冊附屬路由。</p><p translation-origin=\"off\">Only call <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> in the root <code>AppRoutingModule</code>\n(or the <code>AppModule</code> if that's where you register top level application routes).\nIn any other module, you must call the <code><a href=\"api/router/RouterModule#forChild\" class=\"code-anchor\">RouterModule.forChild()</a></code> method to register additional routes.</p>\n\n</div>\n<p translation-result=\"on\">修改後的 <code>HeroesRoutingModule</code> 是這樣的：</p><p translation-origin=\"off\">The updated <code>HeroesRoutingModule</code> looks like this:</p>\n\n<code-example header=\"src/app/heroes/heroes-routing.module.ts\" path=\"router/src/app/heroes/heroes-routing.module.1.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\n\nconst heroesRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'heroes',  component: HeroListComponent },\n  { path: 'hero/:id', component: HeroDetailComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">考慮為每個特性模組提供自己的路由配置檔案。雖然特性路由目前還很少，但即使在小型應用中，路由也會變得越來越複雜。</p><p translation-origin=\"off\">Consider giving each feature module its own route configuration file.\nThough the feature routes are currently minimal, routes have a tendency to grow more complex even in small applications.</p>\n\n</div>\n<p><a id=\"remove-duplicate-hero-routes\"></a></p>\n<h4 id=\"remove-duplicate-hero-routes\" translation-result=\"on\">移除重複的“英雄管理”路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#remove-duplicate-hero-routes\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Remove duplicate hero routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#remove-duplicate-hero-routes\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">英雄類別的路由目前定義在兩個地方：<code>HeroesRoutingModule</code> 中（並最終給 <code>HeroesModule</code>）和 <code>AppRoutingModule</code> 中。</p><p translation-origin=\"off\">The hero routes are currently defined in two places: in the <code>HeroesRoutingModule</code>,\nby way of the <code>HeroesModule</code>, and in the <code>AppRoutingModule</code>.</p>\n\n<p translation-result=\"on\">由特性模組提供的路由會被路由器再組合上它們所匯入的模組的路由。這讓你可以繼續定義特性路由模組中的路由，而不用修改主路由配置。</p><p translation-origin=\"off\">Routes provided by feature modules are combined together into their imported module's routes by the router.\nThis lets you continue defining the feature module routes without modifying the main route configuration.</p>\n\n<p translation-result=\"on\">移除 <code>HeroListComponent</code> 的匯入和來自 <code>app-routing.module.ts</code> 中的 <code>/heroes</code> 路由。</p><p translation-origin=\"off\">Remove the <code>HeroListComponent</code> import and the <code>/heroes</code> route from the <code>app-routing.module.ts</code>.</p>\n\n<p translation-result=\"on\">保留預設路由和萬用字元路由，因為這些路由仍然要在應用的最上層使用。</p><p translation-origin=\"off\">Leave the default and the wildcard routes as these are still in use at the top level of the application.</p>\n\n<code-example header=\"src/app/app-routing.module.ts (v2)\" path=\"router/src/app/app-routing.module.2.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\n// import { HeroListComponent } from './hero-list/hero-list.component';  // &lt;-- delete this line\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n  // { path: 'heroes',     component: HeroListComponent }, // &lt;-- delete this line\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &lt;-- debugging purposes only\n    )\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n<p><a id=\"merge-hero-routes\"></a></p>\n<h4 id=\"remove-heroes-declarations\" translation-result=\"on\">移除英雄列表的宣告<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#remove-heroes-declarations\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Remove heroes declarations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#remove-heroes-declarations\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">因為 <code>HeroesModule</code> 現在提供了 <code>HeroListComponent</code>，所以把它從 <code>AppModule</code> 的 <code>declarations</code> 陣列中移除。現在你已經有了一個單獨的 <code>HeroesModule</code>，你可以用更多的元件和不同的路由來演進英雄特性區。</p><p translation-origin=\"off\">Because the <code>HeroesModule</code> now provides the <code>HeroListComponent</code>, remove it from the <code>AppModule</code>'s <code>declarations</code> array.\nNow that you have a separate <code>HeroesModule</code>, you can evolve the hero feature with more components and different routes.</p>\n\n<p translation-result=\"on\">經過這些步驟，<code>AppModule</code> 變成了這樣：</p><p translation-origin=\"off\">After these steps, the <code>AppModule</code> should look like this:</p>\n\n<code-example header=\"src/app/app.module.ts\" path=\"router/src/app/app.module.3.ts\" region=\"remove-heroes\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { AppComponent } from './app.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule } from './heroes/heroes.module';\n\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-example>\n<p><a id=\"routing-module-order\"></a></p>\n<h3 id=\"module-import-order\" translation-result=\"on\">模組匯入順序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#module-import-order\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Module import order<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#module-import-order\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">請注意該模組的 <code>imports</code> 陣列，<code>AppRoutingModule</code> 是最後一個，並且位於 <code>HeroesModule</code> 之後。</p><p translation-origin=\"off\">Notice that in the module <code>imports</code> array, the <code>AppRoutingModule</code> is last and comes <em>after</em> the <code>HeroesModule</code>.</p>\n\n<code-example header=\"src/app/app.module.ts (module-imports)\" path=\"router/src/app/app.module.3.ts\" region=\"module-imports\">\nimports: [\n  <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n  <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  HeroesModule,\n  AppRoutingModule\n],\n\n</code-example>\n<p translation-result=\"on\">路由配置的順序很重要，因為路由器會接受第一個匹配上導航所要求的路徑的那個路由。</p><p translation-origin=\"off\">The order of route configuration is important because the router accepts the first route that matches a navigation request path.</p>\n\n<p translation-result=\"on\">當所有路由都在同一個 <code>AppRoutingModule</code> 時，你要把預設路由和<a href=\"guide/router-tutorial-toh#wildcard\">萬用字元路由</a>放在最後（這裡是在 <code>/heroes</code> 路由後面），\n這樣路由器才有機會匹配到 <code>/heroes</code> 路由，否則它就會先遇到並匹配上該萬用字元路由，並導航到“頁面未找到”路由。</p><p translation-origin=\"off\">When all routes were in one <code>AppRoutingModule</code>, you put the default and <a href=\"guide/router-tutorial-toh#wildcard\">wildcard</a> routes last, after the <code>/heroes</code> route, so that the router had a chance to match a URL to the <code>/heroes</code> route <em>before</em> hitting the wildcard route and navigating to \"Page not found\".</p>\n\n<p translation-result=\"on\">每個路由模組都會根據匯入的順序把自己的路由配置追加進去。如果你先列出了 <code>AppRoutingModule</code>，那麼萬用字元路由就會被註冊在“英雄管理”路由<em>之前</em>。萬用字元路由（它匹配<em>任意</em>URL）將會攔截住每一個到“英雄管理”路由的導航，因此事實上遮蔽了所有“英雄管理”路由。</p><p translation-origin=\"off\">Each routing module augments the route configuration in the order of import.\nIf you listed <code>AppRoutingModule</code> first, the wildcard route would be registered <em>before</em> the hero routes.\nThe wildcard route —which matches <em>every</em> URL— would intercept the attempt to navigate to a hero route.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">反轉路由模組的匯入順序，就會看到當點選英雄相關的連結時被導向了“頁面未找到”路由。\n要學習如何在執行時檢視路由器配置，參見<a href=\"guide/router-tutorial-toh#inspect-config\" title=\"Inspect the router config\">稍後的內容</a>。</p><p translation-origin=\"off\">Reverse the routing modules to see a click of the heroes link resulting in \"Page not found\".\nLearn about inspecting the runtime router configuration <a href=\"guide/router-tutorial-toh#inspect-config\" title=\"Inspect the router config\">below</a>.</p>\n\n</div>\n<h3 id=\"route-parameters\" translation-result=\"on\">路由引數<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#route-parameters\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Route Parameters<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#route-parameters\"><i class=\"material-icons\">link</i></a></h3>\n\n<p><a id=\"route-def-with-parameter\"></a></p>\n<h4 id=\"route-definition-with-a-parameter\" translation-result=\"on\">帶引數的路由定義<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#route-definition-with-a-parameter\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Route definition with a parameter<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#route-definition-with-a-parameter\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">回到 <code>HeroesRoutingModule</code> 並再次檢查這些路由定義。<code>HeroDetailComponent</code> 路由的路徑中帶有 <code>:id</code> 標記。</p><p translation-origin=\"off\">Return to the <code>HeroesRoutingModule</code> and look at the route definitions again.\nThe route to <code>HeroDetailComponent</code> has an <code>:id</code> token in the path.</p>\n\n<code-example header=\"src/app/heroes/heroes-routing.module.ts (excerpt)\" path=\"router/src/app/heroes/heroes-routing.module.1.ts\" region=\"hero-detail-route\">\n{ path: 'hero/:id', component: HeroDetailComponent }\n\n</code-example>\n<p translation-result=\"on\"><code>:id</code> 標記會為路由引數在路徑中建立一個“空位”。在這裡，這種配置會讓路由器把英雄的 <code>id</code> 插入到那個“空位”中。</p><p translation-origin=\"off\">The <code>:id</code> token creates a slot in the path for a Route Parameter.\nIn this case,  this configuration causes the router to insert the <code>id</code> of a hero into that slot.</p>\n\n<p translation-result=\"on\">如果要告訴路由器導航到詳情元件，並讓它顯示“Magneta”，你會期望這個英雄的 <code>id</code> 像這樣顯示在瀏覽器的 URL 中：</p><p translation-origin=\"off\">If you tell the router to navigate to the detail component and display \"Magneta\", you expect a hero ID to appear in the browser URL like this:</p>\n\n<code-example format=\"nocode\">\n\nlocalhost:4200/hero/15\n\n</code-example>\n<p translation-result=\"on\">如果使用者把此 URL 輸入到瀏覽器的位址列中，路由器就會識別出這種模式，同樣進入“Magneta”的詳情檢視。</p><p translation-origin=\"off\">If a user enters that URL into the browser address bar, the router should recognize the pattern and go to the same \"Magneta\" detail view.</p>\n\n<div class=\"callout is-helpful\">\n<header ng-should-translate=\"\" translation-result=\"on\">路由引數：必須的還是可選的？</header><header ng-should-translate=\"\" translation-origin=\"off\">Route parameter: Required or optional?</header>\n\n<p translation-result=\"on\">在這個場景下，把路由引數的標記 <code>:id</code> 嵌入到路由定義的 <code>path</code> 中是一個好主意，因為對於 <code>HeroDetailComponent</code> 來說 <code>id</code> 是<em>必須的</em>，而且路徑中的值 <code>15</code> 已經足夠把到“Magneta”的路由和到其它英雄的路由明確區分開。</p><p translation-origin=\"off\">Embedding the route parameter token, <code>:id</code>, in the route definition path is a good choice for this scenario because the <code>id</code> is <em>required</em> by the <code>HeroDetailComponent</code> and because the value <code>15</code> in the path clearly distinguishes the route to \"Magneta\" from a route for some other hero.</p>\n\n</div>\n<p><a id=\"route-parameters\"></a></p>\n<h4 id=\"setting-the-route-parameters-in-the-list-view\" translation-result=\"on\">在列表檢視中設定路由引數<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#setting-the-route-parameters-in-the-list-view\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Setting the route parameters in the list view<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#setting-the-route-parameters-in-the-list-view\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">然後導航到 <code>HeroDetailComponent</code> 元件。在那裡，你期望看到所選英雄的詳情，這需要兩部分資訊：導航目標和該英雄的 <code>id</code>。</p><p translation-origin=\"off\">After navigating to the <code>HeroDetailComponent</code>, you expect to see the details of the selected hero.\nYou need two pieces of information: the routing path to the component and the hero's <code>id</code>.</p>\n\n<p translation-result=\"on\">因此，這個<em>連結引數陣列</em>中有兩個條目：路由的<em>路徑</em>和一個用來指定所選英雄 <code>id</code> 的<em>路由引數</em>。</p><p translation-origin=\"off\">Accordingly, the <em>link parameters array</em> has two items:\nThe routing <em>path</em> and a <em>route parameter</em> that specifies the <code>id</code> of the selected hero.</p>\n\n<code-example header=\"src/app/heroes/hero-list/hero-list.component.html (link-parameters-array)\" path=\"router/src/app/heroes/hero-list/hero-list.component.1.html\" region=\"link-parameters-array\">\n&lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\"&gt;\n\n</code-example>\n<p translation-result=\"on\">路由器從該陣列中組合出了目標 URL：<code>localhost:4200/hero/15</code>。</p><p translation-origin=\"off\">The router composes the destination URL from the array like this: <code>localhost:4200/hero/15</code>.</p>\n\n<p translation-result=\"on\">路由器從 URL 中解析出路由引數（<code>id:15</code>），並透過 <strong>ActivatedRoute</strong> 服務來把它提供給 <code>HeroDetailComponent</code> 元件。</p><p translation-origin=\"off\">The router extracts the route parameter (<code>id:15</code>) from the URL and supplies it to the <code>HeroDetailComponent</code> using the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> service.</p>\n\n<p><a id=\"activated-route-in-action\"></a></p>\n<h3 id=\"activated-route-in-action\" translation-result=\"on\"><code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 實戰<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#activatedroute-實戰\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\"><code>Activated <a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> in action<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#activated-route-in-action\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">從路由器（<code>router</code>）套件中匯入 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>、<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 和 <code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code> 令牌。</p><p translation-origin=\"off\">Import the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>, <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>, and <code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code> tokens from the router package.</p>\n\n<code-example header=\"src/app/heroes/hero-detail/hero-detail.component.ts (activated route)\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" region=\"imports\">\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a> } from '@angular/router';\n\n</code-example>\n<p translation-result=\"on\">這裡匯入 <code>switchMap</code> 運運算元是因為你稍後將會處理路由引數的可觀察物件 <code>Observable</code>。</p><p translation-origin=\"off\">Import the <code>switchMap</code> operator because you need it later to process the <code>Observable</code> route parameters.</p>\n\n<code-example header=\"src/app/heroes/hero-detail/hero-detail.component.ts (switchMap operator import)\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" region=\"rxjs-operator-import\">\nimport { switchMap } from 'rxjs/operators';\n\n</code-example>\n<p><a id=\"hero-detail-ctor\"></a></p>\n<p translation-result=\"on\">把這些服務作為私有變數新增到建構函式中，以便 Angular 注入它們（讓它們對元件可見）。</p><p translation-origin=\"off\">Add the services as private variables to the constructor so that Angular injects them (makes them visible to the component).</p>\n\n<code-example header=\"src/app/heroes/hero-detail/hero-detail.component.ts (constructor)\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" region=\"ctor\">\nconstructor(\n  private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  private service: HeroService\n) {}\n\n</code-example>\n<p translation-result=\"on\">在 <code>ngOnInit()</code> 方法中，使用 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 服務來檢索路由的引數，從引數中提取出英雄的 <code>id</code>，並檢索要顯示的英雄。</p><p translation-origin=\"off\">In the <code>ngOnInit()</code> method, use the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> service to retrieve the parameters for the route, pull the hero <code>id</code> from the parameters, and retrieve the hero to display.</p>\n\n<code-example header=\"src/app/heroes/hero-detail/hero-detail.component.ts (ngOnInit)\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" region=\"ngOnInit\">\nngOnInit() {\n  this.hero$ = this.route.paramMap.pipe(\n    switchMap((params: <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a>) =&gt;\n      this.service.getHero(params.get('id')!))\n  );\n}\n\n</code-example>\n<p translation-result=\"on\">當這個 map 發生變化時，<code>paramMap</code> 會從更改後的引數中獲取 <code>id</code> 引數。</p><p translation-origin=\"off\">When the map changes, <code>paramMap</code> gets the <code>id</code> parameter from the changed parameters.</p>\n\n<p translation-result=\"on\">然後，讓 <code>HeroService</code> 去獲取具有該 <code>id</code> 的英雄，並返回 <code>HeroService</code> 請求的結果。</p><p translation-origin=\"off\">Then you tell the <code>HeroService</code> to fetch the hero with that <code>id</code> and return the result of the <code>HeroService</code> request.</p>\n\n<p translation-result=\"on\"><code>switchMap</code> 運運算元做了兩件事。它把 <code>HeroService</code> 返回的 <code>Observable&lt;Hero&gt;</code> 拍平，並取消以前的未完成請求。當 <code>HeroService</code> 仍在檢索舊的 <code>id</code> 時，如果使用者使用新的 <code>id</code> 重新導航到這個路由，<code>switchMap</code> 會放棄那個舊請求，並返回新 <code>id</code> 的英雄。</p><p translation-origin=\"off\">The <code>switchMap</code> operator does two things.\nIt flattens the <code>Observable&lt;Hero&gt;</code> that <code>HeroService</code> returns and cancels previous pending requests.\nIf the user re-navigates to this route with a new <code>id</code> while the <code>HeroService</code> is still retrieving the old <code>id</code>, <code>switchMap</code> discards that old request and returns the hero for the new <code>id</code>.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code> 處理這個可觀察的訂閱，而且該元件的 <code>hero</code> 屬性也會用檢索到的英雄（重新）進行設定。</p><p translation-origin=\"off\"><code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code> handles the observable subscription and the component's <code>hero</code> property will be (re)set with the retrieved hero.</p>\n\n<h4 id=\"parammap-api\"><code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code> API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#parammap-api\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\"><code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code> API 的靈感來自 URLSearchParams<a href=\"https://developer.mozilla.org/docs/Web/API/URLSearchParams\">介面</a>。它提供了處理路由引數 （ <code>paramMap</code> ） 和查詢引數 （ <code>queryParamMap</code> ） 的引數存取的方法。</p><p translation-origin=\"off\">The <code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code> API is inspired by the <a href=\"https://developer.mozilla.org/docs/Web/API/URLSearchParams\">URLSearchParams interface</a>.\nIt provides methods to handle parameter access for both route parameters (<code>paramMap</code>) and query parameters (<code>queryParamMap</code>).</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">成員</nt-wrapper><nt-wrapper translation-origin=\"off\">Member</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>has(name)</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果引數名位於引數列表中，就返回 <code>true</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Returns <code>true</code> if the parameter name is in the map of parameters.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>get(name)</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果這個 map 中有引數名對應的引數值（字串），就返回它，否則返回 <code>null</code>。如果引數值實際上是一個數組，就返回它的<em>第一個</em>元素。</nt-wrapper><nt-wrapper translation-origin=\"off\">Returns the parameter name value (a <code>string</code>) if present, or <code>null</code> if the parameter name is not in the map. Returns the <em>first</em> element if the parameter value is actually an array of values.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>getAll(name)</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果這個 map 中有引數名對應的值，就返回一個字串陣列，否則返回空陣列。當一個引數名可能對應多個值的時候，請使用 <code>getAll</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Returns a <code>string array</code> of the parameter name value if found, or an empty <code>array</code> if the parameter name value is not in the map. Use <code>getAll</code> when a single parameter could have multiple values.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>keys</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">返回這個 map 中的所有引數名組成的字串陣列。</nt-wrapper><nt-wrapper translation-origin=\"off\">Returns a <code>string array</code> of all parameter names in the map.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p><a id=\"reuse\"></a></p>\n<h4 id=\"observable-parammap-and-component-reuse\" translation-result=\"on\"><code>paramMap</code> 可觀察物件與路由複用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#observable-parammap-and-component-reuse\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Observable <code>paramMap</code> and component reuse<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#observable-parammap-and-component-reuse\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在這個例子中，你接收了路由引數的 <code>Observable</code> 物件。這種寫法暗示著這些路由引數在該元件的生存期內可能會變化。</p><p translation-origin=\"off\">In this example, you retrieve the route parameter map from an <code>Observable</code>.\nThat implies that the route parameter map can change during the lifetime of this component.</p>\n\n<p translation-result=\"on\">預設情況下，如果它沒有存取過其它元件就導航到了同一個元件例項，那麼路由器傾向於複用元件例項。如果複用，這些引數可以變化。</p><p translation-origin=\"off\">By default, the router re-uses a component instance when it re-navigates to the same component type without visiting a different component first. The route parameters could change each time.</p>\n\n<p translation-result=\"on\">假設父元件的導航欄有“前進”和“後退”按鈕，用來輪流顯示英雄列表中中英雄的詳情。每次點選都會強制導航到帶前一個或後一個 <code>id</code> 的 <code>HeroDetailComponent</code> 元件。</p><p translation-origin=\"off\">Suppose a parent component navigation bar had \"forward\" and \"back\" buttons that scrolled through the list of heroes.\nEach click navigated imperatively to the <code>HeroDetailComponent</code> with the next or previous <code>id</code>.</p>\n\n<p translation-result=\"on\">你肯定不希望路由器先從 DOM 中移除當前的 <code>HeroDetailComponent</code> 例項，只是為了用下一個 <code>id</code> 重新建立它，因為它將重新渲染檢視。為了更好的使用者體驗，路由器會複用同一個元件例項，而只是更新引數。</p><p translation-origin=\"off\">You wouldn't want the router to remove the current <code>HeroDetailComponent</code> instance from the DOM only to re-create it for the next <code>id</code> as this would re-render the view.\nFor better UX, the router re-uses the same component instance and updates the parameter.</p>\n\n<p translation-result=\"on\">由於 <code>ngOnInit()</code> 在每個元件例項化時只會被呼叫一次，所以你可以使用 <code>paramMap</code> 可觀察物件來檢測路由引數<em>在同一個例項中</em>何時發生了變化。</p><p translation-origin=\"off\">Because <code>ngOnInit()</code> is only called once per component instantiation, you can detect when the route parameters change from <em>within the same instance</em> using the observable <code>paramMap</code> property.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">當在元件中訂閱一個可觀察物件時，你通常總是要在元件銷燬時取消這個訂閱。</p><p translation-origin=\"off\">When subscribing to an observable in a component, you almost always unsubscribe when the component is destroyed.</p>\n\n<p translation-result=\"on\">不過，<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 中的可觀察物件是一個例外，因為 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 及其可觀察物件與 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 本身是隔離的。<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 會在不再需要時銷燬這個路由元件，這意味著此元件的所有成員也都會銷燬，包括注入進來的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 以及那些對它的所有 <code>Observable</code> 屬性的訂閱。</p><p translation-origin=\"off\">However, <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> observables are among the exceptions because <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> and its observables are insulated from the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> itself.\nThe <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> destroys a routed component when it is no longer needed.\nThis means all the component's members will also be destroyed, including the injected <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> and the subscriptions to its <code>Observable</code> properties.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 不會 <code>complete</code> <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 的任何 <code>Observable</code>，所以其 <code>finalize</code> 或 <code>complete</code> 程式碼塊都不會執行。如果你要在 <code>finalize</code> 中做些什麼處理，你仍然要在 <code>ngOnDestroy</code> 中取消訂閱。如果你的 <code>Observable</code> 型管道有某些程式碼不希望在當前元件被銷燬後執行，仍然要主動取消訂閱。</p><p translation-origin=\"off\">The <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> does not <code>complete</code> any <code>Observable</code> of the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> so any <code>finalize</code> or <code>complete</code> blocks will not run.\nIf you need to handle something in a <code>finalize</code>, you still need to unsubscribe in <code>ngOnDestroy</code>.\nYou also have to unsubscribe if your observable pipe has a delay with code you do not want to run after the component is destroyed.</p>\n\n</div>\n<p><a id=\"snapshot\"></a></p>\n<h4 id=\"snapshot-the-no-observable-alternative\" translation-result=\"on\"><code>snapshot</code>：當不需要 Observable 時的替代品<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#snapshot-the-no-observable-alternative\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\"><code>snapshot</code>: the no-observable alternative<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#snapshot-the-no-observable-alternative\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">本應用不需要複用 <code>HeroDetailComponent</code>。使用者總是會先返回英雄列表，再選擇另一位英雄。所以，不存在從一個英雄詳情導航到另一個而不用經過英雄列表的情況。這意味著路由器每次都會建立一個全新的 <code>HeroDetailComponent</code> 例項。</p><p translation-origin=\"off\">This application won't re-use the <code>HeroDetailComponent</code>.\nThe user always returns to the hero list to select another hero to view.\nThere's no way to navigate from one hero detail to another hero detail without visiting the list component in between.\nTherefore, the router creates a new <code>HeroDetailComponent</code> instance every time.</p>\n\n<p translation-result=\"on\">假如你很確定這個 <code>HeroDetailComponent</code> 例項永遠不會被複用，你可以使用 <code>snapshot</code>。</p><p translation-origin=\"off\">When you know for certain that a <code>HeroDetailComponent</code> instance will never be re-used, you can use <code>snapshot</code>.</p>\n\n<p translation-result=\"on\"><code>route.snapshot</code> 提供了路由引數的初始值。你可以透過它來直接存取引數，而不用訂閱或者新增 Observable 的運運算元，程式碼如下：</p><p translation-origin=\"off\"><code>route.snapshot</code> provides the initial value of the route parameter map.\nYou can access the parameters directly without subscribing or adding observable operators as in the following:</p>\n\n<code-example header=\"src/app/heroes/hero-detail/hero-detail.component.ts (ngOnInit snapshot)\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.2.ts\" region=\"snapshot\">\nngOnInit() {\n  const id = this.route.snapshot.paramMap.get('id')!;\n\n  this.hero$ = this.service.getHero(id);\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">用這種技術，<code>snapshot</code> 只會得到這些引數的初始值。如果路由器可能複用該元件，那麼就該用 <code>paramMap</code> 可觀察物件的方式。本課程的範例應用中就用了 <code>paramMap</code> 可觀察物件。</p><p translation-origin=\"off\"><code>snapshot</code> only gets the initial value of the parameter map with this technique.\nUse the observable <code>paramMap</code> approach if there's a possibility that the router could re-use the component.\nThis tutorial sample application uses with the observable <code>paramMap</code>.</p>\n\n</div>\n<p><a id=\"nav-to-list\"></a></p>\n<h3 id=\"navigating-back-to-the-list-component\" translation-result=\"on\">導航回列表元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#navigating-back-to-the-list-component\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Navigating back to the list component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#navigating-back-to-the-list-component\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>HeroDetailComponent</code> 的 “Back” 按鈕使用了 <code>gotoHeroes()</code> 方法，該方法會強制導航回 <code>HeroListComponent</code>。</p><p translation-origin=\"off\">The <code>HeroDetailComponent</code> \"Back\" button uses the <code>gotoHeroes()</code> method that navigates imperatively back to the <code>HeroListComponent</code>.</p>\n\n<p translation-result=\"on\">路由的 <code>navigate()</code> 方法同樣接受一個單條目的<em>連結引數陣列</em>，你也可以把它繫結到 <code>[<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]</code> 指令上。它儲存著到 <code>HeroListComponent</code> 元件的路徑：</p><p translation-origin=\"off\">The router <code>navigate()</code> method takes the same one-item <em>link parameters array</em> that you can bind to a <code>[<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]</code> directive.\nIt holds the path to the <code>HeroListComponent</code>:</p>\n\n<code-example header=\"src/app/heroes/hero-detail/hero-detail.component.ts (excerpt)\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" region=\"gotoHeroes\">\ngotoHeroes() {\n  this.router.navigate(['/heroes']);\n}\n\n</code-example>\n<p><a id=\"optional-route-parameters\"></a></p>\n<h4 id=\"route-parameters-required-or-optional\" translation-result=\"on\">路由引數：必須還是可選？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#route-parameters-required-or-optional\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Route Parameters: Required or optional?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#route-parameters-required-or-optional\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">如果想導航到 <code>HeroDetailComponent</code> 以對 id 為 <code>15</code> 的英雄進行檢視並編輯，就要在路由的 URL 中使用<a href=\"guide/router-tutorial-toh#route-parameters\">路由引數</a>來指定必要引數值。</p><p translation-origin=\"off\">Use <a href=\"guide/router-tutorial-toh#route-parameters\">route parameters</a> to specify a required parameter value within the route URL\nas you do when navigating to the <code>HeroDetailComponent</code> in order to view the hero with <code>id</code> 15:</p>\n\n<code-example format=\"http\" language=\"http\">\n\nlocalhost:4200/hero/15\n\n</code-example>\n<p translation-result=\"on\">你也能在路由請求中新增<em>可選</em>資訊。比如，當從 <code>hero-detail.component.ts</code> 返回到列表時，如果能自動選中剛剛檢視過的英雄就好了。</p><p translation-origin=\"off\">You can also add optional information to a route request.\nFor example, when returning to the <code>hero-detail.component.ts</code> list from the hero detail view, it would be nice if the viewed hero were preselected in the list.</p>\n\n<div class=\"lightbox\">\n  <img alt=\"Selected hero\" src=\"generated/images/guide/router/selected-hero.png\" width=\"600\" height=\"173\">\n</div>\n<p translation-result=\"on\">當從 <code>HeroDetailComponent</code> 返回時，你可以會透過把正在檢視的英雄的 <code>id</code> 作為可選引數包含在 URL 中來實現這個特性。</p><p translation-origin=\"off\">You implement this feature by including the viewed hero's <code>id</code> in the URL as an optional parameter when returning from the <code>HeroDetailComponent</code>.</p>\n\n<p translation-result=\"on\">可選資訊還可以包含其它形式，比如：</p><p translation-origin=\"off\">Optional information can also include other forms such as:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">結構鬆散的搜尋條件。比如 <code>name='wind*'</code>。</p><p translation-origin=\"off\">Loosely structured search criteria; for example, <code>name='wind*'</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">多個值。比如 <code>after='12/31/2015' &amp; before='1/1/2017'</code> - 沒有特定的順序 - <code>before='1/1/2017' &amp; after='12/31/2015'</code> - 具有各種格式 - <code>during='currentYear'</code>。</p><p translation-origin=\"off\">Multiple values; for example, <code>after='12/31/2015' &amp; before='1/1/2017'</code> —in no particular order— <code>before='1/1/2017' &amp; after='12/31/2015'</code> — in a variety of formats— <code>during='currentYear'</code></p>\n\n</li>\n</ul>\n<p translation-result=\"on\">由於這些引數不適合用作 URL 路徑，因此可以使用可選引數在導航過程中傳遞任意複雜的資訊。可選引數不參與模式匹配，因此在表達上提供了巨大的靈活性。</p><p translation-origin=\"off\">As these kinds of parameters don't fit smoothly in a URL path, you can use optional parameters for conveying arbitrarily complex information during navigation.\nOptional parameters aren't involved in pattern matching and afford flexibility of expression.</p>\n\n<p translation-result=\"on\">和必要引數一樣，路由器也支援透過可選引數導航。在你定義完必要引數之後，再透過一個<em>獨立的物件</em>來定義可選引數。</p><p translation-origin=\"off\">The router supports navigation with optional parameters as well as required route parameters.\nDefine optional parameters in a separate object <em>after</em> you define the required route parameters.</p>\n\n<p translation-result=\"on\">通常，對於必傳的值（比如用於區分兩個路由路徑的）使用<em>必備引數</em>；當這個值是可選的、複雜的或多值的時，使用可選引數。</p><p translation-origin=\"off\">In general, use a required route parameter when the value is mandatory (for example, if necessary to distinguish one route path from another); and an optional parameter when the value is optional, complex, and/or multivariate.</p>\n\n<p><a id=\"optionally-selecting\"></a></p>\n<h4 id=\"heroes-list-optionally-selecting-a-hero\" translation-result=\"on\">英雄列表：選定一個英雄（也可不選）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#heroes-list-optionally-selecting-a-hero\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Heroes list: optionally selecting a hero<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#heroes-list-optionally-selecting-a-hero\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">當導航到 <code>HeroDetailComponent</code> 時，你可以在<em>路由引數</em>中指定一個所要編輯的英雄 <code>id</code>，只要把它作為<a href=\"guide/router-tutorial-toh#link-parameters-array\">連結引數陣列</a>中的第二個條目就可以了。</p><p translation-origin=\"off\">When navigating to the <code>HeroDetailComponent</code> you specified the required <code>id</code> of the hero-to-edit in the\nroute parameter and made it the second item of the <a href=\"guide/router-tutorial-toh#link-parameters-array\"><em>link parameters array</em></a>.</p>\n\n<code-example header=\"src/app/heroes/hero-list/hero-list.component.html (link-parameters-array)\" path=\"router/src/app/heroes/hero-list/hero-list.component.1.html\" region=\"link-parameters-array\">\n&lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\"&gt;\n\n</code-example>\n<p translation-result=\"on\">路由器在導航 URL 中內嵌了 <code>id</code> 的值，這是因為你把它用一個 <code>:id</code> 佔位符當做路由引數定義在了路由的 <code>path</code> 中：</p><p translation-origin=\"off\">The router embedded the <code>id</code> value in the navigation URL because you had defined it as a route parameter with an <code>:id</code> placeholder token in the route <code>path</code>:</p>\n\n<code-example header=\"src/app/heroes/heroes-routing.module.ts (hero-detail-route)\" path=\"router/src/app/heroes/heroes-routing.module.1.ts\" region=\"hero-detail-route\">\n{ path: 'hero/:id', component: HeroDetailComponent }\n\n</code-example>\n<p translation-result=\"on\">當用戶點選後退按鈕時，<code>HeroDetailComponent</code> 構造了另一個<em>連結引數陣列</em>，可以用它導航回 <code>HeroListComponent</code>。</p><p translation-origin=\"off\">When the user clicks the back button, the <code>HeroDetailComponent</code> constructs another <em>link parameters array</em>\nwhich it uses to navigate back to the <code>HeroListComponent</code>.</p>\n\n<code-example header=\"src/app/heroes/hero-detail/hero-detail.component.ts (gotoHeroes)\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.1.ts\" region=\"gotoHeroes\">\ngotoHeroes() {\n  this.router.navigate(['/heroes']);\n}\n\n</code-example>\n<p translation-result=\"on\">該陣列缺少一個路由引數，這是因為以前你不需要往 <code>HeroListComponent</code> 傳送資訊。</p><p translation-origin=\"off\">This array lacks a route parameter because previously you didn't need to send information to the <code>HeroListComponent</code>.</p>\n\n<p translation-result=\"on\">現在，使用導航請求傳送當前英雄的 <code>id</code>，以便 <code>HeroListComponent</code> 在其列表中突出顯示該英雄。</p><p translation-origin=\"off\">Now, send the <code>id</code> of the current hero with the navigation request so that the\n<code>HeroListComponent</code> can highlight that hero in its list.</p>\n\n<p translation-result=\"on\">傳送一個包含可選 <code>id</code> 引數的物件。為了示範，這裡還在物件中定義了一個沒用的額外引數（<code>foo</code>），<code>HeroListComponent</code> 應該忽略它。下面是修改過的導航陳述式：</p><p translation-origin=\"off\">Send the <code>id</code> with an object that contains an optional <code>id</code> parameter.\nFor demonstration purposes, there's an extra junk parameter (<code>foo</code>) in the object that the <code>HeroListComponent</code> should ignore.\nHere's the revised navigation statement:</p>\n\n<code-example header=\"src/app/heroes/hero-detail/hero-detail.component.ts (go to heroes)\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\" region=\"gotoHeroes\">\ngotoHeroes(hero: Hero) {\n  const heroId = hero ? hero.id : null;\n  // Pass along the hero id if available\n  // so that the HeroList component can select that hero.\n  // Include a junk 'foo' property for fun.\n  this.router.navigate(['/heroes', { id: heroId, foo: 'foo' }]);\n}\n\n</code-example>\n<p translation-result=\"on\">該應用仍然能工作。點選“back”按鈕返回英雄列表檢視。</p><p translation-origin=\"off\">The application still works. Clicking \"back\" returns to the hero list view.</p>\n\n<p translation-result=\"on\">注意瀏覽器的位址列。</p><p translation-origin=\"off\">Look at the browser address bar.</p>\n\n<p translation-result=\"on\">它應該是這樣的，不過也取決於你在哪裡執行它：</p><p translation-origin=\"off\">It should look something like this, depending on where you run it:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nlocalhost:4200/heroes;id=15;foo=foo\n\n</code-example>\n<p translation-result=\"on\"><code>id</code> 的值像這樣出現在 URL 中（<code>;id=15;foo=foo</code>），但不在 URL 的路徑部分。“Heroes”路由的路徑部分並沒有定義 <code>:id</code>。</p><p translation-origin=\"off\">The <code>id</code> value appears in the URL as (<code>;id=15;foo=foo</code>), not in the URL path.\nThe path for the \"Heroes\" route doesn't have an <code>:id</code> token.</p>\n\n<p translation-result=\"on\">可選的路由引數沒有使用“？”和“&amp;”符號分隔，因為它們將用在 URL 查詢字串中。它們是用“;”分隔的。這是<em>矩陣 URL</em>標記法。</p><p translation-origin=\"off\">The optional route parameters are not separated by \"?\" and \"&amp;\" as they would be in the URL query string.\nThey are separated by semicolons \";\".\nThis is matrix URL notation.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">Matrix URL 寫法首次提出是在<a href=\"https://www.w3.org/DesignIssues/MatrixURIs.html\">1996 提案</a>中，提出者是 Web 的奠基人：Tim Berners-Lee。</p><p translation-origin=\"off\">Matrix URL notation is an idea first introduced in a <a href=\"https://www.w3.org/DesignIssues/MatrixURIs.html\">1996 proposal</a> by the founder of the web, Tim Berners-Lee.</p>\n\n<p translation-result=\"on\">雖然 Matrix 寫法未曾進入過 HTML 標準，但它是合法的。而且在瀏覽器的路由系統中，它作為從父路由和子路由中單獨隔離出引數的方式而廣受歡迎。Angular 的路由器正是這樣一個路由系統，並支援跨瀏覽器的 Matrix 寫法。</p><p translation-origin=\"off\">Although matrix notation never made it into the HTML standard, it is legal and it became popular among browser routing systems as a way to isolate parameters belonging to parent and child routes.\nAs such, the Router provides support for the matrix notation across browsers.</p>\n\n</div>\n<p><a id=\"route-parameters-activated-route\"></a></p>\n<h3 id=\"route-parameters-in-the-activatedroute-service\" translation-result=\"on\"><code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 服務中的路由引數<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#activatedroute-服務中的路由引數\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Route parameters in the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#route-parameters-in-the-activatedroute-service\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">開發到現在，英雄列表還沒有變化。沒有突出顯示的英雄行。</p><p translation-origin=\"off\">In its current state of development, the list of heroes is unchanged.\nNo hero row is highlighted.</p>\n\n<p translation-result=\"on\"><code>HeroListComponent</code> 需要新增使用這些引數的程式碼。</p><p translation-origin=\"off\">The <code>HeroListComponent</code> needs code that expects parameters.</p>\n\n<p translation-result=\"on\">以前，當從 <code>HeroListComponent</code> 導航到 <code>HeroDetailComponent</code> 時，你透過 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 服務訂閱了路由引數這個 <code>Observable</code>，並讓它能用在 <code>HeroDetailComponent</code> 中。你把該服務注入到了 <code>HeroDetailComponent</code> 的建構函式中。</p><p translation-origin=\"off\">Previously, when navigating from the <code>HeroListComponent</code> to the <code>HeroDetailComponent</code>,\nyou subscribed to the route parameter map <code>Observable</code> and made it available to the <code>HeroDetailComponent</code>\nin the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> service.\nYou injected that service in the constructor of the <code>HeroDetailComponent</code>.</p>\n\n<p translation-result=\"on\">這次，你要進行反向導航，從 <code>HeroDetailComponent</code> 到 <code>HeroListComponent</code>。</p><p translation-origin=\"off\">This time you'll be navigating in the opposite direction, from the <code>HeroDetailComponent</code> to the <code>HeroListComponent</code>.</p>\n\n<p translation-result=\"on\">首先，擴充該路由的匯入陳述式，以包含進 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 服務的類；</p><p translation-origin=\"off\">First, extend the router import statement to include the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> service symbol:</p>\n\n<code-example header=\"src/app/heroes/hero-list/hero-list.component.ts (import)\" path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" region=\"import-router\">\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\n</code-example>\n<p translation-result=\"on\">匯入 <code>switchMap</code> 運運算元，在路由引數的 <code>Observable</code> 物件上執行操作。</p><p translation-origin=\"off\">Import the <code>switchMap</code> operator to perform an operation on the <code>Observable</code> of route parameter map.</p>\n\n<code-example header=\"src/app/heroes/hero-list/hero-list.component.ts (rxjs imports)\" path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" region=\"rxjs-imports\">\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n</code-example>\n<p translation-result=\"on\">在 <code>HeroListComponent</code> 建構函式中注入 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>。</p><p translation-origin=\"off\">Inject the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> in the <code>HeroListComponent</code> constructor.</p>\n\n<code-example header=\"src/app/heroes/hero-list/hero-list.component.ts (constructor and ngOnInit)\" path=\"router/src/app/heroes/hero-list/hero-list.component.ts\" region=\"ctor\">\nexport class HeroListComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes$!: Observable&lt;Hero[]&gt;;\n  selectedId = 0;\n\n  constructor(\n    private service: HeroService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>\n  ) {}\n\n  ngOnInit() {\n    this.heroes$ = this.route.paramMap.pipe(\n      switchMap(params =&gt; {\n        this.selectedId = parseInt(params.get('id')!, 10);\n        return this.service.getHeroes();\n      })\n    );\n  }\n}\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 屬性是一個路由引數的 <code>Observable</code>。當用戶導航到這個元件時，paramMap 會發射一個新值，其中包含 <code>id</code>。在 <code>ngOnInit()</code> 中，你訂閱了這些值，設定到 <code>selectedId</code>，並獲取英雄資料。</p><p translation-origin=\"off\">The <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> property is an <code>Observable</code> map of route parameters.\nThe <code>paramMap</code> emits a new map of values that includes <code>id</code> when the user navigates to the component.\nIn <code>ngOnInit()</code> you subscribe to those values, set the <code>selectedId</code>, and get the heroes.</p>\n\n<p translation-result=\"on\">用 <a href=\"guide/class-binding\">CSS 類繫結</a>更新範本。\n如果該方法返回 <code>true</code>，此繫結就會新增 CSS 類 <code>selected</code>，否則就移除它。\n在 <code>&lt;li&gt;</code> 標記中找到它，就像這樣：</p><p translation-origin=\"off\">Update the template with a <a href=\"guide/class-binding\">class binding</a>.\nThe binding adds the <code>selected</code> CSS class when the comparison returns <code>true</code> and removes it when <code>false</code>.\nLook for it within the repeated <code>&lt;li&gt;</code> tag as shown here:</p>\n\n<code-example header=\"src/app/heroes/hero-list/hero-list.component.html\" path=\"router/src/app/heroes/hero-list/hero-list.component.html\">\n&lt;h2&gt;Heroes&lt;/h2&gt;\n&lt;ul class=\"heroes\"&gt;\n  &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes$ | async\" [class.selected]=\"hero.id === selectedId\"&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\"&gt;\n      &lt;span class=\"badge\"&gt;{{ hero.id }}&lt;/span&gt;{{ hero.name }}\n    &lt;/a&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;button type=\"button\" <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/sidekicks\"&gt;Go to sidekicks&lt;/button&gt;\n\n\n</code-example>\n<p translation-result=\"on\">當選中列表條目時，要新增一些樣式。</p><p translation-origin=\"off\">Add some styles to apply when the hero is selected.</p>\n\n<code-example header=\"src/app/heroes/hero-list/hero-list.component.css\" path=\"router/src/app/heroes/hero-list/hero-list.component.css\" region=\"selected\">\n.heroes .selected a {\n  background-color: #d6e6f7;\n}\n\n.heroes .selected a:hover {\n  background-color: #bdd7f5;\n}\n\n</code-example>\n<p translation-result=\"on\">當用戶從英雄列表導航到英雄“Magneta”並返回時，“Magneta”看起來是選中的：</p><p translation-origin=\"off\">When the user navigates from the heroes list to the \"Magneta\" hero and back, \"Magneta\" appears selected:</p>\n\n<div class=\"lightbox\">\n<img alt=\"Selected hero in list has different background color\" src=\"generated/images/guide/router/selected-hero.png\" width=\"600\" height=\"173\">\n</div>\n<p translation-result=\"on\">這個可選的 <code>foo</code> 路由引數人畜無害，路由器會繼續忽略它。</p><p translation-origin=\"off\">The optional <code>foo</code> route parameter is harmless and the router continues to ignore it.</p>\n\n<p><a id=\"route-animation\"></a></p>\n<h3 id=\"adding-routable-animations\" translation-result=\"on\">新增路由動畫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#adding-routable-animations\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Adding routable animations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#adding-routable-animations\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在這一節，你將為<em>英雄詳情</em>元件新增一些<a href=\"guide/animations\">動畫</a>。</p><p translation-origin=\"off\">This section shows you how to add some <a href=\"guide/animations\">animations</a> to the <code>HeroDetailComponent</code>.</p>\n\n<p translation-result=\"on\">首先匯入 <code><a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a></code>，並新增到 <code>imports</code> 陣列中：</p><p translation-origin=\"off\">First, import the <code><a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a></code> and add it to the <code>imports</code> array:</p>\n\n<code-example header=\"src/app/app.module.ts (animations-module)\" path=\"router/src/app/app.module.ts\" region=\"animations-module\">\nimport { <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a> } from '@angular/platform-browser/animations';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a>,\n  ],\n})\n\n</code-example>\n<p translation-result=\"on\">接下來，為指向 <code>HeroListComponent</code> 和 <code>HeroDetailComponent</code> 的路由定義新增一個 <code>data</code> 物件。\n過渡是基於 <a href=\"api/animations/state\"><code>state</code></a> 的，你將使用來自路由的 <code><a href=\"api/animations/animation\" class=\"code-anchor\">animation</a></code> 資料為過渡提供一個有名字的動畫 <code>state</code>。</p><p translation-origin=\"off\">Next, add a <code>data</code> object to the routes for <code>HeroListComponent</code> and <code>HeroDetailComponent</code>.\nTransitions are based on <code>states</code> and you use the <code><a href=\"api/animations/animation\" class=\"code-anchor\">animation</a></code> data from the route to provide a named animation <a href=\"api/animations/state\"><code>state</code></a> for the transitions.</p>\n\n<code-example header=\"src/app/heroes/heroes-routing.module.ts (animation data)\" path=\"router/src/app/heroes/heroes-routing.module.2.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\n\nconst heroesRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'heroes',  component: HeroListComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'heroes' } },\n  { path: 'hero/:id', component: HeroDetailComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'hero' } }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-example>\n<p translation-result=\"on\">在根目錄 <code>src/app/</code> 下建立一個 <code>animations.ts</code>。內容如下：</p><p translation-origin=\"off\">Create an <code>animations.ts</code> file in the root <code>src/app/</code> folder. The contents look like this:</p>\n\n<code-example header=\"src/app/animations.ts (excerpt)\" path=\"router/src/app/animations.ts\">\nimport {\n  <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>, <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>, group,\n  <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>, <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>, <a href=\"api/animations/style\" class=\"code-anchor\">style</a>, <a href=\"api/animations/query\" class=\"code-anchor\">query</a>\n} from '@angular/animations';\n\n\n// Routable animations\nexport const slideInAnimation =\n  <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>('routeAnimation', [\n    <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>('heroes &lt;=&gt; hero', [\n      <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ position: 'relative' }),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter, :leave', [\n        <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%'\n        })\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', [\n        <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '-100%'})\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':leave', <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>()),\n      group([\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':leave', [\n          <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('300ms ease-out', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '100%'}))\n        ]),\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', [\n          <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('300ms ease-out', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '0%'}))\n        ])\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>()),\n    ])\n  ]);\n\n\n</code-example>\n<p translation-result=\"on\">該檔案做了如下工作：</p><p translation-origin=\"off\">This file does the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">匯入動畫符號以建構動畫觸發器、控制狀態並管理狀態之間的過渡。</p><p translation-origin=\"off\">Imports the animation symbols that build the animation triggers, control state, and manage transitions between states</p>\n\n</li>\n<li>\n<p translation-result=\"on\">匯出了一個名叫 <code>slideInAnimation</code> 的常量，並把它設定為一個名叫 <code>routeAnimation</code> 的動畫觸發器。</p><p translation-origin=\"off\">Exports a constant named <code>slideInAnimation</code> set to an animation trigger named <code>routeAnimation</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">定義一個過渡動畫，當在 <code>heroes</code> 和 <code>hero</code> 路由之間來回切換時，如果進入（<code>:enter</code>）應用檢視則讓元件從螢幕的左側滑入，如果離開（<code>:leave</code>）應用檢視則讓元件從右側劃出。</p><p translation-origin=\"off\">Defines one transition when switching back and forth from the <code>heroes</code> and <code>hero</code> routes to ease the component in from the left of the screen as it enters the application view (<code>:enter</code>), the other to animate the component to the right as it leaves the application view (<code>:leave</code>)</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">回到 <code>AppComponent</code>，從 <code>@angular/router</code> 套件匯入 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>，並從 <code>'./animations.ts</code> 匯入 <code>slideInAnimation</code>。</p><p translation-origin=\"off\">Back in the <code>AppComponent</code>, import the <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> token from the <code>@angular/router</code> package and the <code>slideInAnimation</code> from <code>'./animations.ts</code>.</p>\n\n<p translation-result=\"on\">為包含 <code>slideInAnimation</code> 的 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 元資料新增一個 <code>animations</code> 陣列。</p><p translation-origin=\"off\">Add an <code>animations</code> array to the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> metadata that contains the <code>slideInAnimation</code>.</p>\n\n<code-example header=\"src/app/app.component.ts (animations)\" path=\"router/src/app/app.component.2.ts\" region=\"animation-imports\">\nimport { <a href=\"api/router/ChildrenOutletContexts\" class=\"code-anchor\">ChildrenOutletContexts</a> } from '@angular/router';\nimport { slideInAnimation } from './animations';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  templateUrl: 'app.component.html',\n  styleUrls: ['app.component.css'],\n  animations: [ slideInAnimation ]\n})\n\n</code-example>\n<p translation-result=\"on\">要想使用路由動畫，就要把 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 包裝到一個元素中。再把 <code>@routeAnimation</code> 觸發器繫結到該元素上。</p><p translation-origin=\"off\">To use the routable animations, wrap the <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> inside an element, use the <code>@routeAnimation</code> trigger, and bind it to the element.</p>\n\n<p translation-result=\"on\">為了把 <code>@routeAnimation</code> 過渡過渡到指定的狀態，你需要從 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 的 <code>data</code> 中提供它。<code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 匯出成了一個範本變數 <code>outlet</code>，這樣你就可以繫結一個到路由出口的參考了。這個例子中使用了一個 <code>routerOutlet</code> 變數。</p><p translation-origin=\"off\">For the <code>@routeAnimation</code> transitions to key off states, provide it with the <code>data</code> from the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>.\nThe <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> is exposed as an <code>outlet</code> template variable, so you bind a reference to the router outlet.\nThis example uses a variable of <code>routerOutlet</code>.</p>\n\n<code-example header=\"src/app/app.component.html (router outlet)\" path=\"router/src/app/app.component.2.html\">\n&lt;h1&gt;Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Crisis Center&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Heroes&lt;/a&gt;\n&lt;/nav&gt;\n&lt;div [@routeAnimation]=\"getAnimationData()\"&gt;\n  &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n&lt;/div&gt;\n\n</code-example>\n<p translation-result=\"on\"><code>@routeAnimation</code> 屬性繫結到了 <code>getAnimationData()</code>，它會根據主路由所提供的 <code>data</code> 物件返回 <code><a href=\"api/animations/animation\" class=\"code-anchor\">animation</a></code> 屬性。<code><a href=\"api/animations/animation\" class=\"code-anchor\">animation</a></code> 屬性會根據你在 <code>animations.ts</code> 中定義 <code>slideInAnimation</code> 時使用的 <code><a href=\"api/animations/transition\" class=\"code-anchor\">transition</a></code> 名稱進行匹配。</p><p translation-origin=\"off\">The <code>@routeAnimation</code> property is bound to the <code>getAnimationData()</code> which returns the animation property from the <code>data</code> provided by the primary route. The <code><a href=\"api/animations/animation\" class=\"code-anchor\">animation</a></code> property matches the <code><a href=\"api/animations/transition\" class=\"code-anchor\">transition</a></code> names you used in the <code>slideInAnimation</code> defined in <code>animations.ts</code>.</p>\n\n<code-example header=\"src/app/app.component.ts (router outlet)\" path=\"router/src/app/app.component.2.ts\" region=\"function-binding\">\nexport class AppComponent {\n  constructor(private contexts: <a href=\"api/router/ChildrenOutletContexts\" class=\"code-anchor\">ChildrenOutletContexts</a>) {}\n\n  getAnimationData() {\n      return this.contexts.getContext('primary')?.route?.snapshot?.data?.['<a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>'];\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">如果在兩個路由之間切換，導航進來時，<code>HeroDetailComponent</code> 和 <code>HeroListComponent</code> 會從左側滑入；導航離開時將會從右側劃出。</p><p translation-origin=\"off\">When switching between the two routes, the <code>HeroDetailComponent</code> and <code>HeroListComponent</code> now ease in from the left when routed to, and slide to the right when navigating away.</p>\n\n<p><a id=\"milestone-3-wrap-up\"></a></p>\n<h3 id=\"milestone-3-wrap-up\" translation-result=\"on\">里程碑 3 的小結<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-3-wrap-up\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Milestone 3 wrap up<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-3-wrap-up\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">本節包括以下內容：</p><p translation-origin=\"off\">This section covered the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">把應用組織成特性區</p><p translation-origin=\"off\">Organizing the application into feature areas</p>\n\n</li>\n<li>\n<p translation-result=\"on\">命令式的從一個元件導航到另一個</p><p translation-origin=\"off\">Navigating imperatively from one component to another</p>\n\n</li>\n<li>\n<p translation-result=\"on\">透過路由引數傳遞資訊，並在元件中訂閱它們</p><p translation-origin=\"off\">Passing information along in route parameters and subscribe to them in the component</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把這個特性分割槽模組匯入根模組 <code>AppModule</code></p><p translation-origin=\"off\">Importing the feature area NgModule into the <code>AppModule</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">把動畫應用到路由元件上</p><p translation-origin=\"off\">Applying routable animations based on the page</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">做完這些修改之後，目錄結構如下：</p><p translation-origin=\"off\">After these changes, the folder structure is as follows:</p>\n\n<div class=\"filetree\">\n  <div class=\"file\">\n    angular-router-tour-of-heroes\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      src\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        app\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          crisis-list\n        </div>\n          <div class=\"children\">\n            <div class=\"file\">\n              crisis-list.component.css\n            </div>\n            <div class=\"file\">\n              crisis-list.component.html\n            </div>\n            <div class=\"file\">\n              crisis-list.component.ts\n            </div>\n          </div>\n        <div class=\"file\">\n          heroes\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            hero-detail\n          </div>\n            <div class=\"children\">\n              <div class=\"file\">\n                hero-detail.component.css\n              </div>\n              <div class=\"file\">\n                hero-detail.component.html\n              </div>\n              <div class=\"file\">\n                hero-detail.component.ts\n              </div>\n            </div>\n          <div class=\"file\">\n            hero-list\n          </div>\n            <div class=\"children\">\n              <div class=\"file\">\n                hero-list.component.css\n              </div>\n              <div class=\"file\">\n                hero-list.component.html\n              </div>\n              <div class=\"file\">\n                hero-list.component.ts\n              </div>\n            </div>\n          <div class=\"file\">\n            hero.service.ts\n          </div>\n          <div class=\"file\">\n            hero.ts\n          </div>\n          <div class=\"file\">\n            heroes-routing.module.ts\n          </div>\n          <div class=\"file\">\n            heroes.module.ts\n          </div>\n          <div class=\"file\">\n            mock-heroes.ts\n          </div>\n        </div>\n        <div class=\"file\">\n          page-not-found\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            page-not-found.component.css\n          </div>\n          <div class=\"file\">\n            page-not-found.component.html\n          </div>\n          <div class=\"file\">\n            page-not-found.component.ts\n          </div>\n        </div>\n      </div>\n      <div class=\"file\">\n        animations.ts\n      </div>\n      <div class=\"file\">\n        app.component.css\n      </div>\n      <div class=\"file\">\n        app.component.html\n      </div>\n      <div class=\"file\">\n        app.component.ts\n      </div>\n      <div class=\"file\">\n        app.module.ts\n      </div>\n      <div class=\"file\">\n        app-routing.module.ts\n      </div>\n      <div class=\"file\">\n        main.ts\n      </div>\n      <div class=\"file\">\n        message.service.ts\n      </div>\n      <div class=\"file\">\n        index.html\n      </div>\n      <div class=\"file\">\n        styles.css\n      </div>\n      <div class=\"file\">\n        tsconfig.json\n      </div>\n    </div>\n    <div class=\"file\">\n      node_modules …\n    </div>\n    <div class=\"file\">\n      package.json\n    </div>\n  </div>\n</div>\n<p translation-result=\"on\">這裡是當前版本的範例程式相關檔案。</p><p translation-origin=\"off\">Here are the relevant files for this version of the sample application.</p>\n\n<code-tabs>\n    <code-pane header=\"animations.ts\" path=\"router/src/app/animations.ts\">\nimport {\n  <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>, <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>, group,\n  <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>, <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>, <a href=\"api/animations/style\" class=\"code-anchor\">style</a>, <a href=\"api/animations/query\" class=\"code-anchor\">query</a>\n} from '@angular/animations';\n\n\n// Routable animations\nexport const slideInAnimation =\n  <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>('routeAnimation', [\n    <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>('heroes &lt;=&gt; hero', [\n      <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ position: 'relative' }),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter, :leave', [\n        <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%'\n        })\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', [\n        <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '-100%'})\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':leave', <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>()),\n      group([\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':leave', [\n          <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('300ms ease-out', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '100%'}))\n        ]),\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', [\n          <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('300ms ease-out', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({ left: '0%'}))\n        ])\n      ]),\n      <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(':enter', <a href=\"api/animations/animateChild\" class=\"code-anchor\">animateChild</a>()),\n    ])\n  ]);\n\n\n</code-pane>\n    <code-pane header=\"app.component.html\" path=\"router/src/app/app.component.2.html\">\n&lt;h1&gt;Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Crisis Center&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Heroes&lt;/a&gt;\n&lt;/nav&gt;\n&lt;div [@routeAnimation]=\"getAnimationData()\"&gt;\n  &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n&lt;/div&gt;\n\n</code-pane>\n    <code-pane header=\"app.component.ts\" path=\"router/src/app/app.component.2.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/router/ChildrenOutletContexts\" class=\"code-anchor\">ChildrenOutletContexts</a> } from '@angular/router';\nimport { slideInAnimation } from './animations';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  templateUrl: 'app.component.html',\n  styleUrls: ['app.component.css'],\n  animations: [ slideInAnimation ]\n})\nexport class AppComponent {\n  constructor(private contexts: <a href=\"api/router/ChildrenOutletContexts\" class=\"code-anchor\">ChildrenOutletContexts</a>) {}\n\n  getAnimationData() {\n      return this.contexts.getContext('primary')?.route?.snapshot?.data?.['<a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>'];\n  }\n}\n\n\n</code-pane>\n    <code-pane header=\"app.module.ts\" path=\"router/src/app/app.module.3.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a> } from '@angular/platform-browser/animations';\n\nimport { AppComponent } from './app.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule } from './heroes/heroes.module';\n\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    CrisisListComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-pane>\n    <code-pane header=\"app-routing.module.ts\" path=\"router/src/app/app-routing.module.2.ts\" region=\"milestone3\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\n/* . . . */\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'crisis-center', component: CrisisListComponent },\n/* . . . */\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &lt;-- debugging purposes only\n    )\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n</code-pane>\n    <code-pane header=\"hero-list.component.css\" path=\"router/src/app/heroes/hero-list/hero-list.component.css\">\n/* HeroListComponent's private CSS styles */\n.heroes {\n  margin: 0 0 2em 0;\n  list-style-type: none;\n  padding: 0;\n  width: 100%;\n}\n.heroes li {\n  position: relative;\n  cursor: pointer;\n}\n\n.heroes li:hover {\n  left: .1em;\n}\n\n.heroes a {\n  color: black;\n  text-decoration: none;\n  display: block;\n  font-size: 1.2rem;\n  background-color: #eee;\n  margin: .5rem .5rem .5rem 0;\n  padding: .5rem 0;\n  border-radius: 4px;\n}\n\n.heroes a:hover {\n  color: #2c3a41;\n  background-color: #e6e6e6;\n}\n\n.heroes a:active {\n  background-color: #525252;\n  color: #fafafa;\n}\n\n.heroes .selected a {\n  background-color: #d6e6f7;\n}\n\n.heroes .selected a:hover {\n  background-color: #bdd7f5;\n}\n\n.heroes .badge {\n  padding: .5em .6em;\n  color: white;\n  background-color: #435b60;\n  min-width: 16px;\n  margin-right: .8em;\n  border-radius: 4px 0 0 4px;\n}\n\n\n</code-pane>\n    <code-pane header=\"hero-list.component.html\" path=\"router/src/app/heroes/hero-list/hero-list.component.html\">\n&lt;h2&gt;Heroes&lt;/h2&gt;\n&lt;ul class=\"heroes\"&gt;\n  &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes$ | async\" [class.selected]=\"hero.id === selectedId\"&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\"&gt;\n      &lt;span class=\"badge\"&gt;{{ hero.id }}&lt;/span&gt;{{ hero.name }}\n    &lt;/a&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;button type=\"button\" <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/sidekicks\"&gt;Go to sidekicks&lt;/button&gt;\n\n\n</code-pane>\n    <code-pane header=\"hero-list.component.ts\" path=\"router/src/app/heroes/hero-list/hero-list.component.ts\">\n// TODO: Feature Componetized like CrisisCenter\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\nimport { HeroService } from '../hero.service';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  templateUrl: './hero-list.component.html',\n  styleUrls: ['./hero-list.component.css']\n})\nexport class HeroListComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes$!: Observable&lt;Hero[]&gt;;\n  selectedId = 0;\n\n  constructor(\n    private service: HeroService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>\n  ) {}\n\n  ngOnInit() {\n    this.heroes$ = this.route.paramMap.pipe(\n      switchMap(params =&gt; {\n        this.selectedId = parseInt(params.get('id')!, 10);\n        return this.service.getHeroes();\n      })\n    );\n  }\n}\n\n\n</code-pane>\n    <code-pane header=\"hero-detail.component.html\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.html\">\n&lt;h2&gt;Heroes&lt;/h2&gt;\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero$ | async as hero\"&gt;\n  &lt;h3&gt;{{ hero.name }}&lt;/h3&gt;\n  &lt;p&gt;Id: {{ hero.id }}&lt;/p&gt;\n  &lt;label for=\"hero-name\"&gt;Hero name: &lt;/label&gt;\n  &lt;input type=\"text\" id=\"hero-name\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" placeholder=\"name\"/&gt;\n  &lt;button type=\"button\" (click)=\"gotoHeroes(hero)\"&gt;Back&lt;/button&gt;\n&lt;/div&gt;\n\n\n</code-pane>\n    <code-pane header=\"hero-detail.component.ts\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.3.ts\">\nimport { switchMap } from 'rxjs/operators';\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { HeroService } from '../hero.service';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-detail',\n  templateUrl: './hero-detail.component.html',\n  styleUrls: ['./hero-detail.component.css']\n})\nexport class HeroDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  hero$!: Observable&lt;Hero&gt;;\n\n  constructor(\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n    private service: HeroService\n  ) {}\n\n  ngOnInit() {\n    this.hero$ = this.route.paramMap.pipe(\n      switchMap((params: <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a>) =&gt;\n        this.service.getHero(params.get('id')!))\n    );\n  }\n\n  gotoHeroes(hero: Hero) {\n    const heroId = hero ? hero.id : null;\n    // Pass along the hero id if available\n    // so that the HeroList component can select that hero.\n    // Include a junk 'foo' property for fun.\n    this.router.navigate(['/heroes', { id: heroId, foo: 'foo' }]);\n  }\n}\n\n\n</code-pane>\n    <code-pane header=\"hero.service.ts\" path=\"router/src/app/heroes/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\nimport { Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { Hero } from './hero';\nimport { HEROES } from './mock-heroes';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class HeroService {\n\n  constructor(private messageService: MessageService) { }\n\n  getHeroes(): Observable&lt;Hero[]&gt; {\n    // TODO: send the message _after_ fetching the heroes\n    this.messageService.add('HeroService: fetched heroes');\n    return of(HEROES);\n  }\n\n  getHero(id: number | string) {\n    return this.getHeroes().pipe(\n      // (+) before `id` turns the string into a number\n      map((heroes: Hero[]) =&gt; heroes.find(hero =&gt; hero.id === +id)!)\n    );\n  }\n}\n\n\n\n</code-pane>\n    <code-pane header=\"heroes.module.ts\" path=\"router/src/app/heroes/heroes.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\n\nimport { HeroesRoutingModule } from './heroes-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesRoutingModule\n  ],\n  declarations: [\n    HeroListComponent,\n    HeroDetailComponent\n  ]\n})\nexport class HeroesModule {}\n\n\n</code-pane>\n    <code-pane header=\"heroes-routing.module.ts\" path=\"router/src/app/heroes/heroes-routing.module.2.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\n\nconst heroesRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'heroes',  component: HeroListComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'heroes' } },\n  { path: 'hero/:id', component: HeroDetailComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'hero' } }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-pane>\n    <code-pane header=\"message.service.ts\" path=\"router/src/app/message.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class MessageService {\n  messages: string[] = [];\n\n  add(message: string) {\n    this.messages.push(message);\n  }\n\n  clear() {\n    this.messages = [];\n  }\n}\n\n\n</code-pane>\n</code-tabs>\n<p><a id=\"milestone-4\"></a></p>\n<h2 id=\"milestone-4-crisis-center-feature\" translation-result=\"on\">里程碑 4：危機中心<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-4-crisis-center-feature\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Milestone 4: Crisis center feature<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-4-crisis-center-feature\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本節將向你展示如何在應用中新增子路由並使用相對路由。</p><p translation-origin=\"off\">This section shows you how to add child routes and use relative routing in your app.</p>\n\n<p translation-result=\"on\">要為應用當前的危機中心新增更多特性，請執行類似於 heroes 特性的步驟：</p><p translation-origin=\"off\">To add more features to the application's current crisis center, take similar steps as for the heroes feature:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">在 <code>src/app</code> 目錄下建立一個 <code>crisis-center</code> 子目錄</p><p translation-origin=\"off\">Create a <code>crisis-center</code> subfolder in the <code>src/app</code> folder</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把 <code>app/heroes</code> 中的檔案和目錄複製到新的 <code>crisis-center</code> 資料夾中</p><p translation-origin=\"off\">Copy the files and folders from <code>app/heroes</code> into the new <code>crisis-center</code> folder</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在這些新建的檔案中，把每個 \"hero\" 都改成 \"crisis\"，每個 \"heroes\" 都改成 \"crises\"</p><p translation-origin=\"off\">In the new files, change every mention of \"hero\" to \"crisis\", and \"heroes\" to \"crises\"</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把這些 NgModule 檔案改名為 <code>crisis-center.module.ts</code> 和 <code>crisis-center-routing.module.ts</code></p><p translation-origin=\"off\">Rename the NgModule files to <code>crisis-center.module.ts</code> and <code>crisis-center-routing.module.ts</code></p>\n\n</li>\n</ul>\n<p translation-result=\"on\">使用 mock 的 crises 來代替 mock 的 heroes：</p><p translation-origin=\"off\">Use mock crises instead of mock heroes:</p>\n\n<code-example header=\"src/app/crisis-center/mock-crises.ts\" path=\"router/src/app/crisis-center/mock-crises.ts\">\nimport { Crisis } from './crisis';\n\nexport const CRISES: Crisis[] = [\n  { id: 1, name: 'Dragon Burning Cities' },\n  { id: 2, name: 'Sky Rains Great White Sharks' },\n  { id: 3, name: 'Giant Asteroid Heading For Earth' },\n  { id: 4, name: 'Procrastinators Meeting Delayed Again' },\n];\n\n\n</code-example>\n<p translation-result=\"on\">最終的危機中心可以作為引入子路由這個新概念的基礎。你可以把英雄管理保持在當前狀態，以便和<em>危機中心</em>進行對比。</p><p translation-origin=\"off\">The resulting crisis center is a foundation for introducing a new concept —child routing.\nYou can leave Heroes in its current state as a contrast with the Crisis Center.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">遵循<a href=\"https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\" title=\"Separation of Concerns\"><em>關注點分離（Separation of Concerns）</em>原則</a>，對<em>危機中心</em>的修改不會影響 <code>AppModule</code> 或其它特性模組中的元件。</p><p translation-origin=\"off\">In keeping with the <a href=\"https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\" title=\"Separation of Concerns\">Separation of Concerns principle</a>, changes to the Crisis Center don't affect the <code>AppModule</code> or any other feature's component.</p>\n\n</div>\n<p><a id=\"crisis-child-routes\"></a></p>\n<h3 id=\"a-crisis-center-with-child-routes\" translation-result=\"on\">帶有子路由的危機中心<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#a-crisis-center-with-child-routes\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">A crisis center with child routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#a-crisis-center-with-child-routes\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">本節會展示如何組織危機中心，來滿足 Angular 應用所推薦的模式：</p><p translation-origin=\"off\">This section shows you how to organize the crisis center to conform to the following recommended pattern for Angular applications:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">把每個特性放在自己的目錄中</p><p translation-origin=\"off\">Each feature area resides in its own folder</p>\n\n</li>\n<li>\n<p translation-result=\"on\">每個特性都有自己的 Angular 特性模組</p><p translation-origin=\"off\">Each feature has its own Angular feature module</p>\n\n</li>\n<li>\n<p translation-result=\"on\">每個特性區都有自己的根元件</p><p translation-origin=\"off\">Each area has its own area root component</p>\n\n</li>\n<li>\n<p translation-result=\"on\">每個特性區的根元件中都有自己的路由出口及其子路由</p><p translation-origin=\"off\">Each area root component has its own router outlet and child routes</p>\n\n</li>\n<li>\n<p translation-result=\"on\">特性區內的路由很少（也許永遠不會）與其它特性區的路由產生交叉</p><p translation-origin=\"off\">Feature area routes rarely (if ever) cross with routes of other features</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">如果你的應用具有多個特性區，那些特性的元件樹可能由多個元件構成，每個都包含一些其它相關元件的分支。</p><p translation-origin=\"off\">If your application had many feature areas, the component trees might consist of multiple components for those features, each with branches of other, related, components.</p>\n\n<p><a id=\"child-routing-component\"></a></p>\n<h3 id=\"child-routing-component\" translation-result=\"on\">子路由元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#child-routing-component\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Child routing component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#child-routing-component\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 <code>crisis-center</code> 目錄下產生一個 <code>CrisisCenter</code> 元件：</p><p translation-origin=\"off\">Generate a <code>CrisisCenter</code> component in the <code>crisis-center</code> folder:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component crisis-center/crisis-center\n\n</code-example>\n<p translation-result=\"on\">使用如下程式碼更新元件範本：</p><p translation-origin=\"off\">Update the component template with the following markup:</p>\n\n<code-example header=\"src/app/crisis-center/crisis-center/crisis-center.component.html\" path=\"router/src/app/crisis-center/crisis-center/crisis-center.component.html\">\n&lt;h2&gt;Crisis Center&lt;/h2&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n\n</code-example>\n<p translation-result=\"on\"><code>CrisisCenterComponent</code> 和 <code>AppComponent</code> 有下列共同點：</p><p translation-origin=\"off\">The <code>CrisisCenterComponent</code> has the following in common with the <code>AppComponent</code>:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">它是危機中心特性區的<em>根</em>，正如 <code>AppComponent</code> 是整個應用的根</p><p translation-origin=\"off\">It is the root of the crisis center area, just as <code>AppComponent</code> is the root of the entire application</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它是危機管理特性區的殼，正如 <code>AppComponent</code> 是管理高層工作流的殼</p><p translation-origin=\"off\">It is a shell for the crisis management feature area, just as the <code>AppComponent</code> is a shell to manage the high-level workflow</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">就像大多數的殼一樣，<code>CrisisCenterComponent</code> 類是最小化的，因為它沒有業務邏輯，它的範本中沒有連結，只有一個標題和用於放置危機中心的子元件的 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>。</p><p translation-origin=\"off\">Like most shells, the <code>CrisisCenterComponent</code> class is minimal because it has no business logic, and its template has no links, just a title and <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> for the crisis center child component.</p>\n\n<p><a id=\"child-route-config\"></a></p>\n<h3 id=\"child-route-configuration\" translation-result=\"on\">子路由配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#child-route-configuration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Child route configuration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#child-route-configuration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 <code>crisis-center</code> 目錄下產生一個 <code>CrisisCenterHome</code> 元件，作為 \"危機中心\" 特性的宿主頁面。</p><p translation-origin=\"off\">As a host page for the \"Crisis Center\" feature, generate a <code>CrisisCenterHome</code> component in the <code>crisis-center</code> folder.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component crisis-center/crisis-center-home\n\n</code-example>\n<p translation-result=\"on\">用一條歡迎資訊修改 <code>Crisis Center</code> 中的範本。</p><p translation-origin=\"off\">Update the template with a welcome message to the <code>Crisis Center</code>.</p>\n\n<code-example header=\"src/app/crisis-center/crisis-center-home/crisis-center-home.component.html\" path=\"router/src/app/crisis-center/crisis-center-home/crisis-center-home.component.html\">\n&lt;h3&gt;Welcome to the Crisis Center&lt;/h3&gt;\n\n\n</code-example>\n<p translation-result=\"on\">把 <code>heroes-routing.module.ts</code> 檔案複製過來，改名為 <code>crisis-center-routing.module.ts</code>，並修改它。這次你要把子路由定義在父路由 <code>crisis-center</code> 中。</p><p translation-origin=\"off\">Update the <code>crisis-center-routing.module.ts</code> you renamed after copying it from <code>heroes-routing.module.ts</code> file.\nThis time, you define child routes within the parent <code>crisis-center</code> route.</p>\n\n<code-example header=\"src/app/crisis-center/crisis-center-routing.module.ts (Routes)\" path=\"router/src/app/crisis-center/crisis-center-routing.module.1.ts\" region=\"routes\">\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n</code-example>\n<p translation-result=\"on\">注意，父路由 <code>crisis-center</code> 有一個 <code>children</code> 屬性，它有一個包含 <code>CrisisListComponent</code> 的路由。<code>CrisisListComponent</code> 路由還有一個帶兩個路由的 <code>children</code> 陣列。</p><p translation-origin=\"off\">Notice that the parent <code>crisis-center</code> route has a <code>children</code> property with a single route containing the <code>CrisisListComponent</code>.\nThe <code>CrisisListComponent</code> route also has a <code>children</code> array with two routes.</p>\n\n<p translation-result=\"on\">這兩個路由分別導航到了<em>危機中心</em>的兩個子元件：<code>CrisisCenterHomeComponent</code> 和 <code>CrisisDetailComponent</code>。</p><p translation-origin=\"off\">These two routes navigate to the crisis center child components,\n<code>CrisisCenterHomeComponent</code> and <code>CrisisDetailComponent</code>, respectively.</p>\n\n<p translation-result=\"on\">對這些子路由的處理中有一些重要的差異。</p><p translation-origin=\"off\">There are important differences in the way the router treats child routes.</p>\n\n<p translation-result=\"on\">路由器會把這些路由對應的元件放在 <code>CrisisCenterComponent</code> 的 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 中，而不是 <code>AppComponent</code> 殼元件中的。</p><p translation-origin=\"off\">The router displays the components of these routes in the <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> of the <code>CrisisCenterComponent</code>, not in the <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> of the <code>AppComponent</code> shell.</p>\n\n<p translation-result=\"on\"><code>CrisisListComponent</code> 包含危機列表和一個 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code>，用以顯示 <code>Crisis Center Home</code> 和 <code>Crisis Detail</code> 這兩個路由元件。</p><p translation-origin=\"off\">The <code>CrisisListComponent</code> contains the crisis list and a <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> to display the <code>Crisis Center Home</code> and <code>Crisis Detail</code> route components.</p>\n\n<p translation-result=\"on\"><code>Crisis Detail</code> 路由是 <code>Crisis List</code> 的子路由。由於路由器預設會<a href=\"guide/router-tutorial-toh#reuse\">複用元件</a>，因此當你選擇了另一個危機時，<code>CrisisDetailComponent</code> 會被複用。\n作為對比，回頭看看 <code>Hero Detail</code> 路由，每當你從列表中選擇了不同的英雄時，<a href=\"guide/router-tutorial-toh#snapshot-the-no-observable-alternative\">都會重新建立該元件</a>。</p><p translation-origin=\"off\">The <code>Crisis Detail</code> route is a child of the <code>Crisis List</code>.\nThe router <a href=\"guide/router-tutorial-toh#reuse\">reuses components</a> by default, so the <code>Crisis Detail</code> component is re-used as you select different crises.\nIn contrast, back in the <code>Hero Detail</code> route, <a href=\"guide/router-tutorial-toh#snapshot-the-no-observable-alternative\">the component was recreated</a> each time you selected a different hero from the list of heroes.</p>\n\n<p translation-result=\"on\">在最上層，以 <code>/</code> 開頭的路徑指向的總是應用的根。但這裡是子路由。它們是在父路由路徑的基礎上做出的擴充。在路由樹中每深入一步，你就會在該路由的路徑上新增一個斜線 <code>/</code>（除非該路由的路徑是空的）。</p><p translation-origin=\"off\">At the top level, paths that begin with <code>/</code> refer to the root of the application.\nBut child routes extend the path of the parent route.\nWith each step down the route tree, you add a slash followed by the route path, unless the path is empty.</p>\n\n<p translation-result=\"on\">如果把該邏輯應用到危機中心中的導航，那麼父路徑就是 <code>/crisis-center</code>。</p><p translation-origin=\"off\">Apply that logic to navigation within the crisis center for which the parent path is <code>/crisis-center</code>.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">要導航到 <code>CrisisCenterHomeComponent</code>，完整的 URL 是 <code>/crisis-center</code> （<code>/crisis-center</code> + <code>''</code> + <code>''</code>）</p><p translation-origin=\"off\">To navigate to the <code>CrisisCenterHomeComponent</code>, the full URL is <code>/crisis-center</code> (<code>/crisis-center</code> + <code>''</code> + <code>''</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">要導航到 <code>CrisisDetailComponent</code> 以展示 <code>id=2</code> 的危機，完整的 URL 是 <code>/crisis-center/2</code> （<code>/crisis-center</code> + <code>''</code> + <code>'/2'</code>）</p><p translation-origin=\"off\">To navigate to the <code>CrisisDetailComponent</code> for a crisis with <code>id=2</code>, the full URL is <code>/crisis-center/2</code> (<code>/crisis-center</code> + <code>''</code> +  <code>'/2'</code>)</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">本例子中包含站點部分的絕對 URL，就是：</p><p translation-origin=\"off\">The absolute URL for the latter example, including the <code>localhost</code> origin, is as follows:</p>\n\n<code-example>\n\nlocalhost:4200/crisis-center/2\n\n</code-example>\n<p translation-result=\"on\">這裡是完整的 <code>crisis-center.routing.ts</code> 及其匯入陳述式。</p><p translation-origin=\"off\">Here's the complete <code>crisis-center-routing.module.ts</code> file with its imports.</p>\n\n<code-example header=\"src/app/crisis-center/crisis-center-routing.module.ts (excerpt)\" path=\"router/src/app/crisis-center/crisis-center-routing.module.1.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent } from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-example>\n<p><a id=\"import-crisis-module\"></a></p>\n<h3 id=\"import-crisis-center-module-into-the-appmodule-routes\" translation-result=\"on\">把危機中心模組匯入到 <code>AppModule</code> 的路由中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#import-crisis-center-module-into-the-appmodule-routes\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Import crisis center module into the <code>AppModule</code> routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#import-crisis-center-module-into-the-appmodule-routes\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">就像 <code>HeroesModule</code> 模組中一樣，你必須把 <code>CrisisCenterModule</code> 新增到 <code>AppModule</code> 的 <code>imports</code> 陣列中，就在 <code>AppRoutingModule</code> <em>前面</em>：</p><p translation-origin=\"off\">As with the <code>HeroesModule</code>, you must add the <code>CrisisCenterModule</code> to the <code>imports</code> array of the <code>AppModule</code>\n<em>before</em> the <code>AppRoutingModule</code>:</p>\n\n<code-tabs>\n    <code-pane header=\"src/app/crisis-center/crisis-center.module.ts\" path=\"router/src/app/crisis-center/crisis-center.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent } from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';\n\nimport { CrisisCenterRoutingModule } from './crisis-center-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    CrisisCenterRoutingModule\n  ],\n  declarations: [\n    CrisisCenterComponent,\n    CrisisListComponent,\n    CrisisCenterHomeComponent,\n    CrisisDetailComponent\n  ]\n})\nexport class CrisisCenterModule {}\n\n\n</code-pane>\n    <code-pane header=\"src/app/app.module.ts (import CrisisCenterModule)\" path=\"router/src/app/app.module.4.ts\" region=\"crisis-center-module\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule } from './heroes/heroes.module';\nimport { CrisisCenterModule } from './crisis-center/crisis-center.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    CrisisCenterModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-pane>\n</code-tabs>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">這些模組的匯入順序是至關重要的，因為這些模組中定義的路由的順序會影響路由的匹配順序。如果先匯入 <code>AppModule</code>，它的萬用字元路由 (<code>path: '**'</code>)。</p><p translation-origin=\"off\">The import order of the modules is important because the order of the routes defined in the modules affects route matching.\nIf the <code>AppModule</code> were imported first, its wildcard route (<code>path: '**'</code>) would take precedence over the routes defined in <code>CrisisCenterModule</code>.\nFor more information, see the section on <a href=\"guide/router#route-order\">route order</a>.</p>\n\n</div>\n<p translation-result=\"on\">從 <code>app.routing.ts</code> 中移除危機中心的初始路由。因為現在是 <code>HeroesModule</code> 和 <code>CrisisCenter</code> 模組提供了這些特性路由。</p><p translation-origin=\"off\">Remove the initial crisis center route from the <code>app-routing.module.ts</code> because now the <code>HeroesModule</code> and the <code>CrisisCenter</code> modules provide the feature routes.</p>\n\n<p translation-result=\"on\"><code>app-routing.module.ts</code> 檔案中只有應用的最上層路由，比如預設路由和萬用字元路由。</p><p translation-origin=\"off\">The <code>app-routing.module.ts</code> file retains the top-level application routes such as the default and wildcard routes.</p>\n\n<code-example header=\"src/app/app-routing.module.ts (v3)\" path=\"router/src/app/app-routing.module.3.ts\" region=\"v3\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // &lt;-- debugging purposes only\n    )\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n<p><a id=\"relative-navigation\"></a></p>\n<h3 id=\"relative-navigation\" translation-result=\"on\">相對導航<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#relative-navigation\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Relative navigation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#relative-navigation\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">雖然構建出了危機中心特性區，你卻仍在使用以斜槓開頭的<strong>絕對路徑</strong>來導航到危機詳情的路由。</p><p translation-origin=\"off\">While building out the crisis center feature, you navigated to the\ncrisis detail route using an absolute path that begins with a slash.</p>\n\n<p translation-result=\"on\">路由器會從路由配置的最上層來匹配像這樣的絕對路徑。</p><p translation-origin=\"off\">The router matches such absolute paths to routes starting from the top of the route configuration.</p>\n\n<p translation-result=\"on\">你固然可以繼續像危機中心特性區一樣使用絕對路徑，但是那樣會把連結釘死在特定的父路由結構上。如果你修改了父路徑 <code>/crisis-center</code>，那就不得不修改每一個連結引數陣列。</p><p translation-origin=\"off\">You could continue to use absolute paths like this to navigate inside the Crisis Center feature, but that pins the links to the parent routing structure.\nIf you changed the parent <code>/crisis-center</code> path, you would have to change the link parameters array.</p>\n\n<p translation-result=\"on\">透過改成定義<em>相對於</em>當前 URL 的路徑，你可以把連結從這種依賴中解放出來。當你修改了該特性區的父路由路徑時，該特性區內部的導航仍然完好無損。</p><p translation-origin=\"off\">You can free the links from this dependency by defining paths that are relative to the current URL segment.\nNavigation within the feature area remains intact even if you change the parent route path to the feature.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">路由器支援在<em>連結引數陣列</em>中使用“目錄式”語法來為查詢路由名提供幫助：</p><p translation-origin=\"off\">The router supports directory-like syntax in a <em>link parameters list</em> to help guide route name lookup:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">目錄式語法</nt-wrapper><nt-wrapper translation-origin=\"off\">Directory-like syntax</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><code>./</code> <br> <code>無前導斜線</code></nt-wrapper><nt-wrapper translation-origin=\"off\"><code>./</code> <br> <code>no leading slash</code></nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">形式是相對於當前級別的。</nt-wrapper><nt-wrapper translation-origin=\"off\">Relative to the current level.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>../</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">回到當前路由路徑的上一級。</nt-wrapper><nt-wrapper translation-origin=\"off\">Up one level in the route path.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">你可以把相對導航語法和一個祖先路徑組合起來用。如果不得不導航到一個兄弟路由，你可以用 <code>../&lt;sibling&gt;</code> 來回到上一級，然後進入兄弟路由路徑中。</p><p translation-origin=\"off\">You can combine relative navigation syntax with an ancestor path.\nIf you must navigate to a sibling route, you could use the <code>../&lt;sibling&gt;</code> convention to go up\none level, then over and down the sibling route path.</p>\n\n</div>\n<p translation-result=\"on\">用 <code>Router.navigate</code> 方法導航到相對路徑時，你必須提供當前的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>，來讓路由器知道你現在位於路由樹中的什麼位置。</p><p translation-origin=\"off\">To navigate a relative path with the <code>Router.navigate</code> method, you must supply the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>\nto give the router knowledge of where you are in the current route tree.</p>\n\n<p translation-result=\"on\">在<em>連結引數陣列</em>後面，新增一個帶有 <code>relativeTo</code> 屬性的物件，並把它設定為當前的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>。這樣路由器就會基於當前啟用路由的位置來計算出目標 URL。</p><p translation-origin=\"off\">After the <em>link parameters array</em>, add an object with a <code>relativeTo</code> property set to the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>.\nThe router then calculates the target URL based on the active route's location.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">當呼叫路由器的 <code>navigateByUrl()</code> 時，<strong>總是</strong>要指定完整的絕對路徑。</p><p translation-origin=\"off\">Always specify the complete absolute path when calling router's <code>navigateByUrl()</code> method.</p>\n\n</div>\n<p><a id=\"nav-to-crisis\"></a></p>\n<h3 id=\"navigate-to-crisis-list-with-a-relative-url\" translation-result=\"on\">使用相對 URL 導航到危機列表<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#navigate-to-crisis-list-with-a-relative-url\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Navigate to crisis list with a relative URL<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#navigate-to-crisis-list-with-a-relative-url\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你已經注入了組成相對導航路徑所需的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>。</p><p translation-origin=\"off\">You've already injected the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> that you need to compose the relative navigation path.</p>\n\n<p translation-result=\"on\">如果用 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 來代替 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 服務進行導航，就要使用相同的連結引數陣列，不過不再需要提供 <code>relativeTo</code> 屬性。<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 已經隱含在了 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令中。</p><p translation-origin=\"off\">When using a <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> to navigate instead of the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> service, you'd use the same link parameters array, but you wouldn't provide the object with the <code>relativeTo</code> property.\nThe <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> is implicit in a <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> directive.</p>\n\n<p translation-result=\"on\">修改 <code>CrisisDetailComponent</code> 的 <code>gotoCrises()</code> 方法，來使用相對路徑返回<em>危機中心</em>列表。</p><p translation-origin=\"off\">Update the <code>gotoCrises()</code> method of the <code>CrisisDetailComponent</code> to navigate back to the Crisis Center list using relative path navigation.</p>\n\n<code-example header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (relative navigation)\" path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" region=\"gotoCrises-navigate\">\n// Relative navigation back to the crises\nthis.router.navigate(['../', { id: crisisId, foo: 'foo' }], { relativeTo: this.route });\n\n</code-example>\n<p translation-result=\"on\">注意這個路徑使用了 <code>../</code> 語法返回上一級。如果當前危機的 <code>id</code> 是 <code>3</code>，那麼最終返回到的路徑就是 <code>/crisis-center/;id=3;foo=foo</code>。</p><p translation-origin=\"off\">Notice that the path goes up a level using the <code>../</code> syntax.\nIf the current crisis <code>id</code> is <code>3</code>, the resulting path back to the crisis list is  <code>/crisis-center/;id=3;foo=foo</code>.</p>\n\n<p><a id=\"named-outlets\"></a></p>\n<h3 id=\"displaying-multiple-routes-in-named-outlets\" translation-result=\"on\">用命名出口（outlet）顯示多重路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#displaying-multiple-routes-in-named-outlets\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Displaying multiple routes in named outlets<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#displaying-multiple-routes-in-named-outlets\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你決定給使用者提供一種方式來聯絡危機中心。當用戶點選“Contact”按鈕時，你要在一個彈出框中顯示一條訊息。</p><p translation-origin=\"off\">You decide to give users a way to contact the crisis center.\nWhen a user clicks a \"Contact\" button, you want to display a message in a popup view.</p>\n\n<p translation-result=\"on\">即使在應用中的不同頁面之間切換，這個彈出框也應該始終保持開啟狀態，直到使用者傳送了訊息或者手動取消。顯然，你不能把這個彈出框跟其它放到頁面放到同一個路由出口中。</p><p translation-origin=\"off\">The popup should stay open, even when switching between pages in the application, until the user closes it by sending the message or canceling.\nClearly you can't put the popup in the same outlet as the other pages.</p>\n\n<p translation-result=\"on\">迄今為止，你只定義過單路由出口，並且在其中嵌套了子路由以便對路由分組。在每個範本中，路由器只能支援一個無名主路由出口。</p><p translation-origin=\"off\">Until now, you've defined a single outlet and you've nested child routes under that outlet to group routes together.\nThe router only supports one primary unnamed outlet per template.</p>\n\n<p translation-result=\"on\">範本還可以有多個命名的路由出口。每個命名出口都自己有一組帶元件的路由。多重出口可以在同一時間根據不同的路由來顯示不同的內容。</p><p translation-origin=\"off\">A template can also have any number of named outlets.\nEach named outlet has its own set of routes with their own components.\nMultiple outlets can display different content, determined by different routes, all at the same time.</p>\n\n<p translation-result=\"on\">在 <code>AppComponent</code> 中新增一個名叫“popup”的出口，就在無名出口的下方。</p><p translation-origin=\"off\">Add an outlet named \"popup\" in the <code>AppComponent</code>, directly following the unnamed outlet.</p>\n\n<code-example header=\"src/app/app.component.html (outlets)\" path=\"router/src/app/app.component.4.html\" region=\"outlets\">\n&lt;div [@routeAnimation]=\"getAnimationData()\"&gt;\n  &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n&lt;/div&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> name=\"popup\"&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n</code-example>\n<p translation-result=\"on\">一旦你學會了如何把一個彈出框元件路由到該出口，那裡就是將會出現彈出框的地方。</p><p translation-origin=\"off\">That's where a popup goes, once you learn how to route a popup component to it.</p>\n\n<p><a id=\"secondary-routes\"></a></p>\n<h4 id=\"secondary-routes\" translation-result=\"on\">第二路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#secondary-routes\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Secondary routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#secondary-routes\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">命名出口是<em>第二路由</em>的目標。</p><p translation-origin=\"off\">Named outlets are the targets of <em>secondary routes</em>.</p>\n\n<p translation-result=\"on\">第二路由很像主路由，配置方式也一樣。它們只有一些關鍵的不同點。</p><p translation-origin=\"off\">Secondary routes look like primary routes and you configure them the same way.\nThey differ in a few key respects.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">它們彼此互不依賴</p><p translation-origin=\"off\">They are independent of each other</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它們與其它路由組合使用</p><p translation-origin=\"off\">They work in combination with other routes</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它們顯示在命名出口中</p><p translation-origin=\"off\">They are displayed in named outlets</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">產生一個新的元件來組合這個訊息。</p><p translation-origin=\"off\">Generate a new component to compose the message.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component compose-message\n\n</code-example>\n<p translation-result=\"on\">它顯示一個簡單的表單，包括一個頭、一個訊息輸入框和兩個按鈕：“Send”和“Cancel”。</p><p translation-origin=\"off\">It displays a short form with a header, an input box for the message,\nand two buttons, \"Send\" and \"Cancel\".</p>\n\n<div class=\"lightbox\">\n<img alt=\"Contact textarea with send and cancel buttons\" src=\"generated/images/guide/router/contact-form.png\" width=\"400\" height=\"377\">\n</div>\n<p translation-result=\"on\">下面是該元件及其範本和樣式：</p><p translation-origin=\"off\">Here's the component, its template, and styles:</p>\n\n<code-tabs>\n    <code-pane header=\"src/app/compose-message/compose-message.component.html\" path=\"router/src/app/compose-message/compose-message.component.html\">\n&lt;h3&gt;Contact Crisis Center&lt;/h3&gt;\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"details\"&gt;\n  {{ details }}\n&lt;/div&gt;\n&lt;div&gt;\n  &lt;div&gt;\n    &lt;label for=\"message\"&gt;Enter your message: &lt;/label&gt;\n  &lt;/div&gt;\n  &lt;div&gt;\n    &lt;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> id=\"message\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"message\" rows=\"10\" cols=\"35\" [disabled]=\"sending\"&gt;&lt;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"!sending\"&gt;\n  &lt;button type=\"button\" (click)=\"send()\"&gt;Send&lt;/button&gt;\n  &lt;button type=\"button\" (click)=\"cancel()\"&gt;Cancel&lt;/button&gt;\n&lt;/p&gt;\n\n\n</code-pane>\n    <code-pane header=\"src/app/compose-message/compose-message.component.ts\" path=\"router/src/app/compose-message/compose-message.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> } from '@angular/router';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-compose-message',\n  templateUrl: './compose-message.component.html',\n  styleUrls: ['./compose-message.component.css']\n})\nexport class ComposeMessageComponent {\n  details = '';\n  message = '';\n  sending = false;\n\n  constructor(private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  send() {\n    this.sending = true;\n    this.details = 'Sending Message...';\n\n    setTimeout(() =&gt; {\n      this.sending = false;\n      this.closePopup();\n    }, 1000);\n  }\n\n  cancel() {\n    this.closePopup();\n  }\n\n  closePopup() {\n    // Providing a `null` value to the named outlet\n    // clears the contents of the named outlet\n    this.router.navigate([{ outlets: { popup: null }}]);\n  }\n}\n\n\n</code-pane>\n    <code-pane header=\"src/app/compose-message/compose-message.component.css\" path=\"router/src/app/compose-message/compose-message.component.css\">\n<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> {\n  width: 100%;\n  margin-top: 1rem;\n  font-size: 1.2rem;\n  box-sizing: border-box;\n}\n\n\n</code-pane>\n</code-tabs>\n<p translation-result=\"on\">它看起來幾乎和你以前見過其它元件一樣，但有兩個值得注意的區別。</p><p translation-origin=\"off\">It looks similar to any other component in this guide, but there are two key differences.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n<code>send()</code> 方法透過在“傳送”訊息之前等待一秒並關閉彈出視窗來模擬延遲。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThe <code>send()</code> method simulates latency by waiting a second before \"sending\" the message and closing the popup.</p>\n\n</div>\n<p translation-result=\"on\"><code>closePopup()</code> 方法用把 <code>popup</code> 出口導航到 <code>null</code> 的方式關閉了彈出框，它在<a href=\"guide/router-tutorial-toh#clear-secondary-routes\">稍後的部分</a>有講解。</p><p translation-origin=\"off\">The <code>closePopup()</code> method closes the popup view by navigating to the popup outlet with a <code>null</code> which the section on <a href=\"guide/router-tutorial-toh#clear-secondary-routes\">clearing secondary routes</a> covers.</p>\n\n<p><a id=\"add-secondary-route\"></a></p>\n<h4 id=\"add-a-secondary-route\" translation-result=\"on\">新增第二路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#add-a-secondary-route\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Add a secondary route<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#add-a-secondary-route\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">開啟 <code>AppRoutingModule</code>，並把一個新的 <code>compose</code> 路由新增到 <code>appRoutes</code> 中。</p><p translation-origin=\"off\">Open the <code>AppRoutingModule</code> and add a new <code>compose</code> route to the <code>appRoutes</code>.</p>\n\n<code-example header=\"src/app/app-routing.module.ts (compose route)\" path=\"router/src/app/app-routing.module.3.ts\" region=\"compose\">\n{\n  path: 'compose',\n  component: ComposeMessageComponent,\n  outlet: 'popup'\n},\n\n</code-example>\n<p translation-result=\"on\">除了 <code>path</code> 和 <code>component</code> 屬性之外還有一個新的屬性 <code>outlet</code>，它被設定成了 <code>'popup'</code>。這個路由現在指向了 <code>popup</code> 出口，而 <code>ComposeMessageComponent</code> 也將顯示在那裡。</p><p translation-origin=\"off\">In addition to the <code>path</code> and <code>component</code> properties, there's a new property called <code>outlet</code>, which is set to <code>'popup'</code>.\nThis route now targets the popup outlet and the <code>ComposeMessageComponent</code> will display there.</p>\n\n<p translation-result=\"on\">為了給使用者某種途徑來開啟這個彈出框，還要往 <code>AppComponent</code> 範本中新增一個“Contact”連結。</p><p translation-origin=\"off\">To give users a way to open the popup, add a \"Contact\" link to the <code>AppComponent</code> template.</p>\n\n<code-example header=\"src/app/app.component.html (contact-link)\" path=\"router/src/app/app.component.4.html\" region=\"contact-link\">\n&lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[{ outlets: { popup: ['compose'] } }]\"&gt;Contact&lt;/a&gt;\n\n</code-example>\n<p translation-result=\"on\">雖然 <code>compose</code> 路由被配置到了 <code>popup</code> 出口上，但這仍然不足以把該路由和 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令聯絡起來。你還要在<em>連結引數陣列</em>中指定這個命名出口，並透過屬性繫結的形式把它繫結到 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 上。</p><p translation-origin=\"off\">Although the <code>compose</code> route is configured to the \"popup\" outlet, that's not sufficient for connecting the route to a <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> directive.\nYou have to specify the named outlet in a <em>link parameters array</em> and bind it to the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> with a property binding.</p>\n\n<p translation-result=\"on\"><em>連結引數陣列</em>包含一個只有一個 <code>outlets</code> 屬性的物件，它的值是另一個物件，這個物件以一個或多個路由的出口名作為屬性名。在這裡，它只有一個出口名“popup”，它的值則是另一個<em>連結引數陣列</em>，用於指定 <code>compose</code> 路由。</p><p translation-origin=\"off\">The <em>link parameters array</em> contains an object with a single <code>outlets</code> property whose value is another object keyed by one (or more) outlet names.\nIn this case there is only the \"popup\" outlet property and its value is another <em>link parameters array</em> that specifies the <code>compose</code> route.</p>\n\n<p translation-result=\"on\">換句話說，當用戶點選此連結時，路由器會在路由出口 <code>popup</code> 中顯示與 <code>compose</code> 路由相關聯的元件。</p><p translation-origin=\"off\">In other words, when the user clicks this link, the router displays the component associated with the <code>compose</code> route in the <code>popup</code> outlet.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">當只需要考慮一個路由和一個無名出口時，外部物件中的這個 <code>outlets</code> 物件是完全不必要的。</p><p translation-origin=\"off\">This <code>outlets</code> object within an outer object was unnecessary when there was only one route and one unnamed outlet.</p>\n\n<p translation-result=\"on\">路由器假設這個路由指向了無名的主出口，併為你建立這些物件。</p><p translation-origin=\"off\">The router assumed that your route specification targeted the unnamed primary outlet and created these objects for you.</p>\n\n<p translation-result=\"on\">路由到一個命名出口會揭示一個路由特性：你可以在同一個 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令中為多個路由出口指定多個路由。</p><p translation-origin=\"off\">Routing to a named outlet revealed a router feature:\nyou can target multiple outlets with multiple routes in the same <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> directive.</p>\n\n</div>\n<p><a id=\"secondary-route-navigation\"></a></p>\n<h4 id=\"secondary-route-navigation-merging-routes-during-navigation\" translation-result=\"on\">第二路由導航：在導航期間合併路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#secondary-route-navigation-merging-routes-during-navigation\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Secondary route navigation: merging routes during navigation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#secondary-route-navigation-merging-routes-during-navigation\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">導航到<em>危機中心</em>並點選“Contact”，你將會在瀏覽器的位址列看到如下 URL。</p><p translation-origin=\"off\">Navigate to the <em>Crisis Center</em> and click \"Contact\".\nyou should see something like the following URL in the browser address bar.</p>\n\n<code-example format=\"http\" language=\"http\">\n\n<a href=\"api/common/http\" class=\"code-anchor\">http</a>://…/crisis-center(popup:compose)\n\n</code-example>\n<p translation-result=\"on\">這個 URL 中有意義的部分是 <code>...</code> 後面的這些：</p><p translation-origin=\"off\">The relevant part of the URL follows the <code>...</code>:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>crisis-center</code> 是主導航。</p><p translation-origin=\"off\">The <code>crisis-center</code> is the primary navigation</p>\n\n</li>\n<li>\n<p translation-result=\"on\">圓括號包裹的部分是第二路由。</p><p translation-origin=\"off\">Parentheses surround the secondary route</p>\n\n</li>\n<li>\n<p translation-result=\"on\">第二路由包括一個出口名稱（<code>popup</code>）、一個冒號分隔符和第二路由的路徑（<code>compose</code>）。</p><p translation-origin=\"off\">The secondary route consists of an outlet name (<code>popup</code>), a <code>colon</code> separator, and the secondary route path (<code>compose</code>)</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">點選 <em>Heroes</em> 連結，並再次檢視 URL。</p><p translation-origin=\"off\">Click the <em>Heroes</em> link and look at the URL again.</p>\n\n<code-example format=\"http\" language=\"http\">\n\n<a href=\"api/common/http\" class=\"code-anchor\">http</a>://…/heroes(popup:compose)\n\n</code-example>\n<p translation-result=\"on\">主導航的部分變化了，而第二路由沒有變。</p><p translation-origin=\"off\">The primary navigation part changed; the secondary route is the same.</p>\n\n<p translation-result=\"on\">路由器在導航樹中對兩個獨立的分支保持追蹤，並在 URL 中對這棵樹進行表達。</p><p translation-origin=\"off\">The router is keeping track of two separate branches in a navigation tree and generating a representation of that tree in the URL.</p>\n\n<p translation-result=\"on\">你還可以新增更多出口和更多路由（無論是在最上層還是在巢狀(Nesting)的子層）來建立一個帶有多個分支的導航樹。路由器將會產生相應的 URL。</p><p translation-origin=\"off\">You can add many more outlets and routes, at the top level and in nested levels, creating a navigation tree with many branches and the router will generate the URLs to go with it.</p>\n\n<p translation-result=\"on\">透過像前面那樣填充 <code>outlets</code> 物件，你可以告訴路由器立即導航到一棵完整的樹。然後把這個物件透過一個<em>連結引數陣列</em>傳給 <code>router.navigate</code> 方法。</p><p translation-origin=\"off\">You can tell the router to navigate an entire tree at once by filling out the <code>outlets</code> object and then pass that object inside a <em>link parameters array</em> to the <code>router.navigate</code> method.</p>\n\n<p><a id=\"clear-secondary-routes\"></a></p>\n<h4 id=\"clearing-secondary-routes\" translation-result=\"on\">清除第二路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#clearing-secondary-routes\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Clearing secondary routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#clearing-secondary-routes\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">像常規出口一樣，二級出口會一直存在，直到你導航到新元件。</p><p translation-origin=\"off\">Like regular outlets, secondary outlets persists until you navigate away to a new component.</p>\n\n<p translation-result=\"on\">每個第二齣口都有自己獨立的導航，跟主出口的導航彼此獨立。修改主出口中的當前路由並不會影響到 <code>popup</code> 出口中的。這就是為什麼在危機中心和英雄管理之間導航時，彈出框始終都是可見的。</p><p translation-origin=\"off\">Each secondary outlet has its own navigation, independent of the navigation driving the primary outlet.\nChanging a current route that displays in the primary outlet has no effect on the popup outlet.\nThat's why the popup stays visible as you navigate among the crises and heroes.</p>\n\n<p translation-result=\"on\">再看 <code>closePopup()</code> 方法：</p><p translation-origin=\"off\">The <code>closePopup()</code> method again:</p>\n\n<code-example header=\"src/app/compose-message/compose-message.component.ts (closePopup)\" path=\"router/src/app/compose-message/compose-message.component.ts\" region=\"closePopup\">\nclosePopup() {\n  // Providing a `null` value to the named outlet\n  // clears the contents of the named outlet\n  this.router.navigate([{ outlets: { popup: null }}]);\n}\n\n</code-example>\n<p translation-result=\"on\">單擊 “send” 或 “cancel” 按鈕可以清除彈出檢視。<code>closePopup()</code> 函式會使用 <code><a href=\"api/router/Router#navigate\" class=\"code-anchor\">Router.navigate()</a></code> 方法強制導航，並傳入一個<a href=\"guide/router-tutorial-toh#link-parameters-array\">連結引數陣列</a>。</p><p translation-origin=\"off\">Clicking the \"send\" or \"cancel\" buttons clears the popup view.\nThe <code>closePopup()</code> function navigates imperatively with the <code><a href=\"api/router/Router#navigate\" class=\"code-anchor\">Router.navigate()</a></code> method, passing in a <a href=\"guide/router-tutorial-toh#link-parameters-array\">link parameters array</a>.</p>\n\n<p translation-result=\"on\">就像在 <code>AppComponent</code> 中繫結到的 <em>Contact</em> <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 一樣，它也包含了一個帶 <code>outlets</code> 屬性的物件。\n<code>outlets</code> 屬性的值是另一個物件，該物件用一些出口名稱作為屬性名。\n唯一的命名出口是 <code>'popup'</code>。</p><p translation-origin=\"off\">Like the array bound to the <em>Contact</em> <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> in the <code>AppComponent</code>, this one includes an object with an <code>outlets</code> property.\nThe <code>outlets</code> property value is another object with outlet names for keys.\nThe only named outlet is <code>'popup'</code>.</p>\n\n<p translation-result=\"on\">但這次，<code>'popup'</code> 的值是 <code>null</code>。<code>null</code> 不是一個路由，但卻是一個合法的值。把 <code>popup</code> 這個 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 設定為 <code>null</code> 會清除該出口，並且從當前 URL 中移除第二路由 <code>popup</code>。</p><p translation-origin=\"off\">This time, the value of <code>'popup'</code> is <code>null</code>.\nThat's not a route, but it is a legitimate value.\nSetting the popup <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> to <code>null</code> clears the outlet and removes the secondary popup route from the current URL.</p>\n\n<p><a id=\"guards\"></a>\n<a id=\"milestone-5-route-guards\"></a></p>\n<h2 id=\"milestone-5-route-guards\" translation-result=\"on\">里程碑 5：路由守衛<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-5-route-guards\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Milestone 5: Route guards<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-5-route-guards\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">現在，<em>任何使用者</em>都能在<em>任何時候</em>導航到<em>任何地方</em>。但有時候出於種種原因需要控制對該應用的不同部分的存取。可能包括如下場景：</p><p translation-origin=\"off\">At the moment, any user can navigate anywhere in the application any time, but sometimes you need to control access to different parts of your application for various reasons, some of which might include the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">該使用者可能無權導航到目標元件</p><p translation-origin=\"off\">Perhaps the user is not authorized to navigate to the target component</p>\n\n</li>\n<li>\n<p translation-result=\"on\">可能使用者得先登入（認證）</p><p translation-origin=\"off\">Maybe the user must login (authenticate) first</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在顯示目標元件前，你可能得先獲取某些資料</p><p translation-origin=\"off\">Maybe you should fetch some data before you display the target component</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在離開元件前，你可能要先儲存修改</p><p translation-origin=\"off\">You might want to save pending changes before leaving a component</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你可能要詢問使用者：你是否要放棄本次更改，而不用儲存它們？</p><p translation-origin=\"off\">You might ask the user if it's okay to discard pending changes rather than save them</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">你可以往路由配置中新增守衛，來處理這些場景。</p><p translation-origin=\"off\">You add guards to the route configuration to handle these scenarios.</p>\n\n<p translation-result=\"on\">守衛返回一個值，以控制路由器的行為：</p><p translation-origin=\"off\">A guard's return value controls the router's behavior:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">守衛返回的值</nt-wrapper><nt-wrapper translation-origin=\"off\">Guard return value</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>true</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">導航過程會繼續</nt-wrapper><nt-wrapper translation-origin=\"off\">The navigation process continues</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>false</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">導航過程就會終止，且使用者留在原地。</nt-wrapper><nt-wrapper translation-origin=\"off\">The navigation process stops and the user stays put</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">取消當前導航，並開始導航到所返回的 <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code></nt-wrapper><nt-wrapper translation-origin=\"off\">The current navigation cancels and a new navigation is initiated to the <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> returned</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：守衛還可以告訴路由器導航到別處，這樣也會取消當前的導航。要想在守衛中這麼做，就要返回 <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code>。</p><p translation-origin=\"off\"><strong>Note:</strong> The guard can also tell the router to navigate elsewhere, effectively canceling the current navigation.\nWhen doing so inside a guard, the guard should return <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code>.</p>\n\n</div>\n<p translation-result=\"on\">守衛可以用同步的方式返回一個布林值。但在很多情況下，守衛無法用同步的方式給出答案。守衛可能會向用戶問一個問題、把更改儲存到伺服器，或者獲取新資料，而這些都是非同步操作。</p><p translation-origin=\"off\">The guard might return its boolean answer synchronously.\nBut in many cases, the guard can't produce an answer synchronously.\nThe guard could ask the user a question, save changes to the server, or fetch fresh data.\nThese are all asynchronous operations.</p>\n\n<p translation-result=\"on\">因此，路由的守衛可以返回一個 <code>Observable&lt;boolean&gt;</code> 或 <code>Promise&lt;boolean&gt;</code>，並且路由器會等待這個可觀察物件被解析為 <code>true</code> 或 <code>false</code>。</p><p translation-origin=\"off\">Accordingly, a routing guard can return an <code>Observable&lt;boolean&gt;</code> or a <code>Promise&lt;boolean&gt;</code> and the router will wait for the observable or the promise to resolve to <code>true</code> or <code>false</code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n提供給 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 的可觀察物件會在接收到第一個值之後自動完成（complete）。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThe observable provided to the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> automatically completes after it retrieves the first value.</p>\n\n</div>\n<p translation-result=\"on\">路由器可以支援多種守衛介面：</p><p translation-origin=\"off\">The router supports multiple guard methods:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">守衛介面</nt-wrapper><nt-wrapper translation-origin=\"off\">Guard interfaces</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><a href=\"api/router/CanActivateFn\"><code>canActivate</code></a></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">導航<em>到</em>某路由時介入</nt-wrapper><nt-wrapper translation-origin=\"off\">To mediate navigation <em>to</em> a route</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><a href=\"api/router/CanActivateChildFn\"><code>canActivateChild</code></a></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">導航<em>到</em>某個子路由時介入</nt-wrapper><nt-wrapper translation-origin=\"off\">To mediate navigation <em>to</em> a child route</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><a href=\"api/router/CanDeactivateFn\"><code>canDeactivate</code></a></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">從當前路由<em>離開</em>時介入</nt-wrapper><nt-wrapper translation-origin=\"off\">To mediate navigation <em>away</em> from the current route</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><a href=\"api/router/ResolveFn\"><code>resolve</code></a></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在某路由啟用<em>之前</em>獲取路由資料</nt-wrapper><nt-wrapper translation-origin=\"off\">To perform route data retrieval <em>before</em> route activation</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><a href=\"api/router/CanMatchFn\"><code>canMatch</code></a></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">控制是否應該使用 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>，即使 <code>path</code> 與 URL 段匹配。</nt-wrapper><nt-wrapper translation-origin=\"off\">To control whether a <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> should be used at all, even if the <code>path</code> matches the URL segment.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">在分層路由的每個級別上，你都可以設定多個守衛。路由器會先按照從最深的子路由由下往上檢查的順序來檢查 <code>canDeactivate()</code> 守衛。然後它會按照從上到下的順序檢查 <code>canActivate()</code> 守衛。如果特性模組是非同步載入的，在載入它之前還會檢查 <code>canLoad()</code> 守衛。</p><p translation-origin=\"off\">You can have multiple guards at every level of a routing hierarchy.\nThe router checks the <code>canDeactivate</code> guards first, from the deepest child route to the top.\nThen it checks the <code>canActivate</code> and <code>canActivateChild</code> guards from the top down to the deepest child route.\nIf the feature module is loaded asynchronously, the <code>canMatch</code> guard is checked before the module is loaded.</p>\n\n<p translation-result=\"on\">除 <code>canMatch</code> 之外，如果<em>任何</em>一個守衛返回 <code>false</code>，其它尚未完成的守衛會被取消，這樣整個導航就被取消了。如果 <code>canMatch</code> 守衛返回 <code>false</code>，那麼 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 就會繼續處理這些 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 的其餘部分，以檢視是否有別的 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> 配置能匹配此 URL。你可以看作 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 假裝帶這個 <code>canMatch</code> 守衛的路由不存在一樣。</p><p translation-origin=\"off\">With the exception of <code>canMatch</code>, if <em>any</em> guard returns false, pending guards that have not completed are canceled, and the entire navigation is canceled. If a <code>canMatch</code> guard returns <code>false</code>, the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> continues\nprocessing the rest of the <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> to see if a different <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> config matches the URL. You can think of this\nas though the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> is pretending the <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> with the <code>canMatch</code> guard did not exist.</p>\n\n<p translation-result=\"on\">接下來的小節中有一些例子。</p><p translation-origin=\"off\">There are several examples over the next few sections.</p>\n\n<p><a id=\"can-activate-guard\"></a></p>\n<h3 id=\"canactivate-requiring-authentication\" translation-result=\"on\"><code>canActivate</code>：需要身份驗證<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#canactivate-requiring-authentication\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\"><code>canActivate</code>: requiring authentication<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#canactivate-requiring-authentication\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">應用程式通常會根據存取者來決定是否授予某個特性區的存取權。你可以只對已認證過的使用者或具有特定角色的使用者授予存取權，還可以阻止或限制使用者存取權，直到使用者賬戶啟用為止。</p><p translation-origin=\"off\">Applications often restrict access to a feature area based on who the user is.\nYou could permit access only to authenticated users or to users with a specific role.\nYou might block or limit access until the user's account is activated.</p>\n\n<p translation-result=\"on\"><code>canActivate</code> 守衛是一個管理這些導航類業務規則的工具。</p><p translation-origin=\"off\">The <code>canActivate</code> guard is the tool to manage these navigation business rules.</p>\n\n<h4 id=\"add-an-admin-feature-module\" translation-result=\"on\">新增一個“管理”特性模組<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#add-an-admin-feature-module\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Add an admin feature module<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#add-an-admin-feature-module\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">本節將指導你使用一些新的管理功能來擴充危機中心。首先新增一個名為 <code>AdminModule</code> 的新特性模組。</p><p translation-origin=\"off\">This section guides you through extending the crisis center with some new administrative features.\nStart by adding a new feature module named <code>AdminModule</code>.</p>\n\n<p translation-result=\"on\">產生一個帶有特性模組檔案和路由配置檔案的 <code>admin</code> 目錄。</p><p translation-origin=\"off\">Generate an <code>admin</code> folder with a feature module file and a routing configuration file.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate module admin --routing\n\n</code-example>\n<p translation-result=\"on\">接下來，產生一些支援性元件。</p><p translation-origin=\"off\">Next, generate the supporting components.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component admin/admin-dashboard\n\n</code-example>\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component admin/admin\n\n</code-example>\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component admin/manage-crises\n\n</code-example>\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component admin/manage-heroes\n\n</code-example>\n<p translation-result=\"on\">管理特性區的檔案是這樣的：</p><p translation-origin=\"off\">The admin feature file structure looks like this:</p>\n\n<div class=\"filetree\">\n  <div class=\"file\">\n    src/app/admin\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      admin\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          admin.component.css\n        </div>\n        <div class=\"file\">\n          admin.component.html\n        </div>\n        <div class=\"file\">\n          admin.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      admin-dashboard\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          admin-dashboard.component.css\n        </div>\n        <div class=\"file\">\n          admin-dashboard.component.html\n        </div>\n        <div class=\"file\">\n          admin-dashboard.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      manage-crises\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          manage-crises.component.css\n        </div>\n        <div class=\"file\">\n          manage-crises.component.html\n        </div>\n        <div class=\"file\">\n          manage-crises.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      manage-heroes\n    </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          manage-heroes.component.css\n        </div>\n        <div class=\"file\">\n          manage-heroes.component.html\n        </div>\n        <div class=\"file\">\n          manage-heroes.component.ts\n        </div>\n      </div>\n    <div class=\"file\">\n      admin.module.ts\n    </div>\n    <div class=\"file\">\n      admin-routing.module.ts\n    </div>\n  </div>\n</div>\n<p translation-result=\"on\">管理特性模組包含 <code>AdminComponent</code>，它用於在特性模組內的儀表盤路由以及兩個尚未完成的用於管理危機和英雄的元件之間進行路由。</p><p translation-origin=\"off\">The admin feature module contains the <code>AdminComponent</code> used for routing within the feature module, a dashboard route and two unfinished components to manage crises and heroes.</p>\n\n<code-tabs>\n    <code-pane header=\"src/app/admin/admin/admin.component.html\" path=\"router/src/app/admin/admin/admin.component.html\">\n&lt;h2&gt;Admin&lt;/h2&gt;\n&lt;nav&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"./\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\"\n    [routerLinkActiveOptions]=\"{ exact: true }\" ariaCurrentWhenActive=\"page\"&gt;Dashboard&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"./crises\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Manage Crises&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"./heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Manage Heroes&lt;/a&gt;\n&lt;/nav&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n\n</code-pane>\n    <code-pane header=\"src/app/admin/admin-dashboard/admin-dashboard.component.html\" path=\"router/src/app/admin/admin-dashboard/admin-dashboard.component.1.html\">\n&lt;h3&gt;Dashboard&lt;/h3&gt;\n\n\n</code-pane>\n    <code-pane header=\"src/app/admin/admin.module.ts\" path=\"router/src/app/admin/admin.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\n\nimport { AdminComponent } from './admin/admin.component';\nimport { AdminDashboardComponent } from './admin-dashboard/admin-dashboard.component';\nimport { ManageCrisesComponent } from './manage-crises/manage-crises.component';\nimport { ManageHeroesComponent } from './manage-heroes/manage-heroes.component';\n\nimport { AdminRoutingModule } from './admin-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    AdminRoutingModule\n  ],\n  declarations: [\n    AdminComponent,\n    AdminDashboardComponent,\n    ManageCrisesComponent,\n    ManageHeroesComponent\n  ]\n})\nexport class AdminModule {}\n\n\n</code-pane>\n    <code-pane header=\"src/app/admin/manage-crises/manage-crises.component.html\" path=\"router/src/app/admin/manage-crises/manage-crises.component.html\">\n&lt;p&gt;Manage your crises here&lt;/p&gt;\n\n</code-pane>\n    <code-pane header=\"src/app/admin/manage-heroes/manage-heroes.component.html\" path=\"router/src/app/admin/manage-heroes/manage-heroes.component.html\">\n&lt;p&gt;Manage your heroes here&lt;/p&gt;\n\n</code-pane>\n</code-tabs>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">雖然管理儀表盤中的 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 只包含一個沒有其它 URL 段的斜槓 <code>/</code>，但它能匹配管理特性區下的任何路由。但你只希望在存取 <code>Dashboard</code> 路由時才啟用該連結。往 <code>Dashboard</code> 這個 routerLink 上新增另一個繫結 <code>[routerLinkActiveOptions]=\"{ exact: true }\"</code>，這樣就只有當用戶導航到 <code>/admin</code> 這個 URL 時才會啟用它，而不會在導航到它的某個子路由時。</p><p translation-origin=\"off\">Although the admin dashboard <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> only contains a relative slash without an additional URL segment, it is a match to any route within the admin feature area.\nYou only want the <code>Dashboard</code> link to be active when the user visits that route.\nAdding an additional binding to the <code>Dashboard</code> routerLink,<code>[routerLinkActiveOptions]=\"{ exact: true }\"</code>, marks the <code>./</code> link as active when the user navigates to the <code>/admin</code> URL and not when navigating to any of the child routes.</p>\n\n</div>\n<p><a id=\"component-less-route\"></a></p>\n<h5 id=\"component-less-route-grouping-routes-without-a-component\" translation-result=\"on\">無元件路由：分組路由，而不需要元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#component-less-route-grouping-routes-without-a-component\"><i class=\"material-icons\">link</i></a></h5><h5 translation-origin=\"off\">Component-less route: grouping routes without a component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#component-less-route-grouping-routes-without-a-component\"><i class=\"material-icons\">link</i></a></h5>\n\n<p translation-result=\"on\">最初的管理路由配置如下：</p><p translation-origin=\"off\">The initial admin routing configuration:</p>\n\n<code-example header=\"src/app/admin/admin-routing.module.ts (admin routing)\" path=\"router/src/app/admin/admin-routing.module.1.ts\" region=\"admin-routes\">\nconst adminRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'admin',\n    component: AdminComponent,\n    children: [\n      {\n        path: '',\n        children: [\n          { path: 'crises', component: ManageCrisesComponent },\n          { path: 'heroes', component: ManageHeroesComponent },\n          { path: '', component: AdminDashboardComponent }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(adminRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AdminRoutingModule {}\n\n</code-example>\n<p translation-result=\"on\"><code>AdminComponent</code> 下的子路由有一個 <code>path</code> 和一個 <code>children</code> 屬性，但是它沒有使用 <code>component</code>。這就定義了一個無<em>元件</em>路由。</p><p translation-origin=\"off\">The child route under the <code>AdminComponent</code> has a <code>path</code> and a <code>children</code> property but it's not using a <code>component</code>.\nThis defines a <em>component-less</em> route.</p>\n\n<p translation-result=\"on\">要把 <code>Crisis Center</code> 管理下的路由分組到 <code>admin</code> 路徑下，元件是不必要的。此外，無<em>元件</em>路由可以更容易地<a href=\"guide/router-tutorial-toh#can-activate-child-guard\">保護子路由</a>。</p><p translation-origin=\"off\">To group the <code>Crisis Center</code> management routes under the <code>admin</code> path a component is unnecessary.\nAdditionally, a <em>component-less</em> route makes it easier to <a href=\"guide/router-tutorial-toh#can-activate-child-guard\">guard child routes</a>.</p>\n\n<p translation-result=\"on\">接下來，把 <code>AdminModule</code> 匯入到 <code>app.module.ts</code> 中，並把它加入 <code>imports</code> 陣列中來註冊這些管理類路由。</p><p translation-origin=\"off\">Next, import the <code>AdminModule</code> into <code>app.module.ts</code> and add it to the <code>imports</code> array to register the admin routes.</p>\n\n<code-example header=\"src/app/app.module.ts (admin module)\" path=\"router/src/app/app.module.4.ts\" region=\"admin-module\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule } from './heroes/heroes.module';\nimport { CrisisCenterModule } from './crisis-center/crisis-center.module';\n\nimport { AdminModule } from './admin/admin.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    CrisisCenterModule,\n    AdminModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    ComposeMessageComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<p translation-result=\"on\">然後往殼元件 <code>AppComponent</code> 中新增一個連結，讓使用者能點選它，以存取該特性。</p><p translation-origin=\"off\">Add an \"Admin\" link to the <code>AppComponent</code> shell so that users can get to this feature.</p>\n\n<code-example header=\"src/app/app.component.html (template)\" path=\"router/src/app/app.component.5.html\">\n&lt;h1 class=\"title\"&gt;Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Crisis Center&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Heroes&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/admin\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Admin&lt;/a&gt;\n  &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[{ outlets: { popup: ['compose'] } }]\"&gt;Contact&lt;/a&gt;\n&lt;/nav&gt;\n&lt;div [@routeAnimation]=\"getAnimationData()\"&gt;\n  &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n&lt;/div&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> name=\"popup\"&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n</code-example>\n<p><a id=\"guard-admin-feature\"></a></p>\n<h4 id=\"guard-the-admin-feature\" translation-result=\"on\">守護“管理特性”區<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#guard-the-admin-feature\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Guard the admin feature<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#guard-the-admin-feature\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">現在危機中心的每個路由都是對所有人開放的。這些新的管理特性應該只能被已登入使用者存取。</p><p translation-origin=\"off\">Currently, every route within the Crisis Center is open to everyone.\nThe new admin feature should be accessible only to authenticated users.</p>\n\n<p translation-result=\"on\">編寫一個 <code>canActivate()</code> 守衛，將正在嘗試存取管理元件匿名使用者重新導向到登入頁。</p><p translation-origin=\"off\">Write a <code>canActivate()</code> guard method to redirect anonymous users to the login page when they try to enter the admin area.</p>\n\n<p translation-result=\"on\">在 <code>auth</code> 資料夾中建立一個名為 <code>auth.guard.ts</code> 的新檔案。<code>auth.guard.ts</code> 檔案將包含 <code>authGuard</code> 函式。</p><p translation-origin=\"off\">Create a new file named <code>auth.guard.ts</code> in the <code>auth</code> folder. The <code>auth.guard.ts</code> file will contain the <code>authGuard</code> function.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate guard auth/auth\n\n</code-example>\n<p translation-result=\"on\">為了示範這些基礎知識，這個例子只把日誌寫到控制檯中，立即 <code>return</code> true，並允許繼續導航：</p><p translation-origin=\"off\">To demonstrate the fundamentals, this example only logs to the console, returns <code>true</code> immediately, and lets navigation proceed:</p>\n\n<code-example header=\"src/app/auth/auth.guard.ts (excerpt)\" path=\"router/src/app/auth/auth.guard.1.ts\">\n\nexport const authGuard = () =&gt; {\n  console.log('authGuard#canActivate called');\n  return true;\n};\n\n</code-example>\n<p translation-result=\"on\">接下來，開啟 <code>admin-routing.module.ts</code>，匯入 <code>authGuard</code> 函式，修改管理路由並透過 <code>canActivate()</code> 守衛來參考 <code>authGuard</code>：</p><p translation-origin=\"off\">Next, open <code>admin-routing.module.ts</code>, import the <code>authGuard</code> function, and\nupdate the admin route with a <code>canActivate</code> guard property that references it:</p>\n\n<code-example header=\"src/app/admin/admin-routing.module.ts (guarded admin route)\" path=\"router/src/app/admin/admin-routing.module.2.ts\" region=\"admin-route\">\nimport {authGuard} from '../auth/auth.guard';\n\nimport {AdminDashboardComponent} from './admin-dashboard/admin-dashboard.component';\nimport {AdminComponent} from './admin/admin.component';\nimport {ManageCrisesComponent} from './manage-crises/manage-crises.component';\nimport {ManageHeroesComponent} from './manage-heroes/manage-heroes.component';\n\nconst adminRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [{\n  path: 'admin',\n  component: AdminComponent,\n  canActivate: [authGuard],\n\n  children: [{\n    path: '',\n    children: [\n      {path: 'crises', component: ManageCrisesComponent},\n      {path: 'heroes', component: ManageHeroesComponent},\n      {path: '', component: AdminDashboardComponent}\n    ],\n  }]\n}];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({imports: [RouterModule.forChild(adminRoutes)], exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]})\nexport class AdminRoutingModule {\n}\n\n</code-example>\n<p translation-result=\"on\">管理特性區現在受此守衛保護了，不過該守衛還需要做進一步客製。</p><p translation-origin=\"off\">The admin feature is now protected by the guard, but the guard requires more customization to work fully.</p>\n\n<p><a id=\"teach-auth\"></a></p>\n<h4 id=\"authenticate-with-authguard\" translation-result=\"on\">透過 <code>authGuard</code> 驗證<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#authenticate-with-authguard\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Authenticate with <code>authGuard</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#authenticate-with-authguard\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">讓 <code>authGuard</code> 模擬身份驗證。</p><p translation-origin=\"off\">Make the <code>authGuard</code> mimic authentication.</p>\n\n<p translation-result=\"on\"><code>authGuard</code> 可以呼叫應用中的一項服務，該服務能讓使用者登入，並且儲存當前使用者的資訊。在 <code>auth</code> 目錄下產生一個新的 <code>AuthService</code>：</p><p translation-origin=\"off\">The <code>authGuard</code> should call an application service that can log in a user and retain information about the current user.\nGenerate a new <code>AuthService</code> in the <code>auth</code> folder:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate service auth/auth\n\n</code-example>\n<p translation-result=\"on\">修改 <code>AuthService</code> 以登入此使用者：</p><p translation-origin=\"off\">Update the <code>AuthService</code> to log in the user:</p>\n\n<code-example header=\"src/app/auth/auth.service.ts (excerpt)\" path=\"router/src/app/auth/auth.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\nimport { Observable, of } from 'rxjs';\nimport { tap, delay } from 'rxjs/operators';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class AuthService {\n  isLoggedIn = false;\n\n  // store the URL so we can redirect after logging in\n  redirectUrl: string | null = null;\n\n  login(): Observable&lt;boolean&gt; {\n    return of(true).pipe(\n      delay(1000),\n      tap(() =&gt; this.isLoggedIn = true)\n    );\n  }\n\n  logout(): void {\n    this.isLoggedIn = false;\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">雖然不會真的進行登入，但它有一個 <code>isLoggedIn</code> 標誌，用來標識是否使用者已經登入過了。它的 <code>login()</code> 方法會模擬一個對外部服務的 API 呼叫，返回一個可觀察物件（observable）。在短暫的停頓之後，這個可觀察物件就會解析成功。<code>redirectUrl</code> 屬性將會儲存在使用者要存取的 URL 中，以便認證完之後導航到它。</p><p translation-origin=\"off\">Although it doesn't actually log in, it has an <code>isLoggedIn</code> flag to tell you whether the user is authenticated.\nIts <code>login()</code> method simulates an API call to an external service by returning an observable that resolves successfully after a short pause.\nThe <code>redirectUrl</code> property stores the URL that the user wanted to access so you can navigate to it after authentication.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">為了保持最小化，這個例子會將未經身份驗證的使用者重新導向到 <code>/admin</code>。</p><p translation-origin=\"off\">To keep things minimal, this example redirects unauthenticated users to <code>/admin</code>.</p>\n\n</div>\n<p translation-result=\"on\">修改 <code>authGuard</code> 以呼叫 <code>AuthService</code>。</p><p translation-origin=\"off\">Revise the <code>authGuard</code> to call the <code>AuthService</code>.</p>\n\n<code-example header=\"src/app/auth/auth.guard.ts (v2)\" path=\"router/src/app/auth/auth.guard.2.ts\">\nimport {inject} from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> } from '@angular/router';\n\nimport {AuthService} from './auth.service';\n\nexport const authGuard = () =&gt; {\n  const authService = inject(AuthService);\n  const router = inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>);\n\n  if (authService.isLoggedIn) {\n    return true;\n  }\n\n  // Redirect to the login page\n  return router.parseUrl('/login');\n};\n\n\n</code-example>\n<p translation-result=\"on\">這個守衛會返回一個同步布林結果或一個 <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code>。如果使用者已登入，則返回 <code>true</code> 並繼續導航。否則，它會重新導向到登入頁面 —— 你尚未建立它。返回一個 <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> 會告訴 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 取消當前導航並安排一個新的導航來重新導向使用者。</p><p translation-origin=\"off\">This guard returns a synchronous boolean result or a <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code>.\nIf the user is logged in, it returns <code>true</code> and the navigation continues.\nOtherwise, it redirects to a login page; a page you haven't created yet.\nReturning a <code><a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> tells the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> to cancel the current navigation and schedule a new one to redirect the user.</p>\n\n<p><a id=\"add-login-component\"></a></p>\n<h4 id=\"add-the-logincomponent\" translation-result=\"on\">新增 <code>LoginComponent</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#add-the-logincomponent\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Add the <code>LoginComponent</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#add-the-logincomponent\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">你需要一個 <code>LoginComponent</code> 來讓使用者登入進這個應用。在登入之後，你就會跳轉到前面儲存的 URL，如果沒有，就跳轉到預設 URL。該元件沒有什麼新內容，你在路由配置中使用它的方式也沒什麼新意。</p><p translation-origin=\"off\">You need a <code>LoginComponent</code> for the user to log in to the application.\nAfter logging in, you'll redirect to the stored URL if available, or use the default URL.\nThere is nothing new about this component or the way you use it in the router configuration.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component auth/login\n\n</code-example>\n<p translation-result=\"on\">在 <code>auth/auth-routing.module.ts</code> 檔案中註冊一個 <code>/login</code> 路由。在 <code>app.module.ts</code> 中，匯入 <code>AuthModule</code> 並且新增到 <code>AppModule</code> 的 <code>imports</code> 中。</p><p translation-origin=\"off\">Register a <code>/login</code> route in the <code>auth/auth-routing.module.ts</code> file.\nIn <code>app.module.ts</code>, import and add <code>AuthModule</code> to the <code>AppModule</code> imports array.</p>\n\n<code-tabs>\n    <code-pane header=\"src/app/app.module.ts\" path=\"router/src/app/app.module.ts\" region=\"auth\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a> } from '@angular/platform-browser/animations';\n\nimport { AppComponent } from './app.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule } from './heroes/heroes.module';\nimport { AuthModule } from './auth/auth.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    AuthModule,\n    AppRoutingModule,\n  ],\n  declarations: [\n    AppComponent,\n    ComposeMessageComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {\n}\n\n</code-pane>\n    <code-pane header=\"src/app/auth/login/login.component.html\" path=\"router/src/app/auth/login/login.component.html\">\n&lt;h2&gt;Login&lt;/h2&gt;\n&lt;p&gt;{{message}}&lt;/p&gt;\n&lt;p&gt;\n  &lt;button type=\"button\" (click)=\"login()\"  *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"!authService.isLoggedIn\"&gt;Login&lt;/button&gt;\n  &lt;button type=\"button\" (click)=\"logout()\" *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"authService.isLoggedIn\"&gt;Logout&lt;/button&gt;\n&lt;/p&gt;\n\n\n</code-pane>\n    <code-pane header=\"src/app/auth/login/login.component.ts\" path=\"router/src/app/auth/login/login.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> } from '@angular/router';\nimport { AuthService } from '../auth.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-login',\n  templateUrl: './login.component.html',\n  styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {\n  message: string;\n\n  constructor(public authService: AuthService, public router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n    this.message = this.getMessage();\n  }\n\n  getMessage() {\n    return 'Logged ' + (this.authService.isLoggedIn ? 'in' : 'out');\n  }\n\n  login() {\n    this.message = 'Trying to log in ...';\n\n    this.authService.login().subscribe(() =&gt; {\n      this.message = this.getMessage();\n      if (this.authService.isLoggedIn) {\n        // Usually you would use the redirect URL from the auth service.\n        // However to keep the example simple, we will always redirect to `/admin`.\n        const redirectUrl = '/admin';\n\n        // Redirect the user\n        this.router.navigate([redirectUrl]);\n      }\n    });\n  }\n\n  logout() {\n    this.authService.logout();\n    this.message = this.getMessage();\n  }\n}\n\n\n</code-pane>\n    <code-pane header=\"src/app/auth/auth.module.ts\" path=\"router/src/app/auth/auth.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\n\nimport { LoginComponent } from './login/login.component';\nimport { AuthRoutingModule } from './auth-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    AuthRoutingModule\n  ],\n  declarations: [\n    LoginComponent\n  ]\n})\nexport class AuthModule {}\n\n\n</code-pane>\n</code-tabs>\n<p><a id=\"can-activate-child-guard\"></a></p>\n<h3 id=\"canactivatechild-guarding-child-routes\" translation-result=\"on\"><code>canActivateChild</code>：保護子路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#canactivatechild-guarding-child-routes\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\"><code>canActivateChild</code>: guarding child routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#canactivatechild-guarding-child-routes\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你還可以使用 <code>canActivateChild</code> 守衛來保護子路由。<code>canActivateChild</code> 守衛和 <code>canActivate</code> 守衛很像。它們的區別在於，<code>canActivateChild</code> 會在<em>任何子路由</em>被啟用之前執行。</p><p translation-origin=\"off\">You can also protect child routes with the <code>canActivateChild</code> guard.\nThe <code>canActivateChild</code> guard is similar to the <code>canActivate</code> guard.\nThe key difference is that it runs before any child route is activated.</p>\n\n<p translation-result=\"on\">你要保護管理特性模組，防止它被非授權存取，還要保護這個特性模組<em>內部</em>的那些子路由。</p><p translation-origin=\"off\">You protected the admin feature module from unauthorized access.\nYou should also protect child routes <em>within</em> the feature module.</p>\n\n<p translation-result=\"on\">同樣把這個 <code>authGuard</code> 新增到“無元件的”管理路由，來同時保護它的所有子路由，而不是為每個路由單獨新增這個 <code>authGuard</code>。</p><p translation-origin=\"off\">Add the same <code>authGuard</code> to the <code>component-less</code> admin route to protect all other child routes at one time\ninstead of adding the <code>authGuard</code> to each route individually.</p>\n\n<code-example header=\"src/app/admin/admin-routing.module.ts (excerpt)\" path=\"router/src/app/admin/admin-routing.module.3.ts\" region=\"can-activate-child\">\nconst adminRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'admin',\n    component: AdminComponent,\n    canActivate: [authGuard],\n    children: [\n      {\n        path: '',\n        canActivateChild: [authGuard],\n        children: [\n          { path: 'crises', component: ManageCrisesComponent },\n          { path: 'heroes', component: ManageHeroesComponent },\n          { path: '', component: AdminDashboardComponent }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(adminRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AdminRoutingModule {}\n\n</code-example>\n<p><a id=\"can-deactivate-guard\"></a></p>\n<h3 id=\"candeactivate-handling-unsaved-changes\" translation-result=\"on\"><code>canDeactivate</code>：處理未儲存的更改<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#candeactivate-handling-unsaved-changes\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\"><code>canDeactivate</code>: handling unsaved changes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#candeactivate-handling-unsaved-changes\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">回到 “Heroes” 工作流，該應用會立即接受對英雄的每次更改，而不進行驗證。</p><p translation-origin=\"off\">Back in the \"Heroes\" workflow, the application accepts every change to a hero immediately without validation.</p>\n\n<p translation-result=\"on\">在現實世界，你可能不得不積累來自使用者的更改，跨欄位驗證，在伺服器上驗證，或者把變更保持在待定狀態，直到使用者確認這一組欄位或取消並還原所有變更為止。</p><p translation-origin=\"off\">In the real world, you might have to accumulate the users changes, validate across fields, validate on the server, or hold changes in a pending state until the user confirms them as a group or cancels and reverts all changes.</p>\n\n<p translation-result=\"on\">當用戶要導航離開時，你可以讓使用者自己決定該怎麼處理這些未儲存的更改。如果使用者選擇了取消，你就留下來，並允許更多改動。如果使用者選擇了確認，那就進行儲存。</p><p translation-origin=\"off\">When the user navigates away, you can let the user decide what to do with unsaved changes.\nIf the user cancels, you'll stay put and allow more changes.\nIf the user approves, the application can save.</p>\n\n<p translation-result=\"on\">在儲存成功之前，你還可以繼續推遲導航。如果你讓使用者立即移到下一個介面，而儲存卻失敗了（可能因為資料不符合有效性規則），你就會丟失該錯誤的上下文環境。</p><p translation-origin=\"off\">You still might delay navigation until the save succeeds.\nIf you let the user move to the next screen immediately and saving were to fail (perhaps the data is ruled invalid), you would lose the context of the error.</p>\n\n<p translation-result=\"on\">你需要用非同步的方式等待，在伺服器返回答覆之前先停止導航。</p><p translation-origin=\"off\">You need to stop the navigation while you wait, asynchronously, for the server to return with its answer.</p>\n\n<p translation-result=\"on\"><code>canDeactivate</code> 守衛能幫助你決定如何處理未儲存的更改，以及如何處理。</p><p translation-origin=\"off\">The <code>canDeactivate</code> guard helps you decide what to do with unsaved changes and how to proceed.</p>\n\n<p><a id=\"cancel-save\"></a></p>\n<h4 id=\"cancel-and-save\" translation-result=\"on\">取消與儲存<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#cancel-and-save\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Cancel and save<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#cancel-and-save\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">使用者在 <code>CrisisDetailComponent</code> 中更新危機資訊。與 <code>HeroDetailComponent</code> 不同，使用者的改動不會立即更新危機的實體物件。當用戶按下了 Save 按鈕時，應用就更新這個實體物件；如果按了 Cancel 按鈕，那就放棄這些更改。</p><p translation-origin=\"off\">Users update crisis information in the <code>CrisisDetailComponent</code>.\nUnlike the <code>HeroDetailComponent</code>, the user changes do not update the crisis entity immediately.\nInstead, the application updates the entity when the user presses the Save button and discards the changes when the user presses the Cancel button.</p>\n\n<p translation-result=\"on\">這兩個按鈕都會在儲存或取消之後導航回危機列表。</p><p translation-origin=\"off\">Both buttons navigate back to the crisis list after save or cancel.</p>\n\n<code-example header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (cancel and save methods)\" path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" region=\"cancel-save\">\ncancel() {\n  this.gotoCrises();\n}\n\nsave() {\n  this.crisis.name = this.editName;\n  this.gotoCrises();\n}\n\n</code-example>\n<p translation-result=\"on\">在這種情況下，使用者可以點選 heroes 連結，取消，按下瀏覽器後退按鈕，或者不儲存就離開。</p><p translation-origin=\"off\">In this scenario, the user could click the heroes link, cancel, push the browser back button, or navigate away without saving.</p>\n\n<p translation-result=\"on\">這個範例應用會彈出一個確認對話方塊，它會非同步等待使用者的響應，等使用者給出一個明確的答覆。</p><p translation-origin=\"off\">This example application asks the user to be explicit with a confirmation dialog box that waits asynchronously for the user's\nresponse.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你也可以用同步的方式等使用者的答覆，阻塞程式碼。但如果能用非同步的方式等待使用者的答覆，應用就會響應性更好，還能同時做別的事。</p><p translation-origin=\"off\">You could wait for the user's answer with synchronous, blocking code, however, the application is more responsive —and can do other work— by waiting for the user's answer asynchronously.</p>\n\n</div>\n<p translation-result=\"on\">產生一個 <code>Dialog</code> 服務，以處理使用者的確認操作。</p><p translation-origin=\"off\">Generate a <code>Dialog</code> service to handle user confirmation.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate service dialog\n\n</code-example>\n<p translation-result=\"on\">為 <code>DialogService</code> 新增一個 <code>confirm()</code> 方法，以提醒使用者確認。<code>window.confirm</code> 是一個阻塞型操作，它會顯示一個模態對話方塊，並等待使用者的互動。</p><p translation-origin=\"off\">Add a <code>confirm()</code> method to the <code>DialogService</code> to prompt the user to confirm their intent.\nThe <code>window.confirm</code> is a blocking action that displays a modal dialog and waits for user interaction.</p>\n\n<code-example header=\"src/app/dialog.service.ts\" path=\"router/src/app/dialog.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Observable, of } from 'rxjs';\n\n/**\n * Async modal dialog service\n * DialogService makes this app easier to test by faking this service.\n * TODO: better modal implementation that doesn't use window.confirm\n */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class DialogService {\n  /**\n   * Ask user to confirm an action. `message` explains the action and choices.\n   * Returns observable resolving to `true`=confirm or `false`=cancel\n   */\n  confirm(message?: string): Observable&lt;boolean&gt; {\n    const confirmation = window.confirm(message || 'Is it OK?');\n\n    return of(confirmation);\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">它返回<em>observable</em>，當用戶最終決定了如何去做時，它就會被<em>解析</em> —— 或者決定放棄更改直接導航離開（<code>true</code>），或者保留未完成的修改，留在危機編輯器中（<code>false</code>）。</p><p translation-origin=\"off\">It returns an <code>Observable</code> that resolves when the user eventually decides what to do: either to discard changes and navigate away (<code>true</code>) or to preserve the pending changes and stay in the crisis editor (<code>false</code>).</p>\n\n<p><a id=\"canDeactivate\"></a></p>\n<p translation-result=\"on\">產生一個守衛（guard），以檢查元件（任意元件均可）中是否存在 <code>canDeactivate()</code> 方法。</p><p translation-origin=\"off\">Create a guard that checks for the presence of a <code>canDeactivate()</code> method in a component —any component.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate guard can-deactivate\n\n</code-example>\n<p translation-result=\"on\">把下面的程式碼貼上到守衛中。</p><p translation-origin=\"off\">Paste the following code into your guard.</p>\n\n<code-example header=\"src/app/can-deactivate.guard.ts\" path=\"router/src/app/can-deactivate.guard.ts\">\nimport { <a href=\"api/router/CanDeactivateFn\" class=\"code-anchor\">CanDeactivateFn</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nexport interface CanComponentDeactivate {\n  canDeactivate?: () =&gt; Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean;\n}\n\nexport const canDeactivateGuard: <a href=\"api/router/CanDeactivateFn\" class=\"code-anchor\">CanDeactivateFn</a>&lt;CanComponentDeactivate&gt; =\n    (component: CanComponentDeactivate) =&gt; component.canDeactivate ? component.canDeactivate() : true;\n\n\n</code-example>\n<p translation-result=\"on\">守衛不需要知道哪個元件有 <code>deactivate</code> 方法，它可以檢測 <code>CrisisDetailComponent</code> 元件有沒有 <code>canDeactivate()</code> 方法並呼叫它。守衛在不知道任何元件 <code>deactivate</code> 方法細節的情況下，就能讓這個守衛重複使用。</p><p translation-origin=\"off\">While the guard doesn't have to know which component has a <code>deactivate</code> method, it can detect that the <code>CrisisDetailComponent</code> component has the <code>canDeactivate()</code> method and call it.\nThe guard not knowing the details of any component's deactivation method makes the guard reusable.</p>\n\n<p translation-result=\"on\">另外，你也可以為 <code>CrisisDetailComponent</code> 建立一個特定的 <code>canDeactivate</code> 守衛。在需要存取外部資訊時，<code>canDeactivate()</code> 方法為你提供了元件、<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 和 <code><a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a></code> 的當前例項。如果只想為這個元件使用該守衛，並且需要獲取該元件屬性或確認路由器是否允許從該元件導航出去時，這會非常有用。</p><p translation-origin=\"off\">Alternatively, you could make a component-specific <code>canDeactivate</code> guard for the <code>CrisisDetailComponent</code>.\nThe <code>canDeactivate()</code> method provides you with the current instance of the <code>component</code>, the current <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>, and <code><a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a></code> in case you needed to access some external information.\nThis would be useful if you only wanted to use this guard for this component and needed to get the component's properties or confirm whether the router should allow navigation away from it.</p>\n\n<code-example header=\"src/app/can-deactivate.guard.ts (component-specific)\" path=\"router/src/app/can-deactivate.guard.1.ts\">\nimport { Observable } from 'rxjs';\nimport { <a href=\"api/router/CanDeactivateFn\" class=\"code-anchor\">CanDeactivateFn</a>,\n         <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n         <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a> } from '@angular/router';\n\nimport { CrisisDetailComponent } from './crisis-center/crisis-detail/crisis-detail.component';\n\nexport const canDeactivateGuard: <a href=\"api/router/CanDeactivateFn\" class=\"code-anchor\">CanDeactivateFn</a>&lt;CrisisDetailComponent&gt;  = (\n    component: CrisisDetailComponent,\n    route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    state: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>\n  ): Observable&lt;boolean&gt; | boolean =&gt; {\n    // Get the Crisis Center ID\n    console.log(route.paramMap.get('id'));\n\n    // Get the current URL\n    console.log(state.url);\n\n    // Allow synchronous navigation (`true`) if no crisis or the crisis is unchanged\n    if (!component.crisis || component.crisis.name === component.editName) {\n      return true;\n    }\n    // Otherwise ask the user with the dialog service and return its\n    // observable which resolves to true or false when the user decides\n    return component.dialogService.confirm('Discard changes?');\n  };\n\n\n</code-example>\n<p translation-result=\"on\">看看 <code>CrisisDetailComponent</code> 元件，它已經實現了對未儲存的更改進行確認的工作流。</p><p translation-origin=\"off\">Looking back at the <code>CrisisDetailComponent</code>, it implements the confirmation workflow for unsaved changes.</p>\n\n<code-example header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (excerpt)\" path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" region=\"canDeactivate\">\ncanDeactivate(): Observable&lt;boolean&gt; | boolean {\n  // Allow synchronous navigation (`true`) if no crisis or the crisis is unchanged\n  if (!this.crisis || this.crisis.name === this.editName) {\n    return true;\n  }\n  // Otherwise ask the user with the dialog service and return its\n  // observable which resolves to true or false when the user decides\n  return this.dialogService.confirm('Discard changes?');\n}\n\n</code-example>\n<p translation-result=\"on\">注意，<code>canDeactivate()</code> 方法可以同步返回;如果沒有危機，或者沒有待處理的更改，它會立即返回 <code>true</code>。但它也能返回一個 <code>Promise</code> 或一個 <code>Observable</code>，路由器也會等待它解析為真值（導航）或偽造（停留在當前路由上）。</p><p translation-origin=\"off\">Notice that the <code>canDeactivate()</code> method can return synchronously; it returns <code>true</code> immediately if there is no crisis or there are no pending changes.\nBut it can also return a <code>Promise</code> or an <code>Observable</code> and the router will wait for that to resolve to truthy (navigate) or falsy (stay on the current route).</p>\n\n<p translation-result=\"on\">往 <code>crisis-center.routing.module.ts</code> 的危機詳情路由中用 <code>canDeactivate</code> 陣列新增一個 <code>Guard</code>（守衛）。</p><p translation-origin=\"off\">Add the <code>Guard</code> to the crisis detail route in <code>crisis-center-routing.module.ts</code> using the <code>canDeactivate</code> array property.</p>\n\n<code-example header=\"src/app/crisis-center/crisis-center-routing.module.ts (can deactivate guard)\" path=\"router/src/app/crisis-center/crisis-center-routing.module.3.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent } from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';\n\nimport { canDeactivateGuard } from '../can-deactivate.guard';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent,\n            canDeactivate: [canDeactivateGuard]\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n\n</code-example>\n<p translation-result=\"on\">現在，你已經給了使用者一個能保護未儲存更改的安全守衛。</p><p translation-origin=\"off\">Now you have given the user a safeguard against unsaved changes.</p>\n\n<p><a id=\"Resolve\"></a>\n<a id=\"resolve-guard\"></a></p>\n<h3 id=\"resolve-pre-fetching-component-data\" translation-result=\"on\"><em>Resolve</em>: 預先獲取元件資料<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#resolve-pre-fetching-component-data\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\"><em>Resolve</em>: pre-fetching component data<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#resolve-pre-fetching-component-data\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 <code>Hero Detail</code> 和 <code>Crisis Detail</code> 中，它們等待路由讀取完對應的英雄和危機。</p><p translation-origin=\"off\">In the <code>Hero Detail</code> and <code>Crisis Detail</code>, the application waited until the route was activated to fetch the respective hero or crisis.</p>\n\n<p translation-result=\"on\">如果你在使用真實 api，很有可能資料返回有延遲，導致無法即時顯示。在這種情況下，直到資料到達前，顯示一個空的元件不是最好的使用者體驗。</p><p translation-origin=\"off\">If you were using a real world API, there might be some delay before the data to display is returned from the server.\nYou don't want to display a blank component while waiting for the data.</p>\n\n<p translation-result=\"on\">最好使用解析器預先從伺服器上獲取完資料，這樣在路由啟用的那一刻資料就準備好了。還要在路由到此元件之前處理好錯誤。但當某個 <code>id</code> 無法對應到一個危機詳情時，就沒辦法處理它。這時最好把使用者帶回到“危機列表”中，那裡顯示了所有有效的“危機”。</p><p translation-origin=\"off\">To improve this behavior, you can pre-fetch data from the server using a resolver so it's ready the moment the route is activated.\nThis also lets you handle errors before routing to the component.\nThere's no point in navigating to a crisis detail for an <code>id</code> that doesn't have a record.\nIt'd be better to send the user back to the <code>Crisis List</code> that shows only valid crisis centers.</p>\n\n<p translation-result=\"on\">總之，你希望的是隻有當所有必要資料都已經拿到之後，才渲染這個路由元件。</p><p translation-origin=\"off\">In summary, you want to delay rendering the routed component until all necessary data has been fetched.</p>\n\n<p><a id=\"fetch-before-navigating\"></a></p>\n<h4 id=\"fetch-data-before-navigating\" translation-result=\"on\">導航前預先載入路由資訊<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#fetch-data-before-navigating\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Fetch data before navigating<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#fetch-data-before-navigating\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">目前，<code>CrisisDetailComponent</code> 會接收選中的危機。如果該危機沒有找到，路由器就會導航回危機列表檢視。</p><p translation-origin=\"off\">At the moment, the <code>CrisisDetailComponent</code> retrieves the selected crisis.\nIf the crisis is not found, the router navigates back to the crisis list view.</p>\n\n<p translation-result=\"on\">如果能在該路由將要啟用時提前處理了這個問題，那麼使用者體驗會更好。<code>crisisDetailResolver</code> 服務可以接收一個 <code>Crisis</code>，而如果這個 <code>Crisis</code> 不存在，就會在啟用該路由並建立 <code>CrisisDetailComponent</code> 之前先行離開。</p><p translation-origin=\"off\">The experience might be better if all of this were handled first, before the route is activated.\nA <code>crisisDetailResolver</code> could retrieve a <code>Crisis</code> or navigate away, if the <code>Crisis</code> did not exist, <em>before</em> activating the route and creating the <code>CrisisDetailComponent</code>.</p>\n\n<p translation-result=\"on\">在 <code>Crisis Center</code> 特性區域中建立一個 <code>crisis-detail-resolver.ts</code> 檔案。此檔案將包含 <code>crisisDetailResolver</code> 函式。</p><p translation-origin=\"off\">Create a <code>crisis-detail-resolver.ts</code> file within the <code>Crisis Center</code> feature area. This file will contain the <code>crisisDetailResolver</code> function.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate resolver crisis-center/crisis-detail-resolver\n\n</code-example>\n<code-example header=\"src/app/crisis-center/crisis-detail-resolver.ts\" path=\"router/src/app/crisis-center/crisis-detail-resolver.1.ts\">\n\nexport function crisisDetailResolver() {\n}\n\n\n</code-example>\n<p translation-result=\"on\">把 <code>CrisisDetailComponent.ngOnInit()</code> 中與危機檢索有關的邏輯移到 <code>crisisDetailResolver</code> 中。匯入 <code>Crisis</code> 模型、<code>CrisisService</code> 和 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 以便讓你可以在找不到指定的危機時導航到別處。</p><p translation-origin=\"off\">Move the relevant parts of the crisis retrieval logic in <code>CrisisDetailComponent.ngOnInit()</code> into the <code>crisisDetailResolver</code>.\nImport the <code>Crisis</code> model, <code>CrisisService</code>, and the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> so you can navigate elsewhere if you can't fetch the crisis.</p>\n\n<p translation-result=\"on\">為了更明確一點，可以實現一個帶有 <code>Crisis</code> 型別的 <code><a href=\"api/router/ResolveFn\" class=\"code-anchor\">ResolveFn</a></code> 介面。</p><p translation-origin=\"off\">Be explicit and use the <code><a href=\"api/router/ResolveFn\" class=\"code-anchor\">ResolveFn</a></code> type with a type of <code>Crisis</code>.</p>\n\n<p translation-result=\"on\">注入 <code>CrisisService</code> 和 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>。該方法可以返回一個 <code>Promise</code>、一個 <code>Observable</code> 來支援非同步方式，或者直接返回一個值來支援同步方式。</p><p translation-origin=\"off\">Inject the <code>CrisisService</code> and <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>.\nThat method could return a <code>Promise</code>, an <code>Observable</code>, or a synchronous return value.</p>\n\n<p translation-result=\"on\"><code>CrisisService.getCrisis()</code> 方法返回一個可觀察物件，以防止在資料獲取完之前載入本路由。</p><p translation-origin=\"off\">The <code>CrisisService.getCrisis()</code> method returns an observable in order to prevent the route from loading until the data is fetched.</p>\n\n<p translation-result=\"on\">如果它沒有返回有效的 <code>Crisis</code>，就會返回一個 <code>Observable</code>，以取消以前到 <code>CrisisDetailComponent</code> 的在途導航，並把使用者導航回 <code>CrisisListComponent</code>。修改後的 <code>resolver</code> 函式是這樣的：</p><p translation-origin=\"off\">If it doesn't return a valid <code>Crisis</code>, then return an empty <code>Observable</code>, cancel the previous in-progress navigation to the <code>CrisisDetailComponent</code>, and navigate the user back to the <code>CrisisListComponent</code>.\nThe updated resolver function looks like this:</p>\n\n<code-example header=\"src/app/crisis-center/crisis-detail-resolver.ts\" path=\"router/src/app/crisis-center/crisis-detail-resolver.ts\">\nimport {inject} from '@angular/core';\nimport {<a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/router/ResolveFn\" class=\"code-anchor\">ResolveFn</a>, <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>} from '@angular/router';\nimport {EMPTY, of} from 'rxjs';\nimport {mergeMap} from 'rxjs/operators';\n\nimport {Crisis} from './crisis';\nimport {CrisisService} from './crisis.service';\n\nexport const crisisDetailResolver: <a href=\"api/router/ResolveFn\" class=\"code-anchor\">ResolveFn</a>&lt;Crisis&gt; = (route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>) =&gt; {\n  const router = inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>);\n  const cs = inject(CrisisService);\n  const id = route.paramMap.get('id')!;\n\n  return cs.getCrisis(id).pipe(mergeMap(crisis =&gt; {\n    if (crisis) {\n      return of(crisis);\n    } else {  // id not found\n      router.navigate(['/crisis-center']);\n      return EMPTY;\n    }\n  }));\n};\n\n\n</code-example>\n<p translation-result=\"on\">把這個解析器（resolver）匯入到 <code>crisis-center-routing.module.ts</code> 中，並往 <code>CrisisDetailComponent</code> 的路由配置中新增一個 <code>resolve</code> 物件。</p><p translation-origin=\"off\">Import this resolver in the <code>crisis-center-routing.module.ts</code> and add a <code>resolve</code> object to the <code>CrisisDetailComponent</code> route configuration.</p>\n\n<code-example header=\"src/app/crisis-center/crisis-center-routing.module.ts (resolver)\" path=\"router/src/app/crisis-center/crisis-center-routing.module.4.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent } from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';\n\nimport { canDeactivateGuard } from '../can-deactivate.guard';\nimport { crisisDetailResolver } from './crisis-detail-resolver';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent,\n            canDeactivate: [canDeactivateGuard],\n            resolve: {\n              crisis: crisisDetailResolver\n            }\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-example>\n<p translation-result=\"on\"><code>CrisisDetailComponent</code> 不應該再去獲取這個危機的詳情。你只要重新配置路由，就可以修改從哪裡獲取危機的詳情。把 <code>CrisisDetailComponent</code> 改成從 <code>ActivatedRoute.data.crisis</code> 屬性中獲取危機詳情，這正是你重新配置路由的恰當時機。</p><p translation-origin=\"off\">The <code>CrisisDetailComponent</code> should no longer fetch the crisis.\nWhen you re-configured the route, you changed where the crisis is.\nUpdate the <code>CrisisDetailComponent</code> to get the crisis from the  <code>ActivatedRoute.data.crisis</code> property instead;</p>\n\n<code-example header=\"src/app/crisis-center/crisis-detail/crisis-detail.component.ts (ngOnInit v2)\" path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\" region=\"ngOnInit\">\nngOnInit() {\n  this.route.data\n    .subscribe(data =&gt; {\n      const crisis: Crisis = data['crisis'];\n      this.editName = crisis.name;\n      this.crisis = crisis;\n    });\n}\n\n</code-example>\n<p translation-result=\"on\">回顧以下三個重要點：</p><p translation-origin=\"off\">Review the following three important points:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">路由器的這個 <code><a href=\"api/router/ResolveFn\" class=\"code-anchor\">ResolveFn</a></code> 介面是可選的。</p><p translation-origin=\"off\">The router's <code><a href=\"api/router/ResolveFn\" class=\"code-anchor\">ResolveFn</a></code> is optional.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">路由器會在使用者可以導航的任何情況下呼叫該解析器，這樣你就不用針對每個使用案例都編寫程式碼了。</p><p translation-origin=\"off\">The router calls the resolver in any case where the user could navigate away so you don't have to code for each use case.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在任何一個解析器中返回空的 <code>Observable</code> 就會取消導航。</p><p translation-origin=\"off\">Returning an empty <code>Observable</code> in at least one resolver cancels navigation.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">與里程碑相關的危機中心程式碼如下。</p><p translation-origin=\"off\">The relevant Crisis Center code for this milestone follows.</p>\n\n<code-tabs>\n    <code-pane header=\"app.component.html\" path=\"router/src/app/app.component.html\">\n&lt;div class=\"wrapper\"&gt;\n  &lt;h1 class=\"title\"&gt;Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&lt;/h1&gt;\n  &lt;nav&gt;\n    &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Crisis Center&lt;/a&gt;\n    &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/superheroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Heroes&lt;/a&gt;\n    &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/admin\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Admin&lt;/a&gt;\n    &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/login\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Login&lt;/a&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[{ outlets: { popup: ['compose'] } }]\"&gt;Contact&lt;/a&gt;\n  &lt;/nav&gt;\n  &lt;div [@routeAnimation]=\"getRouteAnimationData()\"&gt;\n    &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n  &lt;/div&gt;\n  &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> name=\"popup\"&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n&lt;/div&gt;\n\n\n</code-pane>\n    <code-pane header=\"crisis-center-home.component.html\" path=\"router/src/app/crisis-center/crisis-center-home/crisis-center-home.component.html\">\n&lt;h3&gt;Welcome to the Crisis Center&lt;/h3&gt;\n\n\n</code-pane>\n    <code-pane header=\"crisis-center.component.html\" path=\"router/src/app/crisis-center/crisis-center/crisis-center.component.html\">\n&lt;h2&gt;Crisis Center&lt;/h2&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n\n</code-pane>\n    <code-pane header=\"crisis-center-routing.module.ts\" path=\"router/src/app/crisis-center/crisis-center-routing.module.4.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent } from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';\n\nimport { canDeactivateGuard } from '../can-deactivate.guard';\nimport { crisisDetailResolver } from './crisis-detail-resolver';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'crisis-center',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent,\n            canDeactivate: [canDeactivateGuard],\n            resolve: {\n              crisis: crisisDetailResolver\n            }\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-pane>\n    <code-pane header=\"crisis-list.component.html\" path=\"router/src/app/crisis-center/crisis-list/crisis-list.component.html\">\n&lt;ul class=\"crises\"&gt;\n  &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let crisis of crises$ | async\" [class.selected]=\"crisis.id === selectedId\"&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[crisis.id]\"&gt;\n      &lt;span class=\"badge\"&gt;{{ crisis.id }}&lt;/span&gt;{{ crisis.name }}\n    &lt;/a&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n\n</code-pane>\n    <code-pane header=\"crisis-list.component.ts\" path=\"router/src/app/crisis-center/crisis-list/crisis-list.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\nimport { CrisisService } from '../crisis.service';\nimport { Crisis } from '../crisis';\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-crisis-list',\n  templateUrl: './crisis-list.component.html',\n  styleUrls: ['./crisis-list.component.css']\n})\nexport class CrisisListComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  crises$?: Observable&lt;Crisis[]&gt;;\n  selectedId = 0;\n\n  constructor(\n    private service: CrisisService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>\n  ) {}\n\n  ngOnInit() {\n    this.crises$ = this.route.firstChild?.paramMap.pipe(\n      switchMap(params =&gt; {\n        this.selectedId = parseInt(params.get('id')!, 10);\n        return this.service.getCrises();\n      })\n    );\n  }\n}\n\n\n</code-pane>\n    <code-pane header=\"crisis-detail.component.html\" path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.html\">\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"crisis\"&gt;\n  &lt;h3&gt;{{ editName }}&lt;/h3&gt;\n  &lt;p&gt;Id: {{ crisis.id }}&lt;/p&gt;\n  &lt;label for=\"crisis-name\"&gt;Crisis name: &lt;/label&gt;\n  &lt;input type=\"text\" id=\"crisis-name\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"editName\" placeholder=\"name\"/&gt;\n  &lt;div&gt;\n    &lt;button type=\"button\" (click)=\"save()\"&gt;Save&lt;/button&gt;\n    &lt;button type=\"button\" (click)=\"cancel()\"&gt;Cancel&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n\n</code-pane>\n    <code-pane header=\"crisis-detail.component.ts\" path=\"router/src/app/crisis-center/crisis-detail/crisis-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nimport { Crisis } from '../crisis';\nimport { DialogService } from '../../dialog.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-crisis-detail',\n  templateUrl: './crisis-detail.component.html',\n  styleUrls: ['./crisis-detail.component.css']\n})\nexport class CrisisDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  crisis!: Crisis;\n  editName = '';\n\n  constructor(\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n    public dialogService: DialogService\n  ) {}\n\n  ngOnInit() {\n    this.route.data\n      .subscribe(data =&gt; {\n        const crisis: Crisis = data['crisis'];\n        this.editName = crisis.name;\n        this.crisis = crisis;\n      });\n  }\n\n  cancel() {\n    this.gotoCrises();\n  }\n\n  save() {\n    this.crisis.name = this.editName;\n    this.gotoCrises();\n  }\n\n  canDeactivate(): Observable&lt;boolean&gt; | boolean {\n    // Allow synchronous navigation (`true`) if no crisis or the crisis is unchanged\n    if (!this.crisis || this.crisis.name === this.editName) {\n      return true;\n    }\n    // Otherwise ask the user with the dialog service and return its\n    // observable which resolves to true or false when the user decides\n    return this.dialogService.confirm('Discard changes?');\n  }\n\n  gotoCrises() {\n    const crisisId = this.crisis ? this.crisis.id : null;\n    // Pass along the crisis id if available\n    // so that the CrisisListComponent can select that crisis.\n    // Add a totally useless `foo` parameter for kicks.\n    // Relative navigation back to the crises\n    this.router.navigate(['../', { id: crisisId, foo: 'foo' }], { relativeTo: this.route });\n  }\n}\n\n\n</code-pane>\n    <code-pane header=\"crisis-detail-resolver.ts\" path=\"router/src/app/crisis-center/crisis-detail-resolver.ts\">\nimport {inject} from '@angular/core';\nimport {<a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>, <a href=\"api/router/ResolveFn\" class=\"code-anchor\">ResolveFn</a>, <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>} from '@angular/router';\nimport {EMPTY, of} from 'rxjs';\nimport {mergeMap} from 'rxjs/operators';\n\nimport {Crisis} from './crisis';\nimport {CrisisService} from './crisis.service';\n\nexport const crisisDetailResolver: <a href=\"api/router/ResolveFn\" class=\"code-anchor\">ResolveFn</a>&lt;Crisis&gt; = (route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>) =&gt; {\n  const router = inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>);\n  const cs = inject(CrisisService);\n  const id = route.paramMap.get('id')!;\n\n  return cs.getCrisis(id).pipe(mergeMap(crisis =&gt; {\n    if (crisis) {\n      return of(crisis);\n    } else {  // id not found\n      router.navigate(['/crisis-center']);\n      return EMPTY;\n    }\n  }));\n};\n\n\n</code-pane>\n    <code-pane header=\"crisis.service.ts\" path=\"router/src/app/crisis-center/crisis.service.ts\">\nimport { BehaviorSubject } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { MessageService } from '../message.service';\nimport { Crisis } from './crisis';\nimport { CRISES } from './mock-crises';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class CrisisService {\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> nextCrisisId = 100;\n  private crises$: BehaviorSubject&lt;Crisis[]&gt; = new BehaviorSubject&lt;Crisis[]&gt;(CRISES);\n\n  constructor(private messageService: MessageService) { }\n\n  getCrises() { return this.crises$; }\n\n  getCrisis(id: number | string) {\n    return this.getCrises().pipe(\n      map(crises =&gt; crises.find(crisis =&gt; crisis.id === +id)!)\n    );\n  }\n\n}\n\n\n</code-pane>\n    <code-pane header=\"dialog.service.ts\" path=\"router/src/app/dialog.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Observable, of } from 'rxjs';\n\n/**\n * Async modal dialog service\n * DialogService makes this app easier to test by faking this service.\n * TODO: better modal implementation that doesn't use window.confirm\n */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class DialogService {\n  /**\n   * Ask user to confirm an action. `message` explains the action and choices.\n   * Returns observable resolving to `true`=confirm or `false`=cancel\n   */\n  confirm(message?: string): Observable&lt;boolean&gt; {\n    const confirmation = window.confirm(message || 'Is it OK?');\n\n    return of(confirmation);\n  }\n}\n\n\n</code-pane>\n</code-tabs>\n<p translation-result=\"on\">路由守衛</p><p translation-origin=\"off\">Guards</p>\n\n<code-tabs>\n    <code-pane header=\"auth.guard.ts\" path=\"router/src/app/auth/auth.guard.3.ts\">\nimport { inject } from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> } from '@angular/router';\nimport { AuthService } from './auth.service';\n\nexport const authGuard = () =&gt; {\n  const authService = inject(AuthService);\n  const router = inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>);\n\n  if (authService.isLoggedIn) {\n    return true;\n  }\n\n  // Redirect to the login page\n  return router.parseUrl('/login');\n};\n\n\n</code-pane>\n    <code-pane header=\"can-deactivate.guard.ts\" path=\"router/src/app/can-deactivate.guard.ts\">\nimport { <a href=\"api/router/CanDeactivateFn\" class=\"code-anchor\">CanDeactivateFn</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\n\nexport interface CanComponentDeactivate {\n  canDeactivate?: () =&gt; Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean;\n}\n\nexport const canDeactivateGuard: <a href=\"api/router/CanDeactivateFn\" class=\"code-anchor\">CanDeactivateFn</a>&lt;CanComponentDeactivate&gt; =\n    (component: CanComponentDeactivate) =&gt; component.canDeactivate ? component.canDeactivate() : true;\n\n\n</code-pane>\n</code-tabs>\n<p><a id=\"query-parameters\"></a>\n<a id=\"fragment\"></a></p>\n<h3 id=\"query-parameters-and-fragments\" translation-result=\"on\">查詢引數及片段<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#query-parameters-and-fragments\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Query parameters and fragments<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#query-parameters-and-fragments\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在<a href=\"guide/router-tutorial-toh#optional-route-parameters\">路由引數</a>部分，你只需要處理該路由的專屬引數。但是，你也可以用查詢引數來獲取對所有路由都可用的可選引數。</p><p translation-origin=\"off\">In the <a href=\"guide/router-tutorial-toh#optional-route-parameters\">route parameters</a> section, you only dealt with parameters specific to the route.\nHowever, you can use query parameters to get optional parameters available to all routes.</p>\n\n<p translation-result=\"on\"><a href=\"https://en.wikipedia.org/wiki/Fragment_identifier\">片段</a>可以參考頁面中帶有特定 <code>id</code> 屬性的元素。</p><p translation-origin=\"off\"><a href=\"https://en.wikipedia.org/wiki/Fragment_identifier\">Fragments</a> refer to certain elements on the page identified with an <code>id</code> attribute.</p>\n\n<p translation-result=\"on\">修改 <code>authGuard</code> 以提供 <code>session_id</code> 查詢引數，在導航到其它路由後，它還會存在。</p><p translation-origin=\"off\">Update the <code>authGuard</code> to provide a <code>session_id</code> query that remains after navigating to another route.</p>\n\n<p translation-result=\"on\">再新增一個錨點（<code>A</code>）元素，來讓你能跳轉到頁面中的正確位置。</p><p translation-origin=\"off\">Add an <code>anchor</code> element so you can jump to a certain point on the page.</p>\n\n<p translation-result=\"on\">為 <code>router.navigate()</code> 方法新增一個 <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> 物件，用來導航到 <code>/login</code> 路由。</p><p translation-origin=\"off\">Add the <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> object to the <code>router.navigate()</code> method that navigates you to the <code>/login</code> route.</p>\n\n<code-example header=\"src/app/auth/auth.guard.ts (v3)\" path=\"router/src/app/auth/auth.guard.4.ts\">\nimport { inject } from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a> } from '@angular/router';\nimport { AuthService } from './auth.service';\n\nexport const authGuard = () =&gt; {\n  const authService = inject(AuthService);\n  const router = inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>);\n\n  if (authService.isLoggedIn) {\n    return true;\n  }\n\n  // Create a dummy session id\n  const sessionId = 123456789;\n\n  // Set our navigation extras object\n  // that contains our <a href=\"api/core/global\" class=\"code-anchor\">global</a> <a href=\"api/animations/query\" class=\"code-anchor\">query</a> params and fragment\n  const navigationExtras: <a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a> = {\n    queryParams: { session_id: sessionId },\n    fragment: 'anchor'\n  };\n\n  // Redirect to the login page with extras\n  return router.createUrlTree(['/login'], navigationExtras);\n};\n\n\n\n</code-example>\n<p translation-result=\"on\">還可以在導航之間<strong>保留</strong>查詢引數和片段，而無需再次在導航中提供。在 <code>LoginComponent</code> 中的 <code>router.navigate()</code> 方法中，新增一個物件作為第二個引數，該<strong>物件</strong>提供了 <code>queryParamsHandling</code> 和 <code>preserveFragment</code>，用於傳遞當前的查詢引數和片段到下一個路由。</p><p translation-origin=\"off\">You can also preserve query parameters and fragments across navigations without having to provide them again when navigating.\nIn the <code>LoginComponent</code>, you'll add an <em>object</em> as the second argument in the <code>router.navigate()</code> function and provide the <code>queryParamsHandling</code> and <code>preserveFragment</code> to pass along the current query parameters and fragment to the next route.</p>\n\n<code-example header=\"src/app/auth/login/login.component.ts (preserve)\" path=\"router/src/app/auth/login/login.component.ts\" region=\"preserve\">\n// Set our navigation extras object\n// that passes on our <a href=\"api/core/global\" class=\"code-anchor\">global</a> <a href=\"api/animations/query\" class=\"code-anchor\">query</a> params and fragment\nconst navigationExtras: <a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a> = {\n  queryParamsHandling: 'preserve',\n  preserveFragment: true\n};\n\n// Redirect the user\nthis.router.navigate([redirectUrl], navigationExtras);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><code>queryParamsHandling</code> 特性還提供了 <code>merge</code> 選項，它將會在導航時保留當前的查詢引數，並與其它查詢引數合併。</p><p translation-origin=\"off\">The <code>queryParamsHandling</code> feature also provides a <code>merge</code> option, which preserves and combines the current query parameters with any provided query parameters when navigating.</p>\n\n</div>\n<p translation-result=\"on\">要在登入後導航到 Admin Dashboard 路由，請更新 <code>admin-dashboard.component.ts</code> 以處理這些查詢引數和片段。</p><p translation-origin=\"off\">To navigate to the Admin Dashboard route after logging in, update <code>admin-dashboard.component.ts</code> to handle the\nquery parameters and fragment.</p>\n\n<code-example header=\"src/app/admin/admin-dashboard/admin-dashboard.component.ts (v2)\" path=\"router/src/app/admin/admin-dashboard/admin-dashboard.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-admin-dashboard',\n  templateUrl: './admin-dashboard.component.html',\n  styleUrls: ['./admin-dashboard.component.css']\n})\nexport class AdminDashboardComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  sessionId!: Observable&lt;string&gt;;\n  token!: Observable&lt;string&gt;;\n\n  constructor(private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>) {}\n\n  ngOnInit() {\n    // Capture the session ID if available\n    this.sessionId = this.route\n      .queryParamMap\n      .pipe(map(params =&gt; params.get('session_id') || 'None'));\n\n    // Capture the fragment if available\n    this.token = this.route\n      .fragment\n      .pipe(map(fragment =&gt; fragment || 'None'));\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">查詢引數和片段可透過 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 服務來使用。和路由引數類似，全域查詢引數和片段也是 <code>Observable</code> 物件。在修改過的英雄管理元件中，你將藉助 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code> 直接把 <code>Observable</code> 傳給範本。</p><p translation-origin=\"off\">Query parameters and fragments are also available through the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> service.\nLike route parameters, the query parameters and fragments are provided as an <code>Observable</code>.\nThe updated Crisis Admin component feeds the <code>Observable</code> directly into the template using the <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code>.</p>\n\n<p translation-result=\"on\">按照下列步驟試驗下：點選 Admin 按鈕，它會帶著你提供的 <code>queryParamMap</code> 和 <code>fragment</code> 跳轉到登入頁。點選 Login 按鈕，你就會被重新導向到 <code>Admin Dashboard</code> 頁。注意，它仍然帶著上一步提供的 <code>queryParamMap</code> 和 <code>fragment</code>。</p><p translation-origin=\"off\">Now, you can click on the Admin button, which takes you to the Login page with the provided <code>queryParamMap</code> and <code>fragment</code>.\nAfter you click the login button, notice that you have been redirected to the <code>Admin Dashboard</code> page with the query parameters and fragment still intact in the address bar.</p>\n\n<p translation-result=\"on\">你可以用這些持久化資訊來攜帶需要為每個頁面都提供的資訊，如認證令牌或會話的 ID 等。</p><p translation-origin=\"off\">You can use these persistent bits of information for things that need to be provided across pages like authentication tokens or session ids.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">“查詢引數”和“片段”也可以分別用 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 中的 <strong>queryParamsHandling</strong> 和 <strong>preserveFragment</strong> 儲存。</p><p translation-origin=\"off\">The <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a> params</code> and <code>fragment</code> can also be preserved using a <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> with the <code>queryParamsHandling</code> and <code>preserveFragment</code> bindings respectively.</p>\n\n</div>\n<p><a id=\"asynchronous-routing\"></a></p>\n<h2 id=\"milestone-6-asynchronous-routing\" translation-result=\"on\">里程碑 6：非同步路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-6-asynchronous-routing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Milestone 6: Asynchronous routing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#milestone-6-asynchronous-routing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">完成上面的里程碑後，應用程式很自然地長大了。在某一個時間點，你將達到一個頂點，應用將會需要過多的時間來載入。</p><p translation-origin=\"off\">As you've worked through the milestones, the application has naturally gotten larger.\nAt some point you'll reach a point where the application takes a long time to load.</p>\n\n<p translation-result=\"on\">為了解決這個問題，請使用非同步路由，它會根據請求來延遲載入某些特性模組。延遲載入有很多好處。</p><p translation-origin=\"off\">To remedy this issue, use asynchronous routing, which loads feature modules lazily, on request.\nLazy loading has multiple benefits.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">你可以只在使用者請求時才載入某些特性區。</p><p translation-origin=\"off\">You can load feature areas only when requested by the user</p>\n\n</li>\n<li>\n<p translation-result=\"on\">對於那些只存取應用程式某些區域的使用者，這樣能加快載入速度。</p><p translation-origin=\"off\">You can speed up load time for users that only visit certain areas of the application</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你可以持續擴充延遲載入特性區的功能，而不用增加初始載入的包體積。</p><p translation-origin=\"off\">You can continue expanding lazy loaded feature areas without increasing the size of the initial load bundle</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">你已經完成了一部分。透過把應用組織成一些模組：<code>AppModule</code>、<code>HeroesModule</code>、<code>AdminModule</code> 和 <code>CrisisCenterModule</code>，你已經有了可用於實現延遲載入的候選者。</p><p translation-origin=\"off\">You're already part of the way there.\nBy organizing the application into modules —<code>AppModule</code>, <code>HeroesModule</code>, <code>AdminModule</code>, and <code>CrisisCenterModule</code>— you have natural candidates for lazy loading.</p>\n\n<p translation-result=\"on\">有些模組（比如 <code>AppModule</code>）必須在啟動時載入，但其它的都可以而且應該延遲載入。比如 <code>AdminModule</code> 就只有少數已認證的使用者才需要它，所以你應該只有在正確的人請求它時才載入。</p><p translation-origin=\"off\">Some modules, like <code>AppModule</code>, must be loaded from the start.\nBut others can and should be lazy loaded.\nThe <code>AdminModule</code>, for example, is needed by a few authorized users, so you should only load it when requested by the right people.</p>\n\n<p><a id=\"lazy-loading-route-config\"></a></p>\n<h3 id=\"lazy-loading-route-configuration\" translation-result=\"on\">延遲載入路由配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#lazy-loading-route-configuration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Lazy Loading route configuration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#lazy-loading-route-configuration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">把 <code>admin-routing.module.ts</code> 中的 <code>admin</code> 路徑從 <code>'admin'</code> 改為空路徑 <code>''</code>。</p><p translation-origin=\"off\">Change the <code>admin</code> path in the <code>admin-routing.module.ts</code> from <code>'admin'</code> to an empty string, <code>''</code>, the empty path.</p>\n\n<p translation-result=\"on\">可以用<em>空路徑</em>路由來對路由進行分組，而不用往 URL 中新增額外的路徑片段。使用者仍舊存取 <code>/admin</code>，並且 <code>AdminComponent</code> 仍然作為用來包含子路由的路由元件。</p><p translation-origin=\"off\">Use empty path routes to group routes together without adding any additional path segments to the URL.\nUsers will still visit <code>/admin</code> and the <code>AdminComponent</code> still serves as the Routing Component containing child routes.</p>\n\n<p translation-result=\"on\">開啟 <code>AppRoutingModule</code>，並把一個新的 <code>admin</code> 路由新增到它的 <code>appRoutes</code> 陣列中。</p><p translation-origin=\"off\">Open the <code>AppRoutingModule</code> and add a new <code>admin</code> route to its <code>appRoutes</code> array.</p>\n\n<p translation-result=\"on\">給它一個 <code>loadChildren</code> 屬性（替換掉 <code>children</code> 屬性）。<code>loadChildren</code> 屬性接收一個函式，該函式使用瀏覽器內建的動態匯入語法 <code>import('...')</code> 來延遲載入程式碼，並返回一個承諾（Promise）。其路徑是 <code>AdminModule</code> 的位置（相對於應用的根目錄）。當代碼請求並載入完畢後，這個 <code>Promise</code> 就會解析成一個包含 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的物件，也就是 <code>AdminModule</code>。</p><p translation-origin=\"off\">Give it a <code>loadChildren</code> property instead of a <code>children</code> property.\nThe <code>loadChildren</code> property takes a function that returns a promise using the browser's built-in syntax for lazy loading code using dynamic imports <code>import('...')</code>.\nThe path is the location of the <code>AdminModule</code> (relative to the application root).\nAfter the code is requested and loaded, the <code>Promise</code> resolves an object that contains the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>, in this case the <code>AdminModule</code>.</p>\n\n<code-example header=\"app-routing.module.ts (load children)\" path=\"router/src/app/app-routing.module.5.ts\" region=\"admin-1\">\n{\n  path: 'admin',\n  loadChildren: () =&gt; import('./admin/admin.module').then(m =&gt; m.AdminModule),\n},\n\n</code-example>\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n當使用絕對路徑時，<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的檔案位置必須以 <code>src/app</code> 開頭，以便正確解析。對於自訂的 <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\">使用絕對路徑的路徑對映表</a>，你必須在專案的 <code>tsconfig.json</code> 中必須配置好 <code>baseUrl</code> 和 <code>paths</code> 屬性。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nWhen using absolute paths, the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> file location must begin with <code>src/app</code> in order to resolve correctly.\nFor custom <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\">path mapping with absolute paths</a>, you must configure the <code>baseUrl</code> and <code>paths</code> properties in the project <code>tsconfig.json</code>.</p>\n\n</div>\n<p translation-result=\"on\">當路由器導航到這個路由時，它會用 <code>loadChildren</code> 字串來動態載入 <code>AdminModule</code>，然後把 <code>AdminModule</code> 新增到當前的路由配置中，最後，它把所請求的路由載入到目標 <code>admin</code> 元件中。</p><p translation-origin=\"off\">When the router navigates to this route, it uses the <code>loadChildren</code> string to dynamically load the <code>AdminModule</code>.\nThen it adds the <code>AdminModule</code> routes to its current route configuration.\nFinally, it loads the requested route to the destination admin component.</p>\n\n<p translation-result=\"on\">延遲載入和重新配置工作只會發生一次，也就是在該路由首次被請求時。在後續的請求中，該模組和路由都是立即可用的。</p><p translation-origin=\"off\">The lazy loading and re-configuration happen just once, when the route is first requested; the module and routes are available immediately for subsequent requests.</p>\n\n<p translation-result=\"on\">最後一步是把管理特性區從主應用中完全分離開。根模組 <code>AppModule</code> 既不能載入也不能參考 <code>AdminModule</code> 及其檔案。</p><p translation-origin=\"off\">Take the final step and detach the admin feature set from the main application.\nThe root <code>AppModule</code> must neither load nor reference the <code>AdminModule</code> or its files.</p>\n\n<p translation-result=\"on\">在 <code>app.module.ts</code> 中，從頂部移除 <code>AdminModule</code> 的匯入陳述式，並且從 NgModule 的 <code>imports</code> 陣列中移除 <code>AdminModule</code>。</p><p translation-origin=\"off\">In <code>app.module.ts</code>, remove the <code>AdminModule</code> import statement from the top of the file and remove the <code>AdminModule</code> from the NgModule's <code>imports</code> array.</p>\n\n<p><a id=\"can-match-guard\"></a></p>\n<h3 id=\"canmatch-guarding-unauthorized-access-of-feature-modules\" translation-result=\"on\"><code>canMatch</code>：保護對特性模組的未授權存取<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#canmatch-guarding-unauthorized-access-of-feature-modules\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\"><code>canMatch</code>: guarding unauthorized access of feature modules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#canmatch-guarding-unauthorized-access-of-feature-modules\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你已經使用 <code>canActivate</code> 保護 <code>AdminModule</code> 了，它會阻止未授權使用者存取管理特性區。如果使用者未登入，它就會跳轉到登入頁。</p><p translation-origin=\"off\">You're already protecting the <code>AdminModule</code> with a <code>canActivate</code> guard that prevents unauthorized users from accessing the admin feature area.\nIt redirects to the login page if the user is not authorized.</p>\n\n<p translation-result=\"on\">但是路由器仍然會載入 <code>AdminModule</code> —— 即使使用者無法存取它的任何一個元件。理想的方式是，只有在使用者已登入的情況下你才載入 <code>AdminModule</code>。</p><p translation-origin=\"off\">But the router is still loading the <code>AdminModule</code> even if the user can't visit any of its components.\nIdeally, you'd only load the <code>AdminModule</code> if the user is logged in.</p>\n\n<p translation-result=\"on\"><code>canMatch</code> 守衛控制著 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 是否會嘗試匹配 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>。這能讓你擁有多個 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> 配置，這些配置共享相同的 <code>path</code> 但根據不同的條件進行匹配。這種方法能讓 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 轉而匹配萬用字元 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>。</p><p translation-origin=\"off\">A <code>canMatch</code> guard controls whether the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> attempts to match a <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>. This lets you have\nmultiple <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> configurations that share the same <code>path</code> but are matched based on different conditions. This approach\nallows the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> to match the wildcard <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> instead.</p>\n\n<p translation-result=\"on\">現有的 <code>authGuard</code> 包含支援 <code>canMatch</code> 守衛的邏輯。</p><p translation-origin=\"off\">The existing <code>authGuard</code> contains the logic to support the <code>canMatch</code> guard.</p>\n\n<p translation-result=\"on\">最後，把 <code>authGuard</code> 新增到 <code>admin</code> 路由的 <code>canMatch</code> 陣列中。完整的 <code>admin</code> 路由是這樣的：</p><p translation-origin=\"off\">Finally, add the <code>authGuard</code> to the <code>canMatch</code> array property for the <code>admin</code> route.\nThe completed admin route looks like this:</p>\n\n<code-example header=\"app-routing.module.ts (lazy admin route)\" path=\"router/src/app/app-routing.module.5.ts\" region=\"admin\">\n{\n  path: 'admin',\n  loadChildren: () =&gt; import('./admin/admin.module').then(m =&gt; m.AdminModule),\n  canMatch: [authGuard]\n},\n\n</code-example>\n<p><a id=\"preloading\"></a></p>\n<h3 id=\"preloading-background-loading-of-feature-areas\" translation-result=\"on\">預載入：特性區的後臺載入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#preloading-background-loading-of-feature-areas\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Preloading: background loading of feature areas<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#preloading-background-loading-of-feature-areas\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">除了按需載入模組外，還可以透過預載入方式非同步載入模組。</p><p translation-origin=\"off\">In addition to loading modules on-demand, you can load modules asynchronously with preloading.</p>\n\n<p translation-result=\"on\">當應用啟動時，<code>AppModule</code> 被急性載入，這意味著它會立即載入。而 <code>AdminModule</code> 只在使用者點選連結時載入，這叫做延遲載入。</p><p translation-origin=\"off\">The <code>AppModule</code> is eagerly loaded when the application starts, meaning that it loads right away.\nNow the <code>AdminModule</code> loads only when the user clicks on a link, which is called lazy loading.</p>\n\n<p translation-result=\"on\">預載入允許你在後台載入模組，以便當使用者啟用某個特定的路由時，就可以渲染這些資料了。考慮一下危機中心。它不是使用者看到的第一個檢視。預設情況下，英雄列表才是第一個檢視。為了獲得最小的初始有效負載和最快的啟動時間，你應該急性載入 <code>AppModule</code> 和 <code>HeroesModule</code>。</p><p translation-origin=\"off\">Preloading lets you load modules in the background so that the data is ready to render when the user activates a particular route.\nConsider the Crisis Center.\nIt isn't the first view that a user sees.\nBy default, the Heroes are the first view.\nFor the smallest initial payload and fastest launch time, you should eagerly load the <code>AppModule</code> and the <code>HeroesModule</code>.</p>\n\n<p translation-result=\"on\">你可以延遲載入危機中心。但是，你幾乎可以肯定使用者會在啟動應用之後的幾分鐘記憶體取危機中心。理想情況下，應用啟動時應該只加載 <code>AppModule</code> 和 <code>HeroesModule</code>，然後幾乎立即開始後臺載入 <code>CrisisCenterModule</code>。在使用者瀏覽到危機中心之前，該模組應該已經載入完畢，可供訪問了。</p><p translation-origin=\"off\">You could lazy load the Crisis Center.\nBut you're almost certain that the user will visit the Crisis Center within minutes of launching the app.\nIdeally, the application would launch with just the <code>AppModule</code> and the <code>HeroesModule</code> loaded and then, almost immediately, load the <code>CrisisCenterModule</code> in the background.\nBy the time the user navigates to the Crisis Center, its module is loaded and ready.</p>\n\n<p><a id=\"how-preloading\"></a></p>\n<h4 id=\"how-preloading-works\" translation-result=\"on\">預載入的工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#how-preloading-works\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">How preloading works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#how-preloading-works\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在每次成功的導航後，路由器會在自己的配置中查詢尚未載入並且可以預載入的模組。是否載入某個模組，以及要載入哪些模組，取決於<em>預載入策略</em>。</p><p translation-origin=\"off\">After each successful navigation, the router looks in its configuration for an unloaded module that it can preload.\nWhether it preloads a module, and which modules it preloads, depends upon the preload strategy.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 提供了兩種預載入策略：</p><p translation-origin=\"off\">The <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> offers two preloading strategies:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">策略</nt-wrapper><nt-wrapper translation-origin=\"off\">Strategies</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">不預載入</nt-wrapper><nt-wrapper translation-origin=\"off\">No preloading</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">這是預設值。延遲載入的特性區仍然會按需載入。</nt-wrapper><nt-wrapper translation-origin=\"off\">The default. Lazy loaded feature areas are still loaded on-demand.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">預載入</nt-wrapper><nt-wrapper translation-origin=\"off\">Preloading</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">預載入所有延遲載入的特性區。</nt-wrapper><nt-wrapper translation-origin=\"off\">All lazy loaded feature areas are preloaded.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">路由器或者完全不預載入或者預載入每個延遲載入模組。\n路由器還支援<a href=\"guide/router-tutorial-toh#custom-preloading\">自訂預載入策略</a>，以便完全控制要預載入哪些模組以及何時載入。</p><p translation-origin=\"off\">The router either never preloads, or preloads every lazy loaded module.\nThe <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> also supports <a href=\"guide/router-tutorial-toh#custom-preloading\">custom preloading strategies</a> for fine control over which modules to preload and when.</p>\n\n<p translation-result=\"on\">本節將指導你把 <code>CrisisCenterModule</code> 改成延遲載入的，並使用 <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> 策略來預載入所有延遲載入模組。</p><p translation-origin=\"off\">This section guides you through updating the <code>CrisisCenterModule</code> to load lazily by default and use the <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> strategy to load all lazy loaded modules.</p>\n\n<p><a id=\"lazy-load-crisis-center\"></a></p>\n<h4 id=\"lazy-load-the-crisis-center\" translation-result=\"on\">延遲載入危機中心<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#lazy-load-the-crisis-center\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Lazy load the crisis center<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#lazy-load-the-crisis-center\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">修改路由配置，來延遲載入 <code>CrisisCenterModule</code>。修改的步驟和配置延遲載入 <code>AdminModule</code> 時一樣。</p><p translation-origin=\"off\">Update the route configuration to lazy load the <code>CrisisCenterModule</code>.\nTake the same steps you used to configure <code>AdminModule</code> for lazy loading.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">把 <code>CrisisCenterRoutingModule</code> 中的路徑從 <code>crisis-center</code> 改為空字串。</p><p translation-origin=\"off\">Change the <code>crisis-center</code> path in the <code>CrisisCenterRoutingModule</code> to an empty string.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">往 <code>AppRoutingModule</code> 中新增一個 <code>crisis-center</code> 路由。</p><p translation-origin=\"off\">Add a <code>crisis-center</code> route to the <code>AppRoutingModule</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">設定 <code>loadChildren</code> 字串來載入 <code>CrisisCenterModule</code>。</p><p translation-origin=\"off\">Set the <code>loadChildren</code> string to load the <code>CrisisCenterModule</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">從 <code>app.module.ts</code> 中移除所有對 <code>CrisisCenterModule</code> 的參考。</p><p translation-origin=\"off\">Remove all mention of the <code>CrisisCenterModule</code> from <code>app.module.ts</code>.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">下面是開啟預載入之前的模組修改版：</p><p translation-origin=\"off\">Here are the updated modules <em>before enabling preload</em>:</p>\n\n<code-tabs>\n    <code-pane header=\"app.module.ts\" path=\"router/src/app/app.module.ts\" region=\"preload\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a> } from '@angular/platform-browser/animations';\n\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> } from '@angular/router';\n\nimport { AppComponent } from './app.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { HeroesModule } from './heroes/heroes.module';\nimport { AuthModule } from './auth/auth.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    HeroesModule,\n    AuthModule,\n    AppRoutingModule,\n  ],\n  declarations: [\n    AppComponent,\n    ComposeMessageComponent,\n    PageNotFoundComponent\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {\n}\n\n</code-pane>\n    <code-pane header=\"app-routing.module.ts\" path=\"router/src/app/app-routing.module.6.ts\" region=\"preload-v1\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport {\n  <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>,\n} from '@angular/router';\n\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nimport { authGuard } from './auth/auth.guard';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'compose',\n    component: ComposeMessageComponent,\n    outlet: 'popup'\n  },\n  {\n    path: 'admin',\n    loadChildren: () =&gt; import('./admin/admin.module').then(m =&gt; m.AdminModule),\n    canMatch: [authGuard]\n  },\n  {\n    path: 'crisis-center',\n    loadChildren: () =&gt; import('./crisis-center/crisis-center.module').then(m =&gt; m.CrisisCenterModule)\n  },\n  { path: '',   redirectTo: '/heroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n    )\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule {}\n\n\n</code-pane>\n    <code-pane header=\"crisis-center-routing.module.ts\" path=\"router/src/app/crisis-center/crisis-center-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { CrisisCenterHomeComponent } from './crisis-center-home/crisis-center-home.component';\nimport { CrisisListComponent } from './crisis-list/crisis-list.component';\nimport { CrisisCenterComponent } from './crisis-center/crisis-center.component';\nimport { CrisisDetailComponent } from './crisis-detail/crisis-detail.component';\n\nimport { canDeactivateGuard } from '../can-deactivate.guard';\nimport { crisisDetailResolver } from './crisis-detail-resolver';\n\nconst crisisCenterRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: '',\n    component: CrisisCenterComponent,\n    children: [\n      {\n        path: '',\n        component: CrisisListComponent,\n        children: [\n          {\n            path: ':id',\n            component: CrisisDetailComponent,\n            canDeactivate: [canDeactivateGuard],\n            resolve: {\n              crisis: crisisDetailResolver\n            }\n          },\n          {\n            path: '',\n            component: CrisisCenterHomeComponent\n          }\n        ]\n      }\n    ]\n  }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(crisisCenterRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class CrisisCenterRoutingModule { }\n\n</code-pane>\n</code-tabs>\n<p translation-result=\"on\">你可以現在嘗試它，並確認在點選了“Crisis Center”按鈕之後載入了 <code>CrisisCenterModule</code>。</p><p translation-origin=\"off\">You could try this now and confirm that the  <code>CrisisCenterModule</code> loads after you click the \"Crisis Center\" button.</p>\n\n<p translation-result=\"on\">要為所有延遲載入模組啟用預載入功能，請從 Angular 的路由模組中匯入 <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code>。</p><p translation-origin=\"off\">To enable preloading of all lazy loaded modules, import the <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> token from the Angular router package.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 方法的第二個引數接受一個附加配置選項物件。<code>preloadingStrategy</code> 就是其中之一。把 <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> 新增到 <code>forRoot()</code> 呼叫中：</p><p translation-origin=\"off\">The second argument in the <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> method takes an object for additional configuration options.\nThe <code>preloadingStrategy</code> is one of those options.\nAdd the <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> token to the <code>forRoot()</code> call:</p>\n\n<code-example header=\"src/app/app-routing.module.ts (preload all)\" path=\"router/src/app/app-routing.module.6.ts\" region=\"forRoot\">\nRouterModule.forRoot(\n  appRoutes,\n  {\n    enableTracing: true, // &lt;-- debugging purposes only\n    preloadingStrategy: <a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a>\n  }\n)\n\n</code-example>\n<p translation-result=\"on\">這項配置會讓 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 預載入器立即載入<em>所有</em>延遲載入路由（帶 <code>loadChildren</code> 屬性的路由）。</p><p translation-origin=\"off\">This configures the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> preloader to immediately load all lazy loaded routes (routes with a <code>loadChildren</code> property).</p>\n\n<p translation-result=\"on\">當存取 <code>http://localhost:4200</code> 時，<code>/heroes</code> 路由立即隨之啟動，並且路由器在載入了 <code>HeroesModule</code> 之後立即開始載入 <code>CrisisCenterModule</code>。</p><p translation-origin=\"off\">When you visit <code>http://localhost:4200</code>, the <code>/heroes</code> route loads immediately upon launch and the router starts loading the <code>CrisisCenterModule</code> right after the <code>HeroesModule</code> loads.</p>\n\n<p><a id=\"custom-preloading\"></a></p>\n<h3 id=\"custom-preloading-strategy\" translation-result=\"on\">自訂預載入策略<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#custom-preloading-strategy\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Custom Preloading Strategy<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#custom-preloading-strategy\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在很多場景下，預載入的每個延遲載入模組都能正常工作。但是，考慮到低頻寬和使用者指標等因素，可以為特定的特性模組使用自訂預載入策略。</p><p translation-origin=\"off\">Preloading every lazy loaded module works well in many situations.\nHowever, in consideration of things such as low bandwidth and user metrics, you can use a custom preloading strategy for specific feature modules.</p>\n\n<p translation-result=\"on\">本節將指導你新增一個自訂策略，它只預載入 <code>data.preload</code> 標誌為 <code>true</code> 路由。回想一下，你可以在路由的 <code>data</code> 屬性中新增任何東西。</p><p translation-origin=\"off\">This section guides you through adding a custom strategy that only preloads routes whose <code>data.preload</code> flag is set to <code>true</code>.\nRecall that you can add anything to the <code>data</code> property of a route.</p>\n\n<p translation-result=\"on\">在 <code>AppRoutingModule</code> 的 <code>crisis-center</code> 路由中設定 <code>data.preload</code> 標誌。</p><p translation-origin=\"off\">Set the <code>data.preload</code> flag in the <code>crisis-center</code> route in the <code>AppRoutingModule</code>.</p>\n\n<code-example header=\"src/app/app-routing.module.ts (route data preload)\" path=\"router/src/app/app-routing.module.ts\" region=\"preload-v2\">\n{\n  path: 'crisis-center',\n  loadChildren: () =&gt; import('./crisis-center/crisis-center.module').then(m =&gt; m.CrisisCenterModule),\n  data: { preload: true }\n},\n\n</code-example>\n<p translation-result=\"on\">產生一個新的 <code>SelectivePreloadingStrategy</code> 服務。</p><p translation-origin=\"off\">Generate a new <code>SelectivePreloadingStrategy</code> service.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate service selective-preloading-strategy\n\n</code-example>\n<p translation-result=\"on\">使用下列內容替換 <code>selective-preloading-strategy.service.ts</code>：</p><p translation-origin=\"off\">Replace the contents of <code>selective-preloading-strategy.service.ts</code> with the following:</p>\n\n<code-example header=\"src/app/selective-preloading-strategy.service.ts\" path=\"router/src/app/selective-preloading-strategy.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/router/PreloadingStrategy\" class=\"code-anchor\">PreloadingStrategy</a>, <a href=\"api/router/Route\" class=\"code-anchor\">Route</a> } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class SelectivePreloadingStrategyService implements <a href=\"api/router/PreloadingStrategy\" class=\"code-anchor\">PreloadingStrategy</a> {\n  preloadedModules: string[] = [];\n\n  preload(route: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>, load: () =&gt; Observable&lt;any&gt;): Observable&lt;any&gt; {\n    if (route.canMatch === undefined &amp;&amp; route.data?.['preload'] &amp;&amp; route.path != null) {\n      // add the route path to the preloaded module array\n      this.preloadedModules.push(route.path);\n\n      // log the route path to the console\n      console.log('Preloaded: ' + route.path);\n\n      return load();\n    } else {\n      return of(null);\n    }\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\"><code>SelectivePreloadingStrategyService</code> 實現了 <code><a href=\"api/router/PreloadingStrategy\" class=\"code-anchor\">PreloadingStrategy</a></code>，它有一個方法 <code>preload()</code>。</p><p translation-origin=\"off\"><code>SelectivePreloadingStrategyService</code> implements the <code><a href=\"api/router/PreloadingStrategy\" class=\"code-anchor\">PreloadingStrategy</a></code>, which has one method, <code>preload()</code>.</p>\n\n<p translation-result=\"on\">路由器會用兩個引數來呼叫 <code>preload()</code> 方法：</p><p translation-origin=\"off\">The router calls the <code>preload()</code> method with two arguments:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">要載入的路由。</p><p translation-origin=\"off\">The route to consider.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">一個載入器（loader）函式，它能非同步載入帶路由的模組。</p><p translation-origin=\"off\">A loader function that can load the routed module asynchronously.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\"><code>preload</code> 的實現要返回一個 <code>Observable</code>。如果該路由應該預載入，它就會返回呼叫載入器函式所返回的 <code>Observable</code>。如果該路由<em>不</em>應該預載入，它就返回一個 <code>null</code> 值的 <code>Observable</code> 物件。</p><p translation-origin=\"off\">An implementation of <code>preload</code> must return an <code>Observable</code>.\nIf the route does preload, it returns the observable returned by calling the loader function.\nIf the route does not preload, it returns an <code>Observable</code> of <code>null</code>.</p>\n\n<p translation-result=\"on\">在這個例子中，如果路由的 <code>data.preload</code> 標誌是真值，則 <code>preload()</code> 方法會載入該路由。</p><p translation-origin=\"off\">In this sample, the  <code>preload()</code> method loads the route if the route's <code>data.preload</code> flag is truthy. We also skip loading the\n<code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> if there is a <code>canMatch</code> guard because the user might\nnot have access to it.</p>\n\n<p translation-result=\"on\">它的副作用是 <code>SelectivePreloadingStrategyService</code> 會把所選路由的 <code>path</code> 記錄在它的公共陣列 <code>preloadedModules</code> 中。</p><p translation-origin=\"off\">As a side effect, <code>SelectivePreloadingStrategyService</code> logs the <code>path</code> of a selected route in its public <code>preloadedModules</code> array.</p>\n\n<p translation-result=\"on\">很快，你就會擴充 <code>AdminDashboardComponent</code> 來注入該服務，並且顯示它的 <code>preloadedModules</code> 陣列。</p><p translation-origin=\"off\">Shortly, you'll extend the <code>AdminDashboardComponent</code> to inject this service and display its <code>preloadedModules</code> array.</p>\n\n<p translation-result=\"on\">但是首先，要對 <code>AppRoutingModule</code> 做少量修改。</p><p translation-origin=\"off\">But first, make a few changes to the <code>AppRoutingModule</code>.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">把 <code>SelectivePreloadingStrategyService</code> 匯入到 <code>AppRoutingModule</code> 中。</p><p translation-origin=\"off\">Import <code>SelectivePreloadingStrategyService</code> into <code>AppRoutingModule</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把 <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> 策略替換成對 <code>forRoot()</code> 的呼叫，並且傳入這個 <code>SelectivePreloadingStrategyService</code>。</p><p translation-origin=\"off\">Replace the <code><a href=\"api/router/PreloadAllModules\" class=\"code-anchor\">PreloadAllModules</a></code> strategy in the call to <code>forRoot()</code> with this <code>SelectivePreloadingStrategyService</code>.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">現在，編輯 <code>AdminDashboardComponent</code> 以顯示這些預載入路由的日誌。</p><p translation-origin=\"off\">Now edit the <code>AdminDashboardComponent</code> to display the log of preloaded routes.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">匯入 <code>SelectivePreloadingStrategyService</code>（它是一個服務）。</p><p translation-origin=\"off\">Import the <code>SelectivePreloadingStrategyService</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把它注入到儀表盤的建構函式中。</p><p translation-origin=\"off\">Inject it into the dashboard's constructor.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">修改範本來顯示這個策略服務的 <code>preloadedModules</code> 陣列。</p><p translation-origin=\"off\">Update the template to display the strategy service's <code>preloadedModules</code> array.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">現在檔案如下：</p><p translation-origin=\"off\">Now the file is as follows:</p>\n\n<code-example header=\"src/app/admin/admin-dashboard/admin-dashboard.component.ts (preloaded modules)\" path=\"router/src/app/admin/admin-dashboard/admin-dashboard.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { SelectivePreloadingStrategyService } from '../../selective-preloading-strategy.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-admin-dashboard',\n  templateUrl: './admin-dashboard.component.html',\n  styleUrls: ['./admin-dashboard.component.css']\n})\nexport class AdminDashboardComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  sessionId!: Observable&lt;string&gt;;\n  token!: Observable&lt;string&gt;;\n  modules: string[] = [];\n\n  constructor(\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    preloadStrategy: SelectivePreloadingStrategyService\n  ) {\n    this.modules = preloadStrategy.preloadedModules;\n  }\n\n  ngOnInit() {\n    // Capture the session ID if available\n    this.sessionId = this.route\n      .queryParamMap\n      .pipe(map(params =&gt; params.get('session_id') || 'None'));\n\n    // Capture the fragment if available\n    this.token = this.route\n      .fragment\n      .pipe(map(fragment =&gt; fragment || 'None'));\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">一旦應用載入完了初始路由，<code>CrisisCenterModule</code> 也被預載入了。透過 <code>Admin</code> 特性區中的記錄就可以驗證它，“Preloaded Modules”中列出了 <code>crisis-center</code>。它也被記錄到了瀏覽器的控制檯。</p><p translation-origin=\"off\">Once the application loads the initial route, the <code>CrisisCenterModule</code> is preloaded.\nVerify this by logging in to the <code>Admin</code> feature area and noting that the <code>crisis-center</code> is listed in the <code>Preloaded Modules</code>.\nIt also logs to the browser's console.</p>\n\n<p><a id=\"redirect-advanced\"></a></p>\n<h3 id=\"migrating-urls-with-redirects\" translation-result=\"on\">使用重新導向遷移 URL<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#migrating-urls-with-redirects\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Migrating URLs with redirects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#migrating-urls-with-redirects\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你已經設定好了路由，並且用命令式和宣告式的方式導航到了很多不同的路由。但是，任何應用的需求都會隨著時間而改變。你把連結 <code>/heroes</code> 和 <code>hero/:id</code> 指向了 <code>HeroListComponent</code> 和 <code>HeroDetailComponent</code> 元件。如果有這樣一個需求，要把連結 <code>heroes</code> 變成 <code>superheroes</code>，你可能仍然希望以前的 URL 能正常導航。但你也不想在應用中找到並修改每一個連結，這時候，重新導向就可以省去這些瑣碎的重構工作。</p><p translation-origin=\"off\">You've set up the routes for navigating around your application and used navigation imperatively and declaratively.\nBut like any application, requirements change over time.\nYou've setup links and navigation to <code>/heroes</code> and <code>/hero/:id</code> from the <code>HeroListComponent</code> and <code>HeroDetailComponent</code> components.\nIf there were a requirement that links to <code>heroes</code> become <code>superheroes</code>, you would still want the previous URLs to navigate correctly.\nYou also don't want to update every link in your application, so redirects makes refactoring routes trivial.</p>\n\n<p><a id=\"url-refactor\"></a></p>\n<h4 id=\"changing-heroes-to-superheroes\" translation-result=\"on\">把 <code>/heroes</code> 改為 <code>/superheroes</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#changing-heroes-to-superheroes\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Changing <code>/heroes</code> to <code>/superheroes</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#changing-heroes-to-superheroes\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">本節將指導你將 <code>Hero</code> 路由遷移到新的 URL。在導航之前，<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 會檢查路由配置中的重新導向陳述式，以便將來按需觸發重新導向。要支援這種修改，你就要在 <code>heroes-routing.module</code> 檔案中把老的路由重新導向到新的路由。</p><p translation-origin=\"off\">This section guides you through migrating the <code>Hero</code> routes to new URLs.\nThe <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> checks for redirects in your configuration before navigating, so each redirect is triggered when needed.\nTo support this change, add redirects from the old routes to the new routes in the <code>heroes-routing.module</code>.</p>\n\n<code-example header=\"src/app/heroes/heroes-routing.module.ts (heroes redirects)\" path=\"router/src/app/heroes/heroes-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { HeroListComponent } from './hero-list/hero-list.component';\nimport { HeroDetailComponent } from './hero-detail/hero-detail.component';\n\nconst heroesRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'heroes', redirectTo: '/superheroes' },\n  { path: 'hero/:id', redirectTo: '/superhero/:id' },\n  { path: 'superheroes',  component: HeroListComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'heroes' } },\n  { path: 'superhero/:id', component: HeroDetailComponent, data: { <a href=\"api/animations/animation\" class=\"code-anchor\">animation</a>: 'hero' } }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forChild(heroesRoutes)\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class HeroesRoutingModule { }\n\n</code-example>\n<p translation-result=\"on\">注意，這裡有兩種型別的重新導向。第一種是不帶引數的從 <code>/heroes</code> 重新導向到 <code>/superheroes</code>。這是一種非常直觀的重新導向。第二種是從 <code>/hero/:id</code> 重新導向到 <code>/superhero/:id</code>，它還要包含一個 <code>:id</code> 路由引數。路由器重新導向時使用強大的模式匹配功能，這樣，路由器就會檢查 URL，並且把 <code>path</code> 中帶的路由引數替換成相應的目標形式。以前，你導航到形如 <code>/hero/15</code> 的 URL 時，帶了一個路由引數 <code>id</code>，它的值是 <code>15</code>。</p><p translation-origin=\"off\">Notice two different types of redirects.\nThe first change is from  <code>/heroes</code> to <code>/superheroes</code> without any parameters.\nThe second change is from <code>/hero/:id</code> to <code>/superhero/:id</code>, which includes the <code>:id</code> route parameter.\nRouter redirects also use powerful pattern-matching, so the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> inspects the URL and replaces route parameters in the <code>path</code> with their appropriate destination.\nPreviously, you navigated to a URL such as <code>/hero/15</code> with a route parameter <code>id</code> of <code>15</code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">在重新導向的時候，路由器還支援<a href=\"guide/router-tutorial-toh#query-parameters\">查詢引數</a>和<a href=\"guide/router-tutorial-toh#fragment\">片段(fragment)</a>。</p><p translation-origin=\"off\">The <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> also supports <a href=\"guide/router-tutorial-toh#query-parameters\">query parameters</a> and the <a href=\"guide/router-tutorial-toh#fragment\">fragment</a> when using redirects.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">當使用絕對地址重新導向時，路由器將會使用路由配置的 <code>redirectTo</code> 屬性中規定的查詢引數和片段。</p><p translation-origin=\"off\">When using absolute redirects, the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> uses the query parameters and the fragment from the <code>redirectTo</code> in the route config</p>\n\n</li>\n<li>\n<p translation-result=\"on\">當使用相對地址重新導向時，路由器將會使用源地址（跳轉前的地址）中的查詢引數和片段。</p><p translation-origin=\"off\">When using relative redirects, the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> use the query params and the fragment from the source URL</p>\n\n</li>\n</ul>\n</div>\n<p translation-result=\"on\">目前，空路徑被重新導向到了 <code>/heroes</code>，它又被重新導向到了 <code>/superheroes</code>。這樣不行，因為 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 在每一層的路由配置中只會處理一次重新導向。這樣可以防止出現無限迴圈的重新導向。</p><p translation-origin=\"off\">Currently, the empty path route redirects to <code>/heroes</code>, which redirects to <code>/superheroes</code>.\nThis won't work because the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> handles redirects once at each level of routing configuration.\nThis prevents chaining of redirects, which can lead to endless redirect loops.</p>\n\n<p translation-result=\"on\">所以，你要在 <code>app-routing.module.ts</code> 中修改空路徑路由，讓它重新導向到 <code>/superheroes</code>。</p><p translation-origin=\"off\">Instead, update the empty path route in <code>app-routing.module.ts</code> to redirect to <code>/superheroes</code>.</p>\n\n<code-example header=\"src/app/app-routing.module.ts (superheroes redirect)\" path=\"router/src/app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> } from '@angular/router';\n\nimport { ComposeMessageComponent } from './compose-message/compose-message.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nimport { authGuard } from './auth/auth.guard';\nimport { SelectivePreloadingStrategyService } from './selective-preloading-strategy.service';\n\nconst appRoutes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'compose',\n    component: ComposeMessageComponent,\n    outlet: 'popup'\n  },\n  {\n    path: 'admin',\n    loadChildren: () =&gt; import('./admin/admin.module').then(m =&gt; m.AdminModule),\n    canMatch: [authGuard]\n  },\n  {\n    path: 'crisis-center',\n    loadChildren: () =&gt; import('./crisis-center/crisis-center.module').then(m =&gt; m.CrisisCenterModule),\n    data: { preload: true }\n  },\n  { path: '',   redirectTo: '/superheroes', pathMatch: 'full' },\n  { path: '**', component: PageNotFoundComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      {\n        enableTracing: false, // &lt;-- debugging purposes only\n        preloadingStrategy: SelectivePreloadingStrategyService,\n      }\n    )\n  ],\n  exports: [\n    <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>\n  ]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p translation-result=\"on\">由於 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 與路由配置無關，所以你要修改相關的路由連結，以便在新的路由啟用時，它們也能保持啟用狀態。還要修改 <code>app.component.ts</code> 範本中的 <code>/heroes</code> 這個 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code>。</p><p translation-origin=\"off\">A <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> isn't tied to route configuration, so update the associated router links to remain active when the new route is active.\nUpdate the <code>app.component.ts</code> template for the <code>/heroes</code> <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code>.</p>\n\n<code-example header=\"src/app/app.component.html (superheroes active routerLink)\" path=\"router/src/app/app.component.html\">\n&lt;div class=\"wrapper\"&gt;\n  &lt;h1 class=\"title\"&gt;Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&lt;/h1&gt;\n  &lt;nav&gt;\n    &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/crisis-center\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Crisis Center&lt;/a&gt;\n    &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/superheroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Heroes&lt;/a&gt;\n    &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/admin\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Admin&lt;/a&gt;\n    &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/login\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Login&lt;/a&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[{ outlets: { popup: ['compose'] } }]\"&gt;Contact&lt;/a&gt;\n  &lt;/nav&gt;\n  &lt;div [@routeAnimation]=\"getRouteAnimationData()\"&gt;\n    &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n  &lt;/div&gt;\n  &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a> name=\"popup\"&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n&lt;/div&gt;\n\n\n</code-example>\n<p translation-result=\"on\">修改 <code>hero-detail.component.ts</code> 中的 <code>goToHeroes()</code> 方法，使用可選的路由引數導航回 <code>/superheroes</code>。</p><p translation-origin=\"off\">Update the <code>goToHeroes()</code> method in the <code>hero-detail.component.ts</code> to navigate back to <code>/superheroes</code> with the optional route parameters.</p>\n\n<code-example header=\"src/app/heroes/hero-detail/hero-detail.component.ts (goToHeroes)\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.ts\" region=\"redirect\">\ngotoHeroes(hero: Hero) {\n  const heroId = hero ? hero.id : null;\n  // Pass along the hero id if available\n  // so that the HeroList component can select that hero.\n  // Include a junk 'foo' property for fun.\n  this.router.navigate(['/superheroes', {id: heroId, foo: 'foo'}]);\n}\n\n</code-example>\n<p translation-result=\"on\">當這些重新導向設定好之後，所有以前的路由都指向了它們的新目標，並且每個 URL 也仍然能正常工作。</p><p translation-origin=\"off\">With the redirects setup, all previous routes now point to their new destinations and both URLs still function as intended.</p>\n\n<p><a id=\"inspect-config\"></a></p>\n<h3 id=\"inspect-the-routers-configuration\" translation-result=\"on\">審查路由器配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#inspect-the-routers-configuration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Inspect the router's configuration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#inspect-the-routers-configuration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要確定你的路由是否真的<a href=\"guide/router-tutorial-toh#routing-module-order\">按照正確的順序</a>執行的，你可以審查路由器的配置。</p><p translation-origin=\"off\">To determine if your routes are actually evaluated <a href=\"guide/router-tutorial-toh#routing-module-order\">in the proper order</a>, you can inspect the router's configuration.</p>\n\n<p translation-result=\"on\">可以透過注入路由器並在控制檯中記錄其 <code>config</code> 屬性來實現。比如，把 <code>AppModule</code> 修改為這樣，並在瀏覽器的控制檯視窗中檢視最終的路由配置。</p><p translation-origin=\"off\">Do this by injecting the router and logging to the console its <code>config</code> property.\nFor example, update the <code>AppModule</code> as follows and look in the browser console window to see the finished route configuration.</p>\n\n<code-example header=\"src/app/app.module.ts (inspect the router config)\" path=\"router/src/app/app.module.7.ts\" region=\"inspect-config\">\nexport class AppModule {\n  // Diagnostic only: inspect router configuration\n  constructor(router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n    // Use a custom replacer to display function names in the route configs\n    const replacer = (key, value) =&gt; (typeof value === 'function') ? value.name : value;\n\n    console.log('<a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>: ', JSON.stringify(router.config, replacer, 2));\n  }\n}\n\n</code-example>\n<p><a id=\"final-app\"></a></p>\n<h2 id=\"final-application\" translation-result=\"on\">最終的應用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#final-application\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Final application<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router-tutorial-toh#final-application\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">對這個已完成的路由器應用，參見 <live-example name=\"router\"></live-example>的最終程式碼。</p><p translation-origin=\"off\">For the completed router application, see the <live-example name=\"router\"></live-example> for the final source code.</p>\n\n<p><a id=\"link-parameters-array\"></a></p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n\n\n\n<!-- links to this doc:\n - api/router/RouterOutlet\n - guide/deployment\n - guide/glossary\n - guide/lazy-loading-ngmodules\n - guide/router\n - guide/router-reference\n - guide/routing-overview\n - guide/testing-components-scenarios\n-->\n<!-- links from this doc:\n - api/animations/animate\n - api/animations/animateChild\n - api/animations/animation\n - api/animations/query\n - api/animations/state\n - api/animations/style\n - api/animations/transition\n - api/animations/trigger\n - api/common/AsyncPipe\n - api/common/CommonModule\n - api/common/NgFor\n - api/common/NgIf\n - api/common/http\n - api/core/Component\n - api/core/Injectable\n - api/core/NgModule\n - api/core/OnInit\n - api/core/global\n - api/forms/DefaultValueAccessor\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/platform-browser/animations/BrowserAnimationsModule\n - api/router/ActivatedRoute\n - api/router/ActivatedRoute#paramMap\n - api/router/ActivatedRouteSnapshot\n - api/router/CanActivateChildFn\n - api/router/CanActivateFn\n - api/router/CanDeactivateFn\n - api/router/CanMatchFn\n - api/router/ChildrenOutletContexts\n - api/router/NavigationExtras\n - api/router/ParamMap\n - api/router/PreloadAllModules\n - api/router/PreloadingStrategy\n - api/router/ResolveFn\n - api/router/Route\n - api/router/Router\n - api/router/Router#navigate\n - api/router/RouterLink\n - api/router/RouterLinkActive\n - api/router/RouterModule\n - api/router/RouterModule#forChild\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/router/RouterStateSnapshot\n - api/router/Routes\n - api/router/UrlTree\n - api/upgrade/static\n - cli\n - cli/generate\n - cli/new\n - guide/animations\n - guide/architecture\n - guide/class-binding\n - guide/router#route-order\n - guide/router-reference#example-config\n - guide/router-tutorial-toh#a-crisis-center-with-child-routes\n - guide/router-tutorial-toh#activated-route-in-action\n - guide/router-tutorial-toh#activatedroute-實戰\n - guide/router-tutorial-toh#activatedroute-服務中的路由引數\n - guide/router-tutorial-toh#add-a-secondary-route\n - guide/router-tutorial-toh#add-an-admin-feature-module\n - guide/router-tutorial-toh#add-heroes-functionality\n - guide/router-tutorial-toh#add-the-logincomponent\n - guide/router-tutorial-toh#add-the-router-outlet\n - guide/router-tutorial-toh#adding-routable-animations\n - guide/router-tutorial-toh#authenticate-with-authguard\n - guide/router-tutorial-toh#benefits-of-a-routing-module\n - guide/router-tutorial-toh#can-activate-child-guard\n - guide/router-tutorial-toh#canactivate-requiring-authentication\n - guide/router-tutorial-toh#canactivatechild-guarding-child-routes\n - guide/router-tutorial-toh#canactivatechild保護子路由\n - guide/router-tutorial-toh#canactivate需要身份驗證\n - guide/router-tutorial-toh#cancel-and-save\n - guide/router-tutorial-toh#candeactivate-handling-unsaved-changes\n - guide/router-tutorial-toh#candeactivate處理未儲存的更改\n - guide/router-tutorial-toh#canmatch-guarding-unauthorized-access-of-feature-modules\n - guide/router-tutorial-toh#canmatch保護對特性模組的未授權存取\n - guide/router-tutorial-toh#changing-heroes-to-superheroes\n - guide/router-tutorial-toh#child-route-configuration\n - guide/router-tutorial-toh#child-routing-component\n - guide/router-tutorial-toh#clear-secondary-routes\n - guide/router-tutorial-toh#clearing-secondary-routes\n - guide/router-tutorial-toh#component-less-route-grouping-routes-without-a-component\n - guide/router-tutorial-toh#create-a-sample-application\n - guide/router-tutorial-toh#custom-preloading\n - guide/router-tutorial-toh#custom-preloading-strategy\n - guide/router-tutorial-toh#define-a-wildcard-route\n - guide/router-tutorial-toh#define-routes\n - guide/router-tutorial-toh#displaying-multiple-routes-in-named-outlets\n - guide/router-tutorial-toh#fetch-data-before-navigating\n - guide/router-tutorial-toh#final-application\n - guide/router-tutorial-toh#fragment\n - guide/router-tutorial-toh#guard-the-admin-feature\n - guide/router-tutorial-toh#hero-feature-routing-requirements\n - guide/router-tutorial-toh#heroes-functionality\n - guide/router-tutorial-toh#heroes-list-optionally-selecting-a-hero\n - guide/router-tutorial-toh#how-preloading-works\n - guide/router-tutorial-toh#import-crisis-center-module-into-the-appmodule-routes\n - guide/router-tutorial-toh#inspect-config\n - guide/router-tutorial-toh#inspect-the-routers-configuration\n - guide/router-tutorial-toh#integrate-routing-with-your-app\n - guide/router-tutorial-toh#lazy-load-the-crisis-center\n - guide/router-tutorial-toh#lazy-loading-route-configuration\n - guide/router-tutorial-toh#link-parameters-array\n - guide/router-tutorial-toh#migrating-urls-with-redirects\n - guide/router-tutorial-toh#milestone-1-getting-started\n - guide/router-tutorial-toh#milestone-1-wrap-up\n - guide/router-tutorial-toh#milestone-2-routing-module\n - guide/router-tutorial-toh#milestone-3-heroes-feature\n - guide/router-tutorial-toh#milestone-3-wrap-up\n - guide/router-tutorial-toh#milestone-4-crisis-center-feature\n - guide/router-tutorial-toh#milestone-5-route-guards\n - guide/router-tutorial-toh#milestone-6-asynchronous-routing\n - guide/router-tutorial-toh#module-import-order\n - guide/router-tutorial-toh#navigate-to-crisis-list-with-a-relative-url\n - guide/router-tutorial-toh#navigating-back-to-the-list-component\n - guide/router-tutorial-toh#objectives\n - guide/router-tutorial-toh#observable-parammap-and-component-reuse\n - guide/router-tutorial-toh#optional-route-parameters\n - guide/router-tutorial-toh#parammap-api\n - guide/router-tutorial-toh#parammap-可觀察物件與路由複用\n - guide/router-tutorial-toh#preloading-background-loading-of-feature-areas\n - guide/router-tutorial-toh#prerequisites\n - guide/router-tutorial-toh#query-parameters\n - guide/router-tutorial-toh#query-parameters-and-fragments\n - guide/router-tutorial-toh#redirect\n - guide/router-tutorial-toh#refactor-the-routing-configuration-into-a-routing-module\n - guide/router-tutorial-toh#register-router-and-routes\n - guide/router-tutorial-toh#relative-navigation\n - guide/router-tutorial-toh#remove-duplicate-hero-routes\n - guide/router-tutorial-toh#remove-heroes-declarations\n - guide/router-tutorial-toh#resolve-pre-fetching-component-data\n - guide/router-tutorial-toh#resolve-預先獲取元件資料\n - guide/router-tutorial-toh#reuse\n - guide/router-tutorial-toh#route-definition-with-a-parameter\n - guide/router-tutorial-toh#route-parameters\n - guide/router-tutorial-toh#route-parameters-in-the-activatedroute-service\n - guide/router-tutorial-toh#route-parameters-required-or-optional\n - guide/router-tutorial-toh#router-tutorial-tour-of-heroes\n - guide/router-tutorial-toh#routing-module\n - guide/router-tutorial-toh#routing-module-order\n - guide/router-tutorial-toh#secondary-route-navigation-merging-routes-during-navigation\n - guide/router-tutorial-toh#secondary-routes\n - guide/router-tutorial-toh#set-up-redirects\n - guide/router-tutorial-toh#setting-the-route-parameters-in-the-list-view\n - guide/router-tutorial-toh#snapshot-the-no-observable-alternative\n - guide/router-tutorial-toh#snapshot當不需要-observable-時的替代品\n - guide/router-tutorial-toh#the-sample-application-in-action\n - guide/router-tutorial-toh#wildcard\n - guide/router-tutorial-toh#使用相對-url-導航到危機列表\n - guide/router-tutorial-toh#使用重新導向遷移-url\n - guide/router-tutorial-toh#建立一個範例應用\n - guide/router-tutorial-toh#前提條件\n - guide/router-tutorial-toh#取消與儲存\n - guide/router-tutorial-toh#在列表檢視中設定路由引數\n - guide/router-tutorial-toh#子路由元件\n - guide/router-tutorial-toh#子路由配置\n - guide/router-tutorial-toh#守護管理特性區\n - guide/router-tutorial-toh#定義路由\n - guide/router-tutorial-toh#定義萬用字元路由\n - guide/router-tutorial-toh#審查路由器配置\n - guide/router-tutorial-toh#導航前預先載入路由資訊\n - guide/router-tutorial-toh#導航回列表元件\n - guide/router-tutorial-toh#將路由配置重構為路由模組\n - guide/router-tutorial-toh#帶引數的路由定義\n - guide/router-tutorial-toh#帶有子路由的危機中心\n - guide/router-tutorial-toh#延遲載入危機中心\n - guide/router-tutorial-toh#延遲載入路由配置\n - guide/router-tutorial-toh#把-heroes-改為-superheroes\n - guide/router-tutorial-toh#把危機中心模組匯入到-appmodule-的路由中\n - guide/router-tutorial-toh#把路由整合到應用中\n - guide/router-tutorial-toh#無元件路由分組路由而不需要元件\n - guide/router-tutorial-toh#最終的應用\n - guide/router-tutorial-toh#查詢引數及片段\n - guide/router-tutorial-toh#模組匯入順序\n - guide/router-tutorial-toh#註冊-router-和-routes\n - guide/router-tutorial-toh#新增-logincomponent\n - guide/router-tutorial-toh#新增一個管理特性模組\n - guide/router-tutorial-toh#新增第二路由\n - guide/router-tutorial-toh#新增英雄管理功能\n - guide/router-tutorial-toh#新增路由出口\n - guide/router-tutorial-toh#新增路由動畫\n - guide/router-tutorial-toh#清除第二路由\n - guide/router-tutorial-toh#用命名出口outlet顯示多重路由\n - guide/router-tutorial-toh#目標\n - guide/router-tutorial-toh#相對導航\n - guide/router-tutorial-toh#移除英雄列表的宣告\n - guide/router-tutorial-toh#移除重複的英雄管理路由\n - guide/router-tutorial-toh#第二路由\n - guide/router-tutorial-toh#第二路由導航在導航期間合併路由\n - guide/router-tutorial-toh#自訂預載入策略\n - guide/router-tutorial-toh#英雄列表選定一個英雄也可不選\n - guide/router-tutorial-toh#英雄特性區的路由需求\n - guide/router-tutorial-toh#範例應用實戰\n - guide/router-tutorial-toh#設定跳轉\n - guide/router-tutorial-toh#路由引數\n - guide/router-tutorial-toh#路由引數必須還是可選\n - guide/router-tutorial-toh#路由器課程英雄之旅\n - guide/router-tutorial-toh#路由模組的優點\n - guide/router-tutorial-toh#透過-authguard-驗證\n - guide/router-tutorial-toh#里程碑-1-小結\n - guide/router-tutorial-toh#里程碑-1起步\n - guide/router-tutorial-toh#里程碑-2路由模組\n - guide/router-tutorial-toh#里程碑-3-的小結\n - guide/router-tutorial-toh#里程碑-3-英雄特徵區\n - guide/router-tutorial-toh#里程碑-4危機中心\n - guide/router-tutorial-toh#里程碑-5路由守衛\n - guide/router-tutorial-toh#里程碑-6非同步路由\n - guide/router-tutorial-toh#預載入特性區的後臺載入\n - guide/router-tutorial-toh#預載入的工作原理\n - guide/singleton-services#forRoot-router\n - start\n - tutorial/tour-of-heroes\n - tutorial/tour-of-heroes/toh-pt4\n - https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\n - https://developer.mozilla.org/docs/Web/API/URLSearchParams\n - https://en.wikipedia.org/wiki/Fragment_identifier\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/router-tutorial-toh.md?message=docs%3A%20請簡述你的修改...\n - https://victorsavkin.com/post/146722301646/angular-router-empty-paths-componentless-routes\n - https://vsavkin.tumblr.com/post/146722301646/angular-router-empty-paths-componentless-routes\n - https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\n - https://www.w3.org/DesignIssues/MatrixURIs.html\n-->"}