{"id":"guide/zone","title":"NgZone","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/zone.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <!-- vale Angular.Google_Headings = NO -->\n<h1 id=\"ngzone\">NgZone<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#ngzone\"><i class=\"material-icons\">link</i></a></h1>\n<!-- vale Angular.Google_Headings = YES -->\n<p translation-result=\"on\">Zone 是跨非同步任務而持久存在的執行上下文。你可以將其視為 JavaScript VM 中的<a href=\"https://en.wikipedia.org/wiki/Thread-local_storage\">執行緒本地儲存</a>。本指南介紹瞭如何使用 Angular 的 的 NgZone 自動檢測元件中的更改以更新 HTML。</p><p translation-origin=\"off\">A zone is an execution context that persists across async tasks.\nYou can think of it as <a href=\"https://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage</a> for the JavaScript VM.\nThis guide describes how to use Angular's NgZone to automatically detect changes in the component to update HTML.</p>\n\n<h2 id=\"fundamentals-of-change-detection\" translation-result=\"on\">變更檢測的基礎<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#fundamentals-of-change-detection\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Fundamentals of change detection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#fundamentals-of-change-detection\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要理解 <code><a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a></code> 的好處，重要的是要清楚地瞭解什麼是變更檢測以及它的工作原理。</p><p translation-origin=\"off\">To understand the benefits of <code><a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a></code>, it is important to have a clear grasp of what change detection is and how it works.</p>\n\n<h3 id=\"displaying-and-updating-data-in-angular\" translation-result=\"on\">在 Angular 中顯示和更新資料<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#displaying-and-updating-data-in-angular\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Displaying and updating data in Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#displaying-and-updating-data-in-angular\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 Angular 中，你可以透過把 HTML 範本中的控制項繫結到 Angular 元件的屬性來顯示資料。</p><p translation-origin=\"off\">In Angular, you can display data by binding controls in an HTML template to the properties of an Angular component.</p>\n\n<code-example header=\"src/app/app.component.ts\" path=\"displaying-data/src/app/app.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: `\n    &lt;h1&gt;{{title}}&lt;/h1&gt;\n    &lt;h2&gt;My favorite hero is: {{myHero}}&lt;/h2&gt;\n    `\n})\nexport class AppComponent {\n  title = 'Tour of Heroes';\n  myHero = 'Windstorm';\n}\n\n\n</code-example>\n<p translation-result=\"on\">另外，你也可以將 DOM 事件繫結到 Angular 元件中的方法。在此類方法中，你還可以更新 Angular 元件的屬性，該屬性將更新範本中顯示的相應資料。</p><p translation-origin=\"off\">You can also bind DOM events to a method of an Angular component.\nIn such methods, you can also update a property of the Angular component, which updates the corresponding data displayed in the template.</p>\n\n<code-example header=\"src/app/click-me.component.ts\" path=\"user-input/src/app/click-me.component.ts\" region=\"click-me-component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-click-me',\n  template: `\n    &lt;button type=\"button\" (click)=\"onClickMe()\"&gt;Click me!&lt;/button&gt;\n    {{clickMessage}}`\n})\nexport class ClickMeComponent {\n  clickMessage = '';\n\n  onClickMe() {\n    this.clickMessage = 'You are my hero!';\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">在以上兩個範例中，元件的程式碼僅更新元件的屬性。但是，HTML 也會自動更新。本指南介紹了 Angular 如何以及何時根據 Angular 元件中的資料渲染 HTML。</p><p translation-origin=\"off\">In both of the preceding examples, the component's code updates only the property of the component.\nThe HTML is also updated automatically.\nThis guide describes how and when Angular renders the HTML based on the data from the Angular component.</p>\n\n<h3 id=\"detecting-changes-with-plain-javascript\" translation-result=\"on\">使用普通（Plain）JavaScript 檢測更改<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#detecting-changes-with-plain-javascript\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Detecting changes with plain JavaScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#detecting-changes-with-plain-javascript\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">為了闡明如何檢測到更改和更新值，請考慮以下用普通 JavaScript 編寫的程式碼。</p><p translation-origin=\"off\">To clarify how changes are detected and values updated, consider the following code written in plain JavaScript.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\n&lt;html&gt;\n  &lt;div id=\"dataDiv\"&gt;&lt;/div&gt;\n  &lt;button id=\"btn\"&gt;updateData&lt;/button&gt;\n  &lt;canvas id=\"canvas\"&gt;&lt;/canvas&gt;\n  &lt;script&gt;\n    let value = 'initialValue';\n    // initial rendering\n    detectChange();\n\n    function renderHTML() {\n      document.getElementById('dataDiv').innerText = value;\n    }\n\n    function detectChange() {\n      const currentValue = document.getElementById('dataDiv').innerText;\n      if (currentValue !== value) {\n        renderHTML();\n      }\n    }\n\n    // Example 1: update data inside button click event handler\n    document.getElementById('btn').addEventListener('click', () =&gt; {\n      // update value\n      value = 'button update value';\n      // call detectChange manually\n      detectChange();\n    });\n\n    // Example 2: HTTP Request\n    const xhr = new XMLHttpRequest();\n    xhr.addEventListener('load', function() {\n      // get response from server\n      value = this.responseText;\n      // call detectChange manually\n      detectChange();\n    });\n    xhr.open('GET', serverUrl);\n    xhr.send();\n\n    // Example 3: setTimeout\n    setTimeout(() =&gt; {\n      // update value inside setTimeout callback\n      value = 'timeout update value';\n      // call detectChange manually\n      detectChange();\n    }, 100);\n\n    // Example 4: Promise.then\n    Promise.resolve('promise resolved a value').then(v =&gt; {\n      // update value inside Promise thenCallback\n      value = v;\n      // call detectChange manually\n      detectChange();\n    }, 100);\n\n    // Example 5: some other asynchronous APIs\n    document.getElementById('canvas').toBlob(blob =&gt; {\n      // update value when blob data is created from the canvas\n      value = `value updated by canvas, size is ${blob.size}`;\n      // call detectChange manually\n      detectChange();\n    });\n  &lt;/script&gt;\n&lt;/html&gt;\n\n</code-example>\n<p translation-result=\"on\">更新資料後，需要呼叫 <code>detectChange()</code> 來檢查資料是否已更改。如果資料已更改，則渲染 HTML 以反映更新的資料。</p><p translation-origin=\"off\">After you update the data, you need to call <code>detectChange()</code> manually to see whether the data changed.\nIf the data changed, you render the HTML to reflect the updated data.</p>\n\n<p translation-result=\"on\">在 Angular 中，此步驟是不必要的。每當你更新資料時，你的 HTML 都會自動更新。</p><p translation-origin=\"off\">In Angular, this step is unnecessary.\nWhenever you update the data, your HTML is updated automatically.</p>\n\n<h3 id=\"when-apps-update-html\" translation-result=\"on\">應用何時更新 HTML<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#when-apps-update-html\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">When apps update HTML<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#when-apps-update-html\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要了解變更檢測的工作原理，請首先考慮應用程式何時需要更新 HTML。通常，會由於以下原因之一而發生更新：</p><p translation-origin=\"off\">To understand how change detection works, first consider when the application needs to update the HTML.\nTypically, updates occur for one of the following reasons:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">元件初始化。比如，當引導 Angular 應用程式時，Angular 會載入引導元件並觸發 <a href=\"api/core/ApplicationRef#tick\"><code>ApplicationRef.tick()</code></a> 來呼叫變更檢測和檢視渲染。</p><p translation-origin=\"off\">Component initialization.\nFor example, when bootstrapping an Angular application, Angular loads the bootstrap component and triggers the <a href=\"api/core/ApplicationRef#tick\"><code>ApplicationRef.tick()</code></a> to call change detection and View Rendering.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">事件監聽器。DOM 事件偵聽器可以更新 Angular 元件中的資料，還可以觸發變更檢測，如下例所示。</p><p translation-origin=\"off\">Event listener.\nThe DOM event listener can update the data in an Angular component and also trigger change detection, as in the following example.</p>\n\n<code-example header=\"src/app/click-me.component.ts\" path=\"user-input/src/app/click-me.component.ts\" region=\"click-me-component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-click-me',\n  template: `\n    &lt;button type=\"button\" (click)=\"onClickMe()\"&gt;Click me!&lt;/button&gt;\n    {{clickMessage}}`\n})\nexport class ClickMeComponent {\n  clickMessage = '';\n\n  onClickMe() {\n    this.clickMessage = 'You are my hero!';\n  }\n}\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">HTTP 資料請求。你還可以透過 HTTP 請求從伺服器獲取資料。比如：</p><p translation-origin=\"off\">HTTP Data Request.\nYou can also get data from a server through an HTTP request.\nFor example:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&lt;div&gt;{{data}}&lt;/div&gt;';\n})\nexport class AppComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  data = 'initial value';\n  serverUrl = 'SERVER_URL';\n  constructor(private httpClient: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) {}\n\n  ngOnInit() {\n    this.httpClient.get(this.serverUrl).subscribe(response =&gt; {\n      // user does not need to <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> change detection manually\n      this.data = response.data;\n    });\n  }\n}\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">宏任務，比如 <code>setTimeout()</code> 或 <code>setInterval()</code>。你還可以在諸如 <code>setTimeout()</code> <code>macroTask</code> 的回呼(Callback)函式中更新資料。比如：</p><p translation-origin=\"off\">MacroTasks, such as <code>setTimeout()</code> or <code>setInterval()</code>.\nYou can also update the data in the callback function of a <code>macroTask</code> such as <code>setTimeout()</code>.\nFor example:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&lt;div&gt;{{data}}&lt;/div&gt;';\n})\nexport class AppComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  data = 'initial value';\n\n  ngOnInit() {\n    setTimeout(() =&gt; {\n      // user does not need to <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> change detection manually\n      this.data = 'value updated';\n    });\n  }\n}\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">微任務，比如 <code>Promise.then()</code>。其他非同步 API（比如 <code>fetch</code>）會返回 Promise 物件，因此 <code>then()</code> 回呼(Callback)函式也可以更新資料。比如：</p><p translation-origin=\"off\">MicroTasks, such as <code>Promise.then()</code>.\nOther asynchronous APIs return a Promise object (such as <code>fetch</code>), so the <code>then()</code> callback function can also update the data.\nFor example:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&lt;div&gt;{{data}}&lt;/div&gt;';\n})\nexport class AppComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  data = 'initial value';\n\n  ngOnInit() {\n    Promise.resolve(1).then(v =&gt; {\n      // user does not need to <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> change detection manually\n      this.data = v;\n    });\n  }\n}\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">其他非同步操作。除了 <code>addEventListener()</code>，<code>setTimeout()</code> 和 <code>Promise.then()</code>，還有其他一些操作可以非同步更新資料。比如 <code>WebSocket.onmessage()</code> 和 <code>Canvas.toBlob()</code>。</p><p translation-origin=\"off\">Other async operations.\nBesides <code>addEventListener()</code>, <code>setTimeout()</code> and <code>Promise.then()</code>, there are other operations that can update the data asynchronously.\nSome examples include <code>WebSocket.onmessage()</code> and <code>Canvas.toBlob()</code>.</p>\n\n<p translation-result=\"on\">前面的列表包含應用程式可能會在其中更改資料的最常見場景。只要 Angular 檢測到資料可能已更改，就會執行變更檢測。變更檢測的結果是 DOM 被這些新資料更新。Angular 會以不同的方式檢測變化。對於元件初始化，Angular 呼叫顯式變更檢測。對於<a href=\"https://developer.mozilla.org/docs/Learn/JavaScript/Asynchronous\">非同步操作</a>，Angular 會使用 Zone 在資料可能被修改的地方檢測變化，並自動執行變更檢測。</p><p translation-origin=\"off\">The preceding list contains most common scenarios in which the application might change the data.\nAngular runs change detection whenever it detects that data could have changed.\nThe result of change detection is that the DOM is updated with new data.\nAngular detects the changes in different ways.\nFor component initialization, Angular calls change detection explicitly.\nFor <a href=\"https://developer.mozilla.org/docs/Learn/JavaScript/Asynchronous\">asynchronous operations</a>, Angular uses a zone to detect changes in places where the data could have possibly mutated and it runs change detection automatically.</p>\n\n</li>\n</ol>\n<h2 id=\"zones-and-execution-contexts\" translation-result=\"on\">Zone 和執行上下文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#zones-and-execution-contexts\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Zones and execution contexts<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#zones-and-execution-contexts\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Zone 提供了在非同步任務之間持久存在的執行上下文。<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/this\">執行上下文</a>是一個抽象概念，用於在當前執行的程式碼中儲存有關環境的資訊。考慮以下範例：</p><p translation-origin=\"off\">A zone provides an execution context that persists across async tasks.\n<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/this\">Execution Context</a> is an abstract concept that holds information about the environment within the current code being executed.\nConsider the following example:</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst callback = function() {\n  console.log('setTimeout callback context is', this);\n}\n\nconst ctx1 = { name: 'ctx1' };\nconst ctx2 = { name: 'ctx2' };\n\nconst func = function() {\n  console.log('caller context is', this);\n  setTimeout(callback);\n}\n\nfunc.apply(ctx1);\nfunc.apply(ctx2);\n\n</code-example>\n<p translation-result=\"on\"><code>setTimeout()</code> 回呼(Callback)中的 <code>this</code> 值可能會有所不同，具體取決於 <code>setTimeout()</code> 的呼叫時機。因此，你可能會在非同步操作中丟失上下文。</p><p translation-origin=\"off\">The value of <code>this</code> in the callback of <code>setTimeout()</code> might differ depending on when <code>setTimeout()</code> is called.\nThus, you can lose the context in asynchronous operations.</p>\n\n<p translation-result=\"on\">Zone 提供了不同於 <code>this</code> 的新的 Zone 上下文，該 Zone 上下文在非同步操作中保持不變。在下例中，新的 Zone 上下文稱為 <code>zoneThis</code>。</p><p translation-origin=\"off\">A zone provides a new zone context other than <code>this</code>, the zone context that persists across asynchronous operations.\nIn the following example, the new zone context is called <code>zoneThis</code>.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nzone.run(() =&gt; {\n  // now you are in a zone\n  expect(zoneThis).toBe(zone);\n  setTimeout(function() {\n    // the zoneThis context will be the same zone\n    // when the setTimeout is scheduled\n    expect(zoneThis).toBe(zone);\n  });\n});\n\n</code-example>\n<p translation-result=\"on\">新的上下文 <code>zoneThis</code> 可以從 <code>setTimeout()</code> 的回呼(Callback)函式中檢索出來，這個上下文和呼叫 <code>setTimeout()</code> 時的上下文是一樣的。要獲取此上下文，可以呼叫 <a href=\"https://github.com/angular/angular/blob/main/packages/zone.js/lib/zone.ts\"><code>Zone.current</code></a>。</p><p translation-origin=\"off\">This new context, <code>zoneThis</code>, can be retrieved from the <code>setTimeout()</code> callback function, and this context is the same when the <code>setTimeout()</code> is scheduled.\nTo get the context, you can call <a href=\"https://github.com/angular/angular/blob/main/packages/zone.js/lib/zone.ts\"><code>Zone.current</code></a>.</p>\n\n<h2 id=\"zones-and-async-lifecycle-hooks\" translation-result=\"on\">Zone 和非同步生命週期鉤子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#zones-and-async-lifecycle-hooks\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Zones and async lifecycle hooks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#zones-and-async-lifecycle-hooks\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Zone.js 可以建立在非同步操作中持久存在的上下文，併為非同步操作提供生命週期鉤子。</p><p translation-origin=\"off\">Zone.js can create contexts that persist across asynchronous operations as well as provide lifecycle hooks for asynchronous operations.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst zone = Zone.current.fork({\n  name: 'zone',\n  onScheduleTask: function(delegate, curr, target, task) {\n    console.log('new task is scheduled:', task.type, task.source);\n    return delegate.scheduleTask(target, task);\n  },\n  onInvokeTask: function(delegate, curr, target, task, applyThis, applyArgs) {\n    console.log('task will be invoked:', task.type, task.source);\n    return delegate.invokeTask(target, task, applyThis, applyArgs);\n  },\n  onHasTask: function(delegate, curr, target, hasTaskState) {\n    console.log('task state changed in the zone:', hasTaskState);\n    return delegate.hasTask(target, hasTaskState);\n  },\n  onInvoke: function(delegate, curr, target, callback, applyThis, applyArgs) {\n    console.log('the callback will be invoked:', callback);\n    return delegate.invoke(target, callback, applyThis, applyArgs);\n  }\n});\nzone.run(() =&gt; {\n  setTimeout(() =&gt; {\n    console.log('timeout callback is invoked.');\n  });\n});\n\n</code-example>\n<p translation-result=\"on\">上面的範例建立了一個具有多個鉤子的 Zone。</p><p translation-origin=\"off\">The preceding example creates a zone with several hooks.</p>\n\n<p translation-result=\"on\">當任務狀態更改時，就會觸發 <code>onXXXTask</code> 鉤子。<em>Zone 任務</em>的概念與 JavaScript VM 中任務的概念非常相似：</p><p translation-origin=\"off\">The <code>onXXXTask</code> hooks trigger when the status of the task changes.\nThe concept of a <em>Zone Task</em> is comparable to the JavaScript VM Task concept:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>macroTask</code>：比如 <code>setTimeout()</code></p><p translation-origin=\"off\"><code>macroTask</code>: such as <code>setTimeout()</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>microTask</code>：比如 <code>Promise.then()</code></p><p translation-origin=\"off\"><code>microTask</code>: such as <code>Promise.then()</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>eventTask</code>：比如 <code>element.addEventListener()</code></p><p translation-origin=\"off\"><code>eventTask</code>: such as <code>element.addEventListener()</code></p>\n\n</li>\n</ul>\n<p translation-result=\"on\">這些鉤子在以下情況下觸發：</p><p translation-origin=\"off\">These hooks trigger under the following circumstances:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">鉤子</nt-wrapper><nt-wrapper translation-origin=\"off\">Hooks</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>onScheduleTask</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在計劃新的非同步任務時觸發，比如呼叫 <code>setTimeout()</code> 時。</nt-wrapper><nt-wrapper translation-origin=\"off\">Triggers when a new asynchronous task is scheduled, such as when you call <code>setTimeout()</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>onInvokeTask</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在非同步任務即將執行時觸發，比如 <code>setTimeout()</code> 的回呼(Callback)即將執行時。</nt-wrapper><nt-wrapper translation-origin=\"off\">Triggers when an asynchronous task is about to run, such as when the callback of <code>setTimeout()</code> is about to run.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>onHasTask</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">當 Zone 內的一種任務的狀態從穩定變為不穩定或從不穩定變為穩定時觸發。狀態“穩定”表示該 Zone 內沒有任務，而“不穩定”表示在該 Zone 中計劃了新任務。</nt-wrapper><nt-wrapper translation-origin=\"off\">Triggers when the status of one kind of task inside a zone changes from stable to unstable or from unstable to stable. A status of \"stable\" means there are no tasks inside the zone, while \"unstable\" means a new task is scheduled in the zone.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>onInvoke</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">將在 Zone 中執行同步函式時觸發。</nt-wrapper><nt-wrapper translation-origin=\"off\">Triggers when a synchronous function is going to run in the zone.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">使用這些鉤子，<code>Zone</code> 可以監視 Zone 內所有同步和非同步操作的狀態。</p><p translation-origin=\"off\">With these hooks, <code>Zone</code> can observe the status of all synchronous and asynchronous operations inside a zone.</p>\n\n<p translation-result=\"on\">上面的範例返回以下輸出：</p><p translation-origin=\"off\">The preceding example returns the following output:</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nthe callback will be invoked: () =&gt; {\n  setTimeout(() =&gt; {\n    console.log('timeout callback is invoked.');\n  });\n}\nnew task is scheduled: macroTask setTimeout\ntask state changed in the zone: { microTask: false,\n  macroTask: true,\n  eventTask: false,\n  change: 'macroTask' }\ntask will be invoked macroTask: setTimeout\ntimeout callback is invoked.\ntask state changed in the zone: { microTask: false,\n  macroTask: false,\n  eventTask: false,\n  change: 'macroTask' }\n\n</code-example>\n<p translation-result=\"on\"><code>Zone</code> 的所有函式都由一個名為 <a href=\"https://github.com/angular/angular/tree/main/packages/zone.js/README.md\">Zone.js</a> 的函式庫提供。該庫透過猴子補丁攔截非同步 API 來實現這些特性。猴子補丁是一種在執行時新增或更改函式的預設行為而不更改原始碼的技術。</p><p translation-origin=\"off\">All of the functions of <code>Zone</code> are provided by a library called <a href=\"https://github.com/angular/angular/tree/main/packages/zone.js/README.md\">Zone.js</a>.\nThis library implements those features by intercepting asynchronous APIs through monkey patching.\nMonkey patching is a technique to add or alter the default behavior of a function at runtime without changing the source code.</p>\n\n<!-- vale Angular.Google_Headings = NO -->\n<h2 id=\"ngzone-1\">NgZone<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#ngzone-1\"><i class=\"material-icons\">link</i></a></h2>\n<!-- vale Angular.Google_Headings = YES -->\n<p translation-result=\"on\">雖然 Zone.js 可以監視同步和非同步操作的所有狀態，但 Angular 還提供了一項名為 NgZone 的服務。滿足以下條件時，此服務會建立一個名為 <code>angular</code> 的 Zone 來自動觸發變更檢測。</p><p translation-origin=\"off\">While Zone.js can observe all the states of synchronous and asynchronous operations, Angular additionally provides a service called NgZone.\nThis service creates a zone named <code>angular</code> to automatically trigger change detection when the following conditions are satisfied:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">當執行同步或非同步功能時</p><p translation-origin=\"off\">When a sync or async function is executed</p>\n\n</li>\n<li>\n<p translation-result=\"on\">已經沒有已計劃的 <code>microTask</code></p><p translation-origin=\"off\">When there is no <code>microTask</code> scheduled</p>\n\n</li>\n</ol>\n<!-- vale Angular.Google_Headings = NO -->\n<h3 id=\"ngzone-run-and-runoutsideofangular\" translation-result=\"on\">NgZone <code>run()</code> 和 <code>runOutsideOfAngular()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#ngzone-run-and-runoutsideofangular\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">NgZone <code>run()</code> and <code>runOutsideOfAngular()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#ngzone-run-and-runoutsideofangular\"><i class=\"material-icons\">link</i></a></h3>\n\n<!-- vale Angular.Google_Headings = YES -->\n<p translation-result=\"on\"><code>Zone</code> 處理大多數非同步 API，比如 <code>setTimeout()</code>、<code>Promise.then()</code> 和 <code>addEventListener()</code>。有關完整列表，請參見 <a href=\"https://github.com/angular/angular/blob/main/packages/zone.js/MODULE.md\">Zone 模組的文件</a>。在這些非同步 API 中，你無需手動觸發變更檢測。</p><p translation-origin=\"off\"><code>Zone</code> handles most asynchronous APIs such as <code>setTimeout()</code>, <code>Promise.then()</code>, and <code>addEventListener()</code>.\nFor the full list, see the <a href=\"https://github.com/angular/angular/blob/main/packages/zone.js/MODULE.md\">Zone Module document</a>.\nIn those asynchronous APIs, you don't need to trigger change detection manually.</p>\n\n<p translation-result=\"on\">有些第三方 API 沒有被 Zone 處理。在這種情況下，<code><a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a></code> 服務提供了 <a href=\"api/core/NgZone#run\"><code>run()</code></a> 方法，該方法允許你在 <code>angular</code> Zone 中執行函式。此函式以及該函式中的所有非同步操作會在正確的時間自動觸發變更檢測。</p><p translation-origin=\"off\">Some third party APIs are not handled by Zone.\nIn those cases, the <code><a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a></code> service provides a <a href=\"api/core/NgZone#run\"><code>run()</code></a> method that allows you to run a function inside the Angular zone.\nThis function, and all asynchronous operations in that function, triggers change detection automatically at the correct time.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport class AppComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private ngZone: <a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a>) {}\n  ngOnInit() {\n    // New async API is not handled by Zone, so you need to use ngZone.run()\n    // to make the asynchronous operation callback in the Angular zone and\n    // <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> change detection automatically.\n    someNewAsyncAPI(() =&gt; {\n      this.ngZone.run(() =&gt; {\n        // update the data of the component\n      });\n    });\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">預設情況下，所有非同步操作都在 Angular Zone 內，這會自動觸發變更檢測。另一個常見的情況是你不想觸發變更檢測。在這種情況下，你可以使用另一個 <code><a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a></code> 方法：<a href=\"api/core/NgZone#runoutsideangular\"><code>runOutsideAngular()</code></a>。</p><p translation-origin=\"off\">By default, all asynchronous operations are inside the Angular zone, which triggers change detection automatically.\nAnother common case is when you don't want to trigger change detection.\nIn that situation, you can use another <code><a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a></code> method: <a href=\"api/core/NgZone#runoutsideangular\"><code>runOutsideAngular()</code></a>.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport class AppComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private ngZone: <a href=\"api/core/NgZone\" class=\"code-anchor\">NgZone</a>) {}\n  ngOnInit() {\n    // You know no data will be updated,\n    // so you don't want to <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> change detection in this\n    // specified operation. Instead, call ngZone.runOutsideAngular()\n    this.ngZone.runOutsideAngular(() =&gt; {\n      setTimeout(() =&gt; {\n        // update component data\n        // but don't <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> change detection.\n      });\n    });\n  }\n}\n\n</code-example>\n<!-- vale Angular.Google_Headings = NO -->\n<h3 id=\"setting-up-zonejs\" translation-result=\"on\">設定 Zone.js<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#setting-up-zonejs\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Setting up Zone.js<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#setting-up-zonejs\"><i class=\"material-icons\">link</i></a></h3>\n\n<!-- vale Angular.Google_Headings = YES -->\n<p translation-result=\"on\">為了使 Zone.js 在 Angular 中可用，你需要匯入 <code>zone.js</code> 套件。如果使用的是 Angular CLI，則此步驟將自動完成，並且你會在 <code>src/polyfills.ts</code> 中看到以下行：</p><p translation-origin=\"off\">To make Zone.js available in Angular, you need to import the <code>zone.js</code> package.\nIf you are using the Angular CLI, this step is done automatically, and you can see the following line in the <code>src/polyfills.ts</code>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n/***************************************************************************************************\n * Zone JS is required by default for Angular itself.\n */\nimport 'zone.js';  // Included with Angular CLI.\n\n</code-example>\n<p translation-result=\"on\">在匯入 <code>zone.js</code> 軟體包之前，你可以做如下配置：</p><p translation-origin=\"off\">Before importing the <code>zone.js</code> package, you can set the following configurations:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">禁用一些非同步 API 的猴子補丁，以獲得更好的效能。比如，你可以禁用 <code>requestAnimationFrame()</code> 的猴子補丁，這樣 <code>requestAnimationFrame()</code> 的回呼(Callback)就不會觸發變更檢測。如果你的應用程式不會在 <code>requestAnimationFrame()</code> 回呼(Callback)中更新任何資料，則這種方式很有用。</p><p translation-origin=\"off\">Disabling some asynchronous API monkey patching for better performance.\nFor example, disabling the <code>requestAnimationFrame()</code> monkey patch, so the callback of <code>requestAnimationFrame()</code> does not trigger change detection.\nThis is useful if, in your application, the callback of the <code>requestAnimationFrame()</code> does not update any data.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">指定某些 DOM 事件不在 Angular Zone 內執行；比如，為了防止 <code>mousemove</code> 或 <code>scroll</code> 事件來觸發變更檢測。</p><p translation-origin=\"off\">Specify that certain DOM events do not run inside the Angular zone. For example, to prevent a <code>mousemove</code> or <code>scroll</code> event to trigger change detection</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">還可以更改另外幾個設定。要進行這些更改，你需要建立一個 <code>zone-flags.ts</code> 檔案，如下所示。</p><p translation-origin=\"off\">Several other settings can be changed.\nTo make these changes, you need to create a <code>zone-flags.ts</code> file, such as the following.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n// disable patching requestAnimationFrame\n(window as any).__Zone_disable_requestAnimationFrame = true;\n\n// disable patching specified eventNames\n(window as any).__zone_symbol__UNPATCHED_EVENTS = ['scroll', 'mousemove'];\n\n</code-example>\n<p translation-result=\"on\">接著，在 <code>polyfills.ts</code> 中匯入 <code>zone.js</code> 之前先匯入 <code>zone-flags</code>：</p><p translation-origin=\"off\">Next, import <code>zone-flags</code> before you import <code>zone.js</code> in the <code>polyfills.ts</code>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n/***************************************************************************************************\n * Zone JS is required by default for Angular.\n */\nimport `./zone-flags`;\nimport 'zone.js';  // Included with Angular CLI.\n\n</code-example>\n<p translation-result=\"on\">有關可以配置的內容的更多資訊，請參閱<a href=\"https://github.com/angular/angular/tree/main/packages/zone.js\">Zone.js</a>文件。</p><p translation-origin=\"off\">For more information about what you can configure, see the <a href=\"https://github.com/angular/angular/tree/main/packages/zone.js\">Zone.js</a> documentation.</p>\n\n<!-- vale Angular.Google_Headings = NO -->\n<h3 id=\"noopzone\">NoopZone<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/zone#noopzone\"><i class=\"material-icons\">link</i></a></h3>\n<!-- vale Angular.Google_Headings = YES -->\n<p translation-result=\"on\"><code>Zone</code> 能幫助 Angular 知道何時要觸發變更檢測，並使開發人員專注於應用開發。預設情況下，<code>Zone</code> 已載入且無需其他配置即可工作。也不是一定要用 <code>Zone</code> 才能使 Angular 工作。相反，你也可以選擇自己觸發變更檢測。</p><p translation-origin=\"off\"><code>Zone</code> helps Angular know when to trigger change detection and let the developers focus on the application development.\nBy default, <code>Zone</code> is loaded and works without further configuration.\nYou don't necessarily have to use <code>Zone</code> to make Angular work.\nInstead, you can opt to trigger change detection on your own.</p>\n\n<div class=\"callout is-helpful\">\n<header ng-should-translate=\"\" translation-result=\"on\">禁用 <code>Zone</code></header><header ng-should-translate=\"\" translation-origin=\"off\">Disabling Zone</header>\n\n<p translation-result=\"on\"><strong>如果禁用了 <code>Zone</code>，你就要自己在正確的時間觸發所有變更檢測，這需要你對變更檢測機制有全面的瞭解</strong>。</p><p translation-origin=\"off\"><strong>Disabling <code>Zone</code> requires you to trigger all change detection at the correct timing yourself, which requires comprehensive knowledge of change detection</strong>.</p>\n\n</div>\n<p translation-result=\"on\">要刪除 Zone.js，請進行以下更改。</p><p translation-origin=\"off\">To remove Zone.js, make the following changes.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">從 <code>polyfills.ts</code> 中移除對 <code>zone.js</code> 的匯入：</p><p translation-origin=\"off\">Remove the <code>zone.js</code> import from <code>polyfills.ts</code>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n/***************************************************************************************************\n * Zone JS is required by default for Angular itself.\n */\n// import 'zone.js';  // Included with Angular CLI.\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">在 <code>src/main.ts</code> 中使用 <code>noop</code> Zone 引導 Angular：</p><p translation-origin=\"off\">Bootstrap Angular with the <code>noop</code> zone in <code>src/main.ts</code>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule, { ngZone: 'noop' })\n.catch(err =&gt; console.error(err));\n\n</code-example>\n</li>\n</ol>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/animations/trigger\n - api/common/http/HttpClient\n - api/core/ApplicationRef#tick\n - api/core/Component\n - api/core/NgZone\n - api/core/NgZone#run\n - api/core/NgZone#runoutsideangular\n - api/core/OnInit\n - api/platform-browser-dynamic/platformBrowserDynamic\n - guide/zone#detecting-changes-with-plain-javascript\n - guide/zone#displaying-and-updating-data-in-angular\n - guide/zone#fundamentals-of-change-detection\n - guide/zone#ngzone\n - guide/zone#ngzone-1\n - guide/zone#ngzone-run-and-runoutsideofangular\n - guide/zone#ngzone-run-和-runoutsideofangular\n - guide/zone#noopzone\n - guide/zone#setting-up-zonejs\n - guide/zone#when-apps-update-html\n - guide/zone#zone-和非同步生命週期鉤子\n - guide/zone#zone-和執行上下文\n - guide/zone#zones-and-async-lifecycle-hooks\n - guide/zone#zones-and-execution-contexts\n - guide/zone#使用普通plainjavascript-檢測更改\n - guide/zone#變更檢測的基礎\n - guide/zone#在-angular-中顯示和更新資料\n - guide/zone#應用何時更新-html\n - guide/zone#設定-zonejs\n - https://developer.mozilla.org/docs/Learn/JavaScript/Asynchronous\n - https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/this\n - https://en.wikipedia.org/wiki/Thread-local_storage\n - https://github.com/angular/angular/blob/main/packages/zone.js/MODULE.md\n - https://github.com/angular/angular/blob/main/packages/zone.js/lib/zone.ts\n - https://github.com/angular/angular/tree/main/packages/zone.js\n - https://github.com/angular/angular/tree/main/packages/zone.js/README.md\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/zone.md?message=docs%3A%20請簡述你的修改...\n-->"}