{"id":"guide/schematics-authoring","title":"Authoring schematics","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/schematics-authoring.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"authoring-schematics\" translation-result=\"on\">創作原理圖<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#authoring-schematics\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Authoring schematics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#authoring-schematics\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">你可以建立自己的原理圖來對 Angular 專案進行操作。庫開發人員通常會把這些原理圖與他們的函式庫打包在一起，以便把它們與 Angular CLI 整合在一起。你也可以建立獨立的原理圖來操作 Angular 應用中的檔案和目錄結構，以便為你的開發環境客製它們，並讓它們符合你的標準和約束。多個原理圖還可以串聯起來，透過執行其它原理圖來完成複雜的操作。</p><p translation-origin=\"off\">You can create your own schematics to operate on Angular projects.\nLibrary developers typically package schematics with their libraries to integrate them with the Angular CLI.\nYou can also create stand-alone schematics to manipulate the files and constructs in Angular applications as a way of customizing them for your development environment and making them conform to your standards and constraints.\nSchematics can be chained, running other schematics to perform complex operations.</p>\n\n<p translation-result=\"on\">在應用程式中操作程式碼可能既強大又危險。比如，建立一個已存在的檔案會出錯，如果出現這種情況，就應該放棄已應用的所有其它更改。Angular 原理圖工具透過建立虛擬檔案系統來防止副作用和錯誤。原理圖描述了一個可應用於虛擬檔案系統的轉換管道。當原理圖執行時，轉換就會被記錄在記憶體中，只有當這些更改被確認有效時，才會應用到實際的檔案系統中。</p><p translation-origin=\"off\">Manipulating the code in an application has the potential to be both very powerful and correspondingly dangerous.\nFor example, creating a file that already exists would be an error, and if it was applied immediately, it would discard all the other changes applied so far.\nThe Angular Schematics tooling guards against side effects and errors by creating a virtual file system.\nA schematic describes a pipeline of transformations that can be applied to the virtual file system.\nWhen a schematic runs, the transformations are recorded in memory, and only applied in the real file system once they're confirmed to be valid.</p>\n\n<h2 id=\"schematics-concepts\" translation-result=\"on\">原理圖的概念<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#schematics-concepts\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Schematics concepts<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#schematics-concepts\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">原理圖的公共 API 定義了表達其基本概念的類別。</p><p translation-origin=\"off\">The public API for schematics defines classes that represent the basic concepts.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">虛擬檔案系統用 <code>Tree</code>（樹）表示。<code>Tree</code> 資料結構包含一個<em>基礎狀態 base</em>（一組已經存在的檔案）和一個 <em>暫存區 staging</em>（需要應用到 base 的更改列表）。在進行修改的過程中，你並沒有真正改變它的 base，而是把那些修改新增到了暫存區。</p><p translation-origin=\"off\">The virtual file system is represented by a <code>Tree</code>.\nThe <code>Tree</code> data structure contains a <em>base</em> (a set of files that already exists) and a <em>staging area</em> (a list of changes to be applied to the base).\nWhen making modifications, you don't actually change the base, but add those modifications to the staging area.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>Rule</code>（規則）物件定義了一個函式，它接受 <code>Tree</code>，進行轉換，並返回一個新的 <code>Tree</code>。原理圖的主檔案 <code>index.ts</code> 定義了一組實現原理圖邏輯的規則。</p><p translation-origin=\"off\">A <code>Rule</code> object defines a function that takes a <code>Tree</code>, applies transformations, and returns a new <code>Tree</code>.\nThe main file for a schematic, <code>index.ts</code>, defines a set of rules that implement the schematic's logic.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">轉換由 <code>Action</code>（動作）表示。有四種動作型別：<code>Create</code>、<code>Rename</code>、<code>Overwrite</code> 和 <code>Delete</code>。</p><p translation-origin=\"off\">A transformation is represented by an <code>Action</code>.\nThere are four action types: <code>Create</code>, <code>Rename</code>, <code>Overwrite</code>, and <code>Delete</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">每個原理圖都在一個上下文中執行，上下文由一個 <code>SchematicContext</code> 物件表示。</p><p translation-origin=\"off\">Each schematic runs in a context, represented by a <code>SchematicContext</code> object.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">傳給規則的上下文物件可以存取該原理圖可能會用到的工具函式和元資料，包括一個幫助除錯的日誌 API。上下文還定義了一個<em>合併策略</em>，用於確定如何將這些更改從暫存樹合併到基礎樹中。可以接受或忽略某個更改，也可以丟擲例外。</p><p translation-origin=\"off\">The context object passed into a rule provides access to utility functions and metadata that the schematic might need to work with, including a logging API to help with debugging.\nThe context also defines a <em>merge strategy</em> that determines how changes are merged from the staged tree into the base tree.\nA change can be accepted or ignored, or throw an exception.</p>\n\n<h3 id=\"defining-rules-and-actions\" translation-result=\"on\">定義規則和動作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#defining-rules-and-actions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Defining rules and actions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#defining-rules-and-actions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當你使用 <a href=\"guide/schematics-authoring#cli\">Schematics CLI</a> 建立一個新的空白原理圖時，它所產生的入口函式就是一個<em>規則工廠</em>。<code>RuleFactory</code> 物件定義了一個用於建立 <code>Rule</code> 的高階函式。</p><p translation-origin=\"off\">When you create a new blank schematic with the <a href=\"guide/schematics-authoring#cli\">Schematics CLI</a>, the generated entry function is a <em>rule factory</em>.\nA <code>RuleFactory</code> object defines a higher-order function that creates a <code>Rule</code>.</p>\n\n<code-example header=\"index.ts\" language=\"typescript\">\n\nimport { Rule, SchematicContext, Tree } from '@angular-devkit/schematics';\n\n// You don't have to export the function as default.\n// You can also have more than one rule factory per file.\nexport function helloWorld(_options: any): Rule {\n return (tree: Tree, _context: SchematicContext) =&gt; {\n   return tree;\n };\n}\n\n</code-example>\n<p translation-result=\"on\">你的這些規則可以透過呼叫外部工具和實現邏輯來修改你的專案。比如，你需要一個規則來定義如何將原理圖中的範本合併到宿主專案中。</p><p translation-origin=\"off\">Your rules can make changes to your projects by calling external tools and implementing logic.\nYou need a rule, for example, to define how a template in the schematic is to be merged into the hosting project.</p>\n\n<p translation-result=\"on\">規則可以利用 <code>@schematics/angular</code> 套件提供的實用工具。尋求輔助函式來處理模組、依賴、TypeScript、AST、JSON、Angular CLI 工作區和專案等等。</p><p translation-origin=\"off\">Rules can make use of utilities provided with the <code>@schematics/angular</code> package.\nLook for helper functions for working with modules, dependencies, TypeScript, AST, JSON, Angular CLI workspaces and projects, and more.</p>\n\n<code-example header=\"index.ts\" language=\"typescript\">\n\nimport {\n  JsonAstObject,\n  JsonObject,\n  JsonValue,\n  Path,\n  normalize,\n  parseJsonAst,\n  strings,\n} from '@angular-devkit/core';\n\n</code-example>\n<h3 id=\"defining-input-options-with-a-schema-and-interfaces\" translation-result=\"on\">利用模式和介面來定義輸入選項<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#defining-input-options-with-a-schema-and-interfaces\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Defining input options with a schema and interfaces<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#defining-input-options-with-a-schema-and-interfaces\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">規則可以從呼叫者那裡收集選項值，並把它們注入到範本中。規則可用的選項及其允許的值和預設值是在原理圖的 JSON 模式檔案 <code>&lt;schematic&gt;/schema.json</code> 中定義的。可以用 TypeScript 介面來為這個模式定義變數或列舉的資料型別。</p><p translation-origin=\"off\">Rules can collect option values from the caller and inject them into templates.\nThe options available to your rules, with their allowed values and defaults, are defined in the schematic's JSON schema file, <code>&lt;schematic&gt;/schema.json</code>.\nDefine variable or enumerated data types for the schema using TypeScript interfaces.</p>\n\n<p translation-result=\"on\">該模式定義了原理圖中使用的變數的型別和預設值。比如，假設的 “Hello World” 原理圖可能具有以下模式定義（schema）。</p><p translation-origin=\"off\">The schema defines the types and default values of variables used in the schematic.\nFor example, the hypothetical \"Hello World\" schematic might have the following schema.</p>\n\n<code-example header=\"src/hello-world/schema.json\" language=\"json\">\n\n{\n    \"properties\": {\n        \"name\": {\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"default\": \"world\"\n        },\n        \"useColor\": {\n            \"type\": \"boolean\"\n        }\n    }\n}\n</code-example>\n<p translation-result=\"on\">可以在 <a href=\"https://github.com/angular/angular-cli/blob/main/packages/schematics/angular/application/schema.json\"><code>@schematics/angular</code></a> 中看到 Angular CLI 命令原理圖的模式檔案範例。</p><p translation-origin=\"off\">See examples of schema files for the Angular CLI command schematics in <a href=\"https://github.com/angular/angular-cli/blob/main/packages/schematics/angular/application/schema.json\"><code>@schematics/angular</code></a>.</p>\n\n<h3 id=\"schematic-prompts\" translation-result=\"on\">原理圖提示<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#schematic-prompts\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Schematic prompts<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#schematic-prompts\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">原理圖<em>提示</em>能將使用者互動引入到原理圖執行過程中。可以配置原理圖選項，以向用戶顯示可自訂的問題。在執行原理圖之前會顯示提示，然後將使用者的響應用作選項的值。這使得使用者可以指導原理圖的操作，而無需深入瞭解可用選項的全部範圍。</p><p translation-origin=\"off\">Schematic <em>prompts</em> introduce user interaction into schematic execution.\nConfigure schematic options to display a customizable question to the user.\nThe prompts are displayed before the execution of the schematic, which then uses the response as the value for the option.\nThis lets users direct the operation of the schematic without requiring in-depth knowledge of the full spectrum of available options.</p>\n\n<p translation-result=\"on\">比如，這個 “Hello World” 原理圖可能會要求使用者提供他的名字，並顯示該名字以代替預設名字 “world”。要定義這樣的提示，請將 <code>x-prompt</code> 屬性新增到 <code>name</code> 變數的模式中。</p><p translation-origin=\"off\">The \"Hello World\" schematic might, for example, ask the user for their name, and display that name in place of the default name \"world\".\nTo define such a prompt, add an <code>x-prompt</code> property to the schema for the <code>name</code> variable.</p>\n\n<p translation-result=\"on\">類似地，你可以新增一個提示，以允許使用者確定原理圖在執行其 hello 操作時是否將使用顏色。帶有兩個提示的模式如下。</p><p translation-origin=\"off\">Similarly, you can add a prompt to let the user decide whether the schematic uses color when executing its hello action.\nThe schema with both prompts would be as follows.</p>\n\n<code-example header=\"src/hello-world/schema.json\" language=\"json\">\n\n{\n    \"properties\": {\n        \"name\": {\n            \"type\": \"string\",\n            \"minLength\": 1,\n            \"default\": \"world\",\n            \"x-prompt\": \"What is your name?\"\n        },\n        \"useColor\": {\n            \"type\": \"boolean\",\n            \"x-prompt\": \"Would you like the response in color?\"\n        }\n    }\n}\n</code-example>\n<h4 id=\"prompt-short-form-syntax\" translation-result=\"on\">提示的簡寫語法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#prompt-short-form-syntax\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Prompt short-form syntax<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#prompt-short-form-syntax\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">這些範例使用提示語法的簡寫形式，僅提供問題的文字。在大多數情況下，這就是所需要的。但是請注意，這兩個提示要求使用不同型別的輸入。使用簡寫形式時，將根據屬性的模式自動選擇最合適的型別。在該範例中，<code>name</code> 提示使用 <code>input</code> 型別，因為它是一個字串屬性。<code>useColor</code> 提示使用 <code>confirmation</code> 型別，因為它是布林屬性。在這種情況下，“是” 對應於 <code>true</code> 而 “否” 對應於 <code>false</code>。</p><p translation-origin=\"off\">These examples use a shorthand form of the prompt syntax, supplying only the text of the question.\nIn most cases, this is all that is required.\nNotice however, that the two prompts expect different types of input.\nWhen using the shorthand form, the most appropriate type is automatically selected based on the property's schema.\nIn the example, the <code>name</code> prompt uses the <code>input</code> type because it is a string property.\nThe <code>useColor</code> prompt uses a <code>confirmation</code> type because it is a Boolean property.\nIn this case, \"yes\" corresponds to <code>true</code> and \"no\" corresponds to <code>false</code>.</p>\n\n<p translation-result=\"on\">支援三種輸入型別。</p><p translation-origin=\"off\">There are three supported input types.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">輸入型別</nt-wrapper><nt-wrapper translation-origin=\"off\">Input type</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">確認</nt-wrapper><nt-wrapper translation-origin=\"off\">confirmation</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">是或否的問題；布林選項的理想選擇。</nt-wrapper><nt-wrapper translation-origin=\"off\">A yes or no question; ideal for Boolean options.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">輸入</nt-wrapper><nt-wrapper translation-origin=\"off\">input</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">文字輸入；字串或數字選項的理想選擇。</nt-wrapper><nt-wrapper translation-origin=\"off\">Textual input; ideal for string or number options.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">清單</nt-wrapper><nt-wrapper translation-origin=\"off\">list</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">預定義的一組允許值。</nt-wrapper><nt-wrapper translation-origin=\"off\">A predefined set of allowed values.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">簡而言之，型別是根據屬性的型別和約束來推斷的。</p><p translation-origin=\"off\">In the short form, the type is inferred from the property's type and constraints.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">屬性模式</nt-wrapper><nt-wrapper translation-origin=\"off\">Property schema</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">提示型別</nt-wrapper><nt-wrapper translation-origin=\"off\">Prompt type</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\">\"type\": \"boolean\"</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">確認（“yes” = <code>true</code>，“no” = <code>false</code>）</nt-wrapper><nt-wrapper translation-origin=\"off\">confirmation (\"yes\"=<code>true</code>, \"no\"=<code>false</code>)</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\">\"type\": \"string\"</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">輸入</nt-wrapper><nt-wrapper translation-origin=\"off\">input</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\">\"type\": \"number\"</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">輸入（僅接受有效數字）</nt-wrapper><nt-wrapper translation-origin=\"off\">input (only valid numbers accepted)</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\">\"type\": \"integer\"</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">輸入（僅接受有效數字）</nt-wrapper><nt-wrapper translation-origin=\"off\">input (only valid numbers accepted)</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\">\"enum\": […]</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">列表（列舉成員成為列表中的選擇項）</nt-wrapper><nt-wrapper translation-origin=\"off\">list (enum members become list selections)</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">在以下範例中，該屬性採用列舉值，因此原理圖將自動選擇列表型別，並根據可能的值建立選單。</p><p translation-origin=\"off\">In the following example, the property takes an enumerated value, so the schematic automatically chooses the list type, and creates a menu from the possible values.</p>\n\n<code-example header=\"schema.json\" language=\"json\">\n\n\"style\": {\n  \"description\": \"The file extension or preprocessor to use for style files.\",\n  \"type\": \"string\",\n  \"default\": \"css\",\n  \"enum\": [\n    \"css\",\n    \"scss\",\n    \"sass\",\n    \"less\",\n    \"styl\"\n  ],\n  \"x-prompt\": \"Which stylesheet format would you like to use?\"\n}\n\n</code-example>\n<p translation-result=\"on\">提示執行時會根據 JSON 模式中提供的約束條件自動驗證提供的響應。如果該值不可接受，則提示使用者輸入新值。這樣可以確保傳遞到原理圖的任何值都符合原理圖實現的期望，因此你無需在原理圖的程式碼中新增其它檢查。</p><p translation-origin=\"off\">The prompt runtime automatically validates the provided response against the constraints provided in the JSON schema.\nIf the value is not acceptable, the user is prompted for a new value.\nThis ensures that any values passed to the schematic meet the expectations of the schematic's implementation, so that you do not need to add additional checks within the schematic's code.</p>\n\n<h4 id=\"prompt-long-form-syntax\" translation-result=\"on\">提示的長格式語法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#prompt-long-form-syntax\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Prompt long-form syntax<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#prompt-long-form-syntax\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在需要對提示進行其它自訂和控制情況下，<code>x-prompt</code> 欄位也支援長格式語法。在這種形式下，<code>x-prompt</code> 欄位值是帶有子欄位的 JSON 物件，這些子欄位可自訂提示的行為。</p><p translation-origin=\"off\">The <code>x-prompt</code> field syntax supports a long form for cases where you require additional customization and control over the prompt.\nIn this form, the <code>x-prompt</code> field value is a JSON object with subfields that customize the behavior of the prompt.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">欄位</nt-wrapper><nt-wrapper translation-origin=\"off\">Field</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">資料值</nt-wrapper><nt-wrapper translation-origin=\"off\">Data value</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\">type</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><code>confirmation</code>，<code>input</code> 或 <code>list</code>（以簡短形式自動選擇）</nt-wrapper><nt-wrapper translation-origin=\"off\"><code>confirmation</code>, <code>input</code>, or <code>list</code> (selected automatically in short form)</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\">message</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">字串（必填）</nt-wrapper><nt-wrapper translation-origin=\"off\">string (required)</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\">items</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">字串和/或“標籤/值”物件（僅對 <code>list</code> 型別有效）</nt-wrapper><nt-wrapper translation-origin=\"off\">string and/or label/value object pair (only valid with type <code>list</code>)</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">下面的長格式範例來自 CLI 用來<a href=\"https://github.com/angular/angular-cli/blob/ba8a6ea59983bb52a6f1e66d105c5a77517f062e/packages/schematics/angular/application/schema.json#L56\">產生應用程式</a>的原理圖的 JSON 模式。它定義提示，允許使用者選擇要用於正在建立的應用程式的樣式預處理器。透過使用長格式，原理圖可以為選單選項提供更明確的格式。</p><p translation-origin=\"off\">The following example of the long form is from the JSON schema for the schematic that the CLI uses to <a href=\"https://github.com/angular/angular-cli/blob/ba8a6ea59983bb52a6f1e66d105c5a77517f062e/packages/schematics/angular/application/schema.json#L56\">generate applications</a>.\nIt defines the prompt that lets users choose which style preprocessor they want to use for the application being created.\nBy using the long form, the schematic can provide more explicit formatting of the menu choices.</p>\n\n<code-example header=\"package/schematics/angular/application/schema.json\" language=\"json\">\n\n\"style\": {\n  \"description\": \"The file extension or preprocessor to use for style files.\",\n  \"type\": \"string\",\n  \"default\": \"css\",\n  \"enum\": [\n    \"css\",\n    \"scss\",\n    \"sass\",\n    \"less\"\n  ],\n  \"x-prompt\": {\n    \"message\": \"Which stylesheet format would you like to use?\",\n    \"type\": \"list\",\n    \"items\": [\n      { \"value\": \"css\",  \"label\": \"CSS\" },\n      { \"value\": \"scss\", \"label\": \"SCSS   [ https://sass-lang.com/documentation/syntax#scss                ]\" },\n      { \"value\": \"sass\", \"label\": \"Sass   [ https://sass-lang.com/documentation/syntax#the-indented-syntax ]\" },\n      { \"value\": \"less\", \"label\": \"Less   [ http://lesscss.org/                                            ]\" }\n    ]\n  },\n},\n\n</code-example>\n<h4 id=\"x-prompt-schema\" translation-result=\"on\"><code>x-prompt</code> 模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#x-prompt-schema\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">x-prompt schema<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#x-prompt-schema\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">定義原理圖選項的 JSON 模式支援擴充，以允許對提示及其相應行為進行宣告式定義。無需其它邏輯或更改原理圖程式碼即可支援提示。以下 JSON 模式是 <code>x-prompt</code> 欄位的長格式語法的完整描述。</p><p translation-origin=\"off\">The JSON schema that defines a schematic's options supports extensions to allow the declarative definition of prompts and their respective behavior.\nNo additional logic or changes are required to the code of a schematic to support the prompts.\nThe following JSON schema is a complete description of the long-form syntax for the <code>x-prompt</code> field.</p>\n\n<code-example header=\"x-prompt schema\" language=\"json\">\n\n{\n    \"oneOf\": [\n        { \"type\": \"string\" },\n        {\n            \"type\": \"object\",\n            \"properties\": {\n                \"type\": { \"type\": \"string\" },\n                \"message\": { \"type\": \"string\" },\n                \"items\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"oneOf\": [\n                            { \"type\": \"string\" },\n                            {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"label\": { \"type\": \"string\" },\n                                    \"value\": { }\n                                },\n                                \"required\": [ \"value\" ]\n                            }\n                        ]\n                    }\n                }\n            },\n            \"required\": [ \"message\" ]\n        }\n    ]\n}\n\n</code-example>\n<p><a id=\"cli\"></a></p>\n<h2 id=\"schematics-cli\" translation-result=\"on\">原理圖 CLI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#schematics-cli\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Schematics CLI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#schematics-cli\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">原理圖有自己的命令列工具。使用 Node 6.9 或以上版本，全域安裝 Schematics 命令列工具：</p><p translation-origin=\"off\">Schematics come with their own command-line tool.\nUsing Node 6.9 or later, install the Schematics command line tool globally:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install -g @angular-devkit/schematics-cli\n\n</code-example>\n<p translation-result=\"on\">這將安裝可執行檔案 <code>schematics</code>，你可以用它在自己的專案資料夾中建立一個新的原理圖集合、把一個新的原理圖新增到一個現有的集合中，或者擴充一個現有的原理圖。</p><p translation-origin=\"off\">This installs the <code>schematics</code> executable, which you can use to create a new schematics collection in its own project folder, add a new schematic to an existing collection, or extend an existing schematic.</p>\n\n<p translation-result=\"on\">在下面的章節中，我們將使用 CLI 建立一個新的原理圖集合，以介紹檔案和目錄結構，以及一些基本概念。</p><p translation-origin=\"off\">In the following sections, you will create a new schematics collection using the CLI to introduce the files and file structure, and some of the basic concepts.</p>\n\n<p translation-result=\"on\">但是，原理圖的最常見用途是將 Angular 函式庫與 Angular CLI 整合在一起。可以直接在 Angular 工作區的函式庫專案中建立原理圖檔案，而無需使用 Schematics CLI。參閱<a href=\"guide/schematics-for-libraries\">庫的原理圖</a>。</p><p translation-origin=\"off\">The most common use of schematics, however, is to integrate an Angular library with the Angular CLI.\nDo this by creating the schematic files directly within the library project in an Angular workspace, without using the Schematics CLI.\nSee <a href=\"guide/schematics-for-libraries\">Schematics for Libraries</a>.</p>\n\n<h3 id=\"creating-a-schematics-collection\" translation-result=\"on\">建立一個原理圖的集合<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#creating-a-schematics-collection\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Creating a schematics collection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#creating-a-schematics-collection\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">下列命令用來在同名的新專案資料夾中建立一個名為 <code>hello-world</code> 的新原理圖。</p><p translation-origin=\"off\">The following command creates a new schematic named <code>hello-world</code> in a new project folder of the same name.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nschematics blank --name=hello-world\n\n</code-example>\n<p translation-result=\"on\"><code>blank</code> 原理圖是由 Schematics CLI 提供的。該命令用於建立一個新的專案資料夾（該集合的根資料夾），並在該集合中建立一個最初的命名原理圖。</p><p translation-origin=\"off\">The <code>blank</code> schematic is provided by the Schematics CLI.\nThe command creates a new project folder (the root folder for the collection) and an initial named schematic in the collection.</p>\n\n<p translation-result=\"on\">轉到 collection 資料夾，安裝你的 npm 依賴，然後在常用的編輯器中開啟這個新集合，看看所產生的檔案。比如，如果你正在使用 VS Code：</p><p translation-origin=\"off\">Go to the collection folder, install your npm dependencies, and open your new collection in your favorite editor to see the generated files.\nFor example, if you are using VS Code:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\ncd hello-world\nnpm install\nnpm run build\ncode .\n\n</code-example>\n<p translation-result=\"on\">最初的原理圖與專案資料夾的名字相同，是在 <code>src/hello-world</code> 中產生的。可以把相關的原理圖新增到這個集合中，並修改所產生的骨架程式碼來定義原理圖的功能。每個原理圖的名稱在集合中都必須是唯一的。</p><p translation-origin=\"off\">The initial schematic gets the same name as the project folder, and is generated in <code>src/hello-world</code>.\nAdd related schematics to this collection, and modify the generated skeleton code to define your schematic's functionality.\nEach schematic name must be unique within the collection.</p>\n\n<h3 id=\"running-a-schematic\" translation-result=\"on\">執行原理圖<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#running-a-schematic\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Running a schematic<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#running-a-schematic\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">使用 <code>schematics</code> 命令執行一個命名原理圖。按以下格式提供專案資料夾的路徑、原理圖名稱和所有必選項。</p><p translation-origin=\"off\">Use the <code>schematics</code> command to run a named schematic.\nProvide the path to the project folder, the schematic name, and any mandatory options, in the following format.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nschematics &lt;path-to-schematics-project&gt;:&lt;schematics-name&gt; --&lt;required-option&gt;=&lt;value&gt;\n\n</code-example>\n<p translation-result=\"on\">該路徑可以是絕對路徑，也可以是執行該命令的當前工作目錄的相對路徑。比如，要執行剛產生的原理圖（它沒有必選項），請使用下面的命令。</p><p translation-origin=\"off\">The path can be absolute or relative to the current working directory where the command is executed.\nFor example, to run the schematic you just generated (which has no required options), use the following command.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nschematics .:hello-world\n\n</code-example>\n<h3 id=\"adding-a-schematic-to-a-collection\" translation-result=\"on\">把原理圖新增到集合中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#adding-a-schematic-to-a-collection\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Adding a schematic to a collection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#adding-a-schematic-to-a-collection\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要把一個原理圖新增到現有的集合中，請使用和新建原理圖專案相同的命令，不過要改為在該專案的資料夾下執行該命令。</p><p translation-origin=\"off\">To add a schematic to an existing collection, use the same command you use to start a new schematics project, but run the command inside the project folder.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\ncd hello-world\nschematics blank --name=goodbye-world\n\n</code-example>\n<p translation-result=\"on\">該命令會在你的集合中產生一個新的命名原理圖，它包含一個主檔案 <code>index.ts</code> 及其相關的測試規約。它還會把這個新原理圖的名字（name），說明（description）和工廠函式（factory function）新增到 <code>collection.json</code> 檔案中此集合的 JSON 模式中。</p><p translation-origin=\"off\">The command generates the new named schematic inside your collection, with a main <code>index.ts</code> file and its associated test spec.\nIt also adds the name, description, and factory function for the new schematic to the collection's schema in the <code>collection.json</code> file.</p>\n\n<h2 id=\"collection-contents\" translation-result=\"on\">集合的內容<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#collection-contents\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Collection contents<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#collection-contents\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">集合的根資料夾中包含一些配置檔案、<code>node_modules</code> 資料夾和 <code>src/</code> 資料夾。<code>src/</code> 資料夾包含該集合中各個命名原理圖的子資料夾，以及一個模式檔案（<code>collection.json</code>），它是集合中各個原理圖的模式定義。每個原理圖都是用名稱，描述和工廠函式建立的。</p><p translation-origin=\"off\">The top level of the root project folder for a collection contains configuration files, a <code>node_modules</code> folder, and a <code>src/</code> folder.\nThe <code>src/</code> folder contains subfolders for named schematics in the collection, and a schema, <code>collection.json</code>, which describes the collected schematics.\nEach schematic is created with a name, description, and factory function.</p>\n\n<code-example language=\"json\">\n\n{\n  \"$schema\":\n     \"../node_modules/@angular-devkit/schematics/collection-schema.json\",\n  \"schematics\": {\n    \"hello-world\": {\n      \"description\": \"A blank schematic.\",\n      \"factory\": \"./hello-world/index#helloWorld\"\n    }\n  }\n}\n\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\"><code>$schema</code> 屬性指定了 CLI 進行驗證時所用的模式。</p><p translation-origin=\"off\">The <code>$schema</code> property specifies the schema that the CLI uses for validation.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>schematics</code> 屬性列出了屬於這個集合的各個命名原理圖。每個原理圖都有一個純文字格式的描述，以及指向主檔案中自動產生的那個入口函式。</p><p translation-origin=\"off\">The <code>schematics</code> property lists named schematics that belong to this collection.\nEach schematic has a plain-text description, and points to the generated entry function in the main file.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>factory</code> 屬性指向自動產生的那個入口函式。在這個例子中，你會透過呼叫 <code>helloWorld()</code> 工廠函式來呼叫 <code>hello-world</code> 原理圖。</p><p translation-origin=\"off\">The <code>factory</code> property points to the generated entry function.\nIn this example, you invoke the <code>hello-world</code> schematic by calling the <code>helloWorld()</code> factory function.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">可選屬性 <code>schema</code> 是一個 JSON 模式檔案，它定義了本原理圖中可用的命令列引數。</p><p translation-origin=\"off\">The optional  <code>schema</code> property points to a JSON schema file that defines the command-line options available to the schematic.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">可選陣列屬性 <code>aliases</code> 指定了一個或多個可用來呼叫此原理圖的字串。比如，Angular CLI “generate” 命令的原理圖有一個別名 “g”，這就可以讓你使用命令 <code>ng g</code>。</p><p translation-origin=\"off\">The optional <code>aliases</code> array specifies one or more strings that can be used to invoke the schematic.\nFor example, the schematic for the Angular CLI \"generate\" command has an alias \"g\", that lets you use the command <code>ng g</code>.</p>\n\n</li>\n</ul>\n<h3 id=\"named-schematics\" translation-result=\"on\">命名原理圖<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#named-schematics\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Named schematics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/schematics-authoring#named-schematics\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當你使用 Schematics CLI 建立空白原理圖專案時，該集合的第一個成員是一張與該集合同名的空白原理圖。當你把這個新的命名原理圖新增到本集合中時，它會自動新增到 <code>collection.json</code> 模式中。</p><p translation-origin=\"off\">When you use the Schematics CLI to create a blank schematics project, the new blank schematic is the first member of the collection, and has the same name as the collection.\nWhen you add a new named schematic to this collection, it is automatically added to the  <code>collection.json</code>  schema.</p>\n\n<p translation-result=\"on\">除了名稱和描述外，每個原理圖還有一個 <code>factory</code> 屬性，用於標識此原理圖的入口點。在本例中，你透過在主檔案 <code>hello-world/index.ts</code> 中呼叫 <code>helloWorld()</code> 函式來呼叫此原理圖中定義的功能。</p><p translation-origin=\"off\">In addition to the name and description, each schematic has a <code>factory</code> property that identifies the schematic's entry point.\nIn the example, you invoke the schematic's defined functionality by calling the <code>helloWorld()</code> function in the main file,  <code>hello-world/index.ts</code>.</p>\n\n<div class=\"lightbox\">\n<img alt=\"overview\" src=\"generated/images/guide/schematics/collection-files.gif\" width=\"1149\" height=\"490\">\n</div>\n<p translation-result=\"on\">該集合中每個命名原理圖都有以下主要部分。</p><p translation-origin=\"off\">Each named schematic in the collection has the following main parts.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">部分</nt-wrapper><nt-wrapper translation-origin=\"off\">Parts</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>index.ts</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">定義命名原理圖中轉換邏輯的程式碼。</nt-wrapper><nt-wrapper translation-origin=\"off\">Code that defines the transformation logic for a named schematic.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>schema.json</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">原理圖變數定義。</nt-wrapper><nt-wrapper translation-origin=\"off\">Schematic variable definition.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>schema.d.ts</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">原理圖變數。</nt-wrapper><nt-wrapper translation-origin=\"off\">Schematic variables.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>files/</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">要複製的可選元件/範本檔案。</nt-wrapper><nt-wrapper translation-origin=\"off\">Optional component/template files to replicate.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">原理圖可以在 <code>index.ts</code> 檔案中提供它全部的邏輯，不需要額外的範本。你也可以在 <code>files/</code> 資料夾中提供元件和範本來為 Angular 建立動態原理圖，比如那些獨立的 Angular 專案。這個 index 檔案中的邏輯會透過定義一些用來注入資料和修改變數的規則來配置這些範本。</p><p translation-origin=\"off\">It is possible for a schematic to provide all of its logic in the <code>index.ts</code> file, without additional templates.\nYou can create dynamic schematics for Angular, however, by providing components and templates in the <code>files</code> folder, like those in standalone Angular projects.\nThe logic in the index file configures these templates by defining rules that inject data and modify variables.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/schematics\n-->\n<!-- links from this doc:\n - guide/schematics-authoring#adding-a-schematic-to-a-collection\n - guide/schematics-authoring#authoring-schematics\n - guide/schematics-authoring#cli\n - guide/schematics-authoring#collection-contents\n - guide/schematics-authoring#creating-a-schematics-collection\n - guide/schematics-authoring#defining-input-options-with-a-schema-and-interfaces\n - guide/schematics-authoring#defining-rules-and-actions\n - guide/schematics-authoring#named-schematics\n - guide/schematics-authoring#prompt-long-form-syntax\n - guide/schematics-authoring#prompt-short-form-syntax\n - guide/schematics-authoring#running-a-schematic\n - guide/schematics-authoring#schematic-prompts\n - guide/schematics-authoring#schematics-cli\n - guide/schematics-authoring#schematics-concepts\n - guide/schematics-authoring#x-prompt-schema\n - guide/schematics-authoring#x-prompt-模式\n - guide/schematics-authoring#創作原理圖\n - guide/schematics-authoring#建立一個原理圖的集合\n - guide/schematics-authoring#利用模式和介面來定義輸入選項\n - guide/schematics-authoring#原理圖-cli\n - guide/schematics-authoring#原理圖提示\n - guide/schematics-authoring#原理圖的概念\n - guide/schematics-authoring#命名原理圖\n - guide/schematics-authoring#定義規則和動作\n - guide/schematics-authoring#把原理圖新增到集合中\n - guide/schematics-authoring#提示的簡寫語法\n - guide/schematics-authoring#提示的長格式語法\n - guide/schematics-authoring#執行原理圖\n - guide/schematics-authoring#集合的內容\n - guide/schematics-for-libraries\n - https://github.com/angular/angular-cli/blob/ba8a6ea59983bb52a6f1e66d105c5a77517f062e/packages/schematics/angular/application/schema.json#L56\n - https://github.com/angular/angular-cli/blob/main/packages/schematics/angular/application/schema.json\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/schematics-authoring.md?message=docs%3A%20請簡述你的修改...\n-->"}