{"id":"guide/providers","title":"Providing dependencies in modules","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/providers.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"providing-dependencies-in-modules\" translation-result=\"on\">在模組中提供依賴<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providing-dependencies-in-modules\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Providing dependencies in modules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providing-dependencies-in-modules\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">提供者就是一本說明書，用來指導<a href=\"guide/dependency-injection\">依賴注入</a>系統該如何獲取某個依賴的值。大多數情況下，這些依賴就是你要建立和提供的那些服務。</p><p translation-origin=\"off\">A provider is an instruction to the <a href=\"guide/dependency-injection\">Dependency Injection</a> system on how to obtain a value for a dependency.\nMost of the time, these dependencies are services that you create and provide.</p>\n\n<p translation-result=\"on\">要想檢視本頁提到的這個帶有特性模組的範例應用，參閱 <live-example></live-example>。</p><p translation-origin=\"off\">For the final sample application using the provider that this page describes, see the <live-example></live-example>.</p>\n\n<h2 id=\"providing-a-service\" translation-result=\"on\">提供服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providing-a-service\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Providing a service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providing-a-service\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果你是用 <a href=\"cli\">Angular CLI</a> 建立的應用，那麼可以使用下列 CLI 的 <a href=\"cli/generate\"><code>ng generate</code></a> 命令在專案根目錄下建立一個服務。把其中的 <code>User</code> 替換成你的服務名。</p><p translation-origin=\"off\">If you already have an application that was created with the <a href=\"cli\">Angular CLI</a>, you can create a service using the <a href=\"cli/generate\"><code>ng generate</code></a> CLI command in the root project directory.\nReplace <em>User</em> with the name of your service.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate service User\n\n</code-example>\n<p translation-result=\"on\">該命令會建立下列 <code>UserService</code> 骨架：</p><p translation-origin=\"off\">This command creates the following <code>UserService</code> skeleton:</p>\n\n<code-example header=\"src/app/user.service.ts\" path=\"providers/src/app/user.service.0.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class UserService {\n}\n\n\n</code-example>\n<p translation-result=\"on\">現在，你就可以在應用中到處注入 <code>UserService</code> 了。</p><p translation-origin=\"off\">You can now inject <code>UserService</code> anywhere in your application.</p>\n\n<p translation-result=\"on\">該服務本身是 CLI 建立的一個類別，並且加上了 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 裝飾器。預設情況下，該裝飾器是用 <code>providedIn</code> 屬性進行配置的，它會為該服務建立一個提供者。在這個例子中，<code>providedIn: 'root'</code> 指定 Angular 應該在根注入器中提供該服務。</p><p translation-origin=\"off\">The service itself is a class that the CLI generated and that's decorated with <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code>.\nBy default, this decorator has a <code>providedIn</code> property, which creates a provider for the service.\nIn this case, <code>providedIn: 'root'</code> specifies that Angular should provide the service in the root injector.</p>\n\n<h2 id=\"provider-scope\" translation-result=\"on\">提供者的作用域<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#provider-scope\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Provider scope<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#provider-scope\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">當你把服務提供者新增到應用的根注入器中時，它就在整個應用程式中可用了。另外，這些服務提供者也同樣對整個應用中的類是可用的 —— 只要它們有供查詢用的服務令牌。</p><p translation-origin=\"off\">When you add a service provider to the root application injector, it's available throughout the application.\nAdditionally, these providers are also available to all the classes in the application as long they have the lookup token.</p>\n\n<p translation-result=\"on\">你應該始終在根注入器中提供這些服務 —— 除非你希望該服務只有在消費方要匯入特定的 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 時才生效。</p><p translation-origin=\"off\">You should always provide your service in the root injector unless there is a case where you want the service to be available only if the consumer imports a particular <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>.</p>\n\n<h2 id=\"providedin-and-ngmodules\" translation-result=\"on\"><code>providedIn</code> 與 NgModule<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providedin-and-ngmodules\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\"><code>providedIn</code> and NgModules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providedin-and-ngmodules\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">也可以規定某個服務只有在特定的 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中提供。比如，如果你希望只有當消費方匯入了你建立的 <code>UserModule</code> 時才讓 <code>UserService</code> 在應用中生效，那就可以指定該服務要在該模組中提供：</p><p translation-origin=\"off\">It's also possible to specify that a service should be provided in a particular <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>.\nFor example, if you don't want <code>UserService</code> to be available to applications unless they import a <code>UserModule</code> you've created, you can specify that the service should be provided in the module:</p>\n\n<code-example header=\"src/app/user.service.ts\" path=\"providers/src/app/user.service.1.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { UserModule } from './user.module';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: UserModule,\n})\nexport class UserService {\n}\n\n\n</code-example>\n<p translation-result=\"on\">上面的例子展示的就是在模組中提供服務的首選方式。之所以推薦該方式，是因為當沒有人注入它時，該服務就可以被搖樹最佳化掉。如果沒辦法指定哪個模組該提供這個服務，你也可以在那個模組中為該服務宣告一個提供者：</p><p translation-origin=\"off\">The example above shows the preferred way to provide a service in a module.\nThis method is preferred because it enables tree-shaking of the service if nothing injects it.\nIf it's not possible to specify in the service which module should provide it, you can also declare a provider for the service within the module:</p>\n\n<code-example header=\"src/app/user.module.ts\" path=\"providers/src/app/user.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\n\nimport { UserService } from './user.service';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [UserService],\n})\nexport class UserModule {\n}\n\n\n</code-example>\n<h2 id=\"limiting-provider-scope-by-lazy-loading-modules\" translation-result=\"on\">使用延遲載入模組限制提供者的作用域<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#limiting-provider-scope-by-lazy-loading-modules\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Limiting provider scope by lazy loading modules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#limiting-provider-scope-by-lazy-loading-modules\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在 CLI 產生的基本應用中，模組是急性載入的，這意味著它們都是由本應用啟動的，Angular 會使用一個依賴注入體系來讓一切服務都在模組間有效。對於急性載入式應用，應用中的根注入器會讓所有服務提供者都對整個應用有效。</p><p translation-origin=\"off\">In the basic CLI-generated app, modules are eagerly loaded which means that they are all loaded when the application launches.\nAngular uses an injector system to make things available between modules.\nIn an eagerly loaded app, the root application injector makes all of the providers in all of the modules available throughout the application.</p>\n\n<p translation-result=\"on\">當使用延遲載入時，這種行為需要進行改變。延遲載入就是隻有當需要時才載入模組，比如路由中。它們沒辦法像急性載入模組那樣進行載入。這意味著，在它們的 <code>providers</code> 陣列中列出的服務都是不可用的，因為根注入器並不知道這些模組。</p><p translation-origin=\"off\">This behavior necessarily changes when you use lazy loading.\nLazy loading is when you load modules only when you need them; for example, when routing.\nThey aren't loaded right away like with eagerly loaded modules.\nThis means that any services listed in their provider arrays aren't available because the root injector doesn't know about these modules.</p>\n\n<!--todo: KW--Make diagram here -->\n<!--todo: KW--per Misko: not clear if the lazy modules are siblings or grand-children. They are both depending on router structure. -->\n<p translation-result=\"on\">當 Angular 的路由器延遲載入一個模組時，它會建立一個新的注入器。這個注入器是應用的根注入器的一個子注入器。想象一棵注入器樹，它有唯一的根注入器，而每一個延遲載入模組都有一個自己的子注入器。這個子注入器會操縱所有特定於此模組的提供者，如果有的話。可以遵循這份<a href=\"guide/hierarchical-dependency-injection#resolution-rules\">多級依賴注入規則</a>來了解每個提供者的解析過程。</p><p translation-origin=\"off\">When the Angular router lazy-loads a module, it creates a new injector.\nThis injector is a child of the root application injector.\nImagine a tree of injectors; there is a single root injector and then a child injector for each lazy loaded module.\nThis child injector gets populated with all the module-specific providers, if any.\nLook up resolution for every provider follows the <a href=\"guide/hierarchical-dependency-injection#resolution-rules\">rules of dependency injection hierarchy</a>. </p>\n\n<p translation-result=\"on\">任何在延遲載入模組的上下文中建立的元件（比如路由導航），都會獲取由子注入器提供的服務的區域性例項，而不是應用的根注入器中的例項。而外部模組中的元件，仍然會收到來自於應用的根注入器建立的例項。</p><p translation-origin=\"off\">Any component created within a lazy loaded module's context, such as by router navigation, gets its own local instance of child provided services, not the instance in the root application injector.\nComponents in external modules continue to receive the instances created for the application root injector.</p>\n\n<p translation-result=\"on\">雖然你可以使用延遲載入模組來提供例項，但不是所有的服務都能延遲載入。比如，像路由之類別的模組只能在根模組中使用。路由器需要使用瀏覽器中的全域物件 <code>location</code> 進行工作。</p><p translation-origin=\"off\">Though you can provide services by lazy loading modules, not all services can be lazy loaded.\nFor instance, some modules only work in the root module, such as the Router.\nThe Router works with the global location object in the browser.</p>\n\n<p translation-result=\"on\">從 Angular 9 開始，你可以在每個延遲載入模組中提供服務的新例項。下列程式碼把此功能新增到 <code>UserService</code> 中。</p><p translation-origin=\"off\">As of Angular version 9, you can provide a new instance of a service with each lazy loaded module.\nThe following code adds this functionality to <code>UserService</code>.</p>\n\n<code-example header=\"src/app/user.service.ts\" path=\"providers/src/app/user.service.2.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'any',\n})\nexport class UserService {\n}\n\n\n</code-example>\n<p translation-result=\"on\">透過使用 <code>providedIn: 'any'</code>，所有急性載入的模組都會共享同一個服務單例，不過，延遲載入模組各自有它們自己獨有的單例。如下所示。</p><p translation-origin=\"off\">With <code>providedIn: 'any'</code>, all eagerly loaded modules share a singleton instance; however, lazy loaded modules each get their own unique instance, as shown in the following diagram.</p>\n\n<div class=\"lightbox\">\n<img alt=\"any-provider-scope\" class=\"left\" src=\"generated/images/guide/providers/any-provider.svg\" width=\"607\" height=\"389\">\n</div>\n<h2 id=\"limiting-provider-scope-with-components\" translation-result=\"on\">使用元件限定服務提供者的作用域<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#limiting-provider-scope-with-components\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Limiting provider scope with components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#limiting-provider-scope-with-components\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">另一種限定提供者作用域的方式是把要限定的服務新增到元件的 <code>providers</code> 陣列中。元件中的提供者和 NgModule 中的提供者是彼此獨立的。當你要急性載入一個自帶了全部所需服務的模組時，這種方式是有幫助的。在元件中提供服務，會限定該服務只能在該元件及其子元件中有效，而同一模組中的其它元件不能存取它。</p><p translation-origin=\"off\">Another way to limit provider scope is by adding the service you want to limit to the component's <code>providers</code> array.\nComponent providers and NgModule providers are independent of each other.\nThis method is helpful when you want to eagerly load a module that needs a service all to itself.\nProviding a service in the component limits the service only to that component and its descendants.\nOther components in the same module can't access it.</p>\n\n<code-example header=\"src/app/app.component.ts\" path=\"providers/src/app/app.component.ts\" region=\"component-providers\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  /* . . . */\n  providers: [UserService]\n})\n\n</code-example>\n<h2 id=\"providing-services-in-modules-vs-components\" translation-result=\"on\">在模組中提供服務還是在元件中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providing-services-in-modules-vs-components\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Providing services in modules vs. components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#providing-services-in-modules-vs-components\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">通常，要在根模組中提供整個應用都需要的服務，在延遲載入模組中提供限定範圍的服務。</p><p translation-origin=\"off\">Generally, provide services the whole application needs in the root module and scope services by providing them in lazy loaded modules.</p>\n\n<p translation-result=\"on\">路由器工作在根級，所以如果你把服務提供者放進元件（即使是 <code>AppComponent</code>）中，那些依賴於路由器的延遲載入模組，將無法看到它們。</p><p translation-origin=\"off\">The router works at the root level so if you put providers in a component, even <code>AppComponent</code>, lazy loaded modules, which rely on the router, can't see them.</p>\n\n<!-- KW--Make a diagram here -->\n<p translation-result=\"on\">當你必須把一個服務例項的作用域限定到元件及其元件樹中時，可以使用元件註冊一個服務提供者。比如，使用者編輯元件 <code>UserEditorComponent</code>，它需要一個快取 <code>UserService</code> 例項，那就應該把 <code>UserService</code> 註冊進 <code>UserEditorComponent</code> 中。然後，每個 <code>UserEditorComponent</code> 的例項都會獲取它自己的快取服務例項。</p><p translation-origin=\"off\">Register a provider with a component when you must limit a service instance to a component and its component tree, that is, its child components.\nFor example, a user editing component, <code>UserEditorComponent</code>, that needs a private copy of a caching <code>UserService</code> should register the <code>UserService</code> with the <code>UserEditorComponent</code>.\nThen each new instance of the <code>UserEditorComponent</code> gets its own cached service instance.</p>\n\n<p><a id=\"singleton-services\"></a>\n<a id=\"component-child-injectors\"></a></p>\n<h2 id=\"injector-hierarchy-and-service-instances\" translation-result=\"on\">多級注入器和服務例項<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#injector-hierarchy-and-service-instances\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Injector hierarchy and service instances<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#injector-hierarchy-and-service-instances\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">服務都是某個注入器範圍內的單例，這意味著在給定的注入器中最多有一個服務例項。</p><p translation-origin=\"off\">Services are singletons within the scope of an injector, which means there is at most one instance of a service in a given injector.</p>\n\n<p translation-result=\"on\">Angular DI 具有<a href=\"guide/hierarchical-dependency-injection\">多級注入體系</a>，這意味著巢狀(Nesting)的注入器可以建立自己的服務例項。<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 指定的 <code>providers</code> 的元件的新例項時，它也會為該例項建立一個新的子注入器。同樣，當在執行時延遲載入新的 NgModule 時，Angular 可以使用其自己的提供者為其建立注入器。</p><p translation-origin=\"off\">Angular DI has a <a href=\"guide/hierarchical-dependency-injection\">hierarchical injection system</a>, which means that nested injectors can create their own service instances.\nWhenever Angular creates a new instance of a component that has <code>providers</code> specified in <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code>, it also creates a new child injector for that instance.\nSimilarly, when a new NgModule is lazy-loaded at run time, Angular can create an injector for it with its own providers.</p>\n\n<p translation-result=\"on\">子模組注入器和元件注入器彼此獨立，併為已提供的服務建立它們自己的單獨例項。當 Angular 銷燬 NgModule 或元件例項時，它也會銷燬該注入器和該注入器的服務例項。</p><p translation-origin=\"off\">Child modules and component injectors are independent of each other, and create their own separate instances of the provided services.\nWhen Angular destroys an NgModule or component instance, it also destroys that injector and that injector's service instances.</p>\n\n<p translation-result=\"on\">欲知詳情，請參見<a href=\"guide/hierarchical-dependency-injection\">分層注入器</a>。</p><p translation-origin=\"off\">For more information, see <a href=\"guide/hierarchical-dependency-injection\">Hierarchical injectors</a>.</p>\n\n<h2 id=\"more-on-ngmodules\" translation-result=\"on\">關於 NgModule 的更多知識<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#more-on-ngmodules\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">More on NgModules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/providers#more-on-ngmodules\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你還可能對下列內容感興趣：</p><p translation-origin=\"off\">You may also be interested in:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"guide/singleton-services\">單例服務</a>詳細解釋了本頁包含的那些概念</p><p translation-origin=\"off\"><a href=\"guide/singleton-services\">Singleton Services</a>, which elaborates on the concepts covered on this page</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/lazy-loading-ngmodules\">延遲載入模組</a></p><p translation-origin=\"off\"><a href=\"guide/lazy-loading-ngmodules\">Lazy Loading Modules</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/dependency-injection-providers\">依賴提供者</a></p><p translation-origin=\"off\"><a href=\"guide/dependency-injection-providers\">Dependency providers</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/ngmodule-faq\">NgModule 常見問題</a></p><p translation-origin=\"off\"><a href=\"guide/ngmodule-faq\">NgModule FAQ</a></p>\n\n</li>\n</ul>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/bootstrapping\n - guide/example-apps-list\n - guide/feature-modules\n - guide/lazy-loading-ngmodules\n - guide/module-types\n - guide/ngmodule-api\n - guide/ngmodules\n - guide/sharing-ngmodules\n - tutorial/tour-of-heroes/toh-pt4\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/Injectable\n - api/core/NgModule\n - cli\n - cli/generate\n - guide/dependency-injection\n - guide/dependency-injection-providers\n - guide/hierarchical-dependency-injection\n - guide/hierarchical-dependency-injection#resolution-rules\n - guide/lazy-loading-ngmodules\n - guide/ngmodule-faq\n - guide/providers#injector-hierarchy-and-service-instances\n - guide/providers#limiting-provider-scope-by-lazy-loading-modules\n - guide/providers#limiting-provider-scope-with-components\n - guide/providers#more-on-ngmodules\n - guide/providers#providedin-and-ngmodules\n - guide/providers#providedin-與-ngmodule\n - guide/providers#provider-scope\n - guide/providers#providing-a-service\n - guide/providers#providing-dependencies-in-modules\n - guide/providers#providing-services-in-modules-vs-components\n - guide/providers#使用延遲載入模組限制提供者的作用域\n - guide/providers#使用元件限定服務提供者的作用域\n - guide/providers#關於-ngmodule-的更多知識\n - guide/providers#在模組中提供依賴\n - guide/providers#在模組中提供服務還是在元件中\n - guide/providers#多級注入器和服務例項\n - guide/providers#提供服務\n - guide/providers#提供者的作用域\n - guide/singleton-services\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/providers.md?message=docs%3A%20請簡述你的修改...\n-->"}