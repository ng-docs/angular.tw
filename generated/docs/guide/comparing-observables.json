{"id":"guide/comparing-observables","title":"Observables compared to other techniques","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/comparing-observables.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"observables-compared-to-other-techniques\" translation-result=\"on\">可觀察物件與其它技術的比較<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#observables-compared-to-other-techniques\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Observables compared to other techniques<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#observables-compared-to-other-techniques\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">你可以經常使用可觀察物件（Observable）而不是承諾（Promise）來非同步傳遞值。類似的，可觀察物件也可以取代事件處理器的位置。最後，由於可觀察物件傳遞多個值，所以你可以在任何可能建構和運算元組的地方使用可觀察物件。</p><p translation-origin=\"off\">You can often use observables instead of promises to deliver values asynchronously.\nSimilarly, observables can take the place of event handlers.\nFinally, because observables deliver multiple values, you can use them where you might otherwise build and operate on arrays.</p>\n\n<p translation-result=\"on\">在這些情況下，可觀察物件的行為與其替代技術有一些差異，不過也提供了一些顯著的優勢。下面是對這些差異的詳細比較。</p><p translation-origin=\"off\">Observables behave somewhat differently from the alternative techniques in each of these situations, but offer some significant advantages.\nHere are detailed comparisons of the differences.</p>\n\n<h2 id=\"observables-compared-to-promises\" translation-result=\"on\">可觀察物件 vs. 承諾（Promise）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#observables-compared-to-promises\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Observables compared to promises<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#observables-compared-to-promises\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">可觀察物件經常拿來和 Promise 進行對比。有一些關鍵的不同點：</p><p translation-origin=\"off\">Observables are often compared to promises.\nHere are some key differences:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">可觀察物件是宣告式的，在被訂閱之前，它不會開始執行。Promise 是在建立時就立即執行的。這讓可觀察物件可用於定義那些應該按需執行的菜譜。</p><p translation-origin=\"off\">Observables are declarative; computation does not start until subscription.\nPromises execute immediately on creation.\nThis makes observables useful for defining recipes that can be run whenever you need the result.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">可觀察物件能提供多個值。Promise 只提供一個。這讓可觀察物件可用於隨著時間的推移獲取多個值。</p><p translation-origin=\"off\">Observables provide many values.\nPromises provide one.\nThis makes observables useful for getting multiple values over time.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">可觀察物件會區分串聯處理和訂閱陳述式。Promise 只有 <code>.then()</code> 陳述式。這讓可觀察物件可用於建立供系統的其它部分使用而不希望立即執行的複雜菜譜。</p><p translation-origin=\"off\">Observables differentiate between chaining and subscription.\nPromises only have <code>.then()</code> clauses.\nThis makes observables useful for creating complex transformation recipes to be used by other part of the system, without causing the work to be executed.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">可觀察物件的 <code>subscribe()</code> 會負責處理錯誤。Promise 會把錯誤推送給它的子 Promise。這讓可觀察物件可用於進行集中式、可預測的錯誤處理。</p><p translation-origin=\"off\">Observables <code>subscribe()</code> is responsible for handling errors.\nPromises push errors to the child promises.\nThis makes observables useful for centralized and predictable error handling.</p>\n\n</li>\n</ul>\n<h3 id=\"creation-and-subscription\" translation-result=\"on\">建立與訂閱<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#creation-and-subscription\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Creation and subscription<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#creation-and-subscription\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\">在有消費者訂閱之前，可觀察物件不會執行。<code>subscribe()</code> 會執行一次定義好的行為，並且可以再次呼叫它。每次訂閱都是單獨計算的。重新訂閱會導致重新計算這些值。</p><p translation-origin=\"off\">Observables are not executed until a consumer subscribes.\nThe <code>subscribe()</code> executes the defined behavior once, and it can be called again.\nEach subscription has its own computation.\nResubscription causes recomputation of values.</p>\n\n<code-example header=\"src/observables.ts (observable)\" path=\"comparing-observables/src/observables.ts\" region=\"observable\">\n\n// declare a publishing operation\nconst observable = new Observable&lt;number&gt;(observer =&gt; {\n  // Subscriber fn...\n});\n\n// initiate execution\nobservable.subscribe(value =&gt; {\n  // observer handles notifications\n});\n\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">Promise 會立即執行，並且只執行一次。當 Promise 建立時，會立即計算出結果。沒有辦法重新做一次。所有的 <code>then</code> 陳述式（訂閱）都會共享同一次計算。</p><p translation-origin=\"off\">Promises execute immediately, and just once.\nThe computation of the result is initiated when the promise is created.\nThere is no way to restart work.\nAll <code>then</code> clauses (subscriptions) share the same computation.</p>\n\n<code-example header=\"src/promises.ts (promise)\" path=\"comparing-observables/src/promises.ts\" region=\"promise\">\n// initiate execution\nlet promise = new Promise&lt;number&gt;(resolve =&gt; {\n  // Executer fn...\n});\npromise.then(value =&gt; {\n  // handle result here\n});\n\n</code-example>\n</li>\n</ul>\n<h3 id=\"chaining\" translation-result=\"on\">串聯<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#chaining\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Chaining<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#chaining\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\">可觀察物件會區分各種轉換函式，比如對映和訂閱。只有訂閱才會啟用訂閱者函式，以開始計算那些值。</p><p translation-origin=\"off\">Observables differentiate between transformation function such as a map and subscription.\nOnly subscription activates the subscriber function to start computing the values.</p>\n\n<code-example header=\"src/observables.ts (chain)\" path=\"comparing-observables/src/observables.ts\" region=\"chain\">\n\nobservable.pipe(map(v =&gt; 2 * v));\n\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">Promise 並不區分最後的 <code>.then()</code> 陳述式（等價於訂閱）和中間的 <code>.then()</code> 陳述式（等價於對映）。</p><p translation-origin=\"off\">Promises do not differentiate between the last <code>.then</code> clauses (equivalent to subscription) and intermediate <code>.then</code> clauses (equivalent to map).</p>\n\n<code-example header=\"src/promises.ts (chain)\" path=\"comparing-observables/src/promises.ts\" region=\"chain\">\npromise.then(v =&gt; 2 * v);\n\n</code-example>\n</li>\n</ul>\n<h3 id=\"cancellation\" translation-result=\"on\">可取消<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#cancellation\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Cancellation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#cancellation\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\">可觀察物件的訂閱是可取消的。取消訂閱會移除監聽器，使其不再接受將來的值，並通知訂閱者函式取消正在進行的工作。</p><p translation-origin=\"off\">Observable subscriptions are cancellable.\nUnsubscribing removes the listener from receiving further values, and notifies the subscriber function to cancel work.</p>\n\n<code-example header=\"src/observables.ts (unsubscribe)\" path=\"comparing-observables/src/observables.ts\" region=\"unsubscribe\">\n\nconst subscription = observable.subscribe(() =&gt; {\n  // observer handles notifications\n});\n\nsubscription.unsubscribe();\n\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">Promise 是不可取消的。</p><p translation-origin=\"off\">Promises are not cancellable.</p>\n\n</li>\n</ul>\n<h3 id=\"error-handling\" translation-result=\"on\">錯誤處理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#error-handling\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Error handling<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#error-handling\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\">可觀察物件的錯誤處理工作交給了訂閱者的錯誤處理器，並且該訂閱者會自動取消對這個可觀察物件的訂閱。</p><p translation-origin=\"off\">Observable execution errors are delivered to the subscriber's error handler, and the subscriber automatically unsubscribes from the observable.</p>\n\n<code-example header=\"src/observables.ts (error)\" path=\"comparing-observables/src/observables.ts\" region=\"error\">\nobservable.subscribe(() =&gt; {\n  throw new Error('my error');\n});\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">Promise 會把錯誤推給其子 Promise。</p><p translation-origin=\"off\">Promises push errors to the child promises.</p>\n\n<code-example header=\"src/promises.ts (error)\" path=\"comparing-observables/src/promises.ts\" region=\"error\">\n\npromise.then(() =&gt; {\n  throw new Error('my error');\n});\n\n\n</code-example>\n</li>\n</ul>\n<h3 id=\"cheat-sheet\" translation-result=\"on\">速查表<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#cheat-sheet\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Cheat sheet<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#cheat-sheet\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">下列程式碼片段揭示了同樣的操作要如何分別使用可觀察物件和 Promise 進行實現。</p><p translation-origin=\"off\">The following code snippets illustrate how the same kind of operation is defined using observables and promises.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">操作</nt-wrapper><nt-wrapper translation-origin=\"off\">Operation</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">可觀察物件</nt-wrapper><nt-wrapper translation-origin=\"off\">Observable</nt-wrapper></th>\n<th align=\"left\">Promise</th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">建立</nt-wrapper><nt-wrapper translation-origin=\"off\">Creation</nt-wrapper></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> new Observable((observer) =&gt; { \n&nbsp; observer.next(123); \n}); </code-example></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> new Promise((resolve, reject) =&gt; { \n&nbsp; resolve(123); \n}); </code-example></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">轉換</nt-wrapper><nt-wrapper translation-origin=\"off\">Transform</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> obs.pipe(map((value) =&gt; value * 2));</code-example></nt-wrapper><nt-wrapper><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\">obs.pipe(map((value) =&gt; value * 2));</code-example></nt-wrapper></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> promise.then((value) =&gt; value * 2);</code-example></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">訂閱</nt-wrapper><nt-wrapper translation-origin=\"off\">Subscribe</nt-wrapper></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> sub = obs.subscribe((value) =&gt; { \n&nbsp; console.log(value) \n});</code-example></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> promise.then((value) =&gt; { \n&nbsp; console.log(value); \n}); </code-example></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">取消訂閱</nt-wrapper><nt-wrapper translation-origin=\"off\">Unsubscribe</nt-wrapper></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> sub.unsubscribe();</code-example></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">Promise 被解析時隱含完成。</nt-wrapper><nt-wrapper translation-origin=\"off\">Implied by promise resolution.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<h2 id=\"observables-compared-to-events-api\" translation-result=\"on\">可觀察物件 vs. 事件 API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#observables-compared-to-events-api\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Observables compared to events API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#observables-compared-to-events-api\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">可觀察物件和事件 API 中的事件處理器很像。這兩種技術都會定義通知處理器，並使用它們來處理一段時間內傳遞的多個值。訂閱可觀察物件與新增事件處理器是等價的。一個顯著的不同是你可以配置可觀察物件，使其在把事件傳給事件處理器之前先進行轉換。</p><p translation-origin=\"off\">Observables are very similar to event handlers that use the events API.\nBoth techniques define notification handlers, and use them to process multiple values delivered over time.\nSubscribing to an observable is equivalent to adding an event listener.\nOne significant difference is that you can configure an observable to transform an event before passing the event to the handler.</p>\n\n<p translation-result=\"on\">使用可觀察物件來處理錯誤和非同步操作在 HTTP 請求這樣的場景下更加具有一致性。</p><p translation-origin=\"off\">Using observables to handle events and asynchronous operations can have the advantage of greater consistency in contexts such as HTTP requests.</p>\n\n<p translation-result=\"on\">下列程式碼片段揭示了同樣的操作要如何分別使用可觀察物件和事件 API 進行實現。</p><p translation-origin=\"off\">Here are some code samples that illustrate how the same kind of operation is defined using observables and the events API.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">可觀察物件</nt-wrapper><nt-wrapper translation-origin=\"off\">Observable</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">事件 API</nt-wrapper><nt-wrapper translation-origin=\"off\">Events API</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">建立和取消</nt-wrapper><nt-wrapper translation-origin=\"off\">Creation &amp; cancellation</nt-wrapper></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> // Setup \nconst clicks$ = fromEvent(buttonEl, 'click'); \n// Begin listening \nconst subscription = clicks$ \n&nbsp; .subscribe(e =&gt; console.log('Clicked', e)) \n// Stop listening \nsubscription.unsubscribe(); </code-example></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\">function handler(e) { \n&nbsp; console.log('Clicked', e); \n} \n// Setup &amp; begin listening \nbutton.addEventListener('click', handler); \n// Stop listening \nbutton.removeEventListener('click', handler); </code-example></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">訂閱</nt-wrapper><nt-wrapper translation-origin=\"off\">Subscription</nt-wrapper></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\">observable.subscribe(() =&gt; { \n&nbsp; // notification handlers here \n});</code-example></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\">element.addEventListener(eventName, (event) =&gt; { \n&nbsp; // notification handler here \n}); </code-example></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">配置</nt-wrapper><nt-wrapper translation-origin=\"off\">Configuration</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">偵聽擊鍵，但提供表示輸入值的流。<code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> fromEvent(inputEl, 'keydown').pipe( \n&nbsp; map(e =&gt; e.target.value) \n); </code-example></nt-wrapper><nt-wrapper translation-origin=\"off\">Listen for keystrokes, but provide a stream representing the value in the input. <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> fromEvent(inputEl, 'keydown').pipe( \n&nbsp; map(e =&gt; e.target.value) \n); </code-example></nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">不支援配置。<code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> element.addEventListener(eventName, (event) =&gt; { \n&nbsp; // Cannot change the passed <a href=\"api/router/Event\" class=\"code-anchor\">Event</a> into another \n&nbsp; // value before it gets to the handler \n}); </code-example></nt-wrapper><nt-wrapper translation-origin=\"off\">Does not support configuration. <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> element.addEventListener(eventName, (event) =&gt; { \n&nbsp; // Cannot change the passed <a href=\"api/router/Event\" class=\"code-anchor\">Event</a> into another \n&nbsp; // value before it gets to the handler \n}); </code-example></nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<h2 id=\"observables-compared-to-arrays\" translation-result=\"on\">可觀察物件 vs. 陣列<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#observables-compared-to-arrays\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Observables compared to arrays<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/comparing-observables#observables-compared-to-arrays\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">可觀察物件會隨時間產生值。陣列是用一組靜態的值建立的。某種意義上，可觀察物件是非同步的，而陣列是同步的。\n在下面的例子中，➞ 符號表示非同步傳遞值。</p><p translation-origin=\"off\">An observable produces values over time.\nAn array is created as a static set of values.\nIn a sense, observables are asynchronous where arrays are synchronous.\nIn the following examples, <code>→</code> implies asynchronous value delivery.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">值</nt-wrapper><nt-wrapper translation-origin=\"off\">Values</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">可觀察物件</nt-wrapper><nt-wrapper translation-origin=\"off\">Observable</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">陣列</nt-wrapper><nt-wrapper translation-origin=\"off\">Array</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">給定值</nt-wrapper><nt-wrapper translation-origin=\"off\">Given</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> obs: →1→2→3→5→7 </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> obsB: →'a'→'b'→'c' </code-example></nt-wrapper><nt-wrapper><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> obs: →1→2→3→5→7 </code-example></nt-wrapper></td>\n<td align=\"left\"><nt-wrapper><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> arr: [1, 2, 3, 5, 7] </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> arrB: ['a', 'b', 'c'] </code-example></nt-wrapper><nt-wrapper><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> arr: [1, 2, 3, 5, 7] </code-example></nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>concat()</code></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> concat(obs, obsB) </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> →1→2→3→5→7→'a'→'b'→'c' </code-example></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> arr.concat(arrB) </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> [1,2,3,5,7,'a','b','c'] </code-example></td>\n</tr>\n<tr>\n<td align=\"left\"><code>filter()</code></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> obs.pipe(filter((v) =&gt; v&gt;3)) </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> →5→7 </code-example></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> arr.filter((v) =&gt; v&gt;3) </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> [5, 7] </code-example></td>\n</tr>\n<tr>\n<td align=\"left\"><code>find()</code></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> obs.pipe(find((v) =&gt; v&gt;3)) </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> →5 </code-example></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> arr.find((v) =&gt; v&gt;3) </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> 5 </code-example></td>\n</tr>\n<tr>\n<td align=\"left\"><code>findIndex()</code></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> obs.pipe(findIndex((v) =&gt; v&gt;3)) </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> →3 </code-example></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> arr.findIndex((v) =&gt; v&gt;3) </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> 3 </code-example></td>\n</tr>\n<tr>\n<td align=\"left\"><code>forEach()</code></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> obs.pipe(tap((v) =&gt; { \n &nbsp; console.log(v); \n })) \n 1 \n 2 \n 3 \n 5 \n 7 </code-example></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> arr.forEach((v) =&gt; { \n &nbsp; console.log(v); \n }) \n 1 \n 2 \n 3 \n 5 \n 7 </code-example></td>\n</tr>\n<tr>\n<td align=\"left\"><code>map()</code></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> obs.pipe(map((v) =&gt; -v)) </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> →-1→-2→-3→-5→-7 </code-example></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> arr.map((v) =&gt; -v) </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> [-1, -2, -3, -5, -7] </code-example></td>\n</tr>\n<tr>\n<td align=\"left\"><code>reduce()</code></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> obs.pipe(reduce((s,v)=&gt; s+v, 0)) </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> →18 </code-example></td>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> arr.reduce((s,v) =&gt; s+v, 0) </code-example> <code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> 18 </code-example></td>\n</tr>\n</tbody>\n</table>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/router/Event\n - guide/comparing-observables#cancellation\n - guide/comparing-observables#chaining\n - guide/comparing-observables#cheat-sheet\n - guide/comparing-observables#creation-and-subscription\n - guide/comparing-observables#error-handling\n - guide/comparing-observables#observables-compared-to-arrays\n - guide/comparing-observables#observables-compared-to-events-api\n - guide/comparing-observables#observables-compared-to-other-techniques\n - guide/comparing-observables#observables-compared-to-promises\n - guide/comparing-observables#串聯\n - guide/comparing-observables#建立與訂閱\n - guide/comparing-observables#可取消\n - guide/comparing-observables#可觀察物件-vs-事件-api\n - guide/comparing-observables#可觀察物件-vs-承諾promise\n - guide/comparing-observables#可觀察物件-vs-陣列\n - guide/comparing-observables#可觀察物件與其它技術的比較\n - guide/comparing-observables#速查表\n - guide/comparing-observables#錯誤處理\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/comparing-observables.md?message=docs%3A%20請簡述你的修改...\n-->"}