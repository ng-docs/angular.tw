{"id":"guide/http-intercept-requests-and-responses","title":"HTTP - Intercept requests and responses","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-intercept-requests-and-responses.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"http---intercept-requests-and-responses\" translation-result=\"on\">HTTP - 攔截請求和響應<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#http---intercept-requests-and-responses\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">HTTP - Intercept requests and responses<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#http---intercept-requests-and-responses\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">藉助攔截機制，你可以宣告一些<em>攔截器</em>，它們可以檢查並轉換從應用中發給伺服器的 HTTP 請求。這些攔截器還可以在返回應用的途中檢查和轉換來自伺服器的響應。多個攔截器構成了請求/響應處理器的<em>雙向</em>連結串列。</p><p translation-origin=\"off\">With interception, you declare <em>interceptors</em> that inspect and transform HTTP requests from your application to a server.\nThe same interceptors can also inspect and transform a server's responses on their way back to the application.\nMultiple interceptors form a <em>forward-and-backward</em> chain of request/response handlers.</p>\n\n<p translation-result=\"on\">攔截器可以用一種常規的、標準的方式對每一次 HTTP 的請求/響應任務執行從認證到記日誌等很多種<em>隱含</em>任務。</p><p translation-origin=\"off\">Interceptors can perform a variety of  <em>implicit</em> tasks, from authentication to logging, in a routine, standard way, for every HTTP request/response.</p>\n\n<p translation-result=\"on\">如果沒有攔截機制，那麼開發人員將不得不對每次 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 呼叫<em>顯式</em>實現這些任務。</p><p translation-origin=\"off\">Without interception, developers would have to implement these tasks <em>explicitly</em> for each <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> method call.</p>\n\n<h2 id=\"write-an-interceptor\" translation-result=\"on\">編寫攔截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#write-an-interceptor\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Write an interceptor<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#write-an-interceptor\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要實現攔截器，就要實現一個實現了 <code><a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a></code> 介面中的 <code>intercept()</code> 方法的類別。</p><p translation-origin=\"off\">To implement an interceptor, declare a class that implements the <code>intercept()</code> method of the <code><a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a></code> interface.</p>\n\n<p translation-result=\"on\">這裡是一個什麼也不做的 <code>noop</code> 攔截器，它只會不做任何修改的傳遞這個請求。</p><p translation-origin=\"off\">Here is a do-nothing <code>noop</code> interceptor that passes the request through without touching it:</p>\n\n<code-example header=\"app/http-interceptors/noop-interceptor.ts\" path=\"http/src/app/http-interceptors/noop-interceptor.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport {\n  <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>, <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a>, <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>, <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>\n} from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { Observable } from 'rxjs';\n\n/** Pass untouched request through to the next request handler. */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class NoopInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>):\n    Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    return next.handle(req);\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\"><code>intercept</code> 方法會把請求轉換成一個最終返回 HTTP 回應內文的 <code>Observable</code>。在這個場景中，每個攔截器都完全能自己處理這個請求。</p><p translation-origin=\"off\">The <code>intercept</code> method transforms a request into an <code>Observable</code> that eventually returns the HTTP response.\nIn this sense, each interceptor is fully capable of handling the request entirely by itself.</p>\n\n<p translation-result=\"on\">大多數攔截器攔截都會在傳入時檢查請求，然後把潛在的請求轉發給 <code>next</code> 物件的 <code>handle()</code> 方法，而 <code>next</code> 物件實現了 <a href=\"api/common/http/HttpHandler\"><code>HttpHandler</code></a> 介面。</p><p translation-origin=\"off\">Most interceptors inspect the request on the way in and forward the potentially altered request to the <code>handle()</code> method of the <code>next</code> object which implements the <a href=\"api/common/http/HttpHandler\"><code>HttpHandler</code></a> interface.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nexport abstract class <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a> {\n  abstract handle(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt;;\n}\n\n</code-example>\n<p translation-result=\"on\">像 <code>intercept()</code> 一樣，<code>handle()</code> 方法也會把 HTTP 請求轉換成 <a href=\"guide/http-intercept-requests-and-responses#interceptor-events\"><code>HttpEvents</code></a> 組成的 <code>Observable</code>，它最終包含的是來自伺服器的響應。\n<code>intercept()</code> 函式可以檢查這個可觀察物件，並在把它返回給呼叫者之前修改它。</p><p translation-origin=\"off\">Like <code>intercept()</code>, the <code>handle()</code> method transforms an HTTP request into an <code>Observable</code> of <a href=\"guide/http-intercept-requests-and-responses#interceptor-events\"><code>HttpEvents</code></a> which ultimately include the server's response.\nThe <code>intercept()</code> method could inspect that observable and alter it before returning it to the caller.</p>\n\n<p translation-result=\"on\">這個 <code>no-op</code> 攔截器，會使用原始的請求呼叫 <code>next.handle()</code>，並返回它返回的可觀察物件，而不做任何後續處理。</p><p translation-origin=\"off\">This <code>no-op</code> interceptor calls <code>next.handle()</code> with the original request and returns the observable without doing a thing.</p>\n\n<h2 id=\"the-next-object\" translation-result=\"on\"><code>next</code> 物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#the-next-object\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">The <code>next</code> object<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#the-next-object\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code>next</code> 物件表示攔截器連結串列中的下一個攔截器。這個連結串列中的最後一個 <code>next</code> 物件就是 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的後端處理器（backend handler），它會把請求發給伺服器，並接收伺服器的響應。</p><p translation-origin=\"off\">The <code>next</code> object represents the next interceptor in the chain of interceptors.\nThe final <code>next</code> in the chain is the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> backend handler that sends the request to the server and receives the server's response.</p>\n\n<p translation-result=\"on\">大多數攔截器都會呼叫 <code>next.handle()</code> 以便請求流經下一個攔截器，並最終流向後端處理程式。攔截器<em>可以</em>跳過對 <code>next.handle()</code> 的呼叫，使呼叫鏈短路，並<a href=\"guide/http-interceptor-use-cases#caching\">返回帶有人工回應內文的自訂 <code>Observable</code></a>。</p><p translation-origin=\"off\">Most interceptors call <code>next.handle()</code> so that the request flows through to the next interceptor and, eventually, the backend handler.\nAn interceptor <em>could</em> skip calling <code>next.handle()</code>, short-circuit the chain, and <a href=\"guide/http-interceptor-use-cases#caching\">return its own <code>Observable</code></a> with an artificial server response.</p>\n\n<p translation-result=\"on\">這是一種常見的中介軟體模式，在像 Express.js 這樣的框架中也會找到它。</p><p translation-origin=\"off\">This is a common middleware pattern found in frameworks such as Express.js.</p>\n\n<h2 id=\"provide-the-interceptor\" translation-result=\"on\">提供這個攔截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#provide-the-interceptor\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Provide the interceptor<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#provide-the-interceptor\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">這個 <code>NoopInterceptor</code> 就是一個由 Angular <a href=\"guide/dependency-injection\">依賴注入（DI）</a>系統管理的服務。像其它服務一樣，你也必須先提供這個攔截器類，應用才能使用它。</p><p translation-origin=\"off\">The <code>NoopInterceptor</code> is a service managed by Angular's <a href=\"guide/dependency-injection\">dependency injection (DI)</a> system.\nLike other services, you must provide the interceptor class before the app can use it.</p>\n\n<p translation-result=\"on\">由於攔截器是 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務的（可選）依賴，所以你必須在提供 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的同一個（或其各級父注入器）注入器中提供這些攔截器。那些在 DI 建立完 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> <em>之後</em>再提供的攔截器將會被忽略。</p><p translation-origin=\"off\">Because interceptors are optional dependencies of the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service, you must provide them in the same injector or a parent of the injector that provides <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>.\nInterceptors provided <em>after</em> DI creates the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> are ignored.</p>\n\n<p translation-result=\"on\">由於在 <code>AppModule</code> 中匯入了 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，導致本應用在其根注入器中提供了 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>。所以你也同樣要在 <code>AppModule</code> 中提供這些攔截器。</p><p translation-origin=\"off\">This app provides <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> in the app's root injector, as a side-effect of importing the <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> in <code>AppModule</code>.\nYou should provide interceptors in <code>AppModule</code> as well.</p>\n\n<p translation-result=\"on\">在從 <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a></code> 中匯入了 <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> 注入令牌之後，編寫如下的 <code>NoopInterceptor</code> 提供者註冊陳述式：</p><p translation-origin=\"off\">After importing the <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> injection token from <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a></code>, write the <code>NoopInterceptor</code> provider like this:</p>\n\n<code-example path=\"http/src/app/http-interceptors/index.ts\" region=\"noop-provider\">\n{ provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: NoopInterceptor, multi: true },\n\n</code-example>\n<p translation-result=\"on\">注意 <code>multi: true</code> 選項。這個必須的選項會告訴 Angular <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> 是一個<em>多重提供者</em>的令牌，表示它會注入一個多值的陣列，而不是單一的值。</p><p translation-origin=\"off\">Notice the <code>multi: true</code> option.\nThis required setting tells Angular that <code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> is a token for a <em>multiprovider</em> that injects an array of values, rather than a single value.</p>\n\n<p translation-result=\"on\">你<em>也可以</em>直接把這個提供者新增到 <code>AppModule</code> 中的提供者陣列中，不過那樣會非常囉嗦。況且，你將來還會用這種方式建立更多的攔截器並提供它們。\n你還要<a href=\"guide/http-intercept-requests-and-responses#interceptor-order\">特別注意提供這些攔截器的順序</a>。</p><p translation-origin=\"off\">You <em>could</em> add this provider directly to the providers array of the <code>AppModule</code>.\nHowever, it's rather verbose and there's a good chance that you'll create more interceptors and provide them in the same way.\nYou must also pay <a href=\"guide/http-intercept-requests-and-responses#interceptor-order\">close attention to the order</a> in which you provide these interceptors.</p>\n\n<p translation-result=\"on\">認真考慮建立一個封裝桶（barrel）檔案，用於把所有攔截器都收集起來，一起提供給 <code>httpInterceptorProviders</code> 陣列，可以先從這個 <code>NoopInterceptor</code> 開始。</p><p translation-origin=\"off\">Consider creating a \"barrel\" file that gathers all the interceptor providers into an <code>httpInterceptorProviders</code> array, starting with this first one, the <code>NoopInterceptor</code>.</p>\n\n<code-example header=\"app/http-interceptors/index.ts\" path=\"http/src/app/http-interceptors/index.ts\" region=\"interceptor-providers\">\n/* \"Barrel\" of Http Interceptors */\nimport { <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { NoopInterceptor } from './noop-interceptor';\n\n/** Http interceptor providers in outside-in order */\nexport const httpInterceptorProviders = [\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: NoopInterceptor, multi: true },\n];\n\n</code-example>\n<p translation-result=\"on\">然後匯入它，並把它加到 <code>AppModule</code> 的 <code>providers array</code> 中，就像這樣：</p><p translation-origin=\"off\">Then import and add it to the <code>AppModule</code> <code>providers array</code> like this:</p>\n\n<code-example header=\"app/app.module.ts (interceptor providers)\" path=\"http/src/app/app.module.ts\" region=\"interceptor-providers\">\nproviders: [\n  httpInterceptorProviders\n],\n\n</code-example>\n<p translation-result=\"on\">當你再建立新的攔截器時，就同樣把它們新增到 <code>httpInterceptorProviders</code> 陣列中，而不用再修改 <code>AppModule</code>。</p><p translation-origin=\"off\">As you create new interceptors, add them to the <code>httpInterceptorProviders</code> array and you won't have to revisit the <code>AppModule</code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">在完整的範例程式碼中還有許多其他的攔截器。</p><p translation-origin=\"off\">There are many more interceptors in the complete sample code.</p>\n\n</div>\n<h2 id=\"interceptor-order\" translation-result=\"on\">攔截器的順序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#interceptor-order\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Interceptor order<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#interceptor-order\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 會按你提供攔截器的順序應用它們。比如，考慮一個場景：你想處理 HTTP 請求的身份驗證並記錄它們，然後再將它們傳送到伺服器。要完成此任務，你可以提供 <code>AuthInterceptor</code> 服務，然後提供 <code>LoggingInterceptor</code> 服務。發出的請求將從 <code>AuthInterceptor</code> 到 <code>LoggingInterceptor</code>。這些請求的響應則沿相反的方向流動，從 <code>LoggingInterceptor</code> 回到 <code>AuthInterceptor</code>。以下是該過程的直觀表示：</p><p translation-origin=\"off\">Angular applies interceptors in the order that you provide them.\nFor example, consider a situation in which you want to handle the authentication of your HTTP requests and log them before sending them to a server.\nTo accomplish this task, you could provide an <code>AuthInterceptor</code> service and then a <code>LoggingInterceptor</code> service.\nOutgoing requests would flow from the <code>AuthInterceptor</code> to the <code>LoggingInterceptor</code>.\nResponses from these requests would flow in the other direction, from <code>LoggingInterceptor</code> back to <code>AuthInterceptor</code>.\nThe following is a visual representation of the process:</p>\n\n<div class=\"lightbox\">\n<img alt=\"Interceptor in order of HttpClient, AuthInterceptor, AuthInterceptor, HttpBackend, Server, and back in opposite order to show the two-way flow\" src=\"generated/images/guide/http/interceptor-order.svg\" width=\"300\" height=\"522\">\n</div>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">處理過程中的最後一個攔截器始終是 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>，它負責與伺服器通訊。</p><p translation-origin=\"off\">The last interceptor in the process is always the <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> that handles communication with the server.</p>\n\n</div>\n<p translation-result=\"on\">以後你就再也不能修改這些順序或移除某些攔截器了。如果你需要動態啟用或禁用某個攔截器，那就要在那個攔截器中自行實現這個功能。</p><p translation-origin=\"off\">You cannot change the order or remove interceptors later.\nIf you need to enable and disable an interceptor dynamically, you'll have to build that capability into the interceptor itself.</p>\n\n<p><a id=\"interceptor-events\"></a></p>\n<h2 id=\"handle-interceptor-events\" translation-result=\"on\">處理攔截器事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#handle-interceptor-events\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Handle interceptor events<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#handle-interceptor-events\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">大多數 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法都會返回 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;any&gt;</code> 型的可觀察物件。<code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 類本身就是一個事件，它的型別是 <code><a href=\"api/common/http/HttpEventType#Response\" class=\"code-anchor\">HttpEventType.Response</a></code>。但是，單個 HTTP 請求可以產生其它型別的多個事件，包括報告上傳和下載進度的事件。<code>HttpInterceptor.intercept()</code> 和 <code>HttpHandler.handle()</code> 會返回 <code><a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;</code> 型的可觀察物件。</p><p translation-origin=\"off\">Most <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> methods return observables of <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;any&gt;</code>.\nThe <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> class itself is actually an event, whose type is <code><a href=\"api/common/http/HttpEventType#Response\" class=\"code-anchor\">HttpEventType.Response</a></code>.\nA single HTTP request can, however, generate multiple events of other types, including upload and download progress events.\nThe methods <code>HttpInterceptor.intercept()</code> and <code>HttpHandler.handle()</code> return observables of <code><a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;</code>.</p>\n\n<p translation-result=\"on\">很多攔截器只關心發出的請求，而對 <code>next.handle()</code> 返回的事件流不會做任何修改。但是，有些攔截器需要檢查並修改 <code>next.handle()</code> 的響應。上述做法就可以在流中看到所有這些事件。</p><p translation-origin=\"off\">Many interceptors are only concerned with the outgoing request and return the event stream from <code>next.handle()</code> without modifying it.\nSome interceptors, however, need to examine and modify the response from <code>next.handle()</code>; these operations can see all of these events in the stream.</p>\n\n<p><a id=\"immutability\"></a></p>\n<p translation-result=\"on\">雖然攔截器有能力改變請求和響應，但 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 和 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 例項的屬性卻是隻讀（<code>readonly</code>）的，\n因此讓它們基本上是不可變的。</p><p translation-origin=\"off\">Although interceptors are capable of modifying requests and responses, the <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> and <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> instance properties are <code>readonly</code>, rendering them largely immutable.\nThey are immutable for a good reason:\nAn app might retry a request several times before it succeeds, which means that the interceptor chain can re-process the same request multiple times.\nIf an interceptor could modify the original request object, the re-tried operation would start from the modified request rather than the original.\nImmutability ensures that interceptors see the same request for each try.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">除非有充分的理由，否則你的攔截器應該返回每個事件而不進行任何修改。</p><p translation-origin=\"off\">Your interceptor should return every event without modification unless it has a compelling reason to do otherwise.</p>\n\n</div>\n<p translation-result=\"on\">TypeScript 會阻止你設定 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 的唯讀屬性。</p><p translation-origin=\"off\">TypeScript prevents you from setting <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> read-only properties.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\n// Typescript disallows the following assignment because req.url is readonly\nreq.url = req.url.replace('<a href=\"api/common/http\" class=\"code-anchor\">http</a>://', 'https://');\n\n</code-example>\n<p translation-result=\"on\">如果你必須修改一個請求，先把它複製一份，修改這個複製體後再把它傳給 <code>next.handle()</code>。你可以在一步中複製並修改此請求，例子如下。</p><p translation-origin=\"off\">If you must alter a request, clone it first and modify the clone before passing it to <code>next.handle()</code>.\nYou can clone and modify the request in a single step, as shown in the following example.</p>\n\n<code-example header=\"app/http-interceptors/ensure-https-interceptor.ts (excerpt)\" path=\"http/src/app/http-interceptors/ensure-https-interceptor.ts\" region=\"excerpt\">\n// clone request and replace '<a href=\"api/common/http\" class=\"code-anchor\">http</a>://' with 'https://' at the same time\nconst secureReq = req.clone({\n  url: req.url.replace('<a href=\"api/common/http\" class=\"code-anchor\">http</a>://', 'https://')\n});\n// send the cloned, \"secure\" request to the next handler.\nreturn next.handle(secureReq);\n\n</code-example>\n<p translation-result=\"on\">這個 <code>clone()</code> 方法的雜湊型引數允許你在複製出複製體的同時改變該請求的某些特定屬性。</p><p translation-origin=\"off\">The <code>clone()</code> method's hash argument lets you mutate specific properties of the request while copying the others.</p>\n\n<h3 id=\"modify-a-request-body\" translation-result=\"on\">修改請求體<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#modify-a-request-body\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Modify a request body<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#modify-a-request-body\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>readonly</code> 這種賦值保護，無法防範深修改（修改子物件的屬性），也不能防範你修改請求體物件中的屬性。</p><p translation-origin=\"off\">The <code>readonly</code> assignment guard can't prevent deep updates and, in particular, it can't prevent you from modifying a property of a request body object.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nreq.body.name = req.body.name.trim(); // bad idea!\n\n</code-example>\n<p translation-result=\"on\">如果必須修改請求體，請執行以下步驟。</p><p translation-origin=\"off\">If you must modify the request body, follow these steps.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">複製請求體並在副本中進行修改。</p><p translation-origin=\"off\">Copy the body and make your change in the copy.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">使用 <code>clone()</code> 方法複製這個請求物件。</p><p translation-origin=\"off\">Clone the request object, using its <code>clone()</code> method.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">用修改過的副本替換被複製的請求體。</p><p translation-origin=\"off\">Replace the clone's body with the modified copy.</p>\n\n</li>\n</ol>\n<code-example header=\"app/http-interceptors/trim-name-interceptor.ts (excerpt)\" path=\"http/src/app/http-interceptors/trim-name-interceptor.ts\" region=\"excerpt\">\n// copy the body and trim whitespace from the name property\nconst newBody = { ...body, name: body.name.trim() };\n// clone request and set its body\nconst newReq = req.clone({ body: newBody });\n// send the cloned request to the next handler.\nreturn next.handle(newReq);\n\n</code-example>\n<h3 id=\"clear-the-request-body-in-a-clone\" translation-result=\"on\">清除複製中的請求正文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#clear-the-request-body-in-a-clone\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Clear the request body in a clone<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-intercept-requests-and-responses#clear-the-request-body-in-a-clone\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">有時，你需要清除請求體而不是替換它。為此，請將複製後的請求體設定為 <code>null</code>。</p><p translation-origin=\"off\">Sometimes you need to clear the request body rather than replace it.\nTo do this, set the cloned request body to <code>null</code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>提示</strong>：<br>\n如果你將複製後的請求體設定為 <code>undefined</code>，Angular 就會認為你打算按原樣保留請求體。</p><p translation-origin=\"off\"><strong>TIP</strong>: <br>\nIf you set the cloned request body to <code>undefined</code>, Angular assumes you intend to leave the body as is.</p>\n\n</div>\n<code-example format=\"javascript\" language=\"javascript\">\n\nnewReq = req.clone({ … }); // body not mentioned =&gt; preserve original body\nnewReq = req.clone({ body: undefined }); // preserve original body\nnewReq = req.clone({ body: null }); // clear the body\n\n</code-example>\n\n  <div class=\"reviewed\">最後複查時間：3/16/2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/http-track-show-request-progress\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/common/http\n - api/common/http/HTTP_INTERCEPTORS\n - api/common/http/HttpBackend\n - api/common/http/HttpClient\n - api/common/http/HttpClientModule\n - api/common/http/HttpEvent\n - api/common/http/HttpEventType#Response\n - api/common/http/HttpHandler\n - api/common/http/HttpInterceptor\n - api/common/http/HttpRequest\n - api/common/http/HttpResponse\n - api/core/Injectable\n - guide/dependency-injection\n - guide/http-intercept-requests-and-responses#clear-the-request-body-in-a-clone\n - guide/http-intercept-requests-and-responses#handle-interceptor-events\n - guide/http-intercept-requests-and-responses#http---intercept-requests-and-responses\n - guide/http-intercept-requests-and-responses#http---攔截請求和響應\n - guide/http-intercept-requests-and-responses#interceptor-events\n - guide/http-intercept-requests-and-responses#interceptor-order\n - guide/http-intercept-requests-and-responses#modify-a-request-body\n - guide/http-intercept-requests-and-responses#next-物件\n - guide/http-intercept-requests-and-responses#provide-the-interceptor\n - guide/http-intercept-requests-and-responses#the-next-object\n - guide/http-intercept-requests-and-responses#write-an-interceptor\n - guide/http-intercept-requests-and-responses#修改請求體\n - guide/http-intercept-requests-and-responses#處理攔截器事件\n - guide/http-intercept-requests-and-responses#攔截器的順序\n - guide/http-intercept-requests-and-responses#提供這個攔截器\n - guide/http-intercept-requests-and-responses#清除複製中的請求正文\n - guide/http-intercept-requests-and-responses#編寫攔截器\n - guide/http-interceptor-use-cases#caching\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-intercept-requests-and-responses.md?message=docs%3A%20請簡述你的修改...\n-->"}