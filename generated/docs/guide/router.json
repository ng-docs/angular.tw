{"id":"guide/router","title":"Common Routing Tasks","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/router.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"common-routing-tasks\" translation-result=\"on\">常見路由任務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#common-routing-tasks\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Common Routing Tasks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#common-routing-tasks\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本主題講述當把 Angular 路由器新增到應用中時，如何實現多種常見路由任務。</p><p translation-origin=\"off\">This topic describes how to implement many of the common tasks associated with adding the Angular router to your application.</p>\n\n<p><a id=\"basics\"></a></p>\n<h2 id=\"generate-an-application-with-routing-enabled\" translation-result=\"on\">產生一個支援路由的應用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#generate-an-application-with-routing-enabled\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Generate an application with routing enabled<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#generate-an-application-with-routing-enabled\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">下面的命令會用 Angular CLI 來產生一個帶有應用路由模組（<code>AppRoutingModule</code>）的基本 Angular 應用，它是一個 NgModule，可用來配置路由。下面的例子中應用的名字是 <code>routing-app</code>。</p><p translation-origin=\"off\">The following command uses the Angular CLI to generate a basic Angular application with an application routing module, called <code>AppRoutingModule</code>, which is an NgModule where you can configure your routes.\nThe application name in the following example is <code>routing-app</code>.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng new routing-app --routing --defaults\n\n</code-example>\n<h3 id=\"adding-components-for-routing\" translation-result=\"on\">為路由新增元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#adding-components-for-routing\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Adding components for routing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#adding-components-for-routing\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">為了使用 Angular 的路由器，應用至少要有兩個元件才能從一個導航到另一個。要使用 CLI 建立元件，請在命令列輸入以下內容，其中 <code>first</code> 是元件的名稱：</p><p translation-origin=\"off\">To use the Angular router, an application needs to have at least two components so that it can navigate from one to the other.\nTo create a component using the CLI, enter the following at the command line where <code>first</code> is the name of your component:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component first\n\n</code-example>\n<p translation-result=\"on\">為第二個元件重複這個步驟，但給它一個不同的名字。這裡的新名字是 <code>second</code>。</p><p translation-origin=\"off\">Repeat this step for a second component but give it a different name.\nHere, the new name is <code>second</code>.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component second\n\n</code-example>\n<p translation-result=\"on\">CLI 會自動新增 <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 字尾，所以如果在編寫 <code>first-component</code>，那麼其元件名就是 <code>FirstComponentComponent</code>。</p><p translation-origin=\"off\">The CLI automatically appends <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>, so if you were to write <code>first-component</code>, your component would be <code>FirstComponentComponent</code>.</p>\n\n<p><a id=\"basics-base-href\"></a></p>\n<div class=\"alert is-helpful\">\n<header ng-should-translate=\"\"><code>&lt;base href&gt;</code></header>\n<p translation-result=\"on\">本指南適用於 CLI 產生的 Angular 應用。如果你是手動工作的，請確保你的 index.html 檔案的 <code>&lt;head&gt;</code> 中有 <code>&lt;base href=\"/\"&gt;</code> 陳述式。這裡假定 <code>app</code> 資料夾是應用的根目錄，並使用 <code>\"/\"</code> 作為基礎路徑。</p><p translation-origin=\"off\">This guide works with a CLI-generated Angular application.\nIf you are working manually, make sure that you have <code>&lt;base href=\"/\"&gt;</code> in the <code>&lt;head&gt;</code> of your index.html file.\nThis assumes that the <code>app</code> folder is the application root, and uses <code>\"/\"</code>.</p>\n\n</div>\n<h3 id=\"importing-your-new-components\" translation-result=\"on\">匯入這些新元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#importing-your-new-components\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Importing your new components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#importing-your-new-components\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要使用這些新元件，請把它們匯入到該檔案頂部的 <code>AppRoutingModule</code> 中，具體如下：</p><p translation-origin=\"off\">To use your new components, import them into <code>AppRoutingModule</code> at the top of the file, as follows:</p>\n\n<code-example header=\"AppRoutingModule (excerpt)\">\n\nimport { FirstComponent } from './first/first.component';\nimport { SecondComponent } from './second/second.component';\n\n</code-example>\n<p><a id=\"basic-route\"></a></p>\n<h2 id=\"defining-a-basic-route\" translation-result=\"on\">定義一個基本路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#defining-a-basic-route\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Defining a basic route<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#defining-a-basic-route\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">建立路由有三個基本的建構塊。</p><p translation-origin=\"off\">There are three fundamental building blocks to creating a route.</p>\n\n<p translation-result=\"on\">把 <code>AppRoutingModule</code> 匯入 <code>AppModule</code> 並把它新增到 <code>imports</code> 陣列中。</p><p translation-origin=\"off\">Import the <code>AppRoutingModule</code> into <code>AppModule</code> and add it to the <code>imports</code> array.</p>\n\n<p translation-result=\"on\">Angular CLI 會為你執行這一步驟。但是，如果要手動建立應用或使用現存的非 CLI 應用，請驗證匯入和配置是否正確。下面是使用 <code>--routing</code> 標誌產生的預設 <code>AppModule</code>。</p><p translation-origin=\"off\">The Angular CLI performs this step for you.\nHowever, if you are creating an application manually or working with an existing, non-CLI application, verify that the imports and configuration are correct.\nThe following is the default <code>AppModule</code> using the CLI with the <code>--routing</code> flag.</p>\n\n<code-example header=\"Default CLI AppModule with routing\" path=\"router/src/app/app.module.8.ts\">\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { AppRoutingModule } from './app-routing.module'; // CLI imports AppRoutingModule\nimport { AppComponent } from './app.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    AppRoutingModule // CLI adds AppRoutingModule to the AppModule's imports array\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n\n</code-example>\n<ol>\n<li>\n<p translation-result=\"on\">把 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 和 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 匯入到你的路由模組中。</p><p translation-origin=\"off\">Import <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> and <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> into your routing module.</p>\n\n<p translation-result=\"on\">Angular CLI 會自動執行這一步驟。CLI 還為你的路由設定了 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 陣列，併為 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 配置了 <code>imports</code> 和 <code>exports</code> 陣列。</p><p translation-origin=\"off\">The Angular CLI performs this step automatically.\nThe CLI also sets up a <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> array for your routes and configures the <code>imports</code> and <code>exports</code> arrays for <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code>.</p>\n\n<code-example header=\"CLI application routing module\" path=\"router/src/app/app-routing.module.7.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router'; // CLI imports router\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = []; // sets up routes constant where you define your routes\n\n// configures <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> imports and exports\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">在 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 陣列中定義你的路由。</p><p translation-origin=\"off\">Define your routes in your <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> array.</p>\n\n<p translation-result=\"on\">這個陣列中的每個路由都是一個包含兩個屬性的 JavaScript 物件。第一個屬性 <code>path</code> 定義了該路由的 URL 路徑。第二個屬性 <code>component</code> 定義了要讓 Angular 用作相應路徑的元件。</p><p translation-origin=\"off\">Each route in this array is a JavaScript object that contains two properties.\nThe first property, <code>path</code>, defines the URL path for the route.\nThe second property, <code>component</code>, defines the component Angular should use for the corresponding path.</p>\n\n<code-example header=\"AppRoutingModule (excerpt)\" path=\"router/src/app/app-routing.module.8.ts\" region=\"routes\">\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n];\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">把這些路由新增到你的應用中。</p><p translation-origin=\"off\">Add your routes to your application.</p>\n\n<p translation-result=\"on\">現在你已經定義了路由，可以把它們新增到應用中了。首先，新增到這兩個元件的連結。把要新增路由的連結賦值給 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 屬性。將屬性的值設定為該元件，以便在使用者點選各個連結時顯示這個值。接下來，修改元件範本以包含 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 標籤。該元素會通知 Angular，你可以用所選路由的元件更新應用的檢視。</p><p translation-origin=\"off\">Now that you have defined your routes, add them to your application.\nFirst, add links to the two components.\nAssign the anchor tag that you want to add the route to the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> attribute.\nSet the value of the attribute to the component to show when a user clicks on each link.\nNext, update your component template to include <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>.\nThis element informs Angular to update the application view with the component for the selected route.</p>\n\n<code-example header=\"Template with routerLink and router-outlet\" path=\"router/src/app/app.component.7.html\">\n&lt;h1&gt;Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> App&lt;/h1&gt;\n&lt;!-- This nav gives you links to click, which tells the router which route to use (defined in the routes constant in  AppRoutingModule) --&gt;\n&lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/first-component\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;First <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/second-component\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\" ariaCurrentWhenActive=\"page\"&gt;Second <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/nav&gt;\n&lt;!-- The routed views render in the &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;--&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n\n</code-example>\n</li>\n</ol>\n<p><a id=\"route-order\"></a></p>\n<h3 id=\"route-order\" translation-result=\"on\">路由順序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#route-order\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Route order<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#route-order\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">路由的順序很重要，因為 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 在匹配路由時使用“先到先得”策略，所以應該在不那麼具體的路由前面放置更具體的路由。首先列出靜態路徑的路由，然後是一個與預設路由匹配的空路徑路由。<a href=\"guide/router#setting-up-wildcard-routes\">萬用字元路由</a>是最後一個，因為它匹配每一個 URL，只有當其它路由都沒有匹配時，<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 才會選擇它。</p><p translation-origin=\"off\">The order of routes is important because the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> uses a first-match wins strategy when matching routes, so more specific routes should be placed above less specific routes.\nList routes with a static path first, followed by an empty path route, which matches the default route.\nThe <a href=\"guide/router#setting-up-wildcard-routes\">wildcard route</a> comes last because it matches every URL and the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> selects it only if no other routes match first.</p>\n\n<p><a id=\"getting-route-information\"></a></p>\n<h2 id=\"getting-route-information\" translation-result=\"on\">獲取路由資訊<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#getting-route-information\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Getting route information<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#getting-route-information\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">通常，當用戶導航你的應用時，你會希望把資訊從一個元件傳遞到另一個元件。比如，考慮一個顯示雜貨商品購物清單的應用。列表中的每一項都有一個唯一的 <code>id</code>。要想編輯某個專案，使用者需要單擊“編輯”按鈕，開啟一個 <code>EditGroceryItem</code> 元件。你希望該元件得到該商品的 <code>id</code>，以便它能向用戶顯示正確的資訊。</p><p translation-origin=\"off\">Often, as a user navigates your application, you want to pass information from one component to another.\nFor example, consider an application that displays a shopping list of grocery items.\nEach item in the list has a unique <code>id</code>.\nTo edit an item, users click an Edit button, which opens an <code>EditGroceryItem</code> component.\nYou want that component to retrieve the <code>id</code> for the grocery item so it can display the right information to the user.</p>\n\n<p translation-result=\"on\">可以用一個路由把這種型別的資訊傳給你的應用元件。要做到這一點，你可以使用 <a href=\"api/router/ActivatedRoute\">ActivatedRoute</a> 介面。</p><p translation-origin=\"off\">Use a route to pass this type of information to your application components.\nTo do so, you use the <a href=\"api/router/withComponentInputBinding\">withComponentInputBinding</a> feature with <code><a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a></code> or the <code>bindToComponentInputs</code> option of <code>RouterModule.forRoot</code>.</p>\n\n<p translation-result=\"on\">要從路由中獲取資訊：</p><p translation-origin=\"off\">To get information from a route:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">將 <code><a href=\"api/router/withComponentInputBinding\" class=\"code-anchor\">withComponentInputBinding</a></code> 特性新增到 <code><a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a></code> 方法。</p><p translation-origin=\"off\">Add the <code><a href=\"api/router/withComponentInputBinding\" class=\"code-anchor\">withComponentInputBinding</a></code> feature to the <code><a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a></code> method.</p>\n\n<code-example header=\"provideRouter feature\" path=\"router/src/app/app-routing.module.11.ts\" region=\"withComponentInputBinding\">\nproviders: [\n  <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>(appRoutes, <a href=\"api/router/withComponentInputBinding\" class=\"code-anchor\">withComponentInputBinding</a>()),\n]\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">更新 <code>ngOnInit()</code> 方法來存取這個 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 並追蹤 <code>name</code> 引數：</p><p translation-origin=\"off\">Update the component to have an <code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> matching the name of the parameter.</p>\n\n<code-example header=\"The component input (excerpt)\" path=\"router/src/app/heroes/hero-detail/hero-detail.component.4.ts\" region=\"id-input\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\nset id(heroId: string) {\n  this.hero$ = this.service.getHero(heroId);\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n前面的例子使用了一個變數 <code>name</code>，並根據 <code>name</code> 引數給它賦值。</p><p translation-origin=\"off\"><strong>NOTE:</strong> <br>\nYou can bind all route data with key, value pairs to component inputs: static or resolved route data, path parameters, matrix parameters, and query parameters.</p>\n\n</div>\n</li>\n</ol>\n<p><a id=\"wildcard-route-how-to\"></a></p>\n<h2 id=\"setting-up-wildcard-routes\" translation-result=\"on\">設定萬用字元路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#setting-up-wildcard-routes\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Setting up wildcard routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#setting-up-wildcard-routes\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">當用戶試圖導航到那些不存在的應用部件時，在正常的應用中應該能得到很好的處理。要在應用中新增此功能，需要設定萬用字元路由。當所請求的 URL 與任何路由器路徑都不匹配時，Angular 路由器就會選擇這個路由。</p><p translation-origin=\"off\">A well-functioning application should gracefully handle when users attempt to navigate to a part of your application that does not exist.\nTo add this functionality to your application, you set up a wildcard route.\nThe Angular router selects this route any time the requested URL doesn't match any router paths.</p>\n\n<p translation-result=\"on\">要設定萬用字元路由，請在 <code>routes</code> 定義中新增以下程式碼。</p><p translation-origin=\"off\">To set up a wildcard route, add the following code to your <code>routes</code> definition.</p>\n\n<code-example header=\"AppRoutingModule (excerpt)\">\n\n{ path: '**', component: &lt;component-name&gt; }\n\n</code-example>\n<p translation-result=\"on\">這兩個星號 <code>**</code> 告訴 Angular，這個 <code>routes</code> 定義是萬用字元路由。對於 component 屬性，你可以使用應用中的任何元件。常見的選擇包括應用專屬的 <code>PageNotFoundComponent</code>，你可以定義它來向用戶<a href=\"guide/router#404-page-how-to\">展示 404 頁面</a>，或者跳轉到應用的主元件。萬用字元路由是最後一個路由，因為它匹配所有的 URL。關於路由順序的更多詳細資訊，請參閱<a href=\"guide/router#route-order\">路由順序</a>。</p><p translation-origin=\"off\">The two asterisks, <code>**</code>, indicate to Angular that this <code>routes</code> definition is a wildcard route.\nFor the component property, you can define any component in your application.\nCommon choices include an application-specific <code>PageNotFoundComponent</code>, which you can define to <a href=\"guide/router#404-page-how-to\">display a 404 page</a> to your users; or a redirect to your application's main component.\nA wildcard route is the last route because it matches any URL.\nFor more detail on why order matters for routes, see <a href=\"guide/router#route-order\">Route order</a>.</p>\n\n<p><a id=\"404-page-how-to\"></a></p>\n<h2 id=\"displaying-a-404-page\" translation-result=\"on\">顯示 404 頁面<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#displaying-a-404-page\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Displaying a 404 page<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#displaying-a-404-page\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要顯示 404 頁面，請設定一個<a href=\"guide/router#wildcard-route-how-to\">萬用字元路由</a>，並將 <code>component</code> 屬性設定為你要用於 404 頁面的元件，如下所示：</p><p translation-origin=\"off\">To display a 404 page, set up a <a href=\"guide/router#wildcard-route-how-to\">wildcard route</a> with the <code>component</code> property set to the component you'd like to use for your 404 page as follows:</p>\n\n<code-example header=\"AppRoutingModule (excerpt)\" path=\"router/src/app/app-routing.module.8.ts\" region=\"routes-with-wildcard\">\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];\n\n</code-example>\n<p translation-result=\"on\"><code>path</code> 為 <code>**</code> 的最後一條路由是萬用字元路由。如果請求的 URL 與前面列出的路徑不匹配，路由器會選擇這個路由，並把該使用者送到 <code>PageNotFoundComponent</code>。</p><p translation-origin=\"off\">The last route with the <code>path</code> of <code>**</code> is a wildcard route.\nThe router selects this route if the requested URL doesn't match any of the paths earlier in the list and sends the user to the <code>PageNotFoundComponent</code>.</p>\n\n<h2 id=\"setting-up-redirects\" translation-result=\"on\">設定重新導向<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#setting-up-redirects\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Setting up redirects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#setting-up-redirects\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要設定重新導向，請使用重新導向源的 <code>path</code>、要重新導向目標的 <code>component</code> 和一個 <code>pathMatch</code> 值來配置路由，以告訴路由器該如何匹配 URL。</p><p translation-origin=\"off\">To set up a redirect, configure a route with the <code>path</code> you want to redirect from, the <code>component</code> you want to redirect to, and a <code>pathMatch</code> value that tells the router how to match the URL.</p>\n\n<code-example header=\"AppRoutingModule (excerpt)\" path=\"router/src/app/app-routing.module.8.ts\" region=\"redirect\">\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: 'first-component', component: FirstComponent },\n  { path: 'second-component', component: SecondComponent },\n  { path: '',   redirectTo: '/first-component', pathMatch: 'full' }, // redirect to `first-component`\n  { path: '**', component: PageNotFoundComponent },  // Wildcard route for a 404 page\n];\n\n</code-example>\n<p translation-result=\"on\">在這個例子中，第三個路由是重新導向路由，所以路由器會預設跳到 <code>first-component</code> 路由。注意，這個重新導向路由位於萬用字元路由之前。這裡的 <code>path: ''</code> 表示使用初始的相對 URL（<code>''</code>）。</p><p translation-origin=\"off\">In this example, the third route is a redirect so that the router defaults to the <code>first-component</code> route.\nNotice that this redirect precedes the wildcard route.\nHere, <code>path: ''</code> means to use the initial relative URL (<code>''</code>).</p>\n\n<p translation-result=\"on\">關於 <code>pathMatch</code> 的詳情，請參閱<a href=\"guide/router-tutorial-toh#pathmatch\">聚焦 <code>pathMatch</code></a>部分。</p><p translation-origin=\"off\">For more details on <code>pathMatch</code> see <a href=\"guide/router-tutorial-toh#pathmatch\">Spotlight on <code>pathMatch</code></a>.</p>\n\n<p><a id=\"nesting-routes\"></a></p>\n<h2 id=\"nesting-routes\" translation-result=\"on\">巢狀(Nesting)路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#nesting-routes\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Nesting routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#nesting-routes\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">隨著你的應用變得越來越複雜，你可能要建立一些根元件之外的相對路由。這些巢狀(Nesting)路由型別稱為子路由。這意味著你要為你的應用新增第二 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>，因為它是 <code>AppComponent</code> 之外的另一個 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>。</p><p translation-origin=\"off\">As your application grows more complex, you might want to create routes that are relative to a component other than your root component.\nThese types of nested routes are called child routes.\nThis means you're adding a second <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> to your app, because it is in addition to the <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> in <code>AppComponent</code>.</p>\n\n<p translation-result=\"on\">在這個例子中，還有兩個子元件，<code>child-a</code> 和 <code>child-b</code>。這裡的 <code>FirstComponent</code> 有它自己的 <code>&lt;nav&gt;</code> 和 <code>AppComponent</code> 之外的第二 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>。</p><p translation-origin=\"off\">In this example, there are two additional child components, <code>child-a</code>, and <code>child-b</code>.\nHere, <code>FirstComponent</code> has its own <code>&lt;nav&gt;</code> and a second <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> in addition to the one in <code>AppComponent</code>.</p>\n\n<code-example header=\"In the template\" path=\"router/src/app/app.component.8.html\" region=\"child-routes\">\n&lt;h2&gt;First <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&lt;/h2&gt;\n\n&lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"child-a\"&gt;Child A&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"child-b\"&gt;Child B&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/nav&gt;\n\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n</code-example>\n<p translation-result=\"on\">子路由和其它路由一樣，同時需要 <code>path</code> 和 <code>component</code>。唯一的區別是你要把子路由放在父路由的 <code>children</code> 陣列中。</p><p translation-origin=\"off\">A child route is like any other route, in that it needs both a <code>path</code> and a <code>component</code>.\nThe one difference is that you place child routes in a <code>children</code> array within the parent route.</p>\n\n<code-example header=\"AppRoutingModule (excerpt)\" path=\"router/src/app/app-routing.module.9.ts\" region=\"child-routes\">\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'first-component',\n    component: FirstComponent, // this is the component with the &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt; in the template\n    children: [\n      {\n        path: 'child-a', // child route path\n        component: ChildAComponent, // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        component: ChildBComponent, // another child route component that the router renders\n      },\n    ],\n  },\n];\n\n</code-example>\n<p><a id=\"setting-the-page-title\"></a></p>\n<h2 id=\"setting-the-page-title\" translation-result=\"on\">設定頁面標題<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#setting-the-page-title\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Setting the page title<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#setting-the-page-title\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">應用程式中的每個頁面都應該有一個唯一的標題，以便可以在瀏覽器歷史記錄中識別它們。<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 使用 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> 配置中的 <code>title</code> 屬性設定文件的標題。</p><p translation-origin=\"off\">Each page in your application should have a unique title so that they can be identified in the browser history.\nThe <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> sets the document's title using the <code>title</code> property from the <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> config.</p>\n\n<code-example header=\"AppRoutingModule (excerpt)\" path=\"router/src/app/app-routing.module.10.ts\" region=\"page-title\">\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  {\n    path: 'first-component',\n    title: 'First component',\n    component: FirstComponent,  // this is the component with the &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt; in the template\n    children: [\n      {\n        path: 'child-a',  // child route path\n        title: resolvedChildATitle,\n        component: ChildAComponent,  // child route component that the router renders\n      },\n      {\n        path: 'child-b',\n        title: 'child b',\n        component: ChildBComponent,  // another child route component that the router renders\n      },\n    ],\n  },\n];\n\nconst resolvedChildATitle: <a href=\"api/router/ResolveFn\" class=\"code-anchor\">ResolveFn</a>&lt;string&gt; = () =&gt; Promise.resolve('child a');\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n<code>title</code> 屬性遵循與實現 <code><a href=\"api/router/ResolveFn\" class=\"code-anchor\">ResolveFn</a></code> 的靜態路由 <code>data</code> 和動態值相同的規則。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br> The <code>title</code> property follows the same rules as static route <code>data</code> and dynamic values that implement <code><a href=\"api/router/ResolveFn\" class=\"code-anchor\">ResolveFn</a></code>.</p>\n\n</div>\n<p translation-result=\"on\">你還可以透過擴充 <code><a href=\"api/router/TitleStrategy\" class=\"code-anchor\">TitleStrategy</a></code> 來提供自訂標題策略。</p><p translation-origin=\"off\">You can also provide a custom title strategy by extending the <code><a href=\"api/router/TitleStrategy\" class=\"code-anchor\">TitleStrategy</a></code>.</p>\n\n<code-example header=\"AppRoutingModule (excerpt)\" path=\"router/src/app/app-routing.module.10.ts\" region=\"custom-page-title\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({providedIn: 'root'})\nexport class TemplatePageTitleStrategy extends <a href=\"api/router/TitleStrategy\" class=\"code-anchor\">TitleStrategy</a> {\n  constructor(private readonly title: <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>) {\n    super();\n  }\n\n  override updateTitle(routerState: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>) {\n    const title = this.buildTitle(routerState);\n    if (title !== undefined) {\n      this.title.setTitle(`My Application | ${title}`);\n    }\n  }\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>],\n  providers: [\n    {provide: <a href=\"api/router/TitleStrategy\" class=\"code-anchor\">TitleStrategy</a>, useClass: TemplatePageTitleStrategy},\n  ]\n})\nexport class AppRoutingModule {\n}\n\n</code-example>\n<p><a id=\"using-relative-paths\"></a></p>\n<h2 id=\"using-relative-paths\" translation-result=\"on\">使用相對路徑<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#using-relative-paths\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Using relative paths<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#using-relative-paths\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">相對路徑允許你定義相對於當前 URL 段的路徑。下面的例子展示了到另一個元件 <code>second-component</code> 的相對路由。<code>FirstComponent</code> 和 <code>SecondComponent</code> 在樹中處於同一級別，但是，指向 <code>SecondComponent</code> 的連結位於 <code>FirstComponent</code> 中，這意味著路由器必須先上升一個級別，然後進入二級目錄才能找到 <code>SecondComponent</code>。可以用 <code>../</code> 符號來上升一個級別，而不用寫出到 <code>SecondComponent</code> 的完整路徑。</p><p translation-origin=\"off\">Relative paths let you define paths that are relative to the current URL segment.\nThe following example shows a relative route to another component, <code>second-component</code>.\n<code>FirstComponent</code> and <code>SecondComponent</code> are at the same level in the tree, however, the link to <code>SecondComponent</code> is situated within the <code>FirstComponent</code>, meaning that the router has to go up a level and then into the second directory to find the <code>SecondComponent</code>.\nRather than writing out the whole path to get to <code>SecondComponent</code>, use the <code>../</code> notation to go up a level.</p>\n\n<code-example header=\"In the template\" path=\"router/src/app/app.component.8.html\" region=\"relative-route\">\n\n&lt;h2&gt;First <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&lt;/h2&gt;\n\n&lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"../second-component\"&gt;Relative <a href=\"api/router/Route\" class=\"code-anchor\">Route</a> to second component&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/nav&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n\n</code-example>\n<p translation-result=\"on\">除了 <code>../</code>，還可以使用 <code>./</code> 或者不帶前導斜槓來指定當前級別。</p><p translation-origin=\"off\">In addition to <code>../</code>, use <code>./</code> or no leading slash to specify the current level.</p>\n\n<h3 id=\"specifying-a-relative-route\" translation-result=\"on\">指定相對路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#specifying-a-relative-route\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Specifying a relative route<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#specifying-a-relative-route\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要指定相對路由，請使用 <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> 中的 <code>relativeTo</code> 屬性。在元件類中，從 <code>@angular/router</code> 匯入 <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code>。</p><p translation-origin=\"off\">To specify a relative route, use the <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> <code>relativeTo</code> property.\nIn the component class, import <code><a href=\"api/router/NavigationExtras\" class=\"code-anchor\">NavigationExtras</a></code> from the <code>@angular/router</code>.</p>\n\n<p translation-result=\"on\">然後在導航方法中使用 <code>relativeTo</code> 引數。在連結引數陣列（它包含 <code>items</code>）之後新增一個物件，把該物件的 <code>relativeTo</code> 屬性設定為當前的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>，也就是 <code>this.route</code>。</p><p translation-origin=\"off\">Then use <code>relativeTo</code> in your navigation method.\nAfter the link parameters array, which here contains <code>items</code>, add an object with the <code>relativeTo</code> property set to the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>, which is <code>this.route</code>.</p>\n\n<code-example header=\"RelativeTo\" path=\"router/src/app/app.component.4.ts\" region=\"relative-to\">\ngoToItems() {\n  this.router.navigate(['items'], { relativeTo: this.route });\n}\n\n</code-example>\n<p translation-result=\"on\"><code>goToItems()</code> 方法會把目標 URI 解釋為相對於當前路由的，並導航到 <code>items</code> 路由。</p><p translation-origin=\"off\">The <code>goToItems()</code> method interprets the destination URI as relative to the activated route and navigates to the <code>items</code> route.</p>\n\n<h2 id=\"accessing-query-parameters-and-fragments\" translation-result=\"on\">存取查詢引數和片段<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#accessing-query-parameters-and-fragments\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Accessing query parameters and fragments<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#accessing-query-parameters-and-fragments\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">有時，應用中的某個特性需要存取路由的部件，比如查詢引數或片段（fragment）。本課程的這個階段使用了一個“英雄之旅”中的列表檢視，你可以在其中點選一個英雄來檢視詳情。路由器使用 <code>id</code> 來顯示正確的英雄的詳情。</p><p translation-origin=\"off\">Sometimes, a feature of your application requires accessing a part of a route, such as a query parameter or a fragment.\nThe Tour of Heroes application at this stage in the tutorial uses a list view in which you can click on a hero to see details.\nThe router uses an <code>id</code> to show the correct hero's details.</p>\n\n<p translation-result=\"on\">首先，在要導航的元件中匯入以下成員。</p><p translation-origin=\"off\">First, import the following members in the component you want to navigate from.</p>\n\n<code-example header=\"Component import statements (excerpt)\">\n\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n</code-example>\n<p translation-result=\"on\">接下來，注入當前路由（ActivatedRoute）服務：</p><p translation-origin=\"off\">Next inject the activated route service:</p>\n\n<code-example header=\"Component (excerpt)\">\n\nconstructor(private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>) {}\n\n</code-example>\n<p translation-result=\"on\">配置這個類，讓你有一個可觀察物件 <code>heroes$</code>、一個用來儲存英雄的 <code>id</code> 號的 <code>selectedId</code>，以及 <code>ngOnInit()</code> 中的英雄們，新增下面的程式碼來獲取所選英雄的 <code>id</code>。這個程式碼片段假設你有一個英雄列表、一個英雄服務、一個能獲取你的英雄的函式，以及用來渲染你的列表和細節的 HTML，就像在《英雄之旅》例子中一樣。</p><p translation-origin=\"off\">Configure the class so that you have an observable, <code>heroes$</code>, a <code>selectedId</code> to hold the <code>id</code> number of the hero, and the heroes in the <code>ngOnInit()</code>, add the following code to get the <code>id</code> of the selected hero.\nThis code snippet assumes that you have a heroes list, a hero service, a function to get your heroes, and the HTML to render your list and details, just as in the Tour of Heroes example.</p>\n\n<code-example header=\"Component 1 (excerpt)\">\n\nheroes$: Observable&lt;Hero[]&gt;;\nselectedId: number;\nheroes = HEROES;\n\nngOnInit() {\n  this.heroes$ = this.route.paramMap.pipe(\n    switchMap(params =&gt; {\n      this.selectedId = Number(params.get('id'));\n      return this.service.getHeroes();\n    })\n  );\n}\n\n</code-example>\n<p translation-result=\"on\">接下來，在要導航到的元件中，匯入以下成員。</p><p translation-origin=\"off\">Next, in the component that you want to navigate to, import the following members.</p>\n\n<code-example header=\"Component 2 (excerpt)\">\n\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a> } from '@angular/router';\nimport { Observable } from 'rxjs';\n\n</code-example>\n<p translation-result=\"on\">在元件類別的建構函式中注入 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 和 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>，這樣在這個元件中就可以用它們了：</p><p translation-origin=\"off\">Inject <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> and <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> in the constructor of the component class so they are available to this component:</p>\n\n<code-example header=\"Component 2 (excerpt)\">\n\nhero$: Observable&lt;Hero&gt;;\n\nconstructor(\n  private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>  ) {}\n\nngOnInit() {\n  const heroId = this.route.snapshot.paramMap.get('id');\n  this.hero$ = this.service.getHero(heroId);\n}\n\ngotoItems(hero: Hero) {\n  const heroId = hero ? hero.id : null;\n  // Pass along the hero id if available\n  // so that the HeroList component can select that item.\n  this.router.navigate(['/heroes', { id: heroId }]);\n}\n\n</code-example>\n<p><a id=\"lazy-loading\"></a></p>\n<h2 id=\"lazy-loading\" translation-result=\"on\">延遲載入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#lazy-loading\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Lazy loading<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#lazy-loading\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以配置路由定義來實現延遲載入模組，這意味著 Angular 只會在需要時才載入這些模組，而不是在應用啟動時就載入全部。另外，你可以在後台預載入一些應用部件來改善使用者體驗。</p><p translation-origin=\"off\">You can configure your routes to lazy load modules, which means that Angular only loads modules as needed, rather than loading all modules when the application launches.\nAdditionally, preload parts of your application in the background to improve the user experience.</p>\n\n<p translation-result=\"on\">關於延遲載入和預載入的詳情，請參閱專門的指南<a href=\"guide/lazy-loading-ngmodules\">延遲載入 NgModule</a>。</p><p translation-origin=\"off\">For more information on lazy loading and preloading see the dedicated guide <a href=\"guide/lazy-loading-ngmodules\">Lazy loading NgModules</a>.</p>\n\n<h2 id=\"preventing-unauthorized-access\" translation-result=\"on\">防止未經授權的存取<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#preventing-unauthorized-access\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Preventing unauthorized access<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#preventing-unauthorized-access\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用路由守衛來防止使用者未經授權就導航到應用的某些部分。Angular 中提供了以下路由守衛：</p><p translation-origin=\"off\">Use route guards to prevent users from navigating to parts of an application without authorization.\nThe following route guards are available in Angular:</p>\n\n<ul>\n<li>\n<p><a href=\"api/router/CanActivateFn\"><code>canActivate</code></a></p>\n</li>\n<li>\n<p><a href=\"api/router/CanActivateChildFn\"><code>canActivateChild</code></a></p>\n</li>\n<li>\n<p><a href=\"api/router/CanDeactivateFn\"><code>canDeactivate</code></a></p>\n</li>\n<li>\n<p><a href=\"api/router/CanMatchFn\"><code>canMatch</code></a></p>\n</li>\n<li>\n<p><a href=\"api/router/ResolveFn\"><code>resolve</code></a></p>\n</li>\n<li>\n<p><a href=\"api/router/CanLoadFn\"><code>canLoad</code></a></p>\n</li>\n</ul>\n<p translation-result=\"on\">要想使用路由守衛，可以考慮使用<a href=\"api/router/Route#componentless-routes\">無元件路由</a>，因為這對於保護子路由很方便。</p><p translation-origin=\"off\">To use route guards, consider using <a href=\"api/router/Route#componentless-routes\">component-less routes</a> as this facilitates guarding child routes.</p>\n\n<p translation-result=\"on\">為你的守衛建立一個檔案：</p><p translation-origin=\"off\">Create a file for your guard:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate guard your-guard\n\n</code-example>\n<p translation-result=\"on\">請在守衛檔案裡新增你要用到的守衛函式。下面的例子使用 <code>canActivateFn</code> 來保護該路由。</p><p translation-origin=\"off\">In your guard file, add the guard functions you want to use.\nThe following example uses <code>canActivateFn</code> to guard the route.</p>\n\n<code-example header=\"guard (excerpt)\">\n\nexport const yourGuardFunction: <a href=\"api/router/CanActivateFn\" class=\"code-anchor\">CanActivateFn</a> = (\n    next: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,\n    state: <a href=\"api/router/RouterStateSnapshot\" class=\"code-anchor\">RouterStateSnapshot</a>) =&gt; {\n      // your  logic goes here\n  }\n</code-example>\n<p translation-result=\"on\">在路由模組中，在 <code>routes</code> 配置中使用相應的屬性。這裡的 <code>canActivate</code> 會告訴路由器它要協調到這個特定路由的導航。</p><p translation-origin=\"off\">In your routing module, use the appropriate property in your <code>routes</code> configuration.\nHere, <code>canActivate</code> tells the router to mediate navigation to this particular route.</p>\n\n<code-example header=\"Routing module (excerpt)\">\n{\n  path: '/your-path',\n  component: YourComponent,\n  canActivate: [yourGuardFunction],\n}\n\n</code-example>\n<p translation-result=\"on\">關於此可工作範例的更多資訊，請參閱<a href=\"guide/router-tutorial-toh#milestone-5-route-guards\">路由導航中關於路由守衛的部分</a>。</p><p translation-origin=\"off\">For more information with a working example, see the <a href=\"guide/router-tutorial-toh#milestone-5-route-guards\">routing tutorial section on route guards</a>.</p>\n\n<h2 id=\"link-parameters-array\" translation-result=\"on\">連結引數陣列<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#link-parameters-array\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Link parameters array<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#link-parameters-array\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">連結引數陣列儲存路由導航時所需的成分：</p><p translation-origin=\"off\">A link parameters array holds the following ingredients for router navigation:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">指向目標元件的那個路由的路徑（path）</p><p translation-origin=\"off\">The path of the route to the destination component</p>\n\n</li>\n<li>\n<p translation-result=\"on\">必備路由引數和可選路由引數，它們將進入該路由的 URL</p><p translation-origin=\"off\">Required and optional route parameters that go into the route URL</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">可以把 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令繫結到一個數組，就像這樣：</p><p translation-origin=\"off\">Bind the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> directive to such an array like this:</p>\n\n<code-example header=\"src/app/app.component.ts (h-anchor)\" path=\"router/src/app/app.component.3.ts\" region=\"h-anchor\">\n&lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/heroes']\"&gt;Heroes&lt;/a&gt;\n\n</code-example>\n<p translation-result=\"on\">在指定路由引數時，使用如下的兩元素陣列：</p><p translation-origin=\"off\">The following is a two-element array when specifying a route parameter:</p>\n\n<code-example header=\"src/app/heroes/hero-list/hero-list.component.html (nav-to-detail)\" path=\"router/src/app/heroes/hero-list/hero-list.component.1.html\" region=\"nav-to-detail\">\n&lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/hero', hero.id]\"&gt;\n  &lt;span class=\"badge\"&gt;{{ hero.id }}&lt;/span&gt;{{ hero.name }}\n&lt;/a&gt;\n\n</code-example>\n<p translation-result=\"on\">可以在物件中提供可選的路由引數，比如 <code>{ foo: 'foo' }</code>：</p><p translation-origin=\"off\">Provide optional route parameters in an object, as in <code>{ foo: 'foo' }</code>:</p>\n\n<code-example header=\"src/app/app.component.ts (cc-query-params)\" path=\"router/src/app/app.component.3.ts\" region=\"cc-query-params\">\n&lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center', { foo: 'foo' }]\"&gt;Crisis Center&lt;/a&gt;\n\n</code-example>\n<p translation-result=\"on\">這三個例子涵蓋了你在單級路由的應用中所需的一切。不過，在你新增一個像<em>危機中心</em>一樣的子路由時，你可以建立新連結陣列。</p><p translation-origin=\"off\">These three examples cover the needs of an application with one level of routing.\nHowever, with a child router, such as in the crisis center, you create new link array possibilities.</p>\n\n<p translation-result=\"on\">下面這個最小化 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 例子是基於危機中心指定的<a href=\"guide/router-tutorial-toh#a-crisis-center-with-child-routes\">預設子路由</a>建構的。</p><p translation-origin=\"off\">The following minimal <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> example builds upon a specified <a href=\"guide/router-tutorial-toh#a-crisis-center-with-child-routes\">default child route</a> for the crisis center.</p>\n\n<code-example header=\"src/app/app.component.ts (cc-anchor-w-default)\" path=\"router/src/app/app.component.3.ts\" region=\"cc-anchor-w-default\">\n&lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center']\"&gt;Crisis Center&lt;/a&gt;\n\n</code-example>\n<p translation-result=\"on\">檢視以下內容：</p><p translation-origin=\"off\">Review the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">陣列中的第一個條目標記出了父路由（<code>/crisis-center</code>）。</p><p translation-origin=\"off\">The first item in the array identifies the parent route (<code>/crisis-center</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">這個父路由沒有引數。</p><p translation-origin=\"off\">There are no parameters for this parent route</p>\n\n</li>\n<li>\n<p translation-result=\"on\">沒有預設的子路由，因此你得選取一個。</p><p translation-origin=\"off\">There is no default for the child route so you need to pick one</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你決定跳轉到 <code>CrisisListComponent</code>，它的路由路徑是'/'，但你不用顯式的新增它。</p><p translation-origin=\"off\">You're navigating to the <code>CrisisListComponent</code>, whose route path is <code>/</code>, but you don't need to explicitly add the slash</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">考慮以下路由器連結，它將從應用的根目錄導航到巨龍危機（Dragon Crisis）：</p><p translation-origin=\"off\">Consider the following router link that navigates from the root of the application down to the Dragon Crisis:</p>\n\n<code-example header=\"src/app/app.component.ts (Dragon-anchor)\" path=\"router/src/app/app.component.3.ts\" region=\"Dragon-anchor\">\n&lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center', 1]\"&gt;Dragon Crisis&lt;/a&gt;\n\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\">陣列中的第一個條目標記出了父路由（<code>/crisis-center</code>）。</p><p translation-origin=\"off\">The first item in the array identifies the parent route (<code>/crisis-center</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">這個父路由沒有引數。</p><p translation-origin=\"off\">There are no parameters for this parent route</p>\n\n</li>\n<li>\n<p translation-result=\"on\">陣列中的第二個條目（'/:id'）用來標記出到指定危機的詳情頁的子路由。</p><p translation-origin=\"off\">The second item identifies the child route details about a particular crisis (<code>/:id</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">詳細的子路由需要一個 <code>id</code> 路由引數。</p><p translation-origin=\"off\">The details child route requires an <code>id</code> route parameter</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你把<em>巨龍危機</em>的 <code>id</code> 新增為該陣列中的第二個條目（<code>1</code>）。</p><p translation-origin=\"off\">You added the <code>id</code> of the Dragon Crisis as the second item in the array (<code>1</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">最終產生的路徑是 <code>/crisis-center/1</code>。</p><p translation-origin=\"off\">The resulting path is <code>/crisis-center/1</code></p>\n\n</li>\n</ul>\n<p translation-result=\"on\">你也可以把危機中心的路由單獨重新定義為 <code>AppComponent</code> 的範本：</p><p translation-origin=\"off\">You could also redefine the <code>AppComponent</code> template with Crisis Center routes exclusively:</p>\n\n<code-example header=\"src/app/app.component.ts (template)\" path=\"router/src/app/app.component.3.ts\" region=\"template\">\ntemplate: `\n  &lt;h1 class=\"title\"&gt;Angular <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>&lt;/h1&gt;\n  &lt;nav&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center']\"&gt;Crisis Center&lt;/a&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center/1', { foo: 'foo' }]\"&gt;Dragon Crisis&lt;/a&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/crisis-center/2']\"&gt;Shark Crisis&lt;/a&gt;\n  &lt;/nav&gt;\n  &lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n`\n\n</code-example>\n<p translation-result=\"on\">總之，你可以用一級、兩級或多級路由來寫應用程式。連結引數陣列提供了用來表示任意深度路由的連結引數陣列以及任意合法的路由引數序列、必須的路由器引數以及可選的路由引數物件。</p><p translation-origin=\"off\">In summary, you can write applications with one, two or more levels of routing.\nThe link parameters array affords the flexibility to represent any routing depth and any legal sequence of route paths, (required) router parameters, and (optional) route parameter objects.</p>\n\n<p><a id=\"browser-url-styles\"></a>\n<a id=\"location-strategy\"></a></p>\n<h2 id=\"locationstrategy-and-browser-url-styles\" translation-result=\"on\"><code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> 和瀏覽器的網址樣式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#locationstrategy-和瀏覽器的網址樣式\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\"><code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> and browser URL styles<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#locationstrategy-and-browser-url-styles\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">當路由器導航到一個新的元件檢視時，它會用該檢視的 URL 來更新瀏覽器的當前地址以及歷史。</p><p translation-origin=\"off\">When the router navigates to a new component view, it updates the browser's location and history with a URL for that view.</p>\n\n<p translation-result=\"on\">現代 HTML 5 瀏覽器支援<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Working_with_the_History_API#adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a> API，\n這是一項可以改變瀏覽器的當前地址和歷史，卻又不會觸發伺服器端頁面請求的技術。\n路由器可以合成出一個“自然的”URL，它看起來和那些需要進行頁面載入的 URL 沒什麼區別。</p><p translation-origin=\"off\">Modern HTML5 browsers support <a href=\"https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a>, a technique that changes a browser's location and history without triggering a server page request.\nThe router can compose a \"natural\" URL that is indistinguishable from one that would otherwise require a page load.</p>\n\n<p translation-result=\"on\">下面是危機中心的 URL 在“HTML 5 pushState”風格下的樣子：</p><p translation-origin=\"off\">Here's the Crisis Center URL in this \"HTML5 pushState\" style:</p>\n\n<code-example format=\"none\" language=\"http\">\n\nlocalhost:3002/crisis-center\n\n</code-example>\n<p translation-result=\"on\">老舊的瀏覽器在當前地址的 URL 變化時總會往伺服器傳送頁面請求……唯一的例外規則是：當這些變化位於“#”（被稱為“hash”）後面時不會發送。透過把應用內的路由 URL 拼接在 <code>#</code> 之後，路由器可以獲得這條“例外規則”帶來的優點。下面是到<em>危機中心</em>路由的“hash URL”。</p><p translation-origin=\"off\">Older browsers send page requests to the server when the location URL changes unless the change occurs after a \"#\" (called the \"hash\").\nRouters can take advantage of this exception by composing in-application route URLs with hashes.\nHere's a \"hash URL\" that routes to the Crisis Center.</p>\n\n<code-example format=\"none\" language=\"http\">\n\nlocalhost:3002/src/#/crisis-center\n\n</code-example>\n<p translation-result=\"on\">路由器透過兩種 <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> 提供者來支援所有這些風格：</p><p translation-origin=\"off\">The router supports both styles with two <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> providers:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">提供者</nt-wrapper><nt-wrapper translation-origin=\"off\">Providers</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/common/PathLocationStrategy\" class=\"code-anchor\">PathLocationStrategy</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">預設的 “HTML 5 pushState” 風格。</nt-wrapper><nt-wrapper translation-origin=\"off\">The default \"HTML5 pushState\" style.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">“hash URL”風格。</nt-wrapper><nt-wrapper translation-origin=\"off\">The \"hash URL\" style.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\"><code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 函式把 <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> 設定成了 <code><a href=\"api/common/PathLocationStrategy\" class=\"code-anchor\">PathLocationStrategy</a></code>，使其成為了預設策略。你還可以在啟動過程中改寫（override）它，來切換到 <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> 風格。</p><p translation-origin=\"off\">The <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> function sets the <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> to the <code><a href=\"api/common/PathLocationStrategy\" class=\"code-anchor\">PathLocationStrategy</a></code>, which makes it the default strategy.\nYou also have the option of switching to the <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> with an override during the bootstrapping process.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">關於提供者和引導過程的更多資訊，請參閱<a href=\"guide/dependency-injection-providers\">依賴注入</a>。</p><p translation-origin=\"off\">For more information on providers and the bootstrap process, see <a href=\"guide/dependency-injection-providers\">Dependency Injection</a>.</p>\n\n</div>\n<h2 id=\"choosing-a-routing-strategy\" translation-result=\"on\">選擇路由策略<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#choosing-a-routing-strategy\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Choosing a routing strategy<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#choosing-a-routing-strategy\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你必須在開發專案的早期就選擇一種路由策略，因為一旦該應用進入了生產階段，你網站的存取者就會使用並依賴應用的這些 URL 參考。</p><p translation-origin=\"off\">You must choose a routing strategy early in the development of your project because once the application is in production, visitors to your site use and depend on application URL references.</p>\n\n<p translation-result=\"on\">幾乎所有的 Angular 專案都會使用預設的 HTML 5 風格。它產生的 URL 更易於被使用者理解，它也為將來做<strong>伺服器端渲染</strong>預留了空間。</p><p translation-origin=\"off\">Almost all Angular projects should use the default HTML5 style.\nIt produces URLs that are easier for users to understand and it preserves the option to do server-side rendering.</p>\n\n<p translation-result=\"on\">在伺服器端渲染指定的頁面，是一項可以在該應用首次載入時大幅提升響應速度的技術。那些原本需要十秒甚至更長時間載入的應用，可以預先在伺服器端渲染好，並在少於一秒的時間內完整渲染在使用者的裝置上。</p><p translation-origin=\"off\">Rendering critical pages on the server is a technique that can greatly improve perceived responsiveness when the application first loads.\nAn application that would otherwise take ten or more seconds to start could be rendered on the server and delivered to the user's device in less than a second.</p>\n\n<p translation-result=\"on\">只有當應用的 URL 看起來像是標準的 Web URL，中間沒有 hash（<code>#</code>）時，這個選項才能生效。</p><p translation-origin=\"off\">This option is only available if application URLs look like normal web URLs without hash (<code>#</code>) characters in the middle.</p>\n\n<h2 id=\"base-href\"><code>&lt;base href&gt;</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#base-href\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\">路由器使用瀏覽器的 <a href=\"https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a> API 進行導航。藉助 <code>pushState</code> 你自訂應用中的 URL 路徑 <code>localhost:4200/crisis-center</code>，應用內的 URL 和伺服器的 URL 沒有區別。</p><p translation-origin=\"off\">The router uses the browser's <a href=\"https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries\" title=\"HTML5 browser history push-state\">history.pushState</a> for navigation.\n<code>pushState</code> lets you customize in-application URL paths; for example, <code>localhost:4200/crisis-center</code>.\nThe in-application URLs can be indistinguishable from server URLs.</p>\n\n<p translation-result=\"on\">現代的 HTML5 瀏覽器都支援 <code>pushState</code>，這也就是為什麼很多人把這種 URL 形式稱為 \"HTML 5\" 風格的 URL。</p><p translation-origin=\"off\">Modern HTML5 browsers were the first to support <code>pushState</code> which is why many people refer to these URLs as \"HTML5 style\" URLs.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">路由器預設使用 HTML5 風格的導航。\n在 <a href=\"guide/router#browser-url-styles\">LocationStrategy 與瀏覽器 URL 風格</a>部分，你可以瞭解為何推薦使用 HTML5 風格的 URL，如何調整其行為，以及必要時如何切換到老式的 hash（<code>#</code>）風格。</p><p translation-origin=\"off\">HTML5 style navigation is the router default.\nIn the <a href=\"guide/router#browser-url-styles\">LocationStrategy and browser URL styles</a> section, learn why HTML5 style is preferable, how to adjust its behavior, and how to switch to the older hash (<code>#</code>) style, if necessary.</p>\n\n</div>\n<p translation-result=\"on\">你必須在應用的 <code>index.html</code> 中<strong>新增一個 <a href=\"https://developer.mozilla.org/docs/Web/HTML/Element/base\" title=\"base href\"><code>&lt;base href&gt;</code> 元素</a></strong>才能讓 <code>pushState</code> 路由正常工作。\n瀏覽器要用 <code>&lt;base href&gt;</code> 的值為參考 CSS、指令碼和圖片檔案時使用的<em>相對</em> URL 新增字首。</p><p translation-origin=\"off\">You must add a <a href=\"https://developer.mozilla.org/docs/Web/HTML/Element/base\" title=\"base href\"><code>&lt;base href&gt;</code> element</a> to the application's <code>index.html</code> for <code>pushState</code> routing to work.\nThe browser uses the <code>&lt;base href&gt;</code> value to prefix relative URLs when referencing CSS files, scripts, and images.</p>\n\n<p translation-result=\"on\">請把 <code>&lt;base&gt;</code> 元素新增在 <code>&lt;head&gt;</code> 標籤的緊後面。如果應用的根目錄是 <code>app</code> 目錄，那麼就可以像這個應用程式一樣，設定 <strong><code>index.html</code></strong> 中的 <code>href</code> 值。程式碼如下。</p><p translation-origin=\"off\">Add the <code>&lt;base&gt;</code> element just after the <code>&lt;head&gt;</code> tag.\nIf the <code>app</code> folder is the application root, as it is for this application, set the <code>href</code> value in <code>index.html</code> as shown here.</p>\n\n<code-example header=\"src/index.html (base-href)\" path=\"router/src/index.html\" region=\"base-href\">\n&lt;base href=\"/\"&gt;\n\n</code-example>\n<h3 id=\"html5-urls-and-the-base-href\" translation-result=\"on\">HTML5 網址和 <code>&lt;base href&gt;</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#html5-urls-and-the-base-href\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">HTML5 URLs and the <code>&lt;base href&gt;</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#html5-urls-and-the-base-href\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">後面的指南中會參考 URL 的不同部分。下圖是這些部分所指內容的梗概：</p><p translation-origin=\"off\">The guidelines that follow will refer to different parts of a URL.\nThis diagram outlines what those parts refer to:</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"none\">\n\nfoo://example.com:8042/over/there?name=ferret#nose\n\\_/   \\______________/\\_________/ \\_________/ \\__/\n |           |            |            |        |\nscheme    authority      path        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>   fragment\n\n</code-example>\n<p translation-result=\"on\">由於路由器預設使用 <a href=\"https://developer.mozilla.org/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"Browser history push-state\">HTML5 pushState</a>  風格，所以你<em>必須</em>用一個 <code>&lt;base href&gt;</code> 來配置該策略（Strategy）。</p><p translation-origin=\"off\">While the router uses the <a href=\"https://developer.mozilla.org/docs/Web/API/History_API#Adding_and_modifying_history_entries\" title=\"Browser history push-state\">HTML5 pushState</a> style by default, you must configure that strategy with a <code>&lt;base href&gt;</code>.</p>\n\n<p translation-result=\"on\">配置該策略的首選方式是往 <code>index.html</code> 的 <code>&lt;head&gt;</code> 中新增一個 <a href=\"https://developer.mozilla.org/docs/Web/HTML/Element/base\" title=\"base href\"><code>&lt;base href&gt;</code> element</a>標籤。</p><p translation-origin=\"off\">The preferred way to configure the strategy is to add a <a href=\"https://developer.mozilla.org/docs/Web/HTML/Element/base\" title=\"base href\"><code>&lt;base href&gt;</code> element</a> tag in the <code>&lt;head&gt;</code> of the <code>index.html</code>.</p>\n\n<code-example header=\"src/index.html (base-href)\" path=\"router/src/index.html\" region=\"base-href\">\n&lt;base href=\"/\"&gt;\n\n</code-example>\n<p translation-result=\"on\">如果沒有該標記，瀏覽器就可能無法在“深度連結”進入應用時載入資源（圖片，CSS，指令碼）。</p><p translation-origin=\"off\">Without that tag, the browser might not be able to load resources (images, CSS, scripts) when \"deep linking\" into the application.</p>\n\n<p translation-result=\"on\">有些開發人員可能無法新增 <code>&lt;base&gt;</code> 元素，這可能是因為它們沒有存取 <code>&lt;head&gt;</code> 或 <code>index.html</code> 的許可權。</p><p translation-origin=\"off\">Some developers might not be able to add the <code>&lt;base&gt;</code> element, perhaps because they don't have access to <code>&lt;head&gt;</code> or the <code>index.html</code>.</p>\n\n<p translation-result=\"on\">它們仍然可以使用 HTML 5 格式的 URL，但要採取如下步驟進行補救：</p><p translation-origin=\"off\">Those developers can still use HTML5 URLs by taking the following two steps:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">用適當的 <code><a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a></code> 值提供（provide）路由器。</p><p translation-origin=\"off\">Provide the router with an appropriate <code><a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a></code> value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">對所有 Web 資源（CSS、圖片、指令碼和範本 HTML 檔案）使用根 URL（高優先度 URL）。</p><p translation-origin=\"off\">Use root URLs (URLs with an <code>authority</code>) for all web resources: CSS, images, scripts, and template HTML files.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>&lt;base href&gt;</code> <code>path</code> 應該以“/”結尾，因為瀏覽器會忽略 <code>path</code> 中最右邊的“ <code>/</code> ”後面的字元</p><p translation-origin=\"off\">The <code>&lt;base href&gt;</code> <code>path</code> should end with a \"/\", as browsers ignore characters in the <code>path</code> that follow the right-most \"<code>/</code>\"</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果 <code>&lt;base href&gt;</code> 包含 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> 部分，則只有頁內連結的 <code>path</code> 部分為空並且沒有 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> 時，才會使用這裡的 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code>。這意味著 <code>&lt;base href&gt;</code> 中的 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> 部分只有在使用 <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> 策略時才有用。</p><p translation-origin=\"off\">If the <code>&lt;base href&gt;</code> includes a <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> part, the <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> is only used if the <code>path</code> of a link in the page is empty and has no <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code>.\nThis means that a <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> in the <code>&lt;base href&gt;</code> is only included when using <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果頁內連結是根 URL（高優先度 URL），則 <code>&lt;base href&gt;</code> 不會使用。在這種方式下，<code><a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a></code> 的優先度將會導致所有由 Angular 建立的連結忽略 <code>&lt;base href&gt;</code>。</p><p translation-origin=\"off\">If a link in the page is a root URL (has an <code>authority</code>), the <code>&lt;base href&gt;</code> is not used.\nIn this way, an <code><a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a></code> with an authority will cause all links created by Angular to ignore the <code>&lt;base href&gt;</code> value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>&lt;base href&gt;</code> 中的片段（#後面的部分）<em>永遠不會</em>被使用</p><p translation-origin=\"off\">A fragment in the <code>&lt;base href&gt;</code> is <em>never</em> persisted</p>\n\n</li>\n</ul>\n</li>\n</ol>\n<p translation-result=\"on\">有關如何使用 <code>&lt;base href&gt;</code> 建構目標 URI 的更完整資訊，請參閱 <a href=\"https://tools.ietf.org/html/rfc3986#section-5.2.2\">RFC</a>有關轉換參考的部分。</p><p translation-origin=\"off\">For more complete information on how <code>&lt;base href&gt;</code> is used to construct target URIs, see the <a href=\"https://tools.ietf.org/html/rfc3986#section-5.2.2\">RFC</a> section on transforming references.</p>\n\n<p><a id=\"hashlocationstrategy\"></a></p>\n<h3 id=\"hashlocationstrategy\"><code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/router#hashlocationstrategy\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">可以在根模組的 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 的第二個引數中傳入一個帶有 <code>useHash: true</code> 的物件，以回到基於 <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> 的傳統方式。</p><p translation-origin=\"off\">Use <code><a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a></code> by providing the <code>useHash: true</code> in an object as the second argument of the <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> in the <code>AppModule</code>.</p>\n\n<code-example header=\"src/app/app.module.ts (hash URL strategy)\" path=\"router/src/app/app.module.6.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router';\n\nimport { AppComponent } from './app.component';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    RouterModule.forRoot(routes, { useHash: true })  // .../#/crisis-center/\n  ],\n  declarations: [\n    AppComponent,\n    PageNotFoundComponent\n  ],\n  providers: [\n\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/router\n - api/router/ActivatedRoute\n - api/router/NavigationBehaviorOptions\n - api/router/NavigationExtras\n - api/router/Route\n - api/router/Router\n - api/router/RouterModule\n - api/router/RouterState\n - api/router/TitleStrategy\n - api/router/UrlCreationOptions\n - guide/ajs-quick-reference\n - guide/architecture\n - guide/architecture-next-steps\n - guide/built-in-directives\n - guide/deployment\n - guide/docs-style-guide\n - guide/example-apps-list\n - guide/glossary\n - guide/hierarchical-dependency-injection\n - guide/lazy-loading-ngmodules\n - guide/module-types\n - guide/npm-packages\n - guide/router-reference\n - guide/router-tutorial\n - guide/router-tutorial-toh\n - guide/routing-overview\n - guide/routing-with-urlmatcher\n - guide/universal\n - guide/upgrade\n - guide/what-is-angular\n - start/start-routing\n - tutorial/first-app/first-app-lesson-10\n - tutorial/first-app/first-app-lesson-11\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/APP_BASE_HREF\n - api/common/HashLocationStrategy\n - api/common/LocationStrategy\n - api/common/PathLocationStrategy\n - api/core/Component\n - api/core/Injectable\n - api/core/Input\n - api/core/NgModule\n - api/forms/FormsModule\n - api/platform-browser/BrowserModule\n - api/platform-browser/Title\n - api/router/ActivatedRoute\n - api/router/ActivatedRouteSnapshot\n - api/router/CanActivateChildFn\n - api/router/CanActivateFn\n - api/router/CanDeactivateFn\n - api/router/CanLoadFn\n - api/router/CanMatchFn\n - api/router/NavigationExtras\n - api/router/ParamMap\n - api/router/ResolveFn\n - api/router/Route\n - api/router/Route#componentless-routes\n - api/router/Router\n - api/router/RouterLink\n - api/router/RouterLinkActive\n - api/router/RouterModule\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/router/RouterStateSnapshot\n - api/router/Routes\n - api/router/TitleStrategy\n - api/router/provideRouter\n - api/router/withComponentInputBinding\n - guide/dependency-injection-providers\n - guide/lazy-loading-ngmodules\n - guide/router#404-page-how-to\n - guide/router#accessing-query-parameters-and-fragments\n - guide/router#adding-components-for-routing\n - guide/router#base-href\n - guide/router#browser-url-styles\n - guide/router#choosing-a-routing-strategy\n - guide/router#common-routing-tasks\n - guide/router#defining-a-basic-route\n - guide/router#displaying-a-404-page\n - guide/router#generate-an-application-with-routing-enabled\n - guide/router#getting-route-information\n - guide/router#hashlocationstrategy\n - guide/router#html5-urls-and-the-base-href\n - guide/router#html5-網址和-base-href\n - guide/router#importing-your-new-components\n - guide/router#lazy-loading\n - guide/router#link-parameters-array\n - guide/router#locationstrategy-and-browser-url-styles\n - guide/router#locationstrategy-和瀏覽器的網址樣式\n - guide/router#nesting-routes\n - guide/router#preventing-unauthorized-access\n - guide/router#route-order\n - guide/router#setting-the-page-title\n - guide/router#setting-up-redirects\n - guide/router#setting-up-wildcard-routes\n - guide/router#specifying-a-relative-route\n - guide/router#using-relative-paths\n - guide/router#wildcard-route-how-to\n - guide/router#為路由新增元件\n - guide/router#使用相對路徑\n - guide/router#定義一個基本路由\n - guide/router#匯入這些新元件\n - guide/router#巢狀(Nesting)路由\n - guide/router#常見路由任務\n - guide/router#延遲載入\n - guide/router#指定相對路由\n - guide/router#顯示-404-頁面\n - guide/router#產生一個支援路由的應用\n - guide/router#獲取路由資訊\n - guide/router#設定萬用字元路由\n - guide/router#設定重新導向\n - guide/router#設定頁面標題\n - guide/router#存取查詢引數和片段\n - guide/router#路由順序\n - guide/router#選擇路由策略\n - guide/router#連結引數陣列\n - guide/router#防止未經授權的存取\n - guide/router-tutorial-toh#a-crisis-center-with-child-routes\n - guide/router-tutorial-toh#milestone-5-route-guards\n - guide/router-tutorial-toh#pathmatch\n - https://developer.mozilla.org/docs/Web/API/History_API#Adding_and_modifying_history_entries\n - https://developer.mozilla.org/docs/Web/API/History_API/Working_with_the_History_API#adding_and_modifying_history_entries\n - https://developer.mozilla.org/docs/Web/HTML/Element/base\n - https://developer.mozilla.org/en-US/docs/Web/API/Working_with_the_History_API#adding_and_modifying_history_entries\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/router.md?message=docs%3A%20請簡述你的修改...\n - https://tools.ietf.org/html/rfc3986#section-5.2.2\n-->"}