{"id":"guide/observables-in-angular","title":"Observables in Angular","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/observables-in-angular.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"observables-in-angular\" translation-result=\"on\">Angular 中的可觀察物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#observables-in-angular\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Observables in Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#observables-in-angular\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">Angular 使用可觀察物件作為處理各種常用非同步操作的介面。比如：</p><p translation-origin=\"off\">Angular makes use of observables as an interface to handle a variety of common asynchronous operations.\nFor example:</p>\n\n<!--todo: Have Alex review this -->\n<!-- *   You can define [custom events](guide/event-binding#custom-events-with-eventemitter) that send observable output data from a child to a parent component -->\n<ul>\n<li>\n<p translation-result=\"on\">HTTP 模組使用可觀察物件來處理 AJAX 請求和響應。</p><p translation-origin=\"off\">The HTTP module uses observables to handle AJAX requests and responses</p>\n\n</li>\n<li>\n<p translation-result=\"on\">路由器和表單模組使用可觀察物件來監聽對使用者輸入事件的響應。</p><p translation-origin=\"off\">The Router and Forms modules use observables to listen for and respond to user-input events</p>\n\n</li>\n</ul>\n<h2 id=\"transmitting-data-between-components\" translation-result=\"on\">在元件之間傳遞資料<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#transmitting-data-between-components\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Transmitting data between components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#transmitting-data-between-components\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 提供了一個 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 類，它用來透過元件的 <a href=\"guide/inputs-outputs#output\"><code>@Output()</code> 裝飾器</a> 傳送一些值。<code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 擴充了 <a href=\"https://rxjs.dev/api/index/class/Subject\">RxJS <code>Subject</code></a>，並添加了一個 <code>emit()</code> 方法，這樣它就可以傳送任意值了。當你呼叫 <code>emit()</code> 時，就會把所傳送的值傳給訂閱上來的觀察者的 <code>next()</code> 方法。</p><p translation-origin=\"off\">Angular provides an <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> class that is used when publishing values from a component through the <a href=\"guide/inputs-outputs#output\"><code>@Output()</code> decorator</a>.\n<code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> extends <a href=\"https://rxjs.dev/api/index/class/Subject\">RxJS <code>Subject</code></a>, adding an <code>emit()</code> method so it can send arbitrary values.\nWhen you call <code>emit()</code>, it passes the emitted value to the <code>next()</code> method of any subscribed observer.</p>\n\n<p translation-result=\"on\">這種用法的例子參閱 <a href=\"api/core/EventEmitter\">EventEmitter</a> 文件。下面這個範例元件監聽了 <code>open</code> 和 <code>close</code> 事件：</p><p translation-origin=\"off\">A good example of usage can be found in the <a href=\"api/core/EventEmitter\">EventEmitter</a> documentation.\nHere is the example component that listens for open and close events:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n&lt;app-zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"&gt;&lt;/app-zippy&gt;\n\n</code-example>\n<p translation-result=\"on\">元件的定義如下：</p><p translation-origin=\"off\">Here is the component definition:</p>\n\n<code-example header=\"EventEmitter\" path=\"observables-in-angular/src/main.ts\" region=\"eventemitter\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-zippy',\n  template: `\n    &lt;div class=\"zippy\"&gt;\n      &lt;button type=\"button\" (click)=\"toggle()\"&gt;Toggle&lt;/button&gt;\n      &lt;div [hidden]=\"!visible\"&gt;\n        &lt;ng-content&gt;&lt;/ng-content&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  `,\n})\nexport class ZippyComponent {\n  visible = true;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() open = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;any&gt;();\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() close = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;any&gt;();\n\n  toggle() {\n    this.visible = !this.visible;\n    if (this.visible) {\n      this.open.emit(null);\n    } else {\n      this.close.emit(null);\n    }\n  }\n}\n\n\n</code-example>\n<h2 id=\"http\">HTTP<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#http\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\">Angular 的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 從 HTTP 方法呼叫中返回了可觀察物件。比如，<code>http.get('/api')</code> 就會返回可觀察物件。相對於基於承諾（Promise）的 HTTP API，它有一系列優點：</p><p translation-origin=\"off\">Angular's <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> returns observables from HTTP method calls.\nFor instance, <code>http.get('/api')</code> returns an observable.\nThis provides several advantages over promise-based HTTP APIs:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">可觀察物件不會修改伺服器的響應（和在 Promise 上串聯起來的 <code>.then()</code> 呼叫一樣）。反之，你可以使用一系列運運算元來按需轉換這些值。</p><p translation-origin=\"off\">Observables do not mutate the server response (as can occur through chained <code>.then()</code> calls on promises).\nInstead, you can use a series of operators to transform values as needed.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">HTTP 請求是可以透過 <code>unsubscribe()</code> 方法來取消的</p><p translation-origin=\"off\">HTTP requests are cancellable through the <code>unsubscribe()</code> method</p>\n\n</li>\n<li>\n<p translation-result=\"on\">請求可以進行配置，以獲取進度事件的變化</p><p translation-origin=\"off\">Requests can be configured to get progress event updates</p>\n\n</li>\n<li>\n<p translation-result=\"on\">失敗的請求很容易重試</p><p translation-origin=\"off\">Failed requests can be retried easily</p>\n\n</li>\n</ul>\n<h2 id=\"async-pipe\" translation-result=\"on\">Async 管道<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#async-pipe\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Async pipe<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#async-pipe\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><a href=\"api/common/AsyncPipe\">AsyncPipe</a> 會訂閱一個可觀察物件或 Promise，並返回其發出的最後一個值。當發出新值時，該管道就會把這個元件標記為需要進行變更檢查的（譯註：因此可能導致重新整理介面）。</p><p translation-origin=\"off\">The <a href=\"api/common/AsyncPipe\">AsyncPipe</a> subscribes to an observable or promise and returns the latest value it has emitted.\nWhen a new value is emitted, the pipe marks the component to be checked for changes.</p>\n\n<p translation-result=\"on\">下面的例子把 <code>time</code> 這個可觀察物件繫結到了元件的檢視中。這個可觀察物件會不斷使用當前時間更新元件的檢視。</p><p translation-origin=\"off\">The following example binds the <code>time</code> observable to the component's view.\nThe observable continuously updates the view with the current time.</p>\n\n<code-example header=\"Using async pipe\" path=\"observables-in-angular/src/main.ts\" region=\"pipe\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'async-observable-pipe',\n  template: `&lt;div&gt;&lt;code&gt;observable|<a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a>&lt;/code&gt;:\n       <a href=\"api/common/Time\" class=\"code-anchor\">Time</a>: {{ time | <a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a> }}&lt;/div&gt;`\n})\nexport class AsyncObservablePipeComponent {\n  time = new Observable&lt;string&gt;(observer =&gt; {\n    setInterval(() =&gt; observer.next(new Date().toString()), 1000);\n  });\n}\n\n\n</code-example>\n<h2 id=\"router\" translation-result=\"on\">路由器（router）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#router\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Router<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#router\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><a href=\"api/router/Router#events\"><code>Router.events</code></a> 以可觀察物件的形式提供了其事件。你可以使用 RxJS 中的 <code>filter()</code> 運運算元來找到感興趣的事件，並且訂閱它們，以便根據瀏覽過程中產生的事件序列作出決定。例子如下：</p><p translation-origin=\"off\"><a href=\"api/router/Router#events\"><code>Router.events</code></a> provides events as observables.\nYou can use the <code>filter()</code> operator from RxJS to look for events of interest, and subscribe to them in order to make decisions based on the sequence of events in the navigation process.\nHere's an example:</p>\n\n<code-example header=\"Router events\" path=\"observables-in-angular/src/main.ts\" region=\"router\">\n\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, <a href=\"api/router/NavigationStart\" class=\"code-anchor\">NavigationStart</a> } from '@angular/router';\nimport { filter } from 'rxjs/operators';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-routable',\n  template: 'Routable1Component template'\n})\nexport class Routable1Component implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n\n  navStart: Observable&lt;<a href=\"api/router/NavigationStart\" class=\"code-anchor\">NavigationStart</a>&gt;;\n\n  constructor(router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n    // Create a new Observable that publishes only the <a href=\"api/router/NavigationStart\" class=\"code-anchor\">NavigationStart</a> event\n    this.navStart = router.events.pipe(\n      filter(evt =&gt; evt instanceof <a href=\"api/router/NavigationStart\" class=\"code-anchor\">NavigationStart</a>)\n    ) as Observable&lt;<a href=\"api/router/NavigationStart\" class=\"code-anchor\">NavigationStart</a>&gt;;\n  }\n\n  ngOnInit() {\n    this.navStart.subscribe(() =&gt; console.log('<a href=\"api/router/Navigation\" class=\"code-anchor\">Navigation</a> Started!'));\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\"><a href=\"api/router/ActivatedRoute\">ActivatedRoute</a> 是一個可注入的路由器服務，它使用可觀察物件來獲取關於路由路徑和路由引數的資訊。比如，<code><a href=\"api/router/ActivatedRoute#url\" class=\"code-anchor\">ActivatedRoute.url</a></code> 包含一個用於彙報路由路徑的可觀察物件。例子如下：</p><p translation-origin=\"off\">The <a href=\"api/router/ActivatedRoute\">ActivatedRoute</a> is an injected router service that makes use of observables to get information about a route path and parameters.\nFor example, <code><a href=\"api/router/ActivatedRoute#url\" class=\"code-anchor\">ActivatedRoute.url</a></code> contains an observable that reports the route path or paths.\nHere's an example:</p>\n\n<code-example header=\"ActivatedRoute\" path=\"observables-in-angular/src/main.ts\" region=\"activated_route\">\n\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-routable',\n  template: 'Routable2Component template'\n})\nexport class Routable2Component implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private activatedRoute: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>) {}\n\n  ngOnInit() {\n    this.activatedRoute.url\n      .subscribe(url =&gt; console.log('The URL changed to: ' + url));\n  }\n}\n\n\n</code-example>\n<h2 id=\"reactive-forms\" translation-result=\"on\">響應式表單（reactive forms）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#reactive-forms\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Reactive forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables-in-angular#reactive-forms\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">響應式表單具有一些屬性，它們使用可觀察物件來監聽表單控制項的值。<a href=\"api/forms/FormControl\"><code>FormControl</code></a> 的 <code>valueChanges</code> 屬性和 <code>statusChanges</code> 屬性包含了會發出變更事件的可觀察物件。訂閱可觀察的表單控制項屬性是在元件類中觸發應用邏輯的途徑之一。比如：</p><p translation-origin=\"off\">Reactive forms have properties that use observables to monitor form control values.\nThe <a href=\"api/forms/FormControl\"><code>FormControl</code></a> properties <code>valueChanges</code> and <code>statusChanges</code> contain observables that raise change events.\nSubscribing to an observable form-control property is a way of triggering application logic within the component class.\nFor example:</p>\n\n<code-example header=\"Reactive forms\" path=\"observables-in-angular/src/main.ts\" region=\"forms\">\n\nimport { <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a> } from '@angular/forms';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: 'MyComponent Template'\n})\nexport class MyComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  nameChangeLog: string[] = [];\n  heroForm!: <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>;\n\n  ngOnInit() {\n    this.logNameChange();\n  }\n  logNameChange() {\n    const nameControl = this.heroForm.get('name');\n    nameControl?.valueChanges.forEach(\n      (value: string) =&gt; this.nameChangeLog.push(value)\n    );\n  }\n}\n\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/EventEmitter\n - guide/router-reference\n-->\n<!-- links from this doc:\n - api/common/AsyncPipe\n - api/common/Time\n - api/common/http/HttpClient\n - api/core/Component\n - api/core/EventEmitter\n - api/core/OnInit\n - api/core/Output\n - api/forms/FormControl\n - api/forms/FormGroup\n - api/router/ActivatedRoute\n - api/router/ActivatedRoute#url\n - api/router/Navigation\n - api/router/NavigationStart\n - api/router/Router\n - api/router/Router#events\n - guide/inputs-outputs#output\n - guide/observables-in-angular#angular-中的可觀察物件\n - guide/observables-in-angular#async-pipe\n - guide/observables-in-angular#async-管道\n - guide/observables-in-angular#http\n - guide/observables-in-angular#observables-in-angular\n - guide/observables-in-angular#reactive-forms\n - guide/observables-in-angular#router\n - guide/observables-in-angular#transmitting-data-between-components\n - guide/observables-in-angular#響應式表單reactive-forms\n - guide/observables-in-angular#在元件之間傳遞資料\n - guide/observables-in-angular#路由器router\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/observables-in-angular.md?message=docs%3A%20請簡述你的修改...\n - https://rxjs.dev/api/index/class/Subject\n-->"}