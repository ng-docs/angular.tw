{"id":"guide/testing-components-scenarios","title":"Component testing scenarios","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/testing-components-scenarios.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"component-testing-scenarios\" translation-result=\"on\">元件測試場景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-testing-scenarios\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Component testing scenarios<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-testing-scenarios\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本指南探討了一些常見的元件測試使用案例。</p><p translation-origin=\"off\">This guide explores common component testing use cases.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果你要試驗本指南中所講的應用，請<live-example name=\"testing\" nodownload=\"\">在瀏覽器中執行它</live-example>或<live-example name=\"testing\" downloadonly=\"\">下載並在本地執行它</live-example>。</p><p translation-origin=\"off\">If you'd like to experiment with the application that this guide describes, <live-example name=\"testing\" nodownload=\"\">run it in your browser</live-example> or <live-example name=\"testing\" downloadonly=\"\">download and run it locally</live-example>.</p>\n\n</div>\n<h2 id=\"component-binding\" translation-result=\"on\">元件繫結<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-binding\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Component binding<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-binding\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在範例應用中，<code>BannerComponent</code> 在 HTML 範本中展示了靜態的標題文字。</p><p translation-origin=\"off\">In the example application, the <code>BannerComponent</code> presents static title text in the HTML template.</p>\n\n<p translation-result=\"on\">在少許更改之後，<code>BannerComponent</code> 就會透過繫結元件的 <code>title</code> 屬性來渲染動態標題。</p><p translation-origin=\"off\">After a few changes, the <code>BannerComponent</code> presents a dynamic title by binding to the component's <code>title</code> property like this.</p>\n\n<code-example header=\"app/banner/banner.component.ts\" path=\"testing/src/app/banner/banner.component.ts\" region=\"component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-banner',\n  template: '&lt;h1&gt;{{title}}&lt;/h1&gt;',\n  styles: ['h1 { color: green; font-size: 350%}']\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n</code-example>\n<p translation-result=\"on\">儘管這很小，但你還是決定要新增一個測試來確認該元件實際顯示的是你認為合適的內容。</p><p translation-origin=\"off\">As minimal as this is, you decide to add a test to confirm that component actually displays the right content where you think it should.</p>\n\n<h4 id=\"query-for-the-h1\" translation-result=\"on\">查詢 <code>&lt;h1&gt;</code> 元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#query-for-the-h1\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Query for the <code>&lt;h1&gt;</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#query-for-the-h1\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">你將編寫一系列測試來檢查 <code>&lt;h1&gt;</code> 元素中包裹的 <em>title</em> 屬性插值繫結。</p><p translation-origin=\"off\">You'll write a sequence of tests that inspect the value of the <code>&lt;h1&gt;</code> element that wraps the <em>title</em> property interpolation binding.</p>\n\n<p translation-result=\"on\">你可以修改 <code>beforeEach</code> 以找到帶有標準 HTML <code>querySelector</code> 的元素，並把它賦值給 <code>h1</code> 變數。</p><p translation-origin=\"off\">You update the <code>beforeEach</code> to find that element with a standard HTML <code>querySelector</code> and assign it to the <code>h1</code> variable.</p>\n\n<code-example header=\"app/banner/banner.component.spec.ts (setup)\" path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"setup\">\nlet component: BannerComponent;\nlet fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;BannerComponent&gt;;\nlet h1: HTMLElement;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent test instance\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<p><a id=\"detect-changes\"></a></p>\n<h4 id=\"createcomponent-does-not-bind-data\" translation-result=\"on\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> 不繫結資料<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#createcomponent-不繫結資料\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> does not bind data<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#createcomponent-does-not-bind-data\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">對於你的第一個測試，你希望螢幕上顯示預設的 <code>title</code>。你的直覺就是編寫一個能立即檢查 <code>&lt;h1&gt;</code> 的測試，就像這樣：</p><p translation-origin=\"off\">For your first test you'd like to see that the screen displays the default <code>title</code>.\nYour instinct is to write a test that immediately inspects the <code>&lt;h1&gt;</code> like this:</p>\n\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default-v1\">\nit('should display original title', () =&gt; {\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n<p translation-result=\"on\"><em>那個測試失敗</em>了：</p><p translation-origin=\"off\"><em>That test fails</em> with the message:</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nexpected '' to contain 'Test Tour of Heroes'.\n\n</code-example>\n<p translation-result=\"on\"><strong>當 Angular 執行變更檢測</strong>時就會發生繫結。</p><p translation-origin=\"off\">Binding happens when Angular performs <strong>change detection</strong>.</p>\n\n<p translation-result=\"on\">在生產環境中，當 Angular 建立一個元件，或者使用者輸入按鍵，或者非同步活動（比如 AJAX）完成時，就會自動進行變更檢測。</p><p translation-origin=\"off\">In production, change detection kicks in automatically when Angular creates a component or the user enters a keystroke or an asynchronous activity (for example, AJAX) completes.</p>\n\n<p translation-result=\"on\">該 <code>TestBed.createComponent</code> <em>不會</em>觸發變化檢測，修改後的測試可以證實這一點：</p><p translation-origin=\"off\">The <code>TestBed.createComponent</code> does <em>not</em> trigger change detection; a fact confirmed in the revised test:</p>\n\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"test-w-o-detect-changes\">\nit('no title in the DOM after <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()', () =&gt; {\n  expect(h1.textContent).toEqual('');\n});\n\n</code-example>\n<h4 id=\"detectchanges\"><code>detectChanges()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#detectchanges\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\">你必須透過呼叫 <code>fixture.detectChanges()</code> 來告訴 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 執行資料繫結。只有這樣，<code>&lt;h1&gt;</code> 才能擁有預期的標題。</p><p translation-origin=\"off\">You must tell the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> to perform data binding by calling <code>fixture.detectChanges()</code>.\nOnly then does the <code>&lt;h1&gt;</code> have the expected title.</p>\n\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default\">\nit('should display original title after detectChanges()', () =&gt; {\n  fixture.detectChanges();\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n<p translation-result=\"on\">這裡延遲變更檢測時機是故意而且有用的。這樣才能讓測試者在 Angular 啟動資料繫結並呼叫<a href=\"guide/lifecycle-hooks\">生命週期鉤子</a>之前，檢視並更改元件的狀態。</p><p translation-origin=\"off\">Delayed change detection is intentional and useful.\nIt gives the tester an opportunity to inspect and change the state of the component <em>before Angular initiates data binding and calls <a href=\"guide/lifecycle-hooks\">lifecycle hooks</a></em>.</p>\n\n<p translation-result=\"on\">這是另一個測試，它會在呼叫 <code>fixture.detectChanges()</code> <em>之前</em>改變元件的 <code>title</code> 屬性。</p><p translation-origin=\"off\">Here's another test that changes the component's <code>title</code> property <em>before</em> calling <code>fixture.detectChanges()</code>.</p>\n\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"after-change\">\nit('should display a different test title', () =&gt; {\n  component.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  fixture.detectChanges();\n  expect(h1.textContent).toContain('Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>');\n});\n\n</code-example>\n<p><a id=\"auto-detect-changes\"></a></p>\n<h4 id=\"automatic-change-detection\" translation-result=\"on\">自動變更檢測<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#automatic-change-detection\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Automatic change detection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#automatic-change-detection\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code>BannerComponent</code> 測試會經常呼叫 <code>detectChanges</code>。一些測試人員更喜歡讓 Angular 測試環境自動執行變更檢測。</p><p translation-origin=\"off\">The <code>BannerComponent</code> tests frequently call <code>detectChanges</code>.\nSome testers prefer that the Angular test environment run change detection automatically.</p>\n\n<p translation-result=\"on\">可以透過配置帶有 <code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> 提供者的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 來實現這一點。我們首先從測試工具函式庫中匯入它：</p><p translation-origin=\"off\">That's possible by configuring the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> with the <code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> provider.\nFirst import it from the testing utility library:</p>\n\n<code-example header=\"app/banner/banner.component.detect-changes.spec.ts (import)\" path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"import-ComponentFixtureAutoDetect\">\nimport { <a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a> } from '@angular/core/testing';\n\n</code-example>\n<p translation-result=\"on\">然後把它新增到測試模組配置的 <code>providers</code> 中：</p><p translation-origin=\"off\">Then add it to the <code>providers</code> array of the testing module configuration:</p>\n\n<code-example header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect)\" path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect\">\nTestBed.configureTestingModule({\n  declarations: [ BannerComponent ],\n  providers: [\n    { provide: <a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a>, useValue: true }\n  ]\n});\n\n</code-example>\n<p translation-result=\"on\">這裡有三個測試來說明自動變更檢測是如何工作的。</p><p translation-origin=\"off\">Here are three tests that illustrate how automatic change detection works.</p>\n\n<code-example header=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect Tests)\" path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect-tests\">\nit('should display original title', () =&gt; {\n  // Hooray! No `fixture.detectChanges()` needed\n  expect(h1.textContent).toContain(comp.title);\n});\n\nit('should still see original title after comp.title change', () =&gt; {\n  const oldTitle = comp.title;\n  comp.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  // Displayed title is old because Angular didn't hear the change :(\n  expect(h1.textContent).toContain(oldTitle);\n});\n\nit('should display updated title after detectChanges', () =&gt; {\n  comp.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  fixture.detectChanges(); // detect changes explicitly\n  expect(h1.textContent).toContain(comp.title);\n});\n\n</code-example>\n<p translation-result=\"on\">第一個測試顯示了自動變更檢測的優點。</p><p translation-origin=\"off\">The first test shows the benefit of automatic change detection.</p>\n\n<p translation-result=\"on\">第二個和第三個測試則揭示了一個重要的限制。該 Angular 測試環境<em>不</em>知道測試改變了元件的 <code>title</code>。<code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> 服務會響應<em>非同步活動，</em>比如 Promise、定時器和 DOM 事件。但卻看不見對元件屬性的直接同步更新。該測試必須用 <code>fixture.detectChanges()</code> 來觸發另一個變更檢測週期。</p><p translation-origin=\"off\">The second and third test reveal an important limitation.\nThe Angular testing environment does <em>not</em> know that the test changed the component's <code>title</code>.\nThe <code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> service responds to <em>asynchronous activities</em> such as promise resolution, timers, and DOM events.\nBut a direct, synchronous update of the component property is invisible.\nThe test must call <code>fixture.detectChanges()</code> manually to trigger another cycle of change detection.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">本指南中的範例總是會<em>顯式</em>呼叫 <code>detectChanges()</code>，而不用困惑於測試夾具何時會或不會執行變更檢測。更頻繁的呼叫 <code>detectChanges()</code> 毫無危害，沒必要只在非常必要時才呼叫它。</p><p translation-origin=\"off\">Rather than wonder when the test fixture will or won't perform change detection, the samples in this guide <em>always call</em> <code>detectChanges()</code> <em>explicitly</em>.\nThere is no harm in calling <code>detectChanges()</code> more often than is strictly necessary.</p>\n\n</div>\n<p><a id=\"dispatch-event\"></a></p>\n<h4 id=\"change-an-input-value-with-dispatchevent\" translation-result=\"on\">使用  <code>dispatchEvent()</code> 改變輸入框的值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#change-an-input-value-with-dispatchevent\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Change an input value with <code>dispatchEvent()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#change-an-input-value-with-dispatchevent\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">要模擬使用者輸入，你可以找到 input 元素並設定它的 <code>value</code> 屬性。</p><p translation-origin=\"off\">To simulate user input, find the input element and set its <code>value</code> property.</p>\n\n<p translation-result=\"on\">你會呼叫 <code>fixture.detectChanges()</code> 來觸發 Angular 的變更檢測。但還有一個重要的中間步驟。</p><p translation-origin=\"off\">You will call <code>fixture.detectChanges()</code> to trigger Angular's change detection.\nBut there is an essential, intermediate step.</p>\n\n<p translation-result=\"on\">Angular 並不知道你為 input 設定過 <code>value</code> 屬性。在透過呼叫 <code>dispatchEvent()</code> 分發 <code>input</code> 事件之前，它不會讀取該屬性。<em>緊接著</em>你就呼叫了 <code>detectChanges()</code>。</p><p translation-origin=\"off\">Angular doesn't know that you set the input element's <code>value</code> property.\nIt won't read that property until you raise the element's <code>input</code> event by calling <code>dispatchEvent()</code>.\n<em>Then</em> you call <code>detectChanges()</code>.</p>\n\n<p translation-result=\"on\">下列例子說明了正確的順序。</p><p translation-origin=\"off\">The following example demonstrates the proper sequence.</p>\n\n<code-example header=\"app/hero/hero-detail.component.spec.ts (pipe test)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"title-case-pipe\">\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () =&gt; {\n  // get the name's input and display elements from the DOM\n  const hostElement: HTMLElement = harness.routeNativeElement!;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input')!;\n  const nameDisplay: HTMLElement = hostElement.querySelector('span')!;\n\n  // simulate user entering a new name into the input box\n  nameInput.value = 'quick BROWN  fOx';\n\n  // Dispatch a DOM event so that Angular learns of input value change.\n  nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input'));\n\n  // Tell Angular to update the display binding through the title pipe\n  harness.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n\n</code-example>\n<h2 id=\"component-with-external-files\" translation-result=\"on\">包含外部檔案的元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-external-files\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Component with external files<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-external-files\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">上面的 <code>BannerComponent</code> 是用<em>內聯範本</em>和<em>內聯 css</em> 定義的，它們分別是在 <code>@<a href=\"api/core/Component#template\" class=\"code-anchor\">Component.template</a></code> 和 <code>@<a href=\"api/core/Component#styles\" class=\"code-anchor\">Component.styles</a></code> 屬性中指定的。</p><p translation-origin=\"off\">The preceding <code>BannerComponent</code> is defined with an <em>inline template</em> and <em>inline css</em>, specified in the <code>@<a href=\"api/core/Component#template\" class=\"code-anchor\">Component.template</a></code> and <code>@<a href=\"api/core/Component#styles\" class=\"code-anchor\">Component.styles</a></code> properties respectively.</p>\n\n<p translation-result=\"on\">很多元件都會分別用 <code>@<a href=\"api/core/Component#templateUrl\" class=\"code-anchor\">Component.templateUrl</a></code> 和 <code>@<a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">Component.styleUrls</a></code> 屬性來指定<em>外部範本</em>和<em>外部 css</em>，就像下面的 <code>BannerComponent</code> 變體一樣。</p><p translation-origin=\"off\">Many components specify <em>external templates</em> and <em>external css</em> with the <code>@<a href=\"api/core/Component#templateUrl\" class=\"code-anchor\">Component.templateUrl</a></code> and <code>@<a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">Component.styleUrls</a></code> properties respectively, as the following variant of <code>BannerComponent</code> does.</p>\n\n<code-example header=\"app/banner/banner-external.component.ts (metadata)\" path=\"testing/src/app/banner/banner-external.component.ts\" region=\"metadata\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  styleUrls:  ['./banner-external.component.css']\n})\n\n</code-example>\n<p translation-result=\"on\">這個語法告訴 Angular 編譯器要在元件編譯時讀取外部檔案。</p><p translation-origin=\"off\">This syntax tells the Angular compiler to read the external files during component compilation.</p>\n\n<p translation-result=\"on\">當執行 <code>ng test</code> 命令時，這不是問題，因為它會<em>在執行測試之前編譯應用</em>。</p><p translation-origin=\"off\">That's not a problem when you run the CLI <code>ng test</code> command because it <em>compiles the application before running the tests</em>.</p>\n\n<p translation-result=\"on\">但是，如果在<strong>非 CLI 環境中</strong>執行這些測試，那麼這個元件的測試可能會失敗。比如，如果你在一個 web 程式設計環境（比如 <a href=\"https://plnkr.co\">plunker</a> 中執行 <code>BannerComponent</code> 測試，你會看到如下訊息：</p><p translation-origin=\"off\">However, if you run the tests in a <strong>non-CLI environment</strong>, tests of this component might fail.\nFor example, if you run the <code>BannerComponent</code> tests in a web coding environment such as <a href=\"https://plnkr.co\">plunker</a>, you'll see a message like this one:</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nError: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n\n</code-example>\n<p translation-result=\"on\">當執行環境在測試過程中需要編譯原始碼時，就會得到這條測試失敗的訊息。</p><p translation-origin=\"off\">You get this test failure message when the runtime environment compiles the source code <em>during the tests themselves</em>.</p>\n\n<p translation-result=\"on\">要解決這個問題，可以像 <a href=\"guide/testing-components-scenarios#compile-components\">呼叫 <code>compileComponents</code></a> 中講的那樣呼叫 <code>compileComponents()</code>。</p><p translation-origin=\"off\">To correct the problem, call <code>compileComponents()</code> as explained in the following <a href=\"guide/testing-components-scenarios#compile-components\">Calling compileComponents</a> section.</p>\n\n<p><a id=\"component-with-dependency\"></a></p>\n<h2 id=\"component-with-a-dependency\" translation-result=\"on\">具有依賴的元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-a-dependency\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Component with a dependency<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-a-dependency\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">元件通常都有服務依賴。</p><p translation-origin=\"off\">Components often have service dependencies.</p>\n\n<p translation-result=\"on\"><code>WelcomeComponent</code> 會向登入使用者顯示一條歡迎資訊。它可以基於注入進來的 <code>UserService</code> 的一個屬性瞭解到使用者是誰：</p><p translation-origin=\"off\">The <code>WelcomeComponent</code> displays a welcome message to the logged-in user.\nIt knows who the user is based on a property of the injected <code>UserService</code>:</p>\n\n<code-example header=\"app/welcome/welcome.component.ts\" path=\"testing/src/app/welcome/welcome.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { UserService } from '../model/user.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-welcome',\n  template: '&lt;h3 class=\"welcome\"&gt;&lt;i&gt;{{welcome}}&lt;/i&gt;&lt;/h3&gt;'\n})\nexport class WelcomeComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  welcome = '';\n  constructor(private userService: UserService) { }\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn ?\n      'Welcome, ' + this.userService.user.name : 'Please log in.';\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\"><code>WelcomeComponent</code> 擁有與該服務互動的決策邏輯，該邏輯讓這個元件值得測試。這是 spec 檔案的測試模組配置：</p><p translation-origin=\"off\">The <code>WelcomeComponent</code> has decision logic that interacts with the service, logic that makes this component worth testing.\nHere's the testing module configuration for the spec file:</p>\n\n<code-example header=\"app/welcome/welcome.component.spec.ts\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"config-test-module\">\nTestBed.configureTestingModule({\n   declarations: [ WelcomeComponent ],\n// providers: [ UserService ],  // NO! Don't provide the real service!\n                                // Provide a test-double instead\n   providers: [ { provide: UserService, useValue: userServiceStub } ],\n});\n\n</code-example>\n<p translation-result=\"on\">這次，除了宣告<em>被測元件外</em>，該配置還在 <code>providers</code> 列表中加入了 <code>UserService</code> 提供者。但它不是真正的 <code>UserService</code>。</p><p translation-origin=\"off\">This time, in addition to declaring the <em>component-under-test</em>,\nthe configuration adds a <code>UserService</code> provider to the <code>providers</code> list.\nBut not the real <code>UserService</code>.</p>\n\n<p><a id=\"service-test-doubles\"></a></p>\n<h4 id=\"provide-service-test-doubles\" translation-result=\"on\">為服務提供測試替身<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#provide-service-test-doubles\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Provide service test doubles<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#provide-service-test-doubles\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><em>待測元件</em>不必注入真正的服務。事實上，如果它們是測試替身，比如 stubs，fakes，spies 或 mocks，通常會更好。該測試規約的目的是測試元件，而不是服務，使用真正的服務可能會遇到麻煩。</p><p translation-origin=\"off\">A <em>component-under-test</em> doesn't have to be injected with real services.\nIn fact, it is usually better if they are test doubles such as, stubs, fakes, spies, or mocks.\nThe purpose of the spec is to test the component, not the service, and real services can be trouble.</p>\n\n<p translation-result=\"on\">注入真正的 <code>UserService</code> 可能是個噩夢。真正的服務可能要求使用者提供登入憑據，並嘗試存取認證伺服器。這些行為可能難以攔截。為它建立並註冊一個測試專用版來代替真正的 <code>UserService</code> 要容易得多，也更安全。</p><p translation-origin=\"off\">Injecting the real <code>UserService</code> could be a nightmare.\nThe real service might ask the user for login credentials and attempt to reach an authentication server.\nThese behaviors can be hard to intercept.\nIt is far easier and safer to create and register a test double in place of the real <code>UserService</code>.</p>\n\n<p translation-result=\"on\">這個特定的測試套件提供了 <code>UserService</code> 的最小化模擬，它滿足了 <code>WelcomeComponent</code> 及其測試的需求：</p><p translation-origin=\"off\">This particular test suite supplies a minimal mock of the <code>UserService</code> that satisfies the needs of the <code>WelcomeComponent</code> and its tests:</p>\n\n<code-example header=\"app/welcome/welcome.component.spec.ts\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"user-service-stub\">\nlet userServiceStub: Partial&lt;UserService&gt;;\n\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test User' },\n  };\n\n</code-example>\n<p><a id=\"get-injected-service\"></a></p>\n<h4 id=\"get-injected-services\" translation-result=\"on\">取得所注入的服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#get-injected-services\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Get injected services<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#get-injected-services\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">這些測試需要存取注入到 <code>WelcomeComponent</code> 中的 <code>UserService</code> 樁。</p><p translation-origin=\"off\">The tests need access to the stub <code>UserService</code> injected into the <code>WelcomeComponent</code>.</p>\n\n<p translation-result=\"on\">Angular 有一個多級注入系統。它具有多個層級的注入器，從 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 建立的根注入器開始，直到元件樹中的各個層級。</p><p translation-origin=\"off\">Angular has a hierarchical injection system.\nThere can be injectors at multiple levels, from the root injector created by the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> down through the component tree.</p>\n\n<p translation-result=\"on\">獲得注入服務的最安全的方式（<strong>始終有效</strong>），就是<strong><em>從被測元件</em>的注入器中獲取它</strong>。元件注入器是測試夾具所提供的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 中的一個屬性。</p><p translation-origin=\"off\">The safest way to get the injected service, the way that <strong><em>always works</em></strong>,\nis to <strong>get it from the injector of the <em>component-under-test</em></strong>.\nThe component injector is a property of the fixture's <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>.</p>\n\n<code-example header=\"WelcomeComponent's injector\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"injected-service\">\n// UserService actually injected into the component\nuserService = fixture.debugElement.injector.get(UserService);\n\n</code-example>\n<p><a id=\"testbed-inject\"></a></p>\n<h4 id=\"testbedinject\"><code>TestBed.inject()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#testbedinject\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\">你<em>可能</em>還可以透過 <code>TestBed.inject()</code> 來從根注入器獲得服務。這更容易記憶，也不那麼囉嗦。但這隻有當 Angular 要把根注入器中的服務例項注入測試元件時才是可行的。</p><p translation-origin=\"off\">You <em>might</em> also be able to get the service from the root injector using <code>TestBed.inject()</code>.\nThis is easier to remember and less verbose.\nBut it only works when Angular injects the component with the service instance in the test's root injector.</p>\n\n<p translation-result=\"on\">在下面這個測試套件中，<code>UserService</code><em>唯一的</em>提供者是根測試模組，因此可以安全地呼叫 <code>TestBed.inject()</code>，如下所示：</p><p translation-origin=\"off\">In this test suite, the <em>only</em> provider of <code>UserService</code> is the root testing module, so it is safe to call <code>TestBed.inject()</code> as follows:</p>\n\n<code-example header=\"TestBed injector\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"inject-from-testbed\">\n// UserService from the root injector\nuserService = TestBed.inject(UserService);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><code>TestBed.inject()</code> 不起作用的使用案例，參閱<a href=\"guide/testing-components-scenarios#component-override\"><em>“覆蓋元件提供者”</em></a>部分，它解釋了何時以及為什麼必須從該元件自身的注入器中獲取該服務。</p><p translation-origin=\"off\">For a use case in which <code>TestBed.inject()</code> does not work, see the <a href=\"guide/testing-components-scenarios#component-override\"><em>Override component providers</em></a> section that explains when and why you must get the service from the component's injector instead.</p>\n\n</div>\n<p><a id=\"welcome-spec-setup\"></a></p>\n<h4 id=\"final-setup-and-tests\" translation-result=\"on\">最後的設定與測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#final-setup-and-tests\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Final setup and tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#final-setup-and-tests\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">這裡是完成的 <code>beforeEach()</code>，它使用了 <code>TestBed.inject()</code>：</p><p translation-origin=\"off\">Here's the complete <code>beforeEach()</code>, using <code>TestBed.inject()</code>:</p>\n\n<code-example header=\"app/welcome/welcome.component.spec.ts\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"setup\">\nlet userServiceStub: Partial&lt;UserService&gt;;\n\nbeforeEach(() =&gt; {\n  // stub UserService for test purposes\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test User' },\n  };\n\n  TestBed.configureTestingModule({\n     declarations: [ WelcomeComponent ],\n     providers: [ { provide: UserService, useValue: userServiceStub } ],\n  });\n\n  fixture = TestBed.createComponent(WelcomeComponent);\n  comp    = fixture.componentInstance;\n\n  // UserService from the root injector\n  userService = TestBed.inject(UserService);\n\n  //  get the \"welcome\" element by CSS selector (e.g., by class name)\n  el = fixture.nativeElement.querySelector('.welcome');\n});\n\n</code-example>\n<p translation-result=\"on\">以下是一些測試：</p><p translation-origin=\"off\">And here are some tests:</p>\n\n<code-example header=\"app/welcome/welcome.component.spec.ts\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"tests\">\nit('should welcome the user', () =&gt; {\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content)\n    .withContext('\"Welcome ...\"')\n    .toContain('Welcome');\n  expect(content)\n    .withContext('expected name')\n    .toContain('Test User');\n});\n\nit('should welcome \"Bubba\"', () =&gt; {\n  userService.user.name = 'Bubba'; // welcome message hasn't been shown yet\n  fixture.detectChanges();\n  expect(el.textContent).toContain('Bubba');\n});\n\nit('should request login if not logged in', () =&gt; {\n  userService.isLoggedIn = false; // welcome message hasn't been shown yet\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content)\n    .withContext('not welcomed')\n    .not.toContain('Welcome');\n  expect(content)\n    .withContext('\"log in\"')\n    .toMatch(/log in/i);\n});\n\n</code-example>\n<p translation-result=\"on\">首先是一個健全性測試；它確認了樁服務 <code>UserService</code> 被呼叫過並能正常工作。</p><p translation-origin=\"off\">The first is a sanity test; it confirms that the stubbed <code>UserService</code> is called and working.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">Jasmine 匹配器的第二個引數（比如 <code>'expected name'</code>）是一個可選的失敗標籤。如果此期望失敗，Jasmine 就會把這個標籤貼到期望失敗的訊息中。在具有多個期望的測試規約中，它可以幫我們澄清出現了什麼問題以及都有哪些期望失敗了。</p><p translation-origin=\"off\">The second parameter to the Jasmine matcher (for example, <code>'expected name'</code>) is an optional failure label.\nIf the expectation fails, Jasmine appends this label to the expectation failure message.\nIn a spec with multiple expectations, it can help clarify what went wrong and which expectation failed.</p>\n\n</div>\n<p translation-result=\"on\">當該服務返回不同的值時，其餘的測試會確認該元件的邏輯。第二個測試驗證了更改使用者名稱的效果。當用戶未登入時，第三個測試會檢查元件是否顯示了正確的訊息。</p><p translation-origin=\"off\">The remaining tests confirm the logic of the component when the service returns different values.\nThe second test validates the effect of changing the user name.\nThe third test checks that the component displays the proper message when there is no logged-in user.</p>\n\n<p><a id=\"component-with-async-service\"></a></p>\n<h2 id=\"component-with-async-service\" translation-result=\"on\">帶非同步服務的元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-async-service\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Component with async service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-async-service\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在這個例子中，<code>AboutComponent</code> 範本託管了一個 <code>TwainComponent</code>。<code>TwainComponent</code> 會顯示馬克·吐溫的名言。</p><p translation-origin=\"off\">In this sample, the <code>AboutComponent</code> template hosts a <code>TwainComponent</code>.\nThe <code>TwainComponent</code> displays Mark Twain quotes.</p>\n\n<code-example header=\"app/twain/twain.component.ts (template)\" path=\"testing/src/app/twain/twain.component.ts\" region=\"template\">\ntemplate: `\n  &lt;p class=\"twain\"&gt;&lt;i&gt;{{quote | <a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a>}}&lt;/i&gt;&lt;/p&gt;\n  &lt;button type=\"button\" (click)=\"getQuote()\"&gt;Next quote&lt;/button&gt;\n  &lt;p class=\"error\" *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"errorMessage\"&gt;{{ errorMessage }}&lt;/p&gt;`,\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n元件的 <code>quote</code> 屬性的值透過 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code> 傳遞。這意味著該屬性會返回 <code>Promise</code> 或 <code>Observable</code>。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThe value of the component's <code>quote</code> property passes through an <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code>.\nThat means the property returns either a <code>Promise</code> or an <code>Observable</code>.</p>\n\n</div>\n<p translation-result=\"on\">在這個例子中，<code>TwainComponent.getQuote()</code> 方法告訴你 <code>quote</code> 屬性會返回一個 <code>Observable</code>。</p><p translation-origin=\"off\">In this example, the <code>TwainComponent.getQuote()</code> method tells you that the <code>quote</code> property returns an <code>Observable</code>.</p>\n\n<code-example header=\"app/twain/twain.component.ts (getQuote)\" path=\"testing/src/app/twain/twain.component.ts\" region=\"get-quote\">\ngetQuote() {\n  this.errorMessage = '';\n  this.quote = this.twainService.getQuote().pipe(\n    startWith('...'),\n    catchError( (err: any) =&gt; {\n      // Wait a turn because errorMessage already set once this turn\n      setTimeout(() =&gt; this.errorMessage = err.message || err.toString());\n      return of('...'); // reset message to placeholder\n    })\n  );\n\n</code-example>\n<p translation-result=\"on\">該 <code>TwainComponent</code> 從注入的 <code>TwainService</code> 中獲取名言。該在服務能返回第一條名言之前，該服務會先返回一個佔位流（<code>'...'</code>）。</p><p translation-origin=\"off\">The <code>TwainComponent</code> gets quotes from an injected <code>TwainService</code>.\nThe component starts the returned <code>Observable</code> with a placeholder value (<code>'...'</code>), before the service can return its first quote.</p>\n\n<p translation-result=\"on\"><code>catchError</code> 會攔截服務錯誤，準備一條錯誤資訊，並在流的成功通道上返回佔位值。它必須等一拍（tick）才能設定 <code>errorMessage</code>，以免在同一個變更檢測週期內更新此訊息兩次。</p><p translation-origin=\"off\">The <code>catchError</code> intercepts service errors, prepares an error message, and returns the placeholder value on the success channel.\nIt must wait a tick to set the <code>errorMessage</code> in order to avoid updating that message twice in the same change detection cycle.</p>\n\n<p translation-result=\"on\">這些都是你想要測試的特性。</p><p translation-origin=\"off\">These are all features you'll want to test.</p>\n\n<h4 id=\"testing-with-a-spy\" translation-result=\"on\">使用間諜（spy）進行測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#testing-with-a-spy\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Testing with a spy<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#testing-with-a-spy\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在測試元件時，只有該服務的公開 API 才有意義。通常，測試本身不應該呼叫遠端伺服器。它們應該模擬這樣的呼叫。這個 <code>app/twain/twain.component.spec.ts</code> 中的環境準備工作展示了一種方法：</p><p translation-origin=\"off\">When testing a component, only the service's public API should matter.\nIn general, tests themselves should not make calls to remote servers.\nThey should emulate such calls.\nThe setup in this <code>app/twain/twain.component.spec.ts</code> shows one way to do that:</p>\n\n<code-example header=\"app/twain/twain.component.spec.ts (setup)\" path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"setup\">\nbeforeEach(() =&gt; {\n  testQuote = 'Test Quote';\n\n  // Create a fake TwainService object with a `getQuote()` spy\n  const twainService = jasmine.createSpyObj('TwainService', ['getQuote']);\n  // Make the spy return a synchronous Observable with the test data\n  getQuoteSpy = twainService.getQuote.and.returnValue(of(testQuote));\n\n  TestBed.configureTestingModule({\n    declarations: [TwainComponent],\n    providers: [{provide: TwainService, useValue: twainService}]\n  });\n\n  fixture = TestBed.createComponent(TwainComponent);\n  component = fixture.componentInstance;\n  quoteEl = fixture.nativeElement.querySelector('.twain');\n});\n\n</code-example>\n<p><a id=\"service-spy\"></a></p>\n<p translation-result=\"on\">仔細看一下這個間諜。</p><p translation-origin=\"off\">Focus on the spy.</p>\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy\">\n// Create a fake TwainService object with a `getQuote()` spy\nconst twainService = jasmine.createSpyObj('TwainService', ['getQuote']);\n// Make the spy return a synchronous Observable with the test data\ngetQuoteSpy = twainService.getQuote.and.returnValue(of(testQuote));\n\n</code-example>\n<p translation-result=\"on\">這個間諜的設計目標是讓所有對 <code>getQuote</code> 的呼叫都會收到一個帶有測試名言的可觀察物件。與真正的 <code>getQuote()</code> 方法不同，這個間諜會繞過伺服器，並返回一個立即同步提供可用值的可觀察物件。</p><p translation-origin=\"off\">The spy is designed such that any call to <code>getQuote</code> receives an observable with a test quote.\nUnlike the real <code>getQuote()</code> method, this spy bypasses the server and returns a synchronous observable whose value is available immediately.</p>\n\n<p translation-result=\"on\">雖然這個 <code>Observable</code> 是同步的，但你也可以用這個間諜編寫很多有用的測試。</p><p translation-origin=\"off\">You can write many useful tests with this spy, even though its <code>Observable</code> is synchronous.</p>\n\n<p><a id=\"sync-tests\"></a></p>\n<h4 id=\"synchronous-tests\" translation-result=\"on\">同步測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#synchronous-tests\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Synchronous tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#synchronous-tests\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">同步 <code>Observable</code> 的一個關鍵優勢是，你通常可以把非同步過程轉換成同步測試。</p><p translation-origin=\"off\">A key advantage of a synchronous <code>Observable</code> is that you can often turn asynchronous processes into synchronous tests.</p>\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"sync-test\">\nit('should show quote after component initialized', () =&gt; {\n  fixture.detectChanges();  // onInit()\n\n  // sync spy result shows testQuote immediately after init\n  expect(quoteEl.textContent).toBe(testQuote);\n  expect(getQuoteSpy.calls.any())\n    .withContext('getQuote called')\n    .toBe(true);\n});\n\n</code-example>\n<p translation-result=\"on\">當間諜的結果同步返回時，<code>getQuote()</code> 方法會在第一個變更檢測週期（Angular 在這裡呼叫 <code>ngOnInit</code>）<em>後</em>立即更新螢幕上的訊息。</p><p translation-origin=\"off\">Because the spy result returns synchronously, the <code>getQuote()</code> method updates the message on screen immediately <em>after</em> the first change detection cycle during which Angular calls <code>ngOnInit</code>.</p>\n\n<p translation-result=\"on\">你在測試錯誤路徑時就沒有這麼幸運了。雖然服務間諜會同步返回一個錯誤，但該元件方法會呼叫 <code>setTimeout()</code>。在值可用之前，測試必須等待 JavaScript 引擎的至少一個週期。因此，該測試必須是<em>非同步的</em>。</p><p translation-origin=\"off\">You're not so lucky when testing the error path.\nAlthough the service spy will return an error synchronously, the component method calls <code>setTimeout()</code>.\nThe test must wait at least one full turn of the JavaScript engine before the value becomes available.\nThe test must become <em>asynchronous</em>.</p>\n\n<p><a id=\"fake-async\"></a></p>\n<h4 id=\"async-test-with-fakeasync\" translation-result=\"on\">使用 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 進行非同步測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#使用-fakeasync-進行非同步測試\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Async test with <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-test-with-fakeasync\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">要使用 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 功能，你必須在測試的環境設定檔案中匯入 <code>zone.js/testing</code>。如果是用 Angular CLI 建立的專案，那麼其 <code>src/test.ts</code> 中已經配置好了 <code>zone-testing</code>。</p><p translation-origin=\"off\">To use <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> functionality, you must import <code>zone.js/testing</code> in your test setup file.\nIf you created your project with the Angular CLI, <code>zone-testing</code> is already imported in <code>src/test.ts</code>.</p>\n\n<p translation-result=\"on\">當該服務返回 <code>ErrorObservable</code> 時，下列測試會對其預期行為進行確認。</p><p translation-origin=\"off\">The following test confirms the expected behavior when the service returns an <code>ErrorObservable</code>.</p>\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"error-test\">\nit('should display error when TwainService fails', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n     // tell spy to return an error observable\n     getQuoteSpy.and.returnValue(throwError(() =&gt; new Error('TwainService test failure')));\n     fixture.detectChanges();  // onInit()\n     // sync spy errors immediately after init\n\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();  // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the component's setTimeout()\n\n     fixture.detectChanges();  // update errorMessage within setTimeout()\n\n     expect(errorMessage())\n      .withContext('should display error')\n      .toMatch(/test failure/, );\n     expect(quoteEl.textContent)\n      .withContext('should show placeholder')\n      .toBe('...');\n   }));\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n<code>it()</code> 函式會接收以下形式的引數。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThe <code>it()</code> function receives an argument of the following form.</p>\n\n</div>\n<code-example format=\"javascript\" language=\"javascript\">\n\n<a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; { /* test body */ })\n\n</code-example>\n<p translation-result=\"on\">透過在一個特殊的 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> test zone</code>（譯註：Zone.js 的一個特例）中執行測試體，<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函式可以啟用線性編碼風格。這個測試體看上去是同步的。沒有像 <code>Promise.then()</code> 這樣的巢狀(Nesting)語法來破壞控制流。</p><p translation-origin=\"off\">The <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> function enables a linear coding style by running the test body in a special <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> test zone</code>.\nThe test body appears to be synchronous.\nThere is no nested syntax (like a <code>Promise.then()</code>) to disrupt the flow of control.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">限制：如果測試體要進行 <code>XMLHttpRequest</code>（XHR）呼叫，則 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函式無效。很少會需要在測試中進行 XHR 呼叫，但如果你確實要這麼做，請參閱 <a href=\"guide/testing-components-scenarios#waitForAsync\"><code>waitForAsync()</code></a> 部分。</p><p translation-origin=\"off\">Limitation: The <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> function won't work if the test body makes an <code>XMLHttpRequest</code> (XHR) call.\nXHR calls within a test are rare, but if you need to call XHR, see the <a href=\"guide/testing-components-scenarios#waitForAsync\"><code>waitForAsync()</code></a> section.</p>\n\n</div>\n<p><a id=\"tick\"></a></p>\n<h4 id=\"the-tick-function\" translation-result=\"on\"><code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code> 函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#tick-函式\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">The <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code> function<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-tick-function\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">你必須呼叫 <a href=\"api/core/testing/tick\"><code>tick()</code></a> 來推進虛擬時鐘。</p><p translation-origin=\"off\">You do have to call <a href=\"api/core/testing/tick\"><code>tick()</code></a> to advance the virtual clock.</p>\n\n<p translation-result=\"on\">呼叫 <a href=\"api/core/testing/tick\"><code>tick()</code></a> 時會在所有掛起的非同步活動完成之前模擬時間的流逝。在這種情況下，它會等待錯誤處理程式中的 <code>setTimeout()</code>。</p><p translation-origin=\"off\">Calling <a href=\"api/core/testing/tick\"><code>tick()</code></a> simulates the passage of time until all pending asynchronous activities finish.\nIn this case, it waits for the error handler's <code>setTimeout()</code>.</p>\n\n<p translation-result=\"on\"><a href=\"api/core/testing/tick\"><code>tick()</code></a> 函式接受 <code>millis</code> 和 <code>tickOptions</code> 作為引數，<code>millis</code> 引數表示虛擬時鐘要推進多少，如果未提供，則預設為 <code>0</code>。比如，如果你在 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 測試中有一個 <code>setTimeout(fn, 100)</code>，你就需要使用 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100)</code> 來觸發其 fn 回呼(Callback)。\n<code>tickOptions</code> 是一個可選引數，它帶有一個名為 <code>processNewMacroTasksSynchronously</code> 的屬性，它表示在 tick 時是否要呼叫新產生的宏任務，預設為 <code>true</code>。</p><p translation-origin=\"off\">The <a href=\"api/core/testing/tick\"><code>tick()</code></a> function accepts <code>millis</code> and <code>tickOptions</code> as parameters. The <code>millis</code> parameter specifies how much the virtual clock advances and defaults to <code>0</code> if not provided.\nFor example, if you have a <code>setTimeout(fn, 100)</code> in a <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> test, you need to use <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100)</code> to trigger the fn callback.\nThe optional <code>tickOptions</code> parameter has a property named <code>processNewMacroTasksSynchronously</code>. The <code>processNewMacroTasksSynchronously</code> property represents whether to invoke new generated macro tasks when ticking and defaults to <code>true</code>.</p>\n\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick\">\nit('should run timeout callback with delay after call <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> with millis', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n     let called = false;\n     setTimeout(() =&gt; {\n       called = true;\n     }, 100);\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100);\n     expect(called).toBe(true);\n   }));\n\n</code-example>\n<p translation-result=\"on\"><a href=\"api/core/testing/tick\"><code>tick()</code></a> 函式是你用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 匯入的 Angular 測試工具函式之一。它是 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 的伴生工具，你只能在 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 測試體內呼叫它。</p><p translation-origin=\"off\">The <a href=\"api/core/testing/tick\"><code>tick()</code></a> function is one of the Angular testing utilities that you import with <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>.\nIt's a companion to <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> and you can only call it within a <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> body.</p>\n\n<h4 id=\"tickoptions\">tickOptions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#tickoptions\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\">在此範例中，你有一個新的宏任務，即巢狀(Nesting)的 <code>setTimeout</code> 函式。預設情況下，當 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a></code> 為 setTimeout 時，<code>outside</code> 和 <code>nested</code> 都將被觸發。</p><p translation-origin=\"off\">In this example, you have a new macro task, the nested <code>setTimeout</code> function. By default, when the <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a></code> is setTimeout, <code>outside</code> and <code>nested</code> will both be triggered.</p>\n\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick-new-macro-task-sync\">\nit('should run new macro task callback with delay after call <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> with millis',\n   <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n     function nestedTimer(cb: () =&gt; any): void {\n       setTimeout(() =&gt; setTimeout(() =&gt; cb()));\n     }\n     const callback = jasmine.createSpy('callback');\n     nestedTimer(callback);\n     expect(callback).not.toHaveBeenCalled();\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(0);\n     // the nested timeout will also be triggered\n     expect(callback).toHaveBeenCalled();\n   }));\n\n</code-example>\n<p translation-result=\"on\">在某些情況下，你可能不想在滴答時觸發新的宏任務。你可以用 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(millis, {processNewMacroTasksSynchronously: false})</code> 來避免呼叫新的宏任務。</p><p translation-origin=\"off\">In some case, you don't want to trigger the new macro task when ticking. You can use <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(millis, {processNewMacroTasksSynchronously: false})</code> to not invoke a new macro task.</p>\n\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-tick-new-macro-task-async\">\nit('should not run new macro task callback with delay after call <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> with millis',\n   <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n     function nestedTimer(cb: () =&gt; any): void {\n       setTimeout(() =&gt; setTimeout(() =&gt; cb()));\n     }\n     const callback = jasmine.createSpy('callback');\n     nestedTimer(callback);\n     expect(callback).not.toHaveBeenCalled();\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(0, {processNewMacroTasksSynchronously: false});\n     // the nested timeout will not be triggered\n     expect(callback).not.toHaveBeenCalled();\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(0);\n     expect(callback).toHaveBeenCalled();\n   }));\n\n</code-example>\n<h4 id=\"comparing-dates-inside-fakeasync\" translation-result=\"on\">比較 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 內部的日期<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#比較-fakeasync-內部的日期\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Comparing dates inside <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#comparing-dates-inside-fakeasync\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 可以模擬時間的流逝，以便讓你計算出 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 裡面的日期差。</p><p translation-origin=\"off\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> simulates passage of time, which lets you calculate the difference between dates inside <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>.</p>\n\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-date\">\nit('should get Date diff correctly in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n     const start = Date.now();\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(100);\n     const end = Date.now();\n     expect(end - start).toBe(100);\n   }));\n\n</code-example>\n<h4 id=\"jasmineclock-with-fakeasync\" translation-result=\"on\"><code>jasmine.clock</code> 與 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 聯用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#jasmineclock-與-fakeasync-聯用\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\"><code>jasmine.clock</code> with <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#jasmineclock-with-fakeasync\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">Jasmine 還為模擬日期提供了 <code>clock</code> 特性。而 Angular 會在 <code>jasmine.clock().install()</code> 於 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 方法內呼叫時自動執行這些測試。直到呼叫了 <code>jasmine.clock().uninstall()</code> 為止。<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 不是必須的，如果巢狀(Nesting)它就丟擲錯誤。</p><p translation-origin=\"off\">Jasmine also provides a <code>clock</code> feature to mock dates.\nAngular automatically runs tests that are run after <code>jasmine.clock().install()</code> is called inside a <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> method until <code>jasmine.clock().uninstall()</code> is called.\n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> is not needed and throws an error if nested.</p>\n\n<p translation-result=\"on\">預設情況下，此功能處於禁用狀態。要啟用它，請在匯入 <code>zone-testing</code> 之前先設定全域標誌。</p><p translation-origin=\"off\">By default, this feature is disabled.\nTo enable it, set a global flag before importing <code>zone-testing</code>.</p>\n\n<p translation-result=\"on\">如果你使用的是 Angular CLI，請在 <code>src/test.ts</code> 中配置這個標誌。</p><p translation-origin=\"off\">If you use the Angular CLI, configure this flag in <code>src/test.ts</code>.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n(window as any)['__zone_symbol__fakeAsyncPatchLock'] = true;\nimport 'zone.js/testing';\n\n</code-example>\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-clock\">\ndescribe('use jasmine.clock()', () =&gt; {\n  // need to config __zone_symbol__fakeAsyncPatchLock flag\n  // before loading zone.js/testing\n  beforeEach(() =&gt; {\n    jasmine.clock().install();\n  });\n  afterEach(() =&gt; {\n    jasmine.clock().uninstall();\n  });\n  it('should auto enter <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>', () =&gt; {\n    // is in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> now, don't need to call <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(testFn)\n    let called = false;\n    setTimeout(() =&gt; {\n      called = true;\n    }, 100);\n    jasmine.clock().tick(100);\n    expect(called).toBe(true);\n  });\n});\n\n</code-example>\n<h4 id=\"using-the-rxjs-scheduler-inside-fakeasync\" translation-result=\"on\">在 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 中使用 RxJS 排程器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#在-fakeasync-中使用-rxjs-排程器\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Using the RxJS scheduler inside <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#using-the-rxjs-scheduler-inside-fakeasync\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 使用 RxJS 的排程器，就像使用 <code>setTimeout()</code> 或 <code>setInterval()</code> 一樣，但你需要匯入 <code>zone.js/plugins/zone-patch-rxjs-fake-async</code> 來給 RxJS 排程器打補丁。</p><p translation-origin=\"off\">You can also use RxJS scheduler in <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> just like using <code>setTimeout()</code> or <code>setInterval()</code>, but you need to import <code>zone.js/plugins/zone-patch-rxjs-fake-async</code> to patch RxJS scheduler.</p>\n\n<code-example path=\"testing/src/app/demo/async-helper.spec.ts\" region=\"fake-async-test-rxjs\">\nit('should get Date diff correctly in <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a> with rxjs scheduler', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n     // need to add `import 'zone.js/plugins/zone-patch-rxjs-fake-async'\n     // to patch rxjs scheduler\n     let result = '';\n     of('hello').pipe(delay(1000)).subscribe(v =&gt; {\n       result = v;\n     });\n     expect(result).toBe('');\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n     expect(result).toBe('hello');\n\n     const start = new Date().getTime();\n     let dateDiff = 0;\n     interval(1000).pipe(take(2)).subscribe(() =&gt; dateDiff = (new Date().getTime() - start));\n\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n     expect(dateDiff).toBe(1000);\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(1000);\n     expect(dateDiff).toBe(2000);\n   }));\n\n</code-example>\n<h4 id=\"support-more-macrotasks\" translation-result=\"on\">支援更多的 macroTasks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#support-more-macrotasks\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Support more macroTasks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#support-more-macrotasks\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 預設支援以下宏任務。</p><p translation-origin=\"off\">By default, <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> supports the following macro tasks.</p>\n\n<ul>\n<li>\n<p><code>setTimeout</code></p>\n</li>\n<li>\n<p><code>setInterval</code></p>\n</li>\n<li>\n<p><code>requestAnimationFrame</code></p>\n</li>\n<li>\n<p><code>webkitRequestAnimationFrame</code></p>\n</li>\n<li>\n<p><code>mozRequestAnimationFrame</code></p>\n</li>\n</ul>\n<p translation-result=\"on\">如果你執行其他宏任務，比如 <code>HTMLCanvasElement.toBlob()</code>，就會丟擲 <em>\"Unknown macroTask scheduled in fake async test\"</em> 錯誤。</p><p translation-origin=\"off\">If you run other macro tasks such as <code>HTMLCanvasElement.toBlob()</code>, an <em>\"Unknown macroTask scheduled in fake async test\"</em> error is thrown.</p>\n\n<code-tabs>\n    <code-pane header=\"src/app/shared/canvas.component.spec.ts (failing)\" path=\"testing/src/app/shared/canvas.component.spec.ts\" region=\"without-toBlob-macrotask\">\nimport { <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> } from '@angular/core/testing';\n\nimport { CanvasComponent } from './canvas.component';\n\ndescribe('CanvasComponent', () =&gt; {\n  beforeEach(async () =&gt; {\n    await <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          declarations: [CanvasComponent],\n        })\n        .compileComponents();\n  });\n\n  it('should be able to generate blob data from canvas', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n       const fixture = TestBed.createComponent(CanvasComponent);\n       const canvasComp = fixture.componentInstance;\n\n       fixture.detectChanges();\n       expect(canvasComp.blobSize).toBe(0);\n\n       <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();\n       expect(canvasComp.blobSize).toBeGreaterThan(0);\n     }));\n});\n\n</code-pane>\n    <code-pane header=\"src/app/shared/canvas.component.ts\" path=\"testing/src/app/shared/canvas.component.ts\" region=\"main\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>, <a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'sample-canvas',\n  template: '&lt;canvas #sampleCanvas width=\"200\" height=\"200\"&gt;&lt;/canvas&gt;',\n})\nexport class CanvasComponent implements <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n  blobSize = 0;\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('sampleCanvas') sampleCanvas!: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n  ngAfterViewInit() {\n    const canvas: HTMLCanvasElement = this.sampleCanvas.nativeElement;\n    const context = canvas.getContext('2d')!;\n\n    context.clearRect(0, 0, 200, 200);\n    context.fillStyle = '#FF1122';\n    context.fillRect(0, 0, 200, 200);\n\n    canvas.toBlob(blob =&gt; {\n      this.blobSize = blob?.size ?? 0;\n    });\n  }\n}\n\n</code-pane>\n</code-tabs>\n<p translation-result=\"on\">如果你想支援這種情況，就要在 <code>beforeEach()</code> 定義你要支援的宏任務。比如：</p><p translation-origin=\"off\">If you want to support such a case, you need to define the macro task you want to support in <code>beforeEach()</code>.\nFor example:</p>\n\n<code-example header=\"src/app/shared/canvas.component.spec.ts (excerpt)\" path=\"testing/src/app/shared/canvas.component.spec.ts\" region=\"enable-toBlob-macrotask\">\nbeforeEach(() =&gt; {\n  (window as any).__zone_symbol__FakeAsyncTestMacroTask = [\n    {\n      source: 'HTMLCanvasElement.toBlob',\n      callbackArgs: [{size: 200}],\n    },\n  ];\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n要在依賴 Zone.js 的應用中使用 <code>&lt;canvas&gt;</code> 元素，你需要匯入 <code>zone-patch-canvas</code> 補丁（或者在 <code>polyfills.ts</code> 中，或者在用到 <code>&lt;canvas&gt;</code> 的那個檔案中）：</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nIn order to make the <code>&lt;canvas&gt;</code> element Zone.js-aware in your app, you need to import the <code>zone-patch-canvas</code> patch (either in <code>polyfills.ts</code> or in the specific file that uses <code>&lt;canvas&gt;</code>):</p>\n\n</div>\n<code-example header=\"src/polyfills.ts or src/app/shared/canvas.component.ts\" path=\"testing/src/app/shared/canvas.component.ts\" region=\"import-canvas-patch\">\n// Import patch to make async `HTMLCanvasElement` methods (such as `.toBlob()`) Zone.js-aware.\n// Either import in `polyfills.ts` (if used in more than one places in the app) or in the component\n// file using `HTMLCanvasElement` (if it is only used in a single file).\nimport 'zone.js/plugins/zone-patch-canvas';\n\n</code-example>\n<h4 id=\"async-observables\" translation-result=\"on\">非同步可觀察物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-observables\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Async observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-observables\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">你可能已經對前面這些測試的測試覆蓋率感到滿意。</p><p translation-origin=\"off\">You might be satisfied with the test coverage of these tests.</p>\n\n<p translation-result=\"on\">但是，你可能也會為另一個事實感到不安：真實的服務並不是這樣工作的。真實的服務會向遠端伺服器傳送請求。伺服器需要一定的時間才能做出響應，並且其回應內文肯定不會像前面兩個測試中一樣是立即可用的。</p><p translation-origin=\"off\">However, you might be troubled by the fact that the real service doesn't quite behave this way.\nThe real service sends requests to a remote server.\nA server takes time to respond and the response certainly won't be available immediately as in the previous two tests.</p>\n\n<p translation-result=\"on\">如果能像下面這樣從 <code>getQuote()</code> 間諜中返回一個<em>非同步的</em>可觀察物件，你的測試就會更真實地反映現實世界。</p><p translation-origin=\"off\">Your tests will reflect the real world more faithfully if you return an <em>asynchronous</em> observable from the <code>getQuote()</code> spy like this.</p>\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"async-setup\">\n// Simulate delayed observable values with the `asyncData()` helper\ngetQuoteSpy.and.returnValue(asyncData(testQuote));\n\n</code-example>\n<h4 id=\"async-observable-helpers\" translation-result=\"on\">非同步可觀察物件測試助手<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-observable-helpers\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Async observable helpers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-observable-helpers\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">非同步可觀察物件可以由測試助手 <code>asyncData</code> 產生。測試助手 <code>asyncData</code> 是一個你必須自行編寫的工具函式，當然也可以從下面的範例程式碼中複製它。</p><p translation-origin=\"off\">The async observable was produced by an <code>asyncData</code> helper.\nThe <code>asyncData</code> helper is a utility function that you'll have to write yourself, or copy this one from the sample code.</p>\n\n<code-example header=\"testing/async-observable-helpers.ts\" path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-data\">\n/**\n * Create async observable that emits-once and completes\n * after a JS engine turn\n */\nexport function asyncData&lt;T&gt;(data: T) {\n  return defer(() =&gt; Promise.resolve(data));\n}\n\n</code-example>\n<p translation-result=\"on\">這個助手返回的可觀察物件會在 JavaScript 引擎的下一個週期中傳送 <code>data</code> 值。</p><p translation-origin=\"off\">This helper's observable emits the <code>data</code> value in the next turn of the JavaScript engine.</p>\n\n<p translation-result=\"on\"><a href=\"http://reactivex.io/documentation/operators/defer.html\">RxJS 的 <code>defer()</code> 運運算元</a>返回一個可觀察物件。它的引數是一個返回 Promise 或可觀察物件的工廠函式。當某個訂閱者訂閱 <em>defer</em> 產生的可觀察物件時，defer 就會呼叫此工廠函式產生新的可觀察物件，並讓該訂閱者訂閱這個新物件。</p><p translation-origin=\"off\">The <a href=\"http://reactivex.io/documentation/operators/defer.html\">RxJS <code>defer()</code> operator</a> returns an observable.\nIt takes a factory function that returns either a promise or an observable.\nWhen something subscribes to <em>defer</em>'s observable, it adds the subscriber to a new observable created with that factory.</p>\n\n<p translation-result=\"on\"><code>defer()</code> 運運算元會把 <code>Promise.resolve()</code> 轉換成一個新的可觀察物件，它和 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 一樣只會傳送一次然後立即結束（complete）。這樣，當訂閱者收到資料後就會自動取消訂閱。</p><p translation-origin=\"off\">The <code>defer()</code> operator transforms the <code>Promise.resolve()</code> into a new observable that, like <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>, emits once and completes.\nSubscribers are unsubscribed after they receive the data value.</p>\n\n<p translation-result=\"on\">還有一個類別似的用來產生非同步錯誤的測試助手。</p><p translation-origin=\"off\">There's a similar helper for producing an async error.</p>\n\n<code-example path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-error\">\n/**\n * Create async observable error that errors\n * after a JS engine turn\n */\nexport function asyncError&lt;T&gt;(errorObject: any) {\n  return defer(() =&gt; Promise.reject(errorObject));\n}\n\n</code-example>\n<h4 id=\"more-async-tests\" translation-result=\"on\">更多非同步測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#more-async-tests\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">More async tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#more-async-tests\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">現在，<code>getQuote()</code> 間諜正在返回非同步可觀察物件，你的大多數測試都必須是非同步的。</p><p translation-origin=\"off\">Now that the <code>getQuote()</code> spy is returning async observables, most of your tests will have to be async as well.</p>\n\n<p translation-result=\"on\">下面是一個 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 測試，用於示範你在真實世界中所期望的資料流。</p><p translation-origin=\"off\">Here's a <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> test that demonstrates the data flow you'd expect in the real world.</p>\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"fake-async-test\">\nit('should show quote after getQuote (<a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>)', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n     fixture.detectChanges();  // ngOnInit()\n     expect(quoteEl.textContent)\n      .withContext('should show placeholder')\n      .toBe('...');\n\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();                   // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observable to get the quote\n     fixture.detectChanges();  // update view\n\n     expect(quoteEl.textContent)\n      .withContext('should show quote')\n      .toBe(testQuote);\n     expect(errorMessage())\n      .withContext('should not show error')\n      .toBeNull();\n   }));\n\n</code-example>\n<p translation-result=\"on\">注意，quote 元素會在 <code>ngOnInit()</code> 之後顯示佔位符 <code>'...'</code>。因為第一句名言尚未到來。</p><p translation-origin=\"off\">Notice that the quote element displays the placeholder value (<code>'...'</code>) after <code>ngOnInit()</code>.\nThe first quote hasn't arrived yet.</p>\n\n<p translation-result=\"on\">要清除可觀察物件中的第一句名言，你可以呼叫 <a href=\"api/core/testing/tick\"><code>tick()</code></a>。然後呼叫 <code>detectChanges()</code> 來告訴 Angular 更新螢幕。</p><p translation-origin=\"off\">To flush the first quote from the observable, you call <a href=\"api/core/testing/tick\"><code>tick()</code></a>.\nThen call <code>detectChanges()</code> to tell Angular to update the screen.</p>\n\n<p translation-result=\"on\">然後，你可以斷言 quote 元素是否顯示了預期的文字。</p><p translation-origin=\"off\">Then you can assert that the quote element displays the expected text.</p>\n\n<p><a id=\"waitForAsync\"></a></p>\n<h4 id=\"async-test-with-waitforasync\" translation-result=\"on\">用 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 進行非同步測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#用-waitforasync-進行非同步測試\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Async test with <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#async-test-with-waitforasync\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">要使用 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 函式，你必須在 test 的設定檔案中匯入 <code>zone.js/testing</code>。如果你是用 Angular CLI 建立的專案，那就已經在 <code>src/test.ts</code> 中匯入過 <code>zone-testing</code> 了。</p><p translation-origin=\"off\">To use <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> functionality, you must import <code>zone.js/testing</code> in your test setup file.\nIf you created your project with the Angular CLI, <code>zone-testing</code> is already imported in <code>src/test.ts</code>.</p>\n\n<p translation-result=\"on\">這是之前的 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 測試，用 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 工具函式重寫的版本。</p><p translation-origin=\"off\">Here's the previous <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> test, re-written with the <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> utility.</p>\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"waitForAsync-test\">\nit('should show quote after getQuote (<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>)', <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n     fixture.detectChanges();  // ngOnInit()\n     expect(quoteEl.textContent)\n      .withContext('should show placeholder')\n      .toBe('...');\n\n     fixture.whenStable().then(() =&gt; {  // wait for async getQuote\n       fixture.detectChanges();         // update view with quote\n       expect(quoteEl.textContent).toBe(testQuote);\n       expect(errorMessage())\n        .withContext('should not show error')\n        .toBeNull();\n     });\n   }));\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 工具函式透過把測試程式碼安排到在特殊的<em>非同步測試區（async test zone）</em>下執行來隱藏某些用來處理非同步的樣板程式碼。你不需要把 Jasmine 的 <code>done()</code> 傳給測試並讓測試呼叫 <code>done()</code>，因為它在 Promise 或者可觀察物件的回呼(Callback)函式中是 <code>undefined</code>。</p><p translation-origin=\"off\">The <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> utility hides some asynchronous boilerplate by arranging for the tester's code to run in a special <em>async test zone</em>.\nYou don't need to pass Jasmine's <code>done()</code> into the test and call <code>done()</code> because it is <code>undefined</code> in promise or observable callbacks.</p>\n\n<p translation-result=\"on\">但是，可以透過呼叫 <code>fixture.whenStable()</code> 函式來揭示本測試的非同步性，因為該函式打破了線性的控制流。</p><p translation-origin=\"off\">But the test's asynchronous nature is revealed by the call to <code>fixture.whenStable()</code>, which breaks the linear flow of control.</p>\n\n<p translation-result=\"on\">在 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 中使用 <code>intervalTimer()</code>（比如 <code>setInterval()</code>）時，別忘了在測試後透過 <code>clearInterval()</code> 取消這個定時器，否則 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 永遠不會結束。</p><p translation-origin=\"off\">When using an <code>intervalTimer()</code> such as <code>setInterval()</code> in <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code>, remember to cancel the timer with <code>clearInterval()</code> after the test, otherwise the <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> never ends.</p>\n\n<p><a id=\"when-stable\"></a></p>\n<h4 id=\"whenstable\"><code>whenStable</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#whenstable\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\">測試必須等待 <code>getQuote()</code> 可觀察物件發出下一句名言。它並沒有呼叫 <a href=\"api/core/testing/tick\"><code>tick()</code></a>，而是呼叫了 <code>fixture.whenStable()</code>。</p><p translation-origin=\"off\">The test must wait for the <code>getQuote()</code> observable to emit the next quote.\nInstead of calling <a href=\"api/core/testing/tick\"><code>tick()</code></a>, it calls <code>fixture.whenStable()</code>.</p>\n\n<p translation-result=\"on\"><code>fixture.whenStable()</code> 返回一個 Promise，它會在 JavaScript 引擎的任務佇列變空時解析。在這個例子中，當可觀察物件發出第一句名言時，任務佇列就會變為空。</p><p translation-origin=\"off\">The <code>fixture.whenStable()</code> returns a promise that resolves when the JavaScript engine's task queue becomes empty.\nIn this example, the task queue becomes empty when the observable emits the first quote.</p>\n\n<p translation-result=\"on\">測試會在該 Promise 的回呼(Callback)中繼續進行，它會呼叫 <code>detectChanges()</code> 來用期望的文字更新 quote 元素。</p><p translation-origin=\"off\">The test resumes within the promise callback, which calls <code>detectChanges()</code> to update the quote element with the expected text.</p>\n\n<p><a id=\"jasmine-done\"></a></p>\n<h4 id=\"jasmine-done\">Jasmine <code>done()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#jasmine-done\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\">雖然 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 和 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函式可以大大簡化 Angular 的非同步測試，但你仍然可以回退到傳統技術，並給 <code>it</code> 傳一個以 <a href=\"https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\"><code>done</code> 回呼(Callback)</a>為引數的函式。</p><p translation-origin=\"off\">While the <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> and <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> functions greatly simplify Angular asynchronous testing, you can still fall back to the traditional technique and pass <code>it</code> a function that takes a <a href=\"https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\"><code>done</code> callback</a>.</p>\n\n<p translation-result=\"on\">但你不能在 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 或 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 函式中呼叫 <code>done()</code>，因為那裡的 <code>done</code> 引數是 <code>undefined</code>。</p><p translation-origin=\"off\">You can't call <code>done()</code> in <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> or <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> functions, because the <code>done parameter</code> is <code>undefined</code>.</p>\n\n<p translation-result=\"on\">現在，你要自己負責串聯各種 Promise、處理錯誤，並在適當的時機呼叫 <code>done()</code>。</p><p translation-origin=\"off\">Now you are responsible for chaining promises, handling errors, and calling <code>done()</code> at the appropriate moments.</p>\n\n<p translation-result=\"on\">編寫帶有 <code>done()</code> 的測試函式要比用 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 和 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 的形式笨重。但是當代碼涉及到像 <code>setInterval</code> 這樣的 <code>intervalTimer()</code> 時，它往往是必要的。</p><p translation-origin=\"off\">Writing test functions with <code>done()</code>, is more cumbersome than <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code>and <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>, but it is occasionally necessary when code involves the <code>intervalTimer()</code> like <code>setInterval</code>.</p>\n\n<p translation-result=\"on\">這裡是上一個測試的另外兩種版本，用 <code>done()</code> 編寫。第一個訂閱了透過元件的 <code>quote</code> 屬性暴露給範本的 <code>Observable</code>。</p><p translation-origin=\"off\">Here are two more versions of the previous test, written with <code>done()</code>.\nThe first one subscribes to the <code>Observable</code> exposed to the template by the component's <code>quote</code> property.</p>\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"quote-done-test\">\nit('should show last quote (quote done)', (done: DoneFn) =&gt; {\n  fixture.detectChanges();\n\n  component.quote.pipe(last()).subscribe(() =&gt; {\n    fixture.detectChanges();  // update view with quote\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage())\n      .withContext('should not show error')\n      .toBeNull();\n    done();\n  });\n});\n\n</code-example>\n<p translation-result=\"on\">RxJS 的 <code>last()</code> 運運算元會在完成之前發出可觀察物件的最後一個值，它同樣是測試名言。<code>subscribe</code> 回呼(Callback)會呼叫 <code>detectChanges()</code> 來使用測試名言重新整理的 quote 元素，方法與之前的測試一樣。</p><p translation-origin=\"off\">The RxJS <code>last()</code> operator emits the observable's last value before completing, which will be the test quote.\nThe <code>subscribe</code> callback calls <code>detectChanges()</code> to update the quote element with the test quote, in the same manner as the earlier tests.</p>\n\n<p translation-result=\"on\">在某些測試中，你可能更關心注入的服務方法是如何被調的以及它返回了什麼值，而不是螢幕顯示的內容。</p><p translation-origin=\"off\">In some tests, you're more interested in how an injected service method was called and what values it returned, than what appears on screen.</p>\n\n<p translation-result=\"on\">服務間諜，比如偽 <code>TwainService</code> 上的 <code>qetQuote()</code> 間諜，可以給你那些資訊，並對檢視的狀態做出斷言。</p><p translation-origin=\"off\">A service spy, such as the <code>qetQuote()</code> spy of the fake <code>TwainService</code>, can give you that information and make assertions about the state of the view.</p>\n\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy-done-test\">\nit('should show quote after getQuote (spy done)', (done: DoneFn) =&gt; {\n  fixture.detectChanges();\n\n  // the spy's most recent call returns the observable with the test quote\n  getQuoteSpy.calls.mostRecent().returnValue.subscribe(() =&gt; {\n    fixture.detectChanges();  // update view with quote\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage())\n      .withContext('should not show error')\n      .toBeNull();\n    done();\n  });\n});\n\n</code-example>\n<p><a id=\"marble-testing\"></a></p>\n<h2 id=\"component-marble-tests\" translation-result=\"on\">元件的彈珠測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-marble-tests\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Component marble tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-marble-tests\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">前面的 <code>TwainComponent</code> 測試透過 <code>asyncData</code> 和 <code>asyncError</code> 工具函式模擬了一個來自 <code>TwainService</code> 的非同步回應內文可觀察物件。</p><p translation-origin=\"off\">The previous <code>TwainComponent</code> tests simulated an asynchronous observable response from the <code>TwainService</code> with the <code>asyncData</code> and <code>asyncError</code> utilities.</p>\n\n<p translation-result=\"on\">你可以自己編寫這些簡短易用的函式。不幸的是，對於很多常見的場景來說，它們太簡單了。可觀察物件經常會發送很多次，可能是在經過一段顯著的延遲之後。元件可以用重疊的值序列和錯誤序列來協調多個可觀察物件。</p><p translation-origin=\"off\">These are short, simple functions that you can write yourself.\nUnfortunately, they're too simple for many common scenarios.\nAn observable often emits multiple times, perhaps after a significant delay.\nA component might coordinate multiple observables with overlapping sequences of values and errors.</p>\n\n<p translation-result=\"on\"><strong>RxJS 彈珠測試</strong>是一種測試可觀察場景的好方法，它既簡單又複雜。你很可能已經看過用於說明可觀察物件是如何工作<a href=\"https://rxmarbles.com\">彈珠圖</a>。彈珠測試使用類似的彈珠語言來指定測試中的可觀察流和期望值。</p><p translation-origin=\"off\"><strong>RxJS marble testing</strong> is a great way to test observable scenarios, both simple and complex.\nYou've likely seen the <a href=\"https://rxmarbles.com\">marble diagrams</a> that illustrate how observables work.\nMarble testing uses a similar marble language to specify the observable streams and expectations in your tests.</p>\n\n<p translation-result=\"on\">下面的例子用彈珠測試再次實現了 <code>TwainComponent</code> 中的兩個測試。</p><p translation-origin=\"off\">The following examples revisit two of the <code>TwainComponent</code> tests with marble testing.</p>\n\n<p translation-result=\"on\">首先安裝 npm 包 <code>jasmine-marbles</code>。然後匯入你需要的符號。</p><p translation-origin=\"off\">Start by installing the <code>jasmine-marbles</code> npm package.\nThen import the symbols you need.</p>\n\n<code-example header=\"app/twain/twain.component.marbles.spec.ts (import marbles)\" path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"import-marbles\">\nimport { cold, getTestScheduler } from 'jasmine-marbles';\n\n</code-example>\n<p translation-result=\"on\">獲取名言的完整測試方法如下：</p><p translation-origin=\"off\">Here's the complete test for getting a quote:</p>\n\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"get-quote-test\">\nit('should show quote after getQuote (marbles)', () =&gt; {\n  // observable test quote value and complete(), after delay\n  const q$ = cold('---x|', { x: testQuote });\n  getQuoteSpy.and.returnValue( q$ );\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent)\n    .withContext('should show placeholder')\n    .toBe('...');\n\n  getTestScheduler().flush(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observables\n\n  fixture.detectChanges(); // update view\n\n  expect(quoteEl.textContent)\n    .withContext('should show quote')\n    .toBe(testQuote);\n  expect(errorMessage())\n    .withContext('should not show error')\n    .toBeNull();\n});\n\n</code-example>\n<p translation-result=\"on\">注意，這個 Jasmine 測試是同步的。沒有 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>。彈珠測試使用測試排程程式（scheduler）來模擬同步測試中的時間流逝。</p><p translation-origin=\"off\">Notice that the Jasmine test is synchronous.\nThere's no <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>.\nMarble testing uses a test scheduler to simulate the passage of time in a synchronous test.</p>\n\n<p translation-result=\"on\">彈珠測試的美妙之處在於對可觀察物件流的視覺定義。這個測試定義了一個<a href=\"guide/testing-components-scenarios#cold-observable\"><em>冷</em>可觀察物件</a>，它等待三<a href=\"guide/testing-components-scenarios#marble-frame\">幀</a>（<code>---</code>），發出一個值（<code>x</code>），並完成（<code>|</code>）。在第二個引數中，你把值標記（<code>x</code>）對映到了發出的值（<code>testQuote</code>）。</p><p translation-origin=\"off\">The beauty of marble testing is in the visual definition of the observable streams.\nThis test defines a <a href=\"guide/testing-components-scenarios#cold-observable\"><em>cold</em> observable</a> that waits three <a href=\"guide/testing-components-scenarios#marble-frame\">frames</a> (<code>---</code>), emits a value (<code>x</code>), and completes (<code>|</code>).\nIn the second argument you map the value marker (<code>x</code>) to the emitted value (<code>testQuote</code>).</p>\n\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-quote-marbles\">\nconst q$ = cold('---x|', { x: testQuote });\n\n</code-example>\n<p translation-result=\"on\">這個彈珠庫會構造出相應的可觀察物件，測試程式把它用作 <code>getQuote</code> 間諜的返回值。</p><p translation-origin=\"off\">The marble library constructs the corresponding observable, which the test sets as the <code>getQuote</code> spy's return value.</p>\n\n<p translation-result=\"on\">當你準備好啟用彈珠的可觀察物件時，就告訴 <code>TestScheduler</code> 把它準備好的任務佇列<em>重新整理</em>一下。</p><p translation-origin=\"off\">When you're ready to activate the marble observables, you tell the <code>TestScheduler</code> to <em>flush</em> its queue of prepared tasks like this.</p>\n\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-scheduler-flush\">\ngetTestScheduler().flush(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observables\n\n</code-example>\n<p translation-result=\"on\">這個步驟的作用類似於之前的 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 和 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> 例子中的 <a href=\"api/core/testing/tick\"><code>tick()</code></a> 和 <code>whenStable()</code> 測試。對這種測試的權衡策略與那些例子是一樣的。</p><p translation-origin=\"off\">This step serves a purpose analogous to <a href=\"api/core/testing/tick\"><code>tick()</code></a> and <code>whenStable()</code> in the earlier <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> and <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> examples.\nThe balance of the test is the same as those examples.</p>\n\n<h4 id=\"marble-error-testing\" translation-result=\"on\">彈珠錯誤測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#marble-error-testing\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Marble error testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#marble-error-testing\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">下面是 <code>getQuote()</code> 錯誤測試的彈珠測試版。</p><p translation-origin=\"off\">Here's the marble testing version of the <code>getQuote()</code> error test.</p>\n\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-test\">\nit('should display error when TwainService fails', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  // observable error after delay\n  const q$ = cold('---#|', null, new Error('TwainService test failure'));\n  getQuoteSpy.and.returnValue( q$ );\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent)\n    .withContext('should show placeholder')\n    .toBe('...');\n\n  getTestScheduler().flush(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observables\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();                     // component shows error after a setTimeout()\n  fixture.detectChanges();    // update error message\n\n  expect(errorMessage())\n    .withContext('should display error')\n    .toMatch(/test failure/);\n  expect(quoteEl.textContent)\n    .withContext('should show placeholder')\n    .toBe('...');\n}));\n\n</code-example>\n<p translation-result=\"on\">它仍然是非同步測試，呼叫 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 和 <a href=\"api/core/testing/tick\">tick()</a>，因為該元件在處理錯誤時會呼叫 <code>setTimeout()</code>。</p><p translation-origin=\"off\">It's still an async test, calling <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> and <a href=\"api/core/testing/tick\">tick()</a>, because the component itself calls <code>setTimeout()</code> when processing errors.</p>\n\n<p translation-result=\"on\">看看這個彈珠的可觀察定義。</p><p translation-origin=\"off\">Look at the marble observable definition.</p>\n\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-marbles\">\nconst q$ = cold('---#|', null, new Error('TwainService test failure'));\n\n</code-example>\n<p translation-result=\"on\">這是一個<em>冷</em>可觀察物件，等待三幀，然後發出一個錯誤，井號（<code>#</code>）標出了在第三個引數中指定錯誤的發生時間。第二個引數為 null，因為該可觀察物件永遠不會發出值。</p><p translation-origin=\"off\">This is a <em>cold</em> observable that waits three frames and then emits an error, the hash (<code>#</code>) character indicates the timing of the error that is specified in the third argument.\nThe second argument is null because the observable never emits a value.</p>\n\n<h4 id=\"learn-about-marble-testing\" translation-result=\"on\">瞭解彈珠測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#learn-about-marble-testing\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Learn about marble testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#learn-about-marble-testing\"><i class=\"material-icons\">link</i></a></h4>\n\n<p><a id=\"marble-frame\"></a></p>\n<p translation-result=\"on\"><em>彈珠幀</em>是測試時間線上的虛擬單位。每個符號（<code>-</code>，<code>x</code>，<code>|</code>，<code>#</code>）都表示經過了一幀。</p><p translation-origin=\"off\">A <em>marble frame</em> is a virtual unit of testing time.\nEach symbol (<code>-</code>, <code>x</code>, <code>|</code>, <code>#</code>) marks the passing of one frame.</p>\n\n<p><a id=\"cold-observable\"></a></p>\n<p translation-result=\"on\"><em>冷</em>可觀察物件在你訂閱它之前不會產生值。你的大多數應用中可觀察物件都是冷的。所有的 <a href=\"guide/http\"><em>HttpClient</em></a> 方法返回的都是冷可觀察物件。</p><p translation-origin=\"off\">A <em>cold</em> observable doesn't produce values until you subscribe to it.\nMost of your application observables are cold.\nAll <a href=\"guide/http\"><em>HttpClient</em></a> methods return cold observables.</p>\n\n<p translation-result=\"on\">而<em>熱的</em>可觀察物件在訂閱它<em>之前</em>就已經在生成了這些值。用來報告路由器活動的 <a href=\"api/router/Router#events\"><code>Router.events</code></a> 可觀察物件就是一種<em>熱</em>可觀察物件。</p><p translation-origin=\"off\">A <em>hot</em> observable is already producing values <em>before</em> you subscribe to it.\nThe <a href=\"api/router/Router#events\"><code>Router.events</code></a> observable, which reports router activity, is a <em>hot</em> observable.</p>\n\n<p translation-result=\"on\">RxJS 彈珠測試這個主題非常豐富，超出了本指南的範圍。你可以在網上了解它，先從其<a href=\"https://rxjs.dev/guide/testing/marble-testing\">官方文件</a>開始。</p><p translation-origin=\"off\">RxJS marble testing is a rich subject, beyond the scope of this guide.\nLearn about it on the web, starting with the <a href=\"https://rxjs.dev/guide/testing/marble-testing\">official documentation</a>.</p>\n\n<p><a id=\"component-with-input-output\"></a></p>\n<h2 id=\"component-with-inputs-and-outputs\" translation-result=\"on\">具有輸入和輸出屬性的元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-inputs-and-outputs\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Component with inputs and outputs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-with-inputs-and-outputs\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">具有輸入和輸出屬性的元件通常會出現在宿主元件的檢視範本中。宿主使用屬性繫結來設定輸入屬性，並使用事件繫結來監聽輸出屬性引發的事件。</p><p translation-origin=\"off\">A component with inputs and outputs typically appears inside the view template of a host component.\nThe host uses a property binding to set the input property and an event binding to listen to events raised by the output property.</p>\n\n<p translation-result=\"on\">本測試的目標是驗證這些繫結是否如預期般工作。這些測試應該設定輸入值並監聽輸出事件。</p><p translation-origin=\"off\">The testing goal is to verify that such bindings work as expected.\nThe tests should set input values and listen for output events.</p>\n\n<p translation-result=\"on\"><code>DashboardHeroComponent</code> 是這類元件的一個小例子。它會顯示由 <code>DashboardComponent</code> 提供的一個英雄。點選這個英雄就會告訴 <code>DashboardComponent</code>，使用者已經選擇了此英雄。</p><p translation-origin=\"off\">The <code>DashboardHeroComponent</code> is a tiny example of a component in this role.\nIt displays an individual hero provided by the <code>DashboardComponent</code>.\nClicking that hero tells the <code>DashboardComponent</code> that the user has selected the hero.</p>\n\n<p translation-result=\"on\"><code>DashboardHeroComponent</code> 會像這樣內嵌在 <code>DashboardComponent</code> 範本中的：</p><p translation-origin=\"off\">The <code>DashboardHeroComponent</code> is embedded in the <code>DashboardComponent</code> template like this:</p>\n\n<code-example header=\"app/dashboard/dashboard.component.html (excerpt)\" path=\"testing/src/app/dashboard/dashboard.component.html\" region=\"dashboard-hero\">\n&lt;dashboard-hero *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"  class=\"col-1-4\"\n  [hero]=hero  (selected)=\"gotoDetail($event)\" &gt;\n&lt;/dashboard-hero&gt;\n\n</code-example>\n<p translation-result=\"on\"><code>DashboardHeroComponent</code> 出現在 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 複寫器中，把它的輸入屬性 <code>hero</code> 設定為當前的迴圈變數，並監聽該元件的 <code>selected</code> 事件。</p><p translation-origin=\"off\">The <code>DashboardHeroComponent</code> appears in an <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> repeater, which sets each component's <code>hero</code> input property to the looping value and listens for the component's <code>selected</code> event.</p>\n\n<p translation-result=\"on\">這裡是元件的完整定義：</p><p translation-origin=\"off\">Here's the component's full definition:</p>\n\n<p><a id=\"dashboard-hero-component\"></a></p>\n<code-example header=\"app/dashboard/dashboard-hero.component.ts (component)\" path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'dashboard-hero',\n  template: `\n    &lt;button type=\"button\" (click)=\"click()\" class=\"hero\"&gt;\n      {{hero.name | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a>}}\n    &lt;/button&gt;\n  `,\n  styleUrls: [ './dashboard-hero.component.css' ]\n})\nexport class DashboardHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() selected = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n<p translation-result=\"on\">在測試一個元件時，像這樣簡單的場景沒什麼內在價值，但值得了解它。你可以繼續嘗試這些方法：</p><p translation-origin=\"off\">While testing a component this simple has little intrinsic value, it's worth knowing how.\nUse one of these approaches:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">用 <code>DashboardComponent</code> 來測試它。</p><p translation-origin=\"off\">Test it as used by <code>DashboardComponent</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">把它作為一個獨立的元件進行測試。</p><p translation-origin=\"off\">Test it as a stand-alone component</p>\n\n</li>\n<li>\n<p translation-result=\"on\">用 <code>DashboardComponent</code> 的一個替代品來測試它。</p><p translation-origin=\"off\">Test it as used by a substitute for <code>DashboardComponent</code></p>\n\n</li>\n</ul>\n<p translation-result=\"on\">快速看一眼 <code>DashboardComponent</code> 建構函式就知道不建議採用第一種方法：</p><p translation-origin=\"off\">A quick look at the <code>DashboardComponent</code> constructor discourages the first approach:</p>\n\n<code-example header=\"app/dashboard/dashboard.component.ts (constructor)\" path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\">\nconstructor(private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, private heroService: HeroService) {}\n\n</code-example>\n<p translation-result=\"on\"><code>DashboardComponent</code> 依賴於 Angular 的路由器和 <code>HeroService</code>。你可能不得不用測試替身來代替它們，這有很多工作。路由器看上去特別有挑戰性。</p><p translation-origin=\"off\">The <code>DashboardComponent</code> depends on the Angular router and the <code>HeroService</code>.\nYou'd probably have to replace them both with test doubles, which is a lot of work.\nThe router seems particularly challenging.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><a href=\"guide/testing-components-scenarios#routing-component\">下面的討論</a>涵蓋了如何測試那些需要用到路由器的元件。</p><p translation-origin=\"off\">The <a href=\"guide/testing-components-scenarios#routing-component\">following discussion</a> covers testing components that require the router.</p>\n\n</div>\n<p translation-result=\"on\">當前的目標是測試 <code>DashboardHeroComponent</code>，而不是 <code>DashboardComponent</code>，所以試試第二個和第三個選項。</p><p translation-origin=\"off\">The immediate goal is to test the <code>DashboardHeroComponent</code>, not the <code>DashboardComponent</code>, so, try the second and third options.</p>\n\n<p><a id=\"dashboard-standalone\"></a></p>\n<h4 id=\"test-dashboardherocomponent-stand-alone\" translation-result=\"on\">單獨測試 <code>DashboardHeroComponent</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#test-dashboardherocomponent-stand-alone\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Test <code>DashboardHeroComponent</code> stand-alone<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#test-dashboardherocomponent-stand-alone\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">這裡是 spec 檔案中環境設定部分的內容。</p><p translation-origin=\"off\">Here's the meat of the spec file setup.</p>\n\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (setup)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"setup\">\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({declarations: [DashboardHeroComponent]})\nfixture = TestBed.createComponent(DashboardHeroComponent);\ncomp = fixture.componentInstance;\n\n// find the hero's <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> and element\nheroDe = fixture.debugElement.query(By.css('.hero'));\nheroEl = heroDe.nativeElement;\n\n// mock the hero supplied by the parent component\nexpectedHero = {id: 42, name: 'Test Name'};\n\n// simulate the parent setting the input property with that hero\ncomp.hero = expectedHero;\n\n// <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> initial data binding\nfixture.detectChanges();\n\n</code-example>\n<p translation-result=\"on\">注意這些設定程式碼如何把一個測試英雄（<code>expectedHero</code>）賦值給元件的 <code>hero</code> 屬性的，它模仿了 <code>DashboardComponent</code> 在其複寫器中透過屬性繫結來設定它的方式。</p><p translation-origin=\"off\">Notice how the setup code assigns a test hero (<code>expectedHero</code>) to the component's <code>hero</code> property, emulating the way the <code>DashboardComponent</code> would set it using the property binding in its repeater.</p>\n\n<p translation-result=\"on\">下面的測試驗證了英雄名是透過繫結傳播到範本的。</p><p translation-origin=\"off\">The following test verifies that the hero name is propagated to the template using a binding.</p>\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"name-test\">\nit('should display hero name in uppercase', () =&gt; {\n  const expectedPipedName = expectedHero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\n</code-example>\n<p translation-result=\"on\">因為<a href=\"guide/testing-components-scenarios#dashboard-hero-component\">範本</a>把英雄的名字傳給了 <code><a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">UpperCasePipe</a></code>，所以測試必須要讓元素值與其大寫形式的名字一致。</p><p translation-origin=\"off\">Because the <a href=\"guide/testing-components-scenarios#dashboard-hero-component\">template</a> passes the hero name through the Angular <code><a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">UpperCasePipe</a></code>, the test must match the element value with the upper-cased name.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">這個小測試示範了 Angular 測試會如何驗證一個元件的視覺化表示形式 - 這是<a href=\"guide/testing-components-basics#component-class-testing\">元件類測試</a>所無法實現的 - 成本相對較低，無需進行更慢、更復雜的端到端測試。</p><p translation-origin=\"off\">This small test demonstrates how Angular tests can verify a component's visual representation —something not possible with <a href=\"guide/testing-components-basics#component-class-testing\">component class tests</a>— at low cost and without resorting to much slower and more complicated end-to-end tests.</p>\n\n</div>\n<h4 id=\"clicking\" translation-result=\"on\">點選<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#clicking\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Clicking<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#clicking\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">單擊該英雄應該會讓一個宿主元件（可能是 <code>DashboardComponent</code>）監聽到 <code>selected</code> 事件。</p><p translation-origin=\"off\">Clicking the hero should raise a <code>selected</code> event that the host component (<code>DashboardComponent</code> presumably) can hear:</p>\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test\">\nit('should raise selected event when clicked (triggerEventHandler)', () =&gt; {\n  let selectedHero: Hero | undefined;\n  comp.selected.pipe(first()).subscribe((hero: Hero) =&gt; selectedHero = hero);\n\n  heroDe.triggerEventHandler('click');\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<p translation-result=\"on\">該元件的 <code>selected</code> 屬性給消費者返回了一個 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>，它看起來像是 RxJS 的同步 <code>Observable</code>。該測試只有在宿主元件<em>隱含</em>觸發時才需要<em>顯式</em>訂閱它。</p><p translation-origin=\"off\">The component's <code>selected</code> property returns an <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>, which looks like an RxJS synchronous <code>Observable</code> to consumers.\nThe test subscribes to it <em>explicitly</em> just as the host component does <em>implicitly</em>.</p>\n\n<p translation-result=\"on\">當元件的行為符合預期時，單擊此英雄的元素就會告訴元件的 <code>selected</code> 屬性發出了一個 <code>hero</code> 物件。</p><p translation-origin=\"off\">If the component behaves as expected, clicking the hero's element should tell the component's <code>selected</code> property to emit the <code>hero</code> object.</p>\n\n<p translation-result=\"on\">該測試透過對 <code>selected</code> 的訂閱來檢測該事件。</p><p translation-origin=\"off\">The test detects that event through its subscription to <code>selected</code>.</p>\n\n<p><a id=\"trigger-event-handler\"></a></p>\n<h4 id=\"triggereventhandler\"><code>triggerEventHandler</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#triggereventhandler\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\">前面測試中的 <code>heroDe</code> 是一個指向英雄條目 <code>&lt;div&gt;</code> 的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</p><p translation-origin=\"off\">The <code>heroDe</code> in the previous test is a <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> that represents the hero <code>&lt;div&gt;</code>.</p>\n\n<p translation-result=\"on\">它有一些用於抽象與原生元素互動的 Angular 屬性和方法。這個測試會使用事件名稱 <code>click</code> 來呼叫 <code>DebugElement.triggerEventHandler</code>。<code>click</code> 的事件繫結到了 <code>DashboardHeroComponent.click()</code>。</p><p translation-origin=\"off\">It has Angular properties and methods that abstract interaction with the native element.\nThis test calls the <code>DebugElement.triggerEventHandler</code> with the \"click\" event name.\nThe \"click\" event binding responds by calling <code>DashboardHeroComponent.click()</code>.</p>\n\n<p translation-result=\"on\">Angular 的 <code>DebugElement.triggerEventHandler</code> 可以用<strong>事件的名字</strong>觸發<strong>任何資料繫結事件</strong>。第二個引數是傳給事件處理器的事件物件。</p><p translation-origin=\"off\">The Angular <code>DebugElement.triggerEventHandler</code> can raise <em>any data-bound event</em> by its <em>event name</em>.\nThe second parameter is the event object passed to the handler.</p>\n\n<p translation-result=\"on\">該測試觸發了一個 “click” 事件。</p><p translation-origin=\"off\">The test triggered a \"click\" event.</p>\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"trigger-event-handler\">\nheroDe.triggerEventHandler('click');\n\n</code-example>\n<p translation-result=\"on\">在這裡，測試程式假設執行時間的事件處理器（元件的 <code>click()</code> 方法）不關心事件物件。</p><p translation-origin=\"off\">In this case, the test correctly assumes that the runtime event handler, the component's <code>click()</code> method, doesn't care about the event object.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">其它處理器的要求比較嚴格。比如，<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令期望一個帶有 <code>button</code> 屬性的物件，該屬性用於指出點選時按下的是哪個滑鼠按鈕（如果有）。如果不給出這個事件物件，<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令就會丟擲一個錯誤。</p><p translation-origin=\"off\">Other handlers are less forgiving.\nFor example, the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> directive expects an object with a <code>button</code> property that identifies which mouse button, if any, was pressed during the click.\nThe <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> directive throws an error if the event object is missing.</p>\n\n</div>\n<h4 id=\"click-the-element\" translation-result=\"on\">點選該元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#click-the-element\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Click the element<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#click-the-element\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">下面這個測試改為呼叫原生元素自己的 <code>click()</code> 方法，它對於<em>這個元件</em>來說相當完美。</p><p translation-origin=\"off\">The following test alternative calls the native element's own <code>click()</code> method, which is perfectly fine for <em>this component</em>.</p>\n\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-2\">\nit('should raise selected event when clicked (element.click)', () =&gt; {\n  let selectedHero: Hero | undefined;\n  comp.selected.pipe(first()).subscribe((hero: Hero) =&gt; selectedHero = hero);\n\n  heroEl.click();\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<p><a id=\"click-helper\"></a></p>\n<h4 id=\"click-helper\" translation-result=\"on\"><code>click()</code> 幫助器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#click-helper\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\"><code>click()</code> helper<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#click-helper\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">點選按鈕、連結或者任意 HTML 元素是很常見的測試任務。</p><p translation-origin=\"off\">Clicking a button, an anchor, or an arbitrary HTML element is a common test task.</p>\n\n<p translation-result=\"on\">把<em>點選事件</em>的處理過程包裝到如下的 <code>click()</code> 輔助函式中，可以讓這項任務更一致、更簡單：</p><p translation-origin=\"off\">Make that consistent and straightforward by encapsulating the <em>click-triggering</em> process in a helper such as the following <code>click()</code> function:</p>\n\n<code-example header=\"testing/index.ts (click helper)\" path=\"testing/src/testing/index.ts\" region=\"click-event\">\n/** Button events to pass to `DebugElement.triggerEventHandler` for <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a> event handler */\nexport const ButtonClickEvents = {\n  left: {button: 0},\n  right: {button: 2}\n};\n\n/** Simulate element click. Defaults to mouse left-button click event. */\nexport function click(el: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>|HTMLElement, eventObj: any = ButtonClickEvents.left): void {\n  if (el instanceof HTMLElement) {\n    el.click();\n  } else {\n    el.triggerEventHandler('click', eventObj);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">第一個引數是<strong>用來點選的元素</strong>。如果你願意，可以將自訂的事件物件傳給第二個引數。預設的是（區域性的）<a href=\"https://developer.mozilla.org/docs/Web/API/MouseEvent/button\">滑鼠左鍵事件物件</a>，它被許多事件處理器接受，包括 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令。</p><p translation-origin=\"off\">The first parameter is the <em>element-to-click</em>.\nIf you want, pass a custom event object as the second parameter.\nThe default is a partial <a href=\"https://developer.mozilla.org/docs/Web/API/MouseEvent/button\">left-button mouse event object</a> accepted by many handlers including the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> directive.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><code>click()</code> 輔助函式<strong>不是</strong>Angular 測試工具之一。它是在<strong>本章的例子程式碼</strong>中定義的函式方法，被所有測試例子所用。如果你喜歡它，將它新增到你自己的輔助函式集。</p><p translation-origin=\"off\">The <code>click()</code> helper function is <strong>not</strong> one of the Angular testing utilities.\nIt's a function defined in <em>this guide's sample code</em>.\nAll of the sample tests use it.\nIf you like it, add it to your own collection of helpers.</p>\n\n</div>\n<p translation-result=\"on\">下面是把前面的測試用 <code>click</code> 輔助函式重寫後的版本。</p><p translation-origin=\"off\">Here's the previous test, rewritten using the click helper.</p>\n\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (test with click helper)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-3\">\nit('should raise selected event when clicked (click helper with <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>)', () =&gt; {\n  let selectedHero: Hero | undefined;\n  comp.selected.pipe(first()).subscribe((hero: Hero) =&gt; selectedHero = hero);\n\n  click(heroDe);  // click helper with <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>\n\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<p><a id=\"component-inside-test-host\"></a></p>\n<h2 id=\"component-inside-a-test-host\" translation-result=\"on\">位於測試宿主中的元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-inside-a-test-host\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Component inside a test host<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#component-inside-a-test-host\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">前面的這些測試都是自己扮演宿主元素 <code>DashboardComponent</code> 的角色。但是當 <code>DashboardHeroComponent</code> 真的繫結到某個宿主元素時還能正常工作嗎？</p><p translation-origin=\"off\">The previous tests played the role of the host <code>DashboardComponent</code> themselves.\nBut does the <code>DashboardHeroComponent</code> work correctly when properly data-bound to a host component?</p>\n\n<p translation-result=\"on\">固然，你也可以測試真實的 <code>DashboardComponent</code>。但要想這麼做需要做很多準備工作，特別是它的範本中使用了某些特性，如 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>、 其它元件、佈局 HTML、附加繫結、注入了多個服務的建構函式、如何用正確的方式與那些服務互動等。</p><p translation-origin=\"off\">You could test with the actual <code>DashboardComponent</code>.\nBut doing so could require a lot of setup, especially when its template features an <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> repeater, other components, layout HTML, additional bindings, a constructor that injects multiple services, and it starts interacting with those services right away.</p>\n\n<p translation-result=\"on\">想出這麼多需要努力排除的干擾，只是為了證明一點 —— 可以造出這樣一個令人滿意的<em>測試宿主</em>：</p><p translation-origin=\"off\">Imagine the effort to disable these distractions, just to prove a point that can be made satisfactorily with a <em>test host</em> like this one:</p>\n\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (test host)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  template: `\n    &lt;dashboard-hero\n      [hero]=\"hero\" (selected)=\"onSelected($event)\"&gt;\n    &lt;/dashboard-hero&gt;`\n})\nclass TestHostComponent {\n  hero: Hero = {id: 42, name: 'Test Name'};\n  selectedHero: Hero | undefined;\n  onSelected(hero: Hero) {\n    this.selectedHero = hero;\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">這個測試宿主像 <code>DashboardComponent</code> 那樣綁定了 <code>DashboardHeroComponent</code>，但是沒有 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>、 沒有 <code>HeroService</code>，也沒有 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>。</p><p translation-origin=\"off\">This test host binds to <code>DashboardHeroComponent</code> as the <code>DashboardComponent</code> would but without the noise of the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>, the <code>HeroService</code>, or the <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> repeater.</p>\n\n<p translation-result=\"on\">這個測試宿主使用其測試用的英雄設定了元件的輸入屬性 <code>hero</code>。它使用 <code>onSelected</code> 事件處理器綁定了元件的 <code>selected</code> 事件，其中把事件中發出的英雄記錄到了 <code>selectedHero</code> 屬性中。</p><p translation-origin=\"off\">The test host sets the component's <code>hero</code> input property with its test hero.\nIt binds the component's <code>selected</code> event with its <code>onSelected</code> handler, which records the emitted hero in its <code>selectedHero</code> property.</p>\n\n<p translation-result=\"on\">稍後，這個測試就可以輕鬆檢查 <code>selectedHero</code> 以驗證 <code>DashboardHeroComponent.selected</code> 事件確實發出了所期望的英雄。</p><p translation-origin=\"off\">Later, the tests will be able to check <code>selectedHero</code> to verify that the <code>DashboardHeroComponent.selected</code> event emitted the expected hero.</p>\n\n<p translation-result=\"on\">這個<em>測試宿主</em>中的準備程式碼和獨立測試中的準備過程類似：</p><p translation-origin=\"off\">The setup for the <code>test-host</code> tests is similar to the setup for the stand-alone tests:</p>\n\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (test host setup)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-setup\">\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({declarations: [DashboardHeroComponent, TestHostComponent]})\n// create TestHostComponent instead of DashboardHeroComponent\nfixture = TestBed.createComponent(TestHostComponent);\ntestHost = fixture.componentInstance;\nheroEl = fixture.nativeElement.querySelector('.hero');\nfixture.detectChanges();  // <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> initial data binding\n\n</code-example>\n<p translation-result=\"on\">這個測試模組的配置資訊有三個重要的不同點：</p><p translation-origin=\"off\">This testing module configuration shows three important differences:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">它同時<strong>宣告</strong>了 <code>DashboardHeroComponent</code> 和 <code>TestHostComponent</code>。</p><p translation-origin=\"off\">It <em>declares</em> both the <code>DashboardHeroComponent</code> and the <code>TestHostComponent</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">它<strong>建立</strong>了 <code>TestHostComponent</code>，而非 <code>DashboardHeroComponent</code>。</p><p translation-origin=\"off\">It <em>creates</em> the <code>TestHostComponent</code> instead of the <code>DashboardHeroComponent</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>TestHostComponent</code> 透過繫結機制設定了 <code>DashboardHeroComponent.hero</code>。</p><p translation-origin=\"off\">The <code>TestHostComponent</code> sets the <code>DashboardHeroComponent.hero</code> with a binding</p>\n\n</li>\n</ul>\n<p translation-result=\"on\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> 返回的 <code>fixture</code> 裡有 <code>TestHostComponent</code> 例項，而非 <code>DashboardHeroComponent</code> 元件例項。</p><p translation-origin=\"off\">The <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> returns a <code>fixture</code> that holds an instance of <code>TestHostComponent</code> instead of an instance of <code>DashboardHeroComponent</code>.</p>\n\n<p translation-result=\"on\">當然，建立 <code>TestHostComponent</code> 有建立 <code>DashboardHeroComponent</code> 的副作用，因為後者出現在前者的範本中。英雄元素（<code>heroEl</code>）的查詢陳述式仍然可以在測試 DOM 中找到它，儘管元素樹比以前更深。</p><p translation-origin=\"off\">Creating the <code>TestHostComponent</code> has the side effect of creating a <code>DashboardHeroComponent</code> because the latter appears within the template of the former.\nThe query for the hero element (<code>heroEl</code>) still finds it in the test DOM, albeit at greater depth in the element tree than before.</p>\n\n<p translation-result=\"on\">這些測試本身和它們的孤立版本幾乎相同：</p><p translation-origin=\"off\">The tests themselves are almost identical to the stand-alone version:</p>\n\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (test-host)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-tests\">\nit('should display hero name', () =&gt; {\n  const expectedPipedName = testHost.hero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\nit('should raise selected event when clicked', () =&gt; {\n  click(heroEl);\n  // selected hero should be the same data bound hero\n  expect(testHost.selectedHero).toBe(testHost.hero);\n});\n\n</code-example>\n<p translation-result=\"on\">只有 selected 事件的測試不一樣。它確保被選擇的 <code>DashboardHeroComponent</code> 英雄確實透過事件繫結被傳遞到宿主元件。</p><p translation-origin=\"off\">Only the selected event test differs.\nIt confirms that the selected <code>DashboardHeroComponent</code> hero really does find its way up through the event binding to the host component.</p>\n\n<p><a id=\"routing-component\"></a></p>\n<h2 id=\"routing-component\" translation-result=\"on\">路由元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#routing-component\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Routing component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#routing-component\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">所謂<em>路由元件</em>就是指會要求 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 導航到其它元件的元件。<code>DashboardComponent</code> 就是一個<em>路由元件</em>，因為使用者可以透過點選儀表盤中的某個<em>英雄按鈕</em>來導航到 <code>HeroDetailComponent</code>。</p><p translation-origin=\"off\">A <em>routing component</em> is a component that tells the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> to navigate to another component.\nThe <code>DashboardComponent</code> is a <em>routing component</em> because the user can navigate to the <code>HeroDetailComponent</code> by clicking on one of the <em>hero buttons</em> on the dashboard.</p>\n\n<p translation-result=\"on\">路由確實很複雜。測試 <code>DashboardComponent</code> 看上去有點令人生畏，因為它牽扯到和 <code>HeroService</code> 一起注入進來的 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>。</p><p translation-origin=\"off\">Routing is pretty complicated.\nTesting the <code>DashboardComponent</code> seemed daunting in part because it involves the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>, which it injects together with the <code>HeroService</code>.</p>\n\n<code-example header=\"app/dashboard/dashboard.component.ts (constructor)\" path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\">\nconstructor(private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>, private heroService: HeroService) {}\n\n</code-example>\n<code-example header=\"app/dashboard/dashboard.component.ts (goToDetail)\" path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"goto-detail\">\ngotoDetail(hero: Hero) {\n  const url = `/heroes/${hero.id}`;\n  this.router.navigateByUrl(url);\n}\n\n</code-example>\n<p translation-result=\"on\">Angular 提供了一些測試助手來減少樣板程式碼並更有效地測試依賴於 Router 和 HttpClient 的程式碼。</p><p translation-origin=\"off\">Angular provides test helpers to reduce boilerplate and more effectively test code which depends on the Router and HttpClient.</p>\n\n<code-example header=\"app/dashboard/dashboard.component.spec.ts\" path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"router-harness\">\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({\n      providers: [\n        <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{path: '**', component: DashboardComponent}]),\n        <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n        <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n        HeroService,\n      ]\n    })\n    .compileComponents()\n    .then(async () =&gt; {\n      harness = await RouterTestingHarness.create();\n      comp = await harness.navigateByUrl('/', DashboardComponent);\n      TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne('api/heroes').flush(getTestHeroes());\n    });\n\n</code-example>\n<p translation-result=\"on\">下面這個測試會點選正在顯示的英雄，並確認我們正在導航到所期望的 URL。</p><p translation-origin=\"off\">The following test clicks the displayed hero and confirms that we navigate to the expected URL.</p>\n\n<code-example header=\"app/dashboard/dashboard.component.spec.ts (navigate test)\" path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"navigate-test\">\nit('should tell navigate when hero clicked', async () =&gt; {\n  await heroClick();  // <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> click on first inner &lt;div class=\"hero\"&gt;\n\n  // expecting to navigate to id of the component's first hero\n  const id = comp.heroes[0].id;\n  expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url)\n      .withContext('should nav to HeroDetail for first hero')\n      .toEqual(`/heroes/${id}`);\n});\n\n</code-example>\n<p><a id=\"routed-component-w-param\"></a></p>\n<h2 id=\"routed-components\" translation-result=\"on\">路由目標元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#routed-components\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Routed components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#routed-components\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><em>路由目標元件</em>是指 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 導航到的目標。它測試起來可能很複雜，特別是當路由到的這個元件<em>包含引數</em>的時候。<code>HeroDetailComponent</code> 就是一個<em>路由目標元件</em>，它是某個路由定義指向的目標。</p><p translation-origin=\"off\">A <em>routed component</em> is the destination of a <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> navigation.\nIt can be trickier to test, especially when the route to the component <em>includes parameters</em>.\nThe <code>HeroDetailComponent</code> is a <em>routed component</em> that is the destination of such a route.</p>\n\n<p translation-result=\"on\">當用戶點選<em>儀表盤</em>中的英雄時，<code>DashboardComponent</code> 會要求 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 導航到 <code>heroes/:id</code>。<code>:id</code> 是一個路由引數，它的值就是所要編輯的英雄的 <code>id</code>。</p><p translation-origin=\"off\">When a user clicks a <em>Dashboard</em> hero, the <code>DashboardComponent</code> tells the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> to navigate to <code>heroes/:id</code>.\nThe <code>:id</code> is a route parameter whose value is the <code>id</code> of the hero to edit.</p>\n\n<p translation-result=\"on\">該 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 會根據那個 URL 匹配到一個指向 <code>HeroDetailComponent</code> 的路由。它會建立一個帶有路由資訊的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 物件，並把它注入到一個 <code>HeroDetailComponent</code> 的新例項中。</p><p translation-origin=\"off\">The <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> matches that URL to a route to the <code>HeroDetailComponent</code>.\nIt creates an <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> object with the routing information and injects it into a new instance of the <code>HeroDetailComponent</code>.</p>\n\n<p translation-result=\"on\">下面是 <code>HeroDetailComponent</code> 的建構函式：</p><p translation-origin=\"off\">Here's the <code>HeroDetailComponent</code> constructor:</p>\n\n<code-example header=\"app/hero/hero-detail.component.ts (constructor)\" path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ctor\">\nconstructor(\n  private heroDetailService: HeroDetailService,\n  private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n}\n\n</code-example>\n<p translation-result=\"on\"><code>HeroDetailComponent</code> 元件需要一個 <code>id</code> 引數，以便透過 <code>HeroDetailService</code> 獲取相應的英雄。該元件只能從 <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 屬性中獲取這個 <code>id</code>，這個屬性是一個 <code>Observable</code>。</p><p translation-origin=\"off\">The <code>HeroDetail</code> component needs the <code>id</code> parameter so it can fetch the corresponding hero using the <code>HeroDetailService</code>.\nThe component has to get the <code>id</code> from the <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> property which is an <code>Observable</code>.</p>\n\n<p translation-result=\"on\">它不能僅僅參考 <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 的 <code>id</code> 屬性。該元件不得不<em>訂閱</em> <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 這個可觀察物件，要做好它在生命週期中隨時會發生變化的準備。</p><p translation-origin=\"off\">It can't just reference the <code>id</code> property of the <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code>.\nThe component has to <em>subscribe</em> to the <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> observable and be prepared for the <code>id</code> to change during its lifetime.</p>\n\n<code-example header=\"app/hero/hero-detail.component.ts (ngOnInit)\" path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ng-on-init\">\nngOnInit(): void {\n  // get hero when `id` param changes\n  this.route.paramMap.subscribe(pmap =&gt; this.getHero(pmap.get('id')));\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><a href=\"guide/router-tutorial-toh\">路由課程：英雄之旅</a>一章的 <a href=\"guide/router-tutorial-toh#activated-route-in-action\">ActivatedRoute 實戰</a>部分詳細講解了 <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code>。</p><p translation-origin=\"off\">The <a href=\"guide/router-tutorial-toh#activated-route-in-action\">ActivatedRoute in action</a> section of the <a href=\"guide/router-tutorial-toh\">Router tutorial: tour of heroes</a> guide covers <code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> in more detail.</p>\n\n</div>\n<p translation-result=\"on\">透過導航到不同的路由，測試可以探查 <code>HeroDetailComponent</code> 是如何對不同的 <code>id</code> 引數值做出響應的。</p><p translation-origin=\"off\">Tests can explore how the <code>HeroDetailComponent</code> responds to different <code>id</code> parameter values by navigating to different routes.</p>\n\n<h4 id=\"testing-with-the-routertestingharness\" translation-result=\"on\">使用 <code>ActivatedRouteStub</code> 進行測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/router/testing/RouterTestingHarness\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Testing with the <code><a href=\"api/router/testing/RouterTestingHarness\" class=\"code-anchor\">RouterTestingHarness</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#testing-with-the-routertestingharness\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">下面的測試程式是示範元件在被觀察的 <code>id</code> 指向現有英雄時的行為：</p><p translation-origin=\"off\">Here's a test demonstrating the component's behavior when the observed <code>id</code> refers to an existing hero:</p>\n\n<code-example header=\"app/hero/hero-detail.component.spec.ts (existing id)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-good-id\">\ndescribe('when navigate to existing hero', () =&gt; {\n  let expectedHero: Hero;\n\n  beforeEach(async () =&gt; {\n    expectedHero = firstHero;\n    await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(expectedHero.id);\n  });\n  it('should display that hero\\'s name', () =&gt; {\n    expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n  });\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">稍後會對 <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> 方法和 <code>page</code> 物件進行討論。不過目前，你只要憑直覺來理解就行了。</p><p translation-origin=\"off\">In the following section, the <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> method and <code>page</code> object are discussed.\nRely on your intuition for now.</p>\n\n</div>\n<p translation-result=\"on\">當找不到 <code>id</code> 的時候，元件應該重新路由到 <code>HeroListComponent</code>。</p><p translation-origin=\"off\">When the <code>id</code> cannot be found, the component should re-route to the <code>HeroListComponent</code>.</p>\n\n<p translation-result=\"on\">測試套件的準備程式碼提供了一個和<a href=\"guide/testing-components-scenarios#routing-component\">前面</a>一樣的路由器間諜，它會充當路由器的角色，而不用發起實際的導航。</p><p translation-origin=\"off\">The test suite setup provided the same router harness <a href=\"guide/testing-components-scenarios#routing-component\">described above</a>.</p>\n\n<p translation-result=\"on\">這個測試中會期待該元件嘗試導航到 <code>HeroListComponent</code>。</p><p translation-origin=\"off\">This test expects the component to try to navigate to the <code>HeroListComponent</code>.</p>\n\n<code-example header=\"app/hero/hero-detail.component.spec.ts (bad id)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-bad-id\">\ndescribe('when navigate to non-existent hero id', () =&gt; {\n  beforeEach(async () =&gt; {\n    await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(999);\n  });\n\n  it('should try to navigate back to hero list', () =&gt; {\n    expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes');\n  });\n});\n\n</code-example>\n<h2 id=\"nested-component-tests\" translation-result=\"on\">對巢狀(Nesting)元件的測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#nested-component-tests\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Nested component tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#nested-component-tests\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">元件的範本中通常還會有巢狀(Nesting)元件，巢狀(Nesting)元件的範本還可能包含更多元件。</p><p translation-origin=\"off\">Component templates often have nested components, whose templates might contain more components.</p>\n\n<p translation-result=\"on\">這棵元件樹可能非常深，並且大多數時候在測試這棵樹頂部的元件時，這些巢狀(Nesting)的元件都無關緊要。</p><p translation-origin=\"off\">The component tree can be very deep and, most of the time, the nested components play no role in testing the component at the top of the tree.</p>\n\n<p translation-result=\"on\">比如，<code>AppComponent</code> 會顯示一個帶有連結及其 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令的導覽列。</p><p translation-origin=\"off\">The <code>AppComponent</code>, for example, displays a navigation bar with anchors and their <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> directives.</p>\n\n<code-example header=\"app/app.component.html\" path=\"testing/src/app/app.component.html\">\n&lt;app-banner&gt;&lt;/app-banner&gt;\n&lt;app-welcome&gt;&lt;/app-welcome&gt;\n&lt;nav&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/dashboard\"&gt;Dashboard&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\"&gt;Heroes&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/about\"&gt;About&lt;/a&gt;\n&lt;/nav&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n\n</code-example>\n<p translation-result=\"on\">要想驗證這些連結，你不必用 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 進行導航，也不必使用 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 來指出 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 應該把<em>路由目標元件</em>插入到什麼地方。</p><p translation-origin=\"off\">To validate the links, you don't need the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> to navigate and you don't need the <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> to mark where the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> inserts <em>routed components</em>.</p>\n\n<p translation-result=\"on\">而 <code>BannerComponent</code> 和 <code>WelcomeComponent</code>（寫作 <code>&lt;app-banner&gt;</code> 和 <code>&lt;app-welcome&gt;</code>）也同樣風馬牛不相及。</p><p translation-origin=\"off\">The <code>BannerComponent</code> and <code>WelcomeComponent</code> (indicated by <code>&lt;app-banner&gt;</code> and <code>&lt;app-welcome&gt;</code>) are also irrelevant.</p>\n\n<p translation-result=\"on\">然而，任何測試，只要能在 DOM 中建立 <code>AppComponent</code>，也就同樣能建立這三個元件的例項。如果要建立它們，你就要配置 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>。</p><p translation-origin=\"off\">Yet any test that creates the <code>AppComponent</code> in the DOM also creates instances of these three components and, if you let that happen, you'll have to configure the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> to create them.</p>\n\n<p translation-result=\"on\">如果你忘了宣告它們，Angular 編譯器就無法在 <code>AppComponent</code> 範本中識別出 <code>&lt;app-banner&gt;</code>、<code>&lt;app-welcome&gt;</code> 和 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 標記，並丟擲一個錯誤。</p><p translation-origin=\"off\">If you neglect to declare them, the Angular compiler won't recognize the <code>&lt;app-banner&gt;</code>, <code>&lt;app-welcome&gt;</code>, and <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> tags in the <code>AppComponent</code> template and will throw an error.</p>\n\n<p translation-result=\"on\">如果你宣告的這些都是真實的元件，那麼也同樣要宣告<em>它們</em>的巢狀(Nesting)元件，並要為這棵元件樹中的<em>任何</em>元件提供要注入的<em>所有</em>服務。</p><p translation-origin=\"off\">If you declare the real components, you'll also have to declare <em>their</em> nested components and provide for <em>all</em> services injected in <em>any</em> component in the tree.</p>\n\n<p translation-result=\"on\">如果只是想回答關於連結的一些簡單問題，做這些顯然就太多了。</p><p translation-origin=\"off\">That's too much effort just to answer a few simple questions about links.</p>\n\n<p translation-result=\"on\">本節會講減少此類準備工作的兩項技術。單獨使用或組合使用它們，可以讓這些測試聚焦於要測試的主要元件上。</p><p translation-origin=\"off\">This section describes two techniques for minimizing the setup.\nUse them, alone or in combination, to stay focused on testing the primary component.</p>\n\n<p><a id=\"stub-component\"></a></p>\n<h5 id=\"stubbing-unneeded-components\" translation-result=\"on\">對不需要的元件提供樁（stub）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#stubbing-unneeded-components\"><i class=\"material-icons\">link</i></a></h5><h5 translation-origin=\"off\">Stubbing unneeded components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#stubbing-unneeded-components\"><i class=\"material-icons\">link</i></a></h5>\n\n<p translation-result=\"on\">這項技術中，你要為那些在測試中無關緊要的元件或指令建立和宣告一些測試樁。</p><p translation-origin=\"off\">In the first technique, you create and declare stub versions of the components and directive that play little or no role in the tests.</p>\n\n<code-example header=\"app/app.component.spec.ts (stub declaration)\" path=\"testing/src/app/app.component.spec.ts\" region=\"component-stubs\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({selector: 'app-banner', template: ''})\nclass BannerStubComponent {\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({selector: '<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>', template: ''})\nclass RouterOutletStubComponent {\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({selector: 'app-welcome', template: ''})\nclass WelcomeStubComponent {\n}\n\n</code-example>\n<p translation-result=\"on\">這些測試樁的選擇器要和其對應的真實元件一致，但其範本和類是空的。</p><p translation-origin=\"off\">The stub selectors match the selectors for the corresponding real components.\nBut their templates and classes are empty.</p>\n\n<p translation-result=\"on\">然後在 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置中那些真正有用的元件、指令、管道之後宣告它們。</p><p translation-origin=\"off\">Then declare them in the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration next to the components, directives, and pipes that need to be real.</p>\n\n<code-example header=\"app/app.component.spec.ts (TestBed stubs)\" path=\"testing/src/app/app.component.spec.ts\" region=\"testbed-stubs\">\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({\n      imports: [<a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>],\n      providers: [<a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([])],\n      declarations:\n          [AppComponent, BannerStubComponent, RouterOutletStubComponent, WelcomeStubComponent]\n    })\n\n</code-example>\n<p translation-result=\"on\"><code>AppComponent</code> 是該測試的主角，因此當然要用它的真實版本。</p><p translation-origin=\"off\">The <code>AppComponent</code> is the test subject, so of course you declare the real version.</p>\n\n<p translation-result=\"on\">其它都是測試樁。</p><p translation-origin=\"off\">The rest are stubs.</p>\n\n<p><a id=\"no-errors-schema\"></a></p>\n<h4 id=\"no_errors_schema\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#no_errors_schema\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\">第二種辦法就是把 <code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 新增到 <code>TestBed.schemas</code> 的元資料中。</p><p translation-origin=\"off\">In the second approach, add <code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> to the <code>TestBed.schemas</code> metadata.</p>\n\n<code-example header=\"app/app.component.spec.ts (NO_ERRORS_SCHEMA)\" path=\"testing/src/app/app.component.spec.ts\" region=\"no-errors-schema\">\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({\n      declarations: [\n        AppComponent,\n      ],\n      providers: [<a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([])],\n      imports: [<a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>],\n      schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n    })\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 會要求 Angular 編譯器忽略不認識的那些元素和屬性。</p><p translation-origin=\"off\">The <code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> tells the Angular compiler to ignore unrecognized elements and attributes.</p>\n\n<p translation-result=\"on\">編譯器將會識別出 <code>&lt;app-root&gt;</code> 元素和 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 屬性，因為你在 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置中聲明瞭相應的 <code>AppComponent</code> 和 <code>RouterLinkDirectiveStub</code>。</p><p translation-origin=\"off\">The compiler recognizes the <code>&lt;app-root&gt;</code> element and the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> attribute because you declared a corresponding <code>AppComponent</code> and <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> in the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration.</p>\n\n<p translation-result=\"on\">但編譯器在遇到 <code>&lt;app-banner&gt;</code>、<code>&lt;app-welcome&gt;</code> 或 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 時不會報錯。它只會把它們渲染成空白標籤，而瀏覽器會忽略這些標籤。</p><p translation-origin=\"off\">But the compiler won't throw an error when it encounters <code>&lt;app-banner&gt;</code>, <code>&lt;app-welcome&gt;</code>, or <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>.\nIt simply renders them as empty tags and the browser ignores them.</p>\n\n<p translation-result=\"on\">你不用再提供樁元件了。</p><p translation-origin=\"off\">You no longer need the stub components.</p>\n\n<h4 id=\"use-both-techniques-together\" translation-result=\"on\">同時使用這兩項技術<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#use-both-techniques-together\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Use both techniques together<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#use-both-techniques-together\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">這些是進行<em>淺層</em>測試要用到的技術，之所以叫淺層測試是因為只包含本測試所關心的這個元件範本中的元素。</p><p translation-origin=\"off\">These are techniques for <em>Shallow Component Testing</em>, so-named because they reduce the visual surface of the component to just those elements in the component's template that matter for tests.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 方法在這兩者中比較簡單，但也不要過度使用它。</p><p translation-origin=\"off\">The <code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> approach is the easier of the two but don't overuse it.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 還會阻止編譯器告訴你因為的疏忽或拼寫錯誤而缺失的元件和屬性。你如果人工找出這些 bug 可能要浪費幾個小時，但編譯器可以立即捕獲它們。</p><p translation-origin=\"off\">The <code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> also prevents the compiler from telling you about the missing components and attributes that you omitted inadvertently or misspelled.\nYou could waste hours chasing phantom bugs that the compiler would have caught in an instant.</p>\n\n<p translation-result=\"on\"><em>樁元件</em>方式還有其它優點。雖然<em>這個</em>例子中的樁是空的，但你如果想要和它們用某種形式互動，也可以給它們一些裁剪過的範本和類別。</p><p translation-origin=\"off\">The <em>stub component</em> approach has another advantage.\nWhile the stubs in <em>this</em> example were empty, you could give them stripped-down templates and classes if your tests need to interact with them in some way.</p>\n\n<p translation-result=\"on\">在實踐中，你可以在準備程式碼中組合使用這兩種技術，例子如下。</p><p translation-origin=\"off\">In practice you will combine the two techniques in the same setup, as seen in this example.</p>\n\n<code-example header=\"app/app.component.spec.ts (mixed setup)\" path=\"testing/src/app/app.component.spec.ts\" region=\"mixed-setup\">\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({\n      declarations: [\n        AppComponent,\n        BannerStubComponent,\n      ],\n      providers: [<a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([])],\n      imports: [<a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>],\n      schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n    })\n\n</code-example>\n<p translation-result=\"on\">Angular 編譯器會為 <code>&lt;app-banner&gt;</code> 元素建立 <code>BannerStubComponent</code>，並把 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 應用到帶有 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 屬性的連結上，不過它會忽略 <code>&lt;app-welcome&gt;</code> 和 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 標籤。</p><p translation-origin=\"off\">The Angular compiler creates the <code>BannerStubComponent</code> for the <code>&lt;app-banner&gt;</code> element and applies the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> to the anchors with the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> attribute, but it ignores the <code>&lt;app-welcome&gt;</code> and <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> tags.</p>\n\n<p><a id=\"by-directive\"></a>\n<a id=\"inject-directive\"></a></p>\n<h4 id=\"bydirective-and-injected-directives\" translation-result=\"on\"><code>By.directive</code> 與注入的指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#bydirective-and-injected-directives\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\"><code>By.directive</code> and injected directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#bydirective-and-injected-directives\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">再一步配置觸發了資料繫結的初始化，獲取導航連結的參考：</p><p translation-origin=\"off\">A little more setup triggers the initial data binding and gets references to the navigation links:</p>\n\n<code-example header=\"app/app.component.spec.ts (test setup)\" path=\"testing/src/app/app.component.spec.ts\" region=\"test-setup\">\nbeforeEach(() =&gt; {\n  fixture.detectChanges();  // <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> initial data binding\n\n  // find DebugElements with an attached RouterLinkStubDirective\n  linkDes = fixture.debugElement.queryAll(By.directive(<a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>));\n\n  // get attached link directive instances\n  // using each <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>'s injector\n  routerLinks = linkDes.map(de =&gt; de.injector.get(<a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a>));\n});\n\n</code-example>\n<p translation-result=\"on\">有三點特別重要：</p><p translation-origin=\"off\">Three points of special interest:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">你可以使用 <code>By.directive</code> 來定位一個帶附屬指令的連結元素。</p><p translation-origin=\"off\">Locate the anchor elements with an attached directive using <code>By.directive</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">該查詢返回包含了匹配元素的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 包裝器。</p><p translation-origin=\"off\">The query returns <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> wrappers around the matching elements</p>\n\n</li>\n<li>\n<p translation-result=\"on\">每個 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 都會匯出該元素中的一個依賴注入器，其中帶有指定的指令例項。</p><p translation-origin=\"off\">Each <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> exposes a dependency injector with the specific instance of the directive attached to that element</p>\n\n</li>\n</ul>\n<p translation-result=\"on\"><code>AppComponent</code> 中要驗證的連結如下：</p><p translation-origin=\"off\">The <code>AppComponent</code> links to validate are as follows:</p>\n\n<code-example header=\"app/app.component.html (navigation links)\" path=\"testing/src/app/app.component.html\" region=\"links\">\n&lt;nav&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/dashboard\"&gt;Dashboard&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\"&gt;Heroes&lt;/a&gt;\n  &lt;a <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/about\"&gt;About&lt;/a&gt;\n&lt;/nav&gt;\n\n</code-example>\n<p><a id=\"app-component-tests\"></a></p>\n<p translation-result=\"on\">下面這些測試用來確認那些連結是否如預期般連線到了 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令中：</p><p translation-origin=\"off\">Here are some tests that confirm those links are wired to the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> directives as expected:</p>\n\n<code-example header=\"app/app.component.spec.ts (selected tests)\" path=\"testing/src/app/app.component.spec.ts\" region=\"tests\">\nit('can get RouterLinks from template', () =&gt; {\n  expect(routerLinks.length).withContext('should have 3 routerLinks').toBe(3);\n  expect(routerLinks[0].href).toBe('/dashboard');\n  expect(routerLinks[1].href).toBe('/heroes');\n  expect(routerLinks[2].href).toBe('/about');\n});\n\nit('can click Heroes link in template', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n     const heroesLinkDe = linkDes[1];  // heroes link <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>\n\n     TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).resetConfig([{path: '**', children: []}]);\n     heroesLinkDe.triggerEventHandler('click', {button: 0});\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();\n     fixture.detectChanges();\n\n     expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toBe('/heroes');\n   }));\n\n</code-example>\n<p><a id=\"page-object\"></a></p>\n<h2 id=\"use-a-page-object\" translation-result=\"on\">使用 <code>page</code> 物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#use-a-page-object\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Use a <code>page</code> object<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#use-a-page-object\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code>HeroDetailComponent</code> 是帶有標題、兩個英雄欄位和兩個按鈕的簡單檢視。</p><p translation-origin=\"off\">The <code>HeroDetailComponent</code> is a simple view with a title, two hero fields, and two buttons.</p>\n\n<div class=\"lightbox\">\n<img alt=\"HeroDetailComponent in action\" src=\"generated/images/guide/testing/hero-detail.component.png\" width=\"269\" height=\"170\">\n</div>\n<p translation-result=\"on\">但即使是這麼簡單的表單，其範本中也涉及到不少複雜性。</p><p translation-origin=\"off\">But there's plenty of template complexity even in this simple form.</p>\n\n<code-example path=\"testing/src/app/hero/hero-detail.component.html\" header=\"app/hero/hero-detail.component.html\">\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\"&gt;\n  &lt;h2&gt;&lt;span&gt;{{hero.name | <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">titlecase</a>}}&lt;/span&gt; Details&lt;/h2&gt;\n  &lt;div&gt;\n    &lt;span&gt;id: &lt;/span&gt;{{hero.id}}&lt;/div&gt;\n  &lt;div&gt;\n    &lt;label for=\"name\"&gt;name: &lt;/label&gt;\n    &lt;input id=\"name\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" placeholder=\"name\" /&gt;\n  &lt;/div&gt;\n  &lt;button type=\"button\" (click)=\"save()\"&gt;Save&lt;/button&gt;\n  &lt;button type=\"button\" (click)=\"cancel()\"&gt;Cancel&lt;/button&gt;\n&lt;/div&gt;\n\n\n</code-example>\n<p translation-result=\"on\">這些供練習用的元件需要 ……</p><p translation-origin=\"off\">Tests that exercise the component need …</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">等獲取到英雄之後才能讓元素出現在 DOM 中</p><p translation-origin=\"off\">To wait until a hero arrives before elements appear in the DOM</p>\n\n</li>\n<li>\n<p translation-result=\"on\">一個對標題文字的參考</p><p translation-origin=\"off\">A reference to the title text</p>\n\n</li>\n<li>\n<p translation-result=\"on\">一個對 name 輸入框的參考，以便對它進行探查和修改</p><p translation-origin=\"off\">A reference to the name input box to inspect and set it</p>\n\n</li>\n<li>\n<p translation-result=\"on\">參考兩個按鈕，以便點選它們</p><p translation-origin=\"off\">References to the two buttons so they can click them</p>\n\n</li>\n<li>\n<p translation-result=\"on\">為元件和路由器的方法安插間諜</p><p translation-origin=\"off\">Spies for some of the component and router methods</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">即使是像這樣一個很小的表單，也能產生令人瘋狂的錯綜複雜的條件設定和 CSS 元素選擇。</p><p translation-origin=\"off\">Even a small form such as this one can produce a mess of tortured conditional setup and CSS element selection.</p>\n\n<p translation-result=\"on\">可以使用 <code>Page</code> 類來征服這種複雜性。<code>Page</code> 類可以處理對元件屬性的存取，並對設定這些屬性的邏輯進行封裝。</p><p translation-origin=\"off\">Tame the complexity with a <code>Page</code> class that handles access to component properties and encapsulates the logic that sets them.</p>\n\n<p translation-result=\"on\">下面是一個供 <code>hero-detail.component.spec.ts</code> 使用的 <code>Page</code> 類</p><p translation-origin=\"off\">Here is such a <code>Page</code> class for the <code>hero-detail.component.spec.ts</code></p>\n\n<code-example header=\"app/hero/hero-detail.component.spec.ts (Page)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"page\">\nclass Page {\n  // getter properties wait to <a href=\"api/animations/query\" class=\"code-anchor\">query</a> the DOM until called.\n  get buttons() {\n    return this.queryAll&lt;HTMLButtonElement&gt;('button');\n  }\n  get saveBtn() {\n    return this.buttons[0];\n  }\n  get cancelBtn() {\n    return this.buttons[1];\n  }\n  get nameDisplay() {\n    return this.query&lt;HTMLElement&gt;('span');\n  }\n  get nameInput() {\n    return this.query&lt;HTMLInputElement&gt;('input');\n  }\n\n  //// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> helpers ////\n  private <a href=\"api/animations/query\" class=\"code-anchor\">query</a>&lt;T&gt;(selector: string): T {\n    return harness.routeNativeElement!.querySelector(selector)! as T;\n  }\n\n  private queryAll&lt;T&gt;(selector: string): T[] {\n    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">現在，用來操作和檢查元件的重要鉤子都被井然有序的組織起來了，可以透過 <code>page</code> 例項來使用它們。</p><p translation-origin=\"off\">Now the important hooks for component manipulation and inspection are neatly organized and accessible from an instance of <code>Page</code>.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> 方法會建立一個 <code>page</code> 物件，並在 <code>hero</code> 到來時自動填補空白。</p><p translation-origin=\"off\">A <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> method creates a <code>page</code> object and fills in the blanks once the <code>hero</code> arrives.</p>\n\n<code-example header=\"app/hero/hero-detail.component.spec.ts (createComponent)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"create-component\">\nasync function <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(id: number) {\n  harness = await RouterTestingHarness.create();\n  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);\n  page = new Page();\n\n  const request = TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne(`api/heroes/?id=${id}`);\n  const hero = getTestHeroes().find(h =&gt; h.id === Number(id));\n  request.flush(hero ? [hero] : []);\n  harness.detectChanges();\n}\n\n</code-example>\n<p translation-result=\"on\">還有更多的 <code>HeroDetailComponent</code> 測試可以證明這一點。</p><p translation-origin=\"off\">Here are a few more <code>HeroDetailComponent</code> tests to reinforce the point.</p>\n\n<code-example header=\"app/hero/hero-detail.component.spec.ts (selected tests)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"selected-tests\">\nit('should display that hero\\'s name', () =&gt; {\n  expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n});\n\nit('should navigate when click cancel', () =&gt; {\n  click(page.cancelBtn);\n  expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual(`/heroes/${expectedHero.id}`);\n});\n\nit('should save when click save but not navigate immediately', () =&gt; {\n  click(page.saveBtn);\n  expect(TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne({method: 'PUT', url: 'api/heroes'}));\n  expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes/41');\n});\n\nit('should navigate when click save and save resolves', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n     click(page.saveBtn);\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();  // wait for async save to complete\n     expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes/41');\n   }));\n\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () =&gt; {\n  // get the name's input and display elements from the DOM\n  const hostElement: HTMLElement = harness.routeNativeElement!;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input')!;\n  const nameDisplay: HTMLElement = hostElement.querySelector('span')!;\n\n  // simulate user entering a new name into the input box\n  nameInput.value = 'quick BROWN  fOx';\n\n  // Dispatch a DOM event so that Angular learns of input value change.\n  nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input'));\n\n  // Tell Angular to update the display binding through the title pipe\n  harness.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n</code-example>\n<p><a id=\"compile-components\"></a></p>\n<h2 id=\"calling-compilecomponents\" translation-result=\"on\">呼叫 <code>compileComponents()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#calling-compilecomponents\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Calling <code>compileComponents()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#calling-compilecomponents\"><i class=\"material-icons\">link</i></a></h2>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果你<em>只想</em>使用 CLI 的 <code>ng test</code> 命令來執行測試，那麼可以忽略這一節。</p><p translation-origin=\"off\">Ignore this section if you <em>only</em> run tests with the CLI <code>ng test</code> command because the CLI compiles the application before running the tests.</p>\n\n</div>\n<p translation-result=\"on\">如果你在<strong>非 CLI 環境</strong>中執行測試，這些測試可能會報錯，錯誤資訊如下：</p><p translation-origin=\"off\">If you run tests in a <strong>non-CLI environment</strong>, the tests might fail with a message like this one:</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nError: This test module uses the component BannerComponent\nwhich is using a \"templateUrl\" or \"styleUrls\", but they were never compiled.\nPlease call \"TestBed.compileComponents\" before your test.\n\n</code-example>\n<p translation-result=\"on\">問題的根源在於這個測試中至少有一個元件參考了外部範本或外部 CSS 檔案，就像下面這個版本的 <code>BannerComponent</code> 所示。</p><p translation-origin=\"off\">The root of the problem is at least one of the components involved in the test specifies an external template or CSS file as the following version of the <code>BannerComponent</code> does.</p>\n\n<code-example header=\"app/banner/banner-external.component.ts (external template &amp; css)\" path=\"testing/src/app/banner/banner-external.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  styleUrls:  ['./banner-external.component.css']\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n\n</code-example>\n<p translation-result=\"on\">當 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 檢視建立元件時，這個測試失敗了。</p><p translation-origin=\"off\">The test fails when the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> tries to create the component.</p>\n\n<code-example avoid=\"\" header=\"app/banner/banner-external.component.spec.ts (setup that fails)\" path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"setup-may-fail\">\nbeforeEach(async () =&gt; {\n  await TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  }); // missing call to compileComponents()\n  fixture = TestBed.createComponent(BannerComponent);\n});\n\n</code-example>\n<p translation-result=\"on\">回想一下，這個應用從未編譯過。所以當你呼叫 <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> 的時候，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 就會進行隱含編譯。</p><p translation-origin=\"off\">Recall that the application hasn't been compiled.\nSo when you call <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code>, the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> compiles implicitly.</p>\n\n<p translation-result=\"on\">當它的原始碼都在記憶體中的時候，這樣做沒問題。不過 <code>BannerComponent</code> 需要一些外部檔案，編譯時必須從檔案系統中讀取它，而這是一個天生的<em>非同步</em>操作。</p><p translation-origin=\"off\">That's not a problem when the source code is in memory.\nBut the <code>BannerComponent</code> requires external files that the compiler must read from the file system, an inherently <em>asynchronous</em> operation.</p>\n\n<p translation-result=\"on\">如果 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 繼續執行，這些測試就會繼續執行，並在編譯器完成這些非同步工作之前導致莫名其妙的失敗。</p><p translation-origin=\"off\">If the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> were allowed to continue, the tests would run and fail mysteriously before the compiler could finish.</p>\n\n<p translation-result=\"on\">這些錯誤資訊告訴你要使用 <code>compileComponents()</code> 進行顯式的編譯。</p><p translation-origin=\"off\">The preemptive error message tells you to compile explicitly with <code>compileComponents()</code>.</p>\n\n<h4 id=\"compilecomponents-is-async\" translation-result=\"on\"><code>compileComponents()</code> 是非同步的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#compilecomponents-is-async\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\"><code>compileComponents()</code> is async<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#compilecomponents-is-async\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">你必須在非同步測試函式中呼叫 <code>compileComponents()</code>。</p><p translation-origin=\"off\">You must call <code>compileComponents()</code> within an asynchronous test function.</p>\n\n<div class=\"alert is-critical\">\n<p translation-result=\"on\">如果你忘了把測試函式標為非同步的（比如忘了像稍後的程式碼中那樣使用 <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code>），就會看到下列錯誤。</p><p translation-origin=\"off\">If you neglect to make the test function async (for example, forget to use <code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>()</code> as described), you'll see this error message</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nError: ViewDestroyedError: Attempt to use a destroyed view\n\n</code-example>\n</div>\n<p translation-result=\"on\">典型的做法是把準備邏輯拆成兩個獨立的 <code>beforeEach()</code> 函式：</p><p translation-origin=\"off\">A typical approach is to divide the setup logic into two separate <code>beforeEach()</code> functions:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">函式</nt-wrapper><nt-wrapper translation-origin=\"off\">Functions</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">非同步 <code>beforeEach()</code></nt-wrapper><nt-wrapper translation-origin=\"off\">Asynchronous <code>beforeEach()</code></nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">負責編譯元件</nt-wrapper><nt-wrapper translation-origin=\"off\">Compiles the components</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">同步 <code>beforeEach()</code></nt-wrapper><nt-wrapper translation-origin=\"off\">Synchronous <code>beforeEach()</code></nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">負責執行其餘的準備程式碼</nt-wrapper><nt-wrapper translation-origin=\"off\">Performs the remaining setup</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<h4 id=\"the-async-beforeeach\" translation-result=\"on\">非同步的 <code>beforeEach</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-async-beforeeach\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">The async <code>beforeEach</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-async-beforeeach\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">像下面這樣編寫第一個非同步的 <code>beforeEach</code>。</p><p translation-origin=\"off\">Write the first async <code>beforeEach</code> like this.</p>\n\n<code-example header=\"app/banner/banner-external.component.spec.ts (async beforeEach)\" path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"async-before-each\">\nbeforeEach(async () =&gt; {\n  await TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  }).compileComponents();  // compile template and css\n});\n\n</code-example>\n<p translation-result=\"on\"><code>TestBed.configureTestingModule()</code> 方法返回 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 類，所以你可以鏈式呼叫其它 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 中的靜態方法，比如 <code>compileComponents()</code>。</p><p translation-origin=\"off\">The <code>TestBed.configureTestingModule()</code> method returns the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> class so you can chain calls to other <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> static methods such as <code>compileComponents()</code>.</p>\n\n<p translation-result=\"on\">在這個例子中，<code>BannerComponent</code> 是僅有的待編譯元件。其它例子中可能會使用多個元件來配置測試模組，並且可能引入某些具有其它元件的應用模組。它們中的任何一個都可能需要外部檔案。</p><p translation-origin=\"off\">In this example, the <code>BannerComponent</code> is the only component to compile.\nOther examples configure the testing module with multiple components and might import application modules that hold yet more components.\nAny of them could require external files.</p>\n\n<p translation-result=\"on\"><code>TestBed.compileComponents</code> 方法會非同步編譯測試模組中配置過的所有元件。</p><p translation-origin=\"off\">The <code>TestBed.compileComponents</code> method asynchronously compiles all components configured in the testing module.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">在呼叫了 <code>compileComponents()</code> 之後就不能再重新配置 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 了。</p><p translation-origin=\"off\">Do not re-configure the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> after calling <code>compileComponents()</code>.</p>\n\n</div>\n<p translation-result=\"on\">呼叫 <code>compileComponents()</code> 會關閉當前的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 例項，不再允許進行配置。你不能再呼叫任何 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 中的配置方法，既不能調 <code>configureTestingModule()</code>，也不能呼叫任何 <code>override...</code> 方法。如果你試圖這麼做，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 就會丟擲錯誤。</p><p translation-origin=\"off\">Calling <code>compileComponents()</code> closes the current <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> instance to further configuration.\nYou cannot call any more <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration methods, not <code>configureTestingModule()</code> nor any of the <code>override...</code> methods.\nThe <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> throws an error if you try.</p>\n\n<p translation-result=\"on\">確保 <code>compileComponents()</code> 是呼叫 <code>TestBed.createComponent()</code> 之前的最後一步。</p><p translation-origin=\"off\">Make <code>compileComponents()</code> the last step before calling <code>TestBed.createComponent()</code>.</p>\n\n<h4 id=\"the-synchronous-beforeeach\" translation-result=\"on\">同步的 <code>beforeEach</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-synchronous-beforeeach\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">The synchronous <code>beforeEach</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-synchronous-beforeeach\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">第二個同步 <code>beforeEach()</code> 的例子包含剩下的準備步驟，包括建立元件和查詢那些要檢查的元素。</p><p translation-origin=\"off\">The second, synchronous <code>beforeEach()</code> contains the remaining setup steps, which include creating the component and querying for elements to inspect.</p>\n\n<code-example header=\"app/banner/banner-external.component.spec.ts (synchronous beforeEach)\" path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"sync-before-each\">\nbeforeEach(() =&gt; {\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance;  // BannerComponent test instance\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<p translation-result=\"on\">測試執行器（runner）會先等待第一個非同步 <code>beforeEach</code> 函式執行完再呼叫第二個。</p><p translation-origin=\"off\">Count on the test runner to wait for the first asynchronous <code>beforeEach</code> to finish before calling the second.</p>\n\n<h4 id=\"consolidated-setup\" translation-result=\"on\">整理過的準備程式碼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#consolidated-setup\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Consolidated setup<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#consolidated-setup\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">你可以把這兩個 <code>beforeEach()</code> 函式重整成一個非同步的 <code>beforeEach()</code>。</p><p translation-origin=\"off\">You can consolidate the two <code>beforeEach()</code> functions into a single, async <code>beforeEach()</code>.</p>\n\n<p translation-result=\"on\"><code>compileComponents()</code> 方法返回一個 Promise，所以你可以透過把同步程式碼移到 <code>await</code> 關鍵字後面，在那裡，這個 Promise 已經解析了。</p><p translation-origin=\"off\">The <code>compileComponents()</code> method returns a promise so you can perform the synchronous setup tasks <em>after</em> compilation by moving the synchronous code after the <code>await</code> keyword, where the promise has been resolved.</p>\n\n<code-example header=\"app/banner/banner-external.component.spec.ts (one beforeEach)\" path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"one-before-each\">\nbeforeEach(async () =&gt; {\n  await TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  }).compileComponents();\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance;\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<h4 id=\"compilecomponents-is-harmless\" translation-result=\"on\"><code>compileComponents()</code> 是無害的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#compilecomponents-is-harmless\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\"><code>compileComponents()</code> is harmless<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#compilecomponents-is-harmless\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在不需要 <code>compileComponents()</code> 的時候呼叫它也不會有害處。</p><p translation-origin=\"off\">There's no harm in calling <code>compileComponents()</code> when it's not required.</p>\n\n<p translation-result=\"on\">雖然在執行 <code>ng test</code> 時永遠都不需要呼叫 <code>compileComponents()</code>，但 CLI 產生的元件測試檔案還是會呼叫它。</p><p translation-origin=\"off\">The component test file generated by the CLI calls <code>compileComponents()</code> even though it is never required when running <code>ng test</code>.</p>\n\n<p translation-result=\"on\">但這篇指南中的這些測試只會在必要時才呼叫 <code>compileComponents</code>。</p><p translation-origin=\"off\">The tests in this guide only call <code>compileComponents</code> when necessary.</p>\n\n<p><a id=\"import-module\"></a></p>\n<h2 id=\"setup-with-module-imports\" translation-result=\"on\">準備模組的 <code>imports</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#setup-with-module-imports\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Setup with module imports<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#setup-with-module-imports\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">此前的元件測試程式使用了一些 <code>declarations</code> 來配置模組，就像這樣：</p><p translation-origin=\"off\">Earlier component tests configured the testing module with a few <code>declarations</code> like this:</p>\n\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (configure TestBed)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"config-testbed\">\n<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n    .configureTestingModule({declarations: [DashboardHeroComponent]})\n\n</code-example>\n<p translation-result=\"on\"><code>DashboardComponent</code> 非常簡單。它不需要幫助。但是更加複雜的元件通常依賴其它元件、指令、管道和提供者，所以這些必須也被新增到測試模組中。</p><p translation-origin=\"off\">The <code>DashboardComponent</code> is simple.\nIt needs no help.\nBut more complex components often depend on other components, directives, pipes, and providers and these must be added to the testing module too.</p>\n\n<p translation-result=\"on\">幸運的是，<code>TestBed.configureTestingModule</code> 引數與傳入 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 裝飾器的元資料一樣，也就是所你也可以指定 <code>providers</code> 和 <code>imports</code>。</p><p translation-origin=\"off\">Fortunately, the <code>TestBed.configureTestingModule</code> parameter parallels the metadata passed to the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator which means you can also specify <code>providers</code> and <code>imports</code>.</p>\n\n<p translation-result=\"on\">雖然 <code>HeroDetailComponent</code> 很小，結構也很簡單，但是它需要很多幫助。除了從預設測試模組 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> 中獲得的支援，它還需要：</p><p translation-origin=\"off\">The <code>HeroDetailComponent</code> requires a lot of help despite its small size and simple construction.\nIn addition to the support it receives from the default testing module <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>, it needs:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 裡的 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 和其它，來進行雙向資料繫結</p><p translation-origin=\"off\"><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> and friends in the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> to enable two-way data binding</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>shared</code> 目錄裡的 <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code></p><p translation-origin=\"off\">The <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code> from the <code>shared</code> folder</p>\n\n</li>\n<li>\n<p translation-result=\"on\">一些路由器服務，測試程式將用打樁的方式偽造它們</p><p translation-origin=\"off\">The Router services that these tests are stubbing out</p>\n\n</li>\n<li>\n<p translation-result=\"on\">英雄資料存取這些服務</p><p translation-origin=\"off\">The Hero data access services</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">一種方法是從各個部分配置測試模組，就像這樣：</p><p translation-origin=\"off\">One approach is to configure the testing module from the individual pieces as in this example:</p>\n\n<code-example header=\"app/hero/hero-detail.component.spec.ts (FormsModule setup)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-forms-module\">\nbeforeEach(async () =&gt; {\n  await <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n      .configureTestingModule({\n        imports: [<a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>],\n        declarations: [HeroDetailComponent, <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a>],\n        providers: [\n          <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n          <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n          <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{path: 'heroes/:id', component: HeroDetailComponent}]),\n        ]\n      })\n      .compileComponents();\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">注意，<code>beforeEach()</code> 是非同步的，它呼叫 <code>TestBed.compileComponents</code> 是因為 <code>HeroDetailComponent</code> 有外部範本和 CSS 檔案。</p><p translation-origin=\"off\">Notice that the <code>beforeEach()</code> is asynchronous and calls <code>TestBed.compileComponents</code> because the <code>HeroDetailComponent</code> has an external template and css file.</p>\n\n<p translation-result=\"on\">如<a href=\"guide/testing-components-scenarios#compile-components\">呼叫 <code>compileComponents()</code></a> 中所解釋的那樣，這些測試可以執行在非 CLI 環境下，那裡 Angular 並不會在瀏覽器中編譯它們。</p><p translation-origin=\"off\">As explained in <a href=\"guide/testing-components-scenarios#compile-components\">Calling <code>compileComponents()</code></a>, these tests could be run in a non-CLI environment where Angular would have to compile them in the browser.</p>\n\n</div>\n<h4 id=\"import-a-shared-module\" translation-result=\"on\">匯入共享模組<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#import-a-shared-module\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Import a shared module<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#import-a-shared-module\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">因為很多應用元件都需要 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 和 <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code>，所以開發者建立了 <code>SharedModule</code> 來把它們及其它常用的部分組合在一起。</p><p translation-origin=\"off\">Because many application components need the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> and the <code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code>, the developer created a <code>SharedModule</code> to combine these and other frequently requested parts.</p>\n\n<p translation-result=\"on\">這些測試配置也可以使用 <code>SharedModule</code>，如下所示：</p><p translation-origin=\"off\">The test configuration can use the <code>SharedModule</code> too as seen in this alternative setup:</p>\n\n<code-example header=\"app/hero/hero-detail.component.spec.ts (SharedModule setup)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-shared-module\">\nbeforeEach(async () =&gt; {\n  await <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n      .configureTestingModule({\n        imports: [SharedModule],\n        declarations: [HeroDetailComponent],\n        providers: [\n          <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{path: 'heroes/:id', component: HeroDetailComponent}]),\n          <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n          <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n        ]\n      })\n      .compileComponents();\n});\n\n</code-example>\n<p translation-result=\"on\">它的匯入宣告少一些，稍微乾淨一些，小一些，這個例子中未展示它。</p><p translation-origin=\"off\">It's a bit tighter and smaller, with fewer import statements, which are not shown in this example.</p>\n\n<p><a id=\"feature-module-import\"></a></p>\n<h4 id=\"import-a-feature-module\" translation-result=\"on\">匯入特性模組<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#import-a-feature-module\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Import a feature module<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#import-a-feature-module\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code>HeroDetailComponent</code> 是 <code>HeroModule</code> 這個<a href=\"guide/feature-modules\">特性模組</a>的一部分，它聚合了更多相互依賴的片段，包括 <code>SharedModule</code>。試試下面這個匯入了 <code>HeroModule</code> 的測試配置：</p><p translation-origin=\"off\">The <code>HeroDetailComponent</code> is part of the <code>HeroModule</code> <a href=\"guide/feature-modules\">Feature Module</a> that aggregates more of the interdependent pieces including the <code>SharedModule</code>.\nTry a test configuration that imports the <code>HeroModule</code> like this one:</p>\n\n<code-example header=\"app/hero/hero-detail.component.spec.ts (HeroModule setup)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-hero-module\">\nbeforeEach(async () =&gt; {\n  await <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n      .configureTestingModule({\n        imports: [HeroModule],\n        //  declarations: [ HeroDetailComponent ], // NO!  DOUBLE DECLARATION\n        providers: [\n          <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([\n            {path: 'heroes/:id', component: HeroDetailComponent},\n            {path: 'heroes', component: HeroListComponent},\n          ]),\n          <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n          <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n        ]\n      })\n      .compileComponents();\n});\n\n</code-example>\n<p translation-result=\"on\">這樣特別清爽。只有 <code>providers</code> 裡面的測試替身被保留。連 <code>HeroDetailComponent</code> 宣告都消失了。</p><p translation-origin=\"off\">Only the <em>test doubles</em> in the <code>providers</code> remain.\nEven the <code>HeroDetailComponent</code> declaration is gone.</p>\n\n<p translation-result=\"on\">事實上，如果你試圖宣告它，Angular 就會丟擲一個錯誤，因為 <code>HeroDetailComponent</code> 同時宣告在了 <code>HeroModule</code> 和 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 建立的 <code>DynamicTestModule</code> 中。</p><p translation-origin=\"off\">In fact, if you try to declare it, Angular will throw an error because <code>HeroDetailComponent</code> is declared in both the <code>HeroModule</code> and the <code>DynamicTestModule</code> created by the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果模組中有很多共同依賴，並且該模組很小（這也是特性模組的應有形態），那麼直接匯入元件的特性模組可以成為配置這些測試的最佳方式。</p><p translation-origin=\"off\">Importing the component's feature module can be the best way to configure tests when there are many mutual dependencies within the module and the module is small, as feature modules tend to be.</p>\n\n</div>\n<p><a id=\"component-override\"></a></p>\n<h2 id=\"override-component-providers\" translation-result=\"on\">改寫元件的服務提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#override-component-providers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Override component providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#override-component-providers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code>HeroDetailComponent</code> 提供自己的 <code>HeroDetailService</code> 服務。</p><p translation-origin=\"off\">The <code>HeroDetailComponent</code> provides its own <code>HeroDetailService</code>.</p>\n\n<code-example header=\"app/hero/hero-detail.component.ts (prototype)\" path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"prototype\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector:    'app-hero-detail',\n  templateUrl: './hero-detail.component.html',\n  styleUrls:  ['./hero-detail.component.css' ],\n  providers:  [ HeroDetailService ]\n})\nexport class HeroDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(\n    private heroDetailService: HeroDetailService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">在 <code>TestBed.configureTestingModule</code> 的 <code>providers</code> 中 stub 偽造元件的 <code>HeroDetailService</code> 是不可行的。這些是<strong>測試模組</strong>的提供者，而非元件的。元件級別的提供者應該在<strong>fixture 級別</strong>的依賴注入器中進行準備。</p><p translation-origin=\"off\">It's not possible to stub the component's <code>HeroDetailService</code> in the <code>providers</code> of the <code>TestBed.configureTestingModule</code>.\nThose are providers for the <em>testing module</em>, not the component.\nThey prepare the dependency injector at the <em>fixture level</em>.</p>\n\n<p translation-result=\"on\">Angular 會使用自己的注入器來建立這些元件，這個注入器是夾具的注入器的子注入器。它使用這個子注入器註冊了該元件服務提供者（這裡是 <code>HeroDetailService</code>）。</p><p translation-origin=\"off\">Angular creates the component with its <em>own</em> injector, which is a <em>child</em> of the fixture injector.\nIt registers the component's providers (the <code>HeroDetailService</code> in this case) with the child injector.</p>\n\n<p translation-result=\"on\">測試沒辦法從測試夾具的注入器中獲取子注入器中的服務，而 <code>TestBed.configureTestingModule</code> 也沒法配置它們。</p><p translation-origin=\"off\">A test cannot get to child injector services from the fixture injector.\nAnd <code>TestBed.configureTestingModule</code> can't configure them either.</p>\n\n<p translation-result=\"on\">Angular 始終都在建立真實 <code>HeroDetailService</code> 的例項。</p><p translation-origin=\"off\">Angular has created new instances of the real <code>HeroDetailService</code> all along!</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果 <code>HeroDetailService</code> 向遠端伺服器發出自己的 XHR 請求，這些測試可能會失敗或者超時。這個遠端伺服器可能根本不存在。</p><p translation-origin=\"off\">These tests could fail or timeout if the <code>HeroDetailService</code> made its own XHR calls to a remote server.\nThere might not be a remote server to call.</p>\n\n<p translation-result=\"on\">幸運的是，<code>HeroDetailService</code> 將遠端資料存取的責任交給了注入進來的 <code>HeroService</code>。</p><p translation-origin=\"off\">Fortunately, the <code>HeroDetailService</code> delegates responsibility for remote data access to an injected <code>HeroService</code>.</p>\n\n<code-example header=\"app/hero/hero-detail.service.ts (prototype)\" path=\"testing/src/app/hero/hero-detail.service.ts\" region=\"prototype\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({providedIn: 'root'})\nexport class HeroDetailService {\n  constructor(private heroService: HeroService) {}\n  /* . . . */\n}\n\n</code-example>\n<p translation-result=\"on\"><a href=\"guide/testing-components-scenarios#feature-module-import\">前面的測試配置</a>使用 <code>TestHeroService</code> 替換了真實的 <code>HeroService</code>，它攔截了發往伺服器的請求，並偽造了伺服器的響應。</p><p translation-origin=\"off\">The <a href=\"guide/testing-components-scenarios#feature-module-import\">previous test configuration</a> replaces the real <code>HeroService</code> with a <code>TestHeroService</code> that intercepts server requests and fakes their responses.</p>\n\n</div>\n<p translation-result=\"on\">如果你沒有這麼幸運怎麼辦？如果偽造 <code>HeroService</code> 很難怎麼辦？如果 <code>HeroDetailService</code> 自己發出伺服器請求怎麼辦？</p><p translation-origin=\"off\">What if you aren't so lucky.\nWhat if faking the <code>HeroService</code> is hard?\nWhat if <code>HeroDetailService</code> makes its own server requests?</p>\n\n<p translation-result=\"on\"><code>TestBed.overrideComponent</code> 方法可以將元件的 <code>providers</code> 替換為容易管理的<strong>測試替身</strong>，參閱下面的變體準備程式碼：</p><p translation-origin=\"off\">The <code>TestBed.overrideComponent</code> method can replace the component's <code>providers</code> with easy-to-manage <em>test doubles</em> as seen in the following setup variation:</p>\n\n<code-example header=\"app/hero/hero-detail.component.spec.ts (Override setup)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-override\">\nbeforeEach(async () =&gt; {\n  await <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n      .configureTestingModule({\n        imports: [HeroModule],\n        providers: [\n          <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{path: 'heroes/:id', component: HeroDetailComponent}]),\n          // HeroDetailService at this level is IRRELEVANT!\n          {provide: HeroDetailService, useValue: {}}\n        ]\n      })\n      .overrideComponent(\n          HeroDetailComponent,\n          {set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}})\n      .compileComponents();\n});\n\n</code-example>\n<p translation-result=\"on\">注意，<code>TestBed.configureTestingModule</code> 不再提供偽造的 <code>HeroService</code>，因為<a href=\"guide/testing-components-scenarios#spy-stub\">並不需要</a>。</p><p translation-origin=\"off\">Notice that <code>TestBed.configureTestingModule</code> no longer provides a fake <code>HeroService</code> because it's <a href=\"guide/testing-components-scenarios#spy-stub\">not needed</a>.</p>\n\n<p><a id=\"override-component-method\"></a></p>\n<h4 id=\"the-overridecomponent-method\" translation-result=\"on\"><code>overrideComponent</code> 方法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-overridecomponent-method\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">The <code>overrideComponent</code> method<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-overridecomponent-method\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">注意這個 <code>overrideComponent</code> 方法。</p><p translation-origin=\"off\">Focus on the <code>overrideComponent</code> method.</p>\n\n<code-example header=\"app/hero/hero-detail.component.spec.ts (overrideComponent)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-component-method\">\n.overrideComponent(\n    HeroDetailComponent,\n    {set: {providers: [{provide: HeroDetailService, useClass: HeroDetailServiceSpy}]}})\n\n</code-example>\n<p translation-result=\"on\">它接受兩個引數：要改寫的元件型別（<code>HeroDetailComponent</code>），以及用於改寫的元資料物件。<a href=\"guide/testing-utility-apis#metadata-override-object\">用於改寫的元資料物件</a>是一個泛型，其定義如下：</p><p translation-origin=\"off\">It takes two arguments: the component type to override (<code>HeroDetailComponent</code>) and an override metadata object.\nThe <a href=\"guide/testing-utility-apis#metadata-override-object\">override metadata object</a> is a generic defined as follows:</p>\n\n<code-example language=\"javascript\">\n\ntype <a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&lt;T&gt; = {\n  add?: Partial&lt;T&gt;;\n  remove?: Partial&lt;T&gt;;\n  set?: Partial&lt;T&gt;;\n};\n\n</code-example>\n<p translation-result=\"on\">元資料重載物件可以新增和刪除元資料屬性的專案，也可以徹底重設這些屬性。這個例子重新設定了元件的 <code>providers</code> 元資料。</p><p translation-origin=\"off\">A metadata override object can either add-and-remove elements in metadata properties or completely reset those properties.\nThis example resets the component's <code>providers</code> metadata.</p>\n\n<p translation-result=\"on\">這個型別引數 <code>T</code> 就是你傳給 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 裝飾器的元資料：</p><p translation-origin=\"off\">The type parameter, <code>T</code>, is the kind of metadata you'd pass to the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> decorator:</p>\n\n<code-example language=\"javascript\">\n\nselector?: string;\ntemplate?: string;\ntemplateUrl?: string;\nproviders?: any[];\n…\n\n</code-example>\n<p><a id=\"spy-stub\"></a></p>\n<h4 id=\"provide-a-spy-stub-herodetailservicespy\" translation-result=\"on\">提供 <em>間諜樁</em>（<code>HeroDetailServiceSpy</code>）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#provide-a-spy-stub-herodetailservicespy\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Provide a <em>spy stub</em> (<code>HeroDetailServiceSpy</code>)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#provide-a-spy-stub-herodetailservicespy\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">這個例子把元件的 <code>providers</code> 陣列完全替換成了一個包含 <code>HeroDetailServiceSpy</code> 的新陣列。</p><p translation-origin=\"off\">This example completely replaces the component's <code>providers</code> array with a new array containing a <code>HeroDetailServiceSpy</code>.</p>\n\n<p translation-result=\"on\"><code>HeroDetailServiceSpy</code> 是實際 <code>HeroDetailService</code> 服務的樁版本，它偽造了該服務的所有必要特性。但它既不需要注入也不會委託給低層的 <code>HeroService</code> 服務，因此不用為 <code>HeroService</code> 提供測試替身。</p><p translation-origin=\"off\">The <code>HeroDetailServiceSpy</code> is a stubbed version of the real <code>HeroDetailService</code> that fakes all necessary features of that service.\nIt neither injects nor delegates to the lower level <code>HeroService</code> so there's no need to provide a test double for that.</p>\n\n<p translation-result=\"on\">透過對該服務的方法進行刺探，<code>HeroDetailComponent</code> 的關聯測試將會對 <code>HeroDetailService</code> 是否被呼叫過進行斷言。因此，這個樁類會把它的方法實現為刺探方法：</p><p translation-origin=\"off\">The related <code>HeroDetailComponent</code> tests will assert that methods of the <code>HeroDetailService</code> were called by spying on the service methods.\nAccordingly, the stub implements its methods as spies:</p>\n\n<code-example header=\"app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"hds-spy\">\nclass HeroDetailServiceSpy {\n  testHero: Hero = {...testHero};\n\n  /* emit cloned test hero */\n  getHero = jasmine.createSpy('getHero').and.callFake(\n      () =&gt; asyncData(Object.assign({}, this.testHero)));\n\n  /* emit clone of test hero, with changes merged in */\n  saveHero = jasmine.createSpy('saveHero')\n                 .and.callFake((hero: Hero) =&gt; asyncData(Object.assign(this.testHero, hero)));\n}\n\n\n</code-example>\n<p><a id=\"override-tests\"></a></p>\n<h4 id=\"the-override-tests\" translation-result=\"on\">改寫測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-override-tests\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">The override tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#the-override-tests\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">現在，測試程式可以透過操控這個 spy-stub 的 <code>testHero</code>，直接控制組件的英雄，並確認那個服務方法被呼叫過。</p><p translation-origin=\"off\">Now the tests can control the component's hero directly by manipulating the spy-stub's <code>testHero</code> and confirm that service methods were called.</p>\n\n<code-example header=\"app/hero/hero-detail.component.spec.ts (override tests)\" path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-tests\">\n  let hdsSpy: HeroDetailServiceSpy;\n\n  beforeEach(async () =&gt; {\n    harness = await RouterTestingHarness.create();\n    component = await harness.navigateByUrl(`/heroes/${testHero.id}`, HeroDetailComponent);\n    page = new Page();\n    // get the component's injected HeroDetailServiceSpy\n    hdsSpy = harness.routeDebugElement!.injector.get(HeroDetailService) as any;\n\n    harness.detectChanges();\n  });\n\n  it('should have called `getHero`', () =&gt; {\n    expect(hdsSpy.getHero.calls.count())\n        .withContext('getHero called once')\n        .toBe(1, 'getHero called once');\n  });\n\n  it('should display stub hero\\'s name', () =&gt; {\n    expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);\n  });\n\n  it('should save stub hero change', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n       const origName = hdsSpy.testHero.name;\n       const newName = 'New Name';\n\n       page.nameInput.value = newName;\n\n       page.nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input'));  // tell Angular\n\n       expect(component.hero.name).withContext('component hero has new name').toBe(newName);\n       expect(hdsSpy.testHero.name)\n           .withContext('service hero unchanged before save')\n           .toBe(origName);\n\n       click(page.saveBtn);\n       expect(hdsSpy.saveHero.calls.count()).withContext('saveHero called once').toBe(1);\n\n       <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();  // wait for async save to complete\n       expect(hdsSpy.testHero.name)\n           .withContext('service hero has new name after save')\n           .toBe(newName);\n       expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes');\n     }));\n}\n\n////////////////////\nimport {getTestHeroes} from '../model/testing/test-hero.service';\n\nconst firstHero = getTestHeroes()[0];\n\nfunction heroModuleSetup() {\n  beforeEach(async () =&gt; {\n    await <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          imports: [HeroModule],\n          //  declarations: [ HeroDetailComponent ], // NO!  DOUBLE DECLARATION\n          providers: [\n            <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([\n              {path: 'heroes/:id', component: HeroDetailComponent},\n              {path: 'heroes', component: HeroListComponent},\n            ]),\n            <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n            <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n          ]\n        })\n        .compileComponents();\n  });\n\n  describe('when navigate to existing hero', () =&gt; {\n    let expectedHero: Hero;\n\n    beforeEach(async () =&gt; {\n      expectedHero = firstHero;\n      await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(expectedHero.id);\n    });\n    it('should display that hero\\'s name', () =&gt; {\n      expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n    });\n\n    it('should navigate when click cancel', () =&gt; {\n      click(page.cancelBtn);\n      expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual(`/heroes/${expectedHero.id}`);\n    });\n\n    it('should save when click save but not navigate immediately', () =&gt; {\n      click(page.saveBtn);\n      expect(TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne({method: 'PUT', url: 'api/heroes'}));\n      expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes/41');\n    });\n\n    it('should navigate when click save and save resolves', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n         click(page.saveBtn);\n         <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();  // wait for async save to complete\n         expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes/41');\n       }));\n\n    it('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () =&gt; {\n      // get the name's input and display elements from the DOM\n      const hostElement: HTMLElement = harness.routeNativeElement!;\n      const nameInput: HTMLInputElement = hostElement.querySelector('input')!;\n      const nameDisplay: HTMLElement = hostElement.querySelector('span')!;\n\n      // simulate user entering a new name into the input box\n      nameInput.value = 'quick BROWN  fOx';\n\n      // Dispatch a DOM event so that Angular learns of input value change.\n      nameInput.dispatchEvent(new <a href=\"api/router/Event\" class=\"code-anchor\">Event</a>('input'));\n\n      // Tell Angular to update the display binding through the title pipe\n      harness.detectChanges();\n\n      expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n    });\n\n  });\n\n  describe('when navigate to non-existent hero id', () =&gt; {\n    beforeEach(async () =&gt; {\n      await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(999);\n    });\n\n    it('should try to navigate back to hero list', () =&gt; {\n      expect(TestBed.inject(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>).url).toEqual('/heroes');\n    });\n  });\n}\n\n/////////////////////\nimport {<a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>} from '@angular/forms';\nimport {<a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a>} from '../shared/title-case.pipe';\n\nfunction formsModuleSetup() {\n  beforeEach(async () =&gt; {\n    await <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          imports: [<a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>],\n          declarations: [HeroDetailComponent, <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a>],\n          providers: [\n            <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n            <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n            <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{path: 'heroes/:id', component: HeroDetailComponent}]),\n          ]\n        })\n        .compileComponents();\n  });\n\n  it('should display 1st hero\\'s name', async () =&gt; {\n    const expectedHero = firstHero;\n    await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(expectedHero.id).then(() =&gt; {\n      expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n    });\n  });\n}\n\n///////////////////////\n\nfunction sharedModuleSetup() {\n  beforeEach(async () =&gt; {\n    await <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          imports: [SharedModule],\n          declarations: [HeroDetailComponent],\n          providers: [\n            <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([{path: 'heroes/:id', component: HeroDetailComponent}]),\n            <a href=\"api/common/http/provideHttpClient\" class=\"code-anchor\">provideHttpClient</a>(),\n            <a href=\"api/common/http/testing/provideHttpClientTesting\" class=\"code-anchor\">provideHttpClientTesting</a>(),\n          ]\n        })\n        .compileComponents();\n  });\n\n  it('should display 1st hero\\'s name', async () =&gt; {\n    const expectedHero = firstHero;\n    await <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(expectedHero.id).then(() =&gt; {\n      expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n    });\n  });\n}\n\n/////////// Helpers /////\n\n/** Create the HeroDetailComponent, initialize it, set test variables  */\nasync function <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(id: number) {\n  harness = await RouterTestingHarness.create();\n  component = await harness.navigateByUrl(`/heroes/${id}`, HeroDetailComponent);\n  page = new Page();\n\n  const request = TestBed.inject(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>).expectOne(`api/heroes/?id=${id}`);\n  const hero = getTestHeroes().find(h =&gt; h.id === Number(id));\n  request.flush(hero ? [hero] : []);\n  harness.detectChanges();\n}\n\nclass Page {\n  // getter properties wait to <a href=\"api/animations/query\" class=\"code-anchor\">query</a> the DOM until called.\n  get buttons() {\n    return this.queryAll&lt;HTMLButtonElement&gt;('button');\n  }\n  get saveBtn() {\n    return this.buttons[0];\n  }\n  get cancelBtn() {\n    return this.buttons[1];\n  }\n  get nameDisplay() {\n    return this.query&lt;HTMLElement&gt;('span');\n  }\n  get nameInput() {\n    return this.query&lt;HTMLInputElement&gt;('input');\n  }\n\n  //// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> helpers ////\n  private <a href=\"api/animations/query\" class=\"code-anchor\">query</a>&lt;T&gt;(selector: string): T {\n    return harness.routeNativeElement!.querySelector(selector)! as T;\n  }\n\n  private queryAll&lt;T&gt;(selector: string): T[] {\n    return harness.routeNativeElement!.querySelectorAll(selector) as any as T[];\n  }\n}\n\n\n</code-example>\n<p><a id=\"more-overrides\"></a></p>\n<h4 id=\"more-overrides\" translation-result=\"on\">更多的改寫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#more-overrides\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">More overrides<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-scenarios#more-overrides\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code>TestBed.overrideComponent</code> 方法可以在相同或不同的元件中被反覆呼叫。<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 還提供了類似的 <code>overrideDirective</code>、<code>overrideModule</code> 和 <code>overridePipe</code> 方法，用來深入並重載這些其它類別的部件。</p><p translation-origin=\"off\">The <code>TestBed.overrideComponent</code> method can be called multiple times for the same or different components.\nThe <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> offers similar <code>overrideDirective</code>, <code>overrideModule</code>, and <code>overridePipe</code> methods for digging into and replacing parts of these other classes.</p>\n\n<p translation-result=\"on\">自己探索這些選項和組合。</p><p translation-origin=\"off\">Explore the options and combinations on your own.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/DebugElement\n - guide/testing\n - guide/testing-attribute-directives\n - guide/testing-components-basics\n - guide/testing-utility-apis\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/animations/trigger\n - api/common/AsyncPipe\n - api/common/CommonModule\n - api/common/NgFor\n - api/common/NgIf\n - api/common/TitleCasePipe\n - api/common/UpperCasePipe\n - api/common/http/HttpClient\n - api/common/http/provideHttpClient\n - api/common/http/testing/HttpTestingController\n - api/common/http/testing/provideHttpClientTesting\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/Component#styleUrls\n - api/core/Component#styles\n - api/core/Component#template\n - api/core/Component#templateUrl\n - api/core/DebugElement\n - api/core/ElementRef\n - api/core/EventEmitter\n - api/core/Injectable\n - api/core/Input\n - api/core/NO_ERRORS_SCHEMA\n - api/core/NgModule\n - api/core/OnInit\n - api/core/Output\n - api/core/ViewChild\n - api/core/createComponent\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixtureAutoDetect\n - api/core/testing/MetadataOverride\n - api/core/testing/TestBed\n - api/core/testing/fakeAsync\n - api/core/testing/flush\n - api/core/testing/tick\n - api/core/testing/waitForAsync\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/Title\n - api/router/ActivatedRoute\n - api/router/ActivatedRoute#paramMap\n - api/router/Event\n - api/router/Router\n - api/router/Router#events\n - api/router/RouterLink\n - api/router/RouterOutlet\n - api/router/provideRouter\n - api/router/testing/RouterTestingHarness\n - guide/feature-modules\n - guide/http\n - guide/lifecycle-hooks\n - guide/router-tutorial-toh\n - guide/router-tutorial-toh#activated-route-in-action\n - guide/testing-components-basics#component-class-testing\n - guide/testing-components-scenarios#async-observable-helpers\n - guide/testing-components-scenarios#async-observables\n - guide/testing-components-scenarios#async-test-with-fakeasync\n - guide/testing-components-scenarios#async-test-with-waitforasync\n - guide/testing-components-scenarios#automatic-change-detection\n - guide/testing-components-scenarios#bydirective-and-injected-directives\n - guide/testing-components-scenarios#bydirective-與注入的指令\n - guide/testing-components-scenarios#calling-compilecomponents\n - guide/testing-components-scenarios#change-an-input-value-with-dispatchevent\n - guide/testing-components-scenarios#click-helper\n - guide/testing-components-scenarios#click-the-element\n - guide/testing-components-scenarios#click-幫助器\n - guide/testing-components-scenarios#clicking\n - guide/testing-components-scenarios#cold-observable\n - guide/testing-components-scenarios#comparing-dates-inside-fakeasync\n - guide/testing-components-scenarios#compile-components\n - guide/testing-components-scenarios#compilecomponents-is-async\n - guide/testing-components-scenarios#compilecomponents-is-harmless\n - guide/testing-components-scenarios#compilecomponents-是非同步的\n - guide/testing-components-scenarios#compilecomponents-是無害的\n - guide/testing-components-scenarios#component-binding\n - guide/testing-components-scenarios#component-inside-a-test-host\n - guide/testing-components-scenarios#component-marble-tests\n - guide/testing-components-scenarios#component-override\n - guide/testing-components-scenarios#component-testing-scenarios\n - guide/testing-components-scenarios#component-with-a-dependency\n - guide/testing-components-scenarios#component-with-async-service\n - guide/testing-components-scenarios#component-with-external-files\n - guide/testing-components-scenarios#component-with-inputs-and-outputs\n - guide/testing-components-scenarios#consolidated-setup\n - guide/testing-components-scenarios#createcomponent-does-not-bind-data\n - guide/testing-components-scenarios#createcomponent-不繫結資料\n - guide/testing-components-scenarios#dashboard-hero-component\n - guide/testing-components-scenarios#detectchanges\n - guide/testing-components-scenarios#feature-module-import\n - guide/testing-components-scenarios#final-setup-and-tests\n - guide/testing-components-scenarios#get-injected-services\n - guide/testing-components-scenarios#import-a-feature-module\n - guide/testing-components-scenarios#import-a-shared-module\n - guide/testing-components-scenarios#jasmine-done\n - guide/testing-components-scenarios#jasmineclock-with-fakeasync\n - guide/testing-components-scenarios#jasmineclock-與-fakeasync-聯用\n - guide/testing-components-scenarios#learn-about-marble-testing\n - guide/testing-components-scenarios#marble-error-testing\n - guide/testing-components-scenarios#marble-frame\n - guide/testing-components-scenarios#more-async-tests\n - guide/testing-components-scenarios#more-overrides\n - guide/testing-components-scenarios#nested-component-tests\n - guide/testing-components-scenarios#no_errors_schema\n - guide/testing-components-scenarios#override-component-providers\n - guide/testing-components-scenarios#overridecomponent-方法\n - guide/testing-components-scenarios#provide-a-spy-stub-herodetailservicespy\n - guide/testing-components-scenarios#provide-service-test-doubles\n - guide/testing-components-scenarios#query-for-the-h1\n - guide/testing-components-scenarios#routed-components\n - guide/testing-components-scenarios#routing-component\n - guide/testing-components-scenarios#setup-with-module-imports\n - guide/testing-components-scenarios#spy-stub\n - guide/testing-components-scenarios#stubbing-unneeded-components\n - guide/testing-components-scenarios#support-more-macrotasks\n - guide/testing-components-scenarios#synchronous-tests\n - guide/testing-components-scenarios#test-dashboardherocomponent-stand-alone\n - guide/testing-components-scenarios#testbedinject\n - guide/testing-components-scenarios#testing-with-a-spy\n - guide/testing-components-scenarios#testing-with-the-routertestingharness\n - guide/testing-components-scenarios#the-async-beforeeach\n - guide/testing-components-scenarios#the-override-tests\n - guide/testing-components-scenarios#the-overridecomponent-method\n - guide/testing-components-scenarios#the-synchronous-beforeeach\n - guide/testing-components-scenarios#the-tick-function\n - guide/testing-components-scenarios#tick-函式\n - guide/testing-components-scenarios#tickoptions\n - guide/testing-components-scenarios#triggereventhandler\n - guide/testing-components-scenarios#use-a-page-object\n - guide/testing-components-scenarios#use-both-techniques-together\n - guide/testing-components-scenarios#using-the-rxjs-scheduler-inside-fakeasync\n - guide/testing-components-scenarios#waitForAsync\n - guide/testing-components-scenarios#whenstable\n - guide/testing-components-scenarios#為服務提供測試替身\n - guide/testing-components-scenarios#瞭解彈珠測試\n - guide/testing-components-scenarios#位於測試宿主中的元件\n - guide/testing-components-scenarios#使用--dispatchevent-改變輸入框的值\n - guide/testing-components-scenarios#使用-activatedroutestub-進行測試\n - guide/testing-components-scenarios#使用-fakeasync-進行非同步測試\n - guide/testing-components-scenarios#使用-page-物件\n - guide/testing-components-scenarios#使用間諜spy進行測試\n - guide/testing-components-scenarios#具有依賴的元件\n - guide/testing-components-scenarios#具有輸入和輸出屬性的元件\n - guide/testing-components-scenarios#準備模組的-imports\n - guide/testing-components-scenarios#包含外部檔案的元件\n - guide/testing-components-scenarios#單獨測試-dashboardherocomponent\n - guide/testing-components-scenarios#取得所注入的服務\n - guide/testing-components-scenarios#同時使用這兩項技術\n - guide/testing-components-scenarios#同步測試\n - guide/testing-components-scenarios#同步的-beforeeach\n - guide/testing-components-scenarios#在-fakeasync-中使用-rxjs-排程器\n - guide/testing-components-scenarios#對不需要的元件提供樁stub\n - guide/testing-components-scenarios#對巢狀(Nesting)元件的測試\n - guide/testing-components-scenarios#匯入共享模組\n - guide/testing-components-scenarios#匯入特性模組\n - guide/testing-components-scenarios#帶非同步服務的元件\n - guide/testing-components-scenarios#非同步可觀察物件\n - guide/testing-components-scenarios#非同步可觀察物件測試助手\n - guide/testing-components-scenarios#非同步的-beforeeach\n - guide/testing-components-scenarios#彈珠錯誤測試\n - guide/testing-components-scenarios#提供-間諜樁herodetailservicespy\n - guide/testing-components-scenarios#支援更多的-macrotasks\n - guide/testing-components-scenarios#改寫測試\n - guide/testing-components-scenarios#改寫元件的服務提供者\n - guide/testing-components-scenarios#整理過的準備程式碼\n - guide/testing-components-scenarios#更多非同步測試\n - guide/testing-components-scenarios#更多的改寫\n - guide/testing-components-scenarios#最後的設定與測試\n - guide/testing-components-scenarios#查詢-h1-元素\n - guide/testing-components-scenarios#比較-fakeasync-內部的日期\n - guide/testing-components-scenarios#點選\n - guide/testing-components-scenarios#點選該元素\n - guide/testing-components-scenarios#用-waitforasync-進行非同步測試\n - guide/testing-components-scenarios#元件測試場景\n - guide/testing-components-scenarios#元件的彈珠測試\n - guide/testing-components-scenarios#元件繫結\n - guide/testing-components-scenarios#自動變更檢測\n - guide/testing-components-scenarios#呼叫-compilecomponents\n - guide/testing-components-scenarios#路由目標元件\n - guide/testing-components-scenarios#路由元件\n - guide/testing-utility-apis#metadata-override-object\n - http://reactivex.io/documentation/operators/defer.html\n - https://developer.mozilla.org/docs/Web/API/MouseEvent/button\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/testing-components-scenarios.md?message=docs%3A%20請簡述你的修改...\n - https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\n - https://plnkr.co\n - https://rxjs.dev/guide/testing/marble-testing\n - https://rxmarbles.com\n-->"}