{"id":"guide/http-pass-metadata-to-interceptors","title":"HTTP - Pass metadata to interceptors","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-pass-metadata-to-interceptors.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"http---pass-metadata-to-interceptors\" translation-result=\"on\">HTTP - 將元資料傳遞給攔截器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#http---pass-metadata-to-interceptors\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">HTTP - Pass metadata to interceptors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#http---pass-metadata-to-interceptors\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">許多攔截器都需要進行配置或從配置中受益。考慮一個重試失敗請求的攔截器。預設情況下，攔截器可能會重試請求三次，但是對於特別容易出錯或敏感的請求，你可能要改寫這個重試次數。</p><p translation-origin=\"off\">Many interceptors require or benefit from configuration.\nConsider an interceptor that retries failed requests.\nBy default, the interceptor might retry a request three times, but you might want to override this retry count for particularly error-prone or sensitive requests.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 請求包含一個<em>上下文</em>，該上下文可以攜帶有關請求的元資料。該上下文可供攔截器讀取或修改，儘管傳送請求時它並不會傳輸到後端伺服器。這允許應用程式或其他攔截器使用配置引數來標記這些請求，比如重試請求的次數。</p><p translation-origin=\"off\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> requests contain a <em>context</em> that can carry metadata about the request.\nThis context is available for interceptors to read or modify, though it is not transmitted to the backend server when the request is sent.\nThis lets applications or other interceptors tag requests with configuration parameters, such as how many times to retry a request.</p>\n\n<h2 id=\"create-a-context-token\" translation-result=\"on\">建立上下文標記<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#create-a-context-token\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Create a context token<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#create-a-context-token\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code> 用於在上下文中儲存和檢索值。你可以用 <code>new</code> 運算子建立上下文令牌，如以下例所示：</p><p translation-origin=\"off\">Angular stores and retrieves a value in the context using an <code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code>.\nYou can create a context token using the <code>new</code> operator, as in the following example:</p>\n\n<code-example header=\"creating a context token\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"context-token\">\nexport const RETRY_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 3);\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code> 建立期間傳遞的 lambda 函式 <code>() =&gt; 3</code> 有兩個用途：</p><p translation-origin=\"off\">The lambda function <code>() =&gt; 3</code> passed during the creation of the <code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a></code> serves two purposes:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">它允許 TypeScript 推斷此令牌的型別：<code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>&lt;number&gt;</code>。這個請求上下文是型別安全的 —— 從請求上下文中讀取令牌將返回適當型別的值。</p><p translation-origin=\"off\">It lets TypeScript infer the type of this token:\n<code><a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>&lt;number&gt;</code>\nThe request context is type-safe —reading a token from a request's context returns a value of the appropriate type.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它會設定令牌的預設值。如果尚未為此令牌設定其他值，那麼這就是請求上下文返回的值。使用預設值可以避免檢查是否已設定了特定值。</p><p translation-origin=\"off\">It sets the default value for the token.\nThis is the value that the request context returns if no other value was set for this token.\nUsing a default value avoids the need to check if a particular value is set.</p>\n\n</li>\n</ol>\n<h2 id=\"set-context-values-when-making-a-request\" translation-result=\"on\">發出請求時設定上下文值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#set-context-values-when-making-a-request\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Set context values when making a request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#set-context-values-when-making-a-request\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">發出請求時，你可以提供一個 <code><a href=\"api/common/http/HttpContext\" class=\"code-anchor\">HttpContext</a></code> 例項，在該例項中你已經設定了一些上下文值。</p><p translation-origin=\"off\">When making a request, you can provide an <code><a href=\"api/common/http/HttpContext\" class=\"code-anchor\">HttpContext</a></code> instance, in which you have already set the context values.</p>\n\n<code-example header=\"setting context values\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"set-context\">\nthis.httpClient\n    .get('/data/feed', {\n      context: new <a href=\"api/common/http/HttpContext\" class=\"code-anchor\">HttpContext</a>().set(RETRY_COUNT, 5),\n    })\n    .subscribe(results =&gt; {/* ... */});\n\n</code-example>\n<h2 id=\"read-context-values-in-an-interceptor\" translation-result=\"on\">在攔截器中讀取上下文值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#read-context-values-in-an-interceptor\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Read context values in an interceptor<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#read-context-values-in-an-interceptor\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpContext#get\" class=\"code-anchor\">HttpContext.get()</a></code> 在給定請求的上下文中讀取令牌的值。如果尚未顯式設定令牌的值，則 Angular 將返回標記中指定的預設值。</p><p translation-origin=\"off\">Within an interceptor, you can read the value of a token in a given request's context with <code><a href=\"api/common/http/HttpContext#get\" class=\"code-anchor\">HttpContext.get()</a></code>.\nIf you have not explicitly set a value for the token, Angular returns the default value specified in the token.</p>\n\n<code-example header=\"reading context values in an interceptor\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"reading-context\">\nimport {retry} from 'rxjs';\n\nexport class RetryInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    const retryCount = req.context.get(RETRY_COUNT);\n\n    return next.handle(req).pipe(\n        // Retry the request a configurable number of times.\n        retry(retryCount),\n    );\n  }\n}\n\n</code-example>\n<h2 id=\"contexts-are-mutable\" translation-result=\"on\">上下文是可變的（Mutable）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#contexts-are-mutable\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Contexts are mutable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-pass-metadata-to-interceptors#contexts-are-mutable\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">與 <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 例項的大多數其他方面不同，請求上下文是可變的，並且在請求的其他不可變轉換過程中仍然存在。這允許攔截器透過此上下文協調來操作。比如，<code>RetryInterceptor</code> 範例可以使用第二個上下文令牌來追蹤在執行給定請求期間發生過多少錯誤：</p><p translation-origin=\"off\">Unlike most other aspects of <code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> instances, the request context is mutable and persists across other immutable transformations of the request.\nThis lets interceptors coordinate operations through the context.\nFor instance, the <code>RetryInterceptor</code> example could use a second context token to track how many errors occur during the execution of a given request:</p>\n\n<code-example header=\"coordinating operations through the context\" path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"mutable-context\">\nimport {retry, tap} from 'rxjs/operators';\nexport const RETRY_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 3);\nexport const ERROR_COUNT = new <a href=\"api/common/http/HttpContextToken\" class=\"code-anchor\">HttpContextToken</a>(() =&gt; 0);\n\nexport class RetryInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n    const retryCount = req.context.get(RETRY_COUNT);\n\n    return next.handle(req).pipe(\n        tap({\n              // An error has occurred, so increment this request's ERROR_COUNT.\n             error: () =&gt; req.context.set(ERROR_COUNT, req.context.get(ERROR_COUNT) + 1)\n            }),\n        // Retry the request a configurable number of times.\n        retry(retryCount),\n    );\n  }\n}\n\n</code-example>\n\n  <div class=\"reviewed\">最後複查時間：11/15/2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpContext\n - api/common/http/HttpContext#get\n - api/common/http/HttpContextToken\n - api/common/http/HttpEvent\n - api/common/http/HttpHandler\n - api/common/http/HttpInterceptor\n - api/common/http/HttpRequest\n - guide/http-pass-metadata-to-interceptors#contexts-are-mutable\n - guide/http-pass-metadata-to-interceptors#create-a-context-token\n - guide/http-pass-metadata-to-interceptors#http---pass-metadata-to-interceptors\n - guide/http-pass-metadata-to-interceptors#http---將元資料傳遞給攔截器\n - guide/http-pass-metadata-to-interceptors#read-context-values-in-an-interceptor\n - guide/http-pass-metadata-to-interceptors#set-context-values-when-making-a-request\n - guide/http-pass-metadata-to-interceptors#上下文是可變的mutable\n - guide/http-pass-metadata-to-interceptors#建立上下文標記\n - guide/http-pass-metadata-to-interceptors#發出請求時設定上下文值\n - guide/http-pass-metadata-to-interceptors#在攔截器中讀取上下文值\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-pass-metadata-to-interceptors.md?message=docs%3A%20請簡述你的修改...\n-->"}