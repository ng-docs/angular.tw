{"id":"guide/elements","title":"Angular elements overview","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/elements.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"angular-elements-overview\" translation-result=\"on\">Angular 元素（Elements）概覽<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#angular-elements-overview\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Angular elements overview<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#angular-elements-overview\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\"><em>Angular 元素</em>就是打包成<em>自訂元素</em>的 Angular 元件。所謂自訂元素就是一套與具體框架無關的用於定義新 HTML 元素的 Web 標準。</p><p translation-origin=\"off\"><em>Angular elements</em> are Angular components packaged as <em>custom elements</em> (also called Web Components), a web standard for defining new HTML elements in a framework-agnostic way.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">這裡所說的範例應用，參閱<live-example></live-example>。</p><p translation-origin=\"off\">For the sample application that this page describes, see the <live-example></live-example>.</p>\n\n</div>\n<p translation-result=\"on\"><a href=\"https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements\">自訂元素</a>這項特性目前受到了 Chrome、Edge（基於 Chromium 的版本）、Opera 和 Safari 的支援，在其它瀏覽器中也能透過Polyfill指令碼（參閱<a href=\"guide/elements#browser-support\">瀏覽器支援</a>）加以支援。\n自訂元素擴充了 HTML，它允許你定義一個由 JavaScript 程式碼建立和控制的標籤。\n瀏覽器會維護一個自訂元素的登錄檔 <code>CustomElementRegistry</code>，它把一個可例項化的 JavaScript 類對映到 HTML 標籤上。</p><p translation-origin=\"off\"><a href=\"https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements\">Custom elements</a> are a Web Platform feature currently supported by Chrome, Edge (Chromium-based), Firefox, Opera, and Safari, and available in other browsers through polyfills (see <a href=\"guide/elements#browser-support\">Browser Support</a>).\nA custom element extends HTML by allowing you to define a tag whose content is created and controlled by JavaScript code.\nThe browser maintains a <code>CustomElementRegistry</code> of defined custom elements, which maps an instantiable JavaScript class to an HTML tag.</p>\n\n<p translation-result=\"on\"><code>@angular/elements</code> 包匯出了一個 <code><a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>()</code> API，它在 Angular 元件介面與變更檢測功能和內建 DOM API 之間建立了一個橋樑。</p><p translation-origin=\"off\">The <code>@angular/elements</code> package exports a <code><a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>()</code> API that provides a bridge from Angular's component interface and change detection functionality to the built-in DOM API.</p>\n\n<p translation-result=\"on\">把元件轉換成自訂元素可以讓所有所需的 Angular 基礎設施都在瀏覽器中可用。\n建立自訂元素的方式簡單直觀，它會自動把你元件定義的檢視連同變更檢測與資料繫結等 Angular 的功能對映為相應的內建 HTML 等價物。</p><p translation-origin=\"off\">Transforming a component to a custom element makes all of the required Angular infrastructure available to the browser.\nCreating a custom element is simple and straightforward, and automatically connects your component-defined view with change detection and data binding, mapping Angular functionality to the corresponding built-in HTML equivalents.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">我們正在持續開發自訂元素功能，讓它們可以用在由其它框架所建構的 Web 應用中。\nAngular 框架的一個小型的、自包含的版本將會作為服務注入進去，以提供元件的變更檢測和資料繫結功能。\n要了解這個開發方向的更多內容，參閱<a href=\"https://www.youtube.com/watch?v=Z1gLFPLVJjY&amp;t=4s\">這個影片演講</a>。</p><p translation-origin=\"off\">We are working on custom elements that can be used by web apps built on other frameworks.\nA minimal, self-contained version of the Angular framework is injected as a service to support the component's change-detection and data-binding functionality.\nFor more about the direction of development, check out this <a href=\"https://www.youtube.com/watch?v=Z1gLFPLVJjY&amp;t=4s\">video presentation</a>.</p>\n\n</div>\n<h2 id=\"using-custom-elements\" translation-result=\"on\">使用自訂元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#using-custom-elements\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Using custom elements<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#using-custom-elements\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">自訂元素會自舉 —— 它們在新增到 DOM 中時就會自行啟動自己，並在從 DOM 中移除時自行銷燬自己。一旦自訂元素新增到了任何頁面的 DOM 中，它的外觀和行為就和其它的 HTML 元素一樣了，不需要對 Angular 的術語或使用約定有任何特殊的瞭解。</p><p translation-origin=\"off\">Custom elements bootstrap themselves - they start automatically when they are added to the DOM, and are automatically destroyed when removed from the DOM.\nOnce a custom element is added to the DOM for any page, it looks and behaves like any other HTML element, and does not require any special knowledge of Angular terms or usage conventions.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳細資訊</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">Angular 應用程式中的簡單動態內容</nt-wrapper><nt-wrapper translation-origin=\"off\">Easy dynamic content in an Angular application</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">把元件轉換成自訂元素為你在 Angular 應用中建立動態 HTML 內容提供了一種簡單的方式。在 Angular 應用中，你直接新增到 DOM 中的 HTML 內容是不會經過 Angular 處理的，除非你使用<em>動態元件</em>來藉助自己的程式碼把 HTML 標籤與你的應用資料關聯起來並參與變更檢測。而使用自訂元件，所有這些裝配工作都是自動的。</nt-wrapper><nt-wrapper translation-origin=\"off\">Transforming a component to a custom element provides a straightforward path to creating dynamic HTML content in your Angular application. HTML content that you add directly to the DOM in an Angular application is normally displayed without Angular processing, unless you define a <em>dynamic component</em>, adding your own code to connect the HTML tag to your application data, and participate in change detection. With a custom element, all of that wiring is taken care of automatically.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">富內容應用</nt-wrapper><nt-wrapper translation-origin=\"off\">Content-rich applications</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果你有一個富內容應用（比如正在展示本文件的這個），自訂元素能讓你的內容提供者使用複雜的 Angular 功能，而不要求他了解 Angular 的知識。比如，像本文件這樣的 Angular 指南是使用 Angular 導航工具直接新增到 DOM 中的，但是其中可以包含特殊的元素，比如 <code>&lt;code-snippet&gt;</code>，它可以執行復雜的操作。你所要告訴你的內容提供者的一切，就是這個自訂元素的語法。他們不需要了解關於 Angular 的任何知識，也不需要了解你的元件的資料結構或實現。</nt-wrapper><nt-wrapper translation-origin=\"off\">If you have a content-rich application, such as the Angular app that presents this documentation, custom elements let you give your content providers sophisticated Angular functionality without requiring knowledge of Angular. For example, an Angular guide like this one is added directly to the DOM by the Angular navigation tools, but can include special elements like <code>&lt;code-snippet&gt;</code> that perform complex operations. All you need to tell your content provider is the syntax of your custom element. They don't need to know anything about Angular, or anything about your component's data structures or implementation.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<h3 id=\"how-it-works\" translation-result=\"on\">工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#how-it-works\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">How it works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#how-it-works\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">使用 <code><a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>()</code> 函式來把元件轉換成一個可註冊成瀏覽器中自訂元素的類別。\n註冊完這個配置好的類之後，就可以在內容中像內建 HTML 元素一樣使用這個新元素了，比如直接把它加到 DOM 中：</p><p translation-origin=\"off\">Use the <code><a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>()</code> function to convert a component into a class that can be registered with the browser as a custom element.\nAfter you register your configured class with the browser's custom-element registry, use the new element just like a built-in HTML element in content that you add directly into the DOM:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;my-popup message=\"Use Angular!\"&gt;&lt;/my-popup&gt;\n\n</code-example>\n<p translation-result=\"on\">當你的自訂元素放進頁面中時，瀏覽器會建立一個已註冊類別的例項。其內容是由元件範本提供的，它使用 Angular 範本語法，並且使用元件和 DOM 資料進行渲染。元件的輸入屬性（Property）對應於該元素的輸入屬性（Attribute）。</p><p translation-origin=\"off\">When your custom element is placed on a page, the browser creates an instance of the registered class and adds it to the DOM.\nThe content is provided by the component's template, which uses Angular template syntax, and is rendered using the component and DOM data.\nInput properties in the component correspond to input attributes for the element.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Custom element in browser\" class=\"left\" src=\"generated/images/guide/elements/customElement1.png\" width=\"600\" height=\"360\">\n</div>\n<h2 id=\"transforming-components-to-custom-elements\" translation-result=\"on\">把元件轉換成自訂元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#transforming-components-to-custom-elements\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Transforming components to custom elements<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#transforming-components-to-custom-elements\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 提供了 <code><a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>()</code> 函式，以支援把 Angular 元件及其依賴轉換成自訂元素。該函式會收集該元件的 <code>Observable</code> 型屬性，提供瀏覽器建立和銷燬例項時所需的 Angular 功能，還會對變更進行檢測並做出響應。</p><p translation-origin=\"off\">Angular provides the <code><a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>()</code> function for converting an Angular component, together with its dependencies, to a custom element.\nThe function collects the component's observable properties, along with the Angular functionality the browser needs to create and destroy instances, and to detect and respond to changes.</p>\n\n<p translation-result=\"on\">這個轉換過程實現了 <code><a href=\"api/elements/NgElementConstructor\" class=\"code-anchor\">NgElementConstructor</a></code> 介面，並建立了一個構造器類，用於產生該元件的一個自舉型例項。</p><p translation-origin=\"off\">The conversion process implements the <code><a href=\"api/elements/NgElementConstructor\" class=\"code-anchor\">NgElementConstructor</a></code> interface, and creates a\nconstructor class that is configured to produce a self-bootstrapping instance of your component.</p>\n\n<p translation-result=\"on\">使用內建的 <a href=\"https://developer.mozilla.org/docs/Web/API/CustomElementRegistry/define\"><code>customElements.define()</code></a> 函式把這個配置好的構造器和相關的自訂元素標籤註冊到瀏覽器的 <a href=\"https://developer.mozilla.org/docs/Web/API/CustomElementRegistry\"><code>CustomElementRegistry</code></a> 中。\n當瀏覽器遇到這個已註冊元素的標籤時，就會使用該構造器來建立一個自訂元素的例項。</p><p translation-origin=\"off\">Use the built-in <a href=\"https://developer.mozilla.org/docs/Web/API/CustomElementRegistry/define\"><code>customElements.define()</code></a> function to register the configured constructor and its associated custom-element tag with the browser's <a href=\"https://developer.mozilla.org/docs/Web/API/CustomElementRegistry\"><code>CustomElementRegistry</code></a>.\nWhen the browser encounters the tag for the registered element, it uses the constructor to create a custom-element instance.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Transform a component to a custom element\" class=\"left\" src=\"generated/images/guide/elements/createElement.png\" width=\"600\" height=\"400\">\n</div>\n<div class=\"alert is-important\">\n<p translation-result=\"on\">不要將 <a href=\"api/core/Component\"><code>@Component</code></a> 的<a href=\"api/core/Directive#selector\">選擇器</a>用作自訂元素的標記名稱。由於 Angular 會為單個 DOM 元素建立兩個元件例項，所以這可能導致意外行為：一個是常規的 Angular 元件，而另一個是自訂元素。</p><p translation-origin=\"off\">Avoid using the <a href=\"api/core/Component\"><code>@Component</code></a> <a href=\"api/core/Directive#selector\">selector</a> as the custom-element tag name.\nThis can lead to unexpected behavior, due to Angular creating two component instances for a single DOM element:\nOne regular Angular component and a second one using the custom element.</p>\n\n</div>\n<h3 id=\"mapping\" translation-result=\"on\">對映<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#mapping\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Mapping<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#mapping\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><em>寄宿</em>著 Angular 元件的自訂元素在元件中定義的\"資料及邏輯\"和標準的 DOM API 之間建立了一座橋樑。元件的屬性和邏輯會直接對映到 HTML 屬性和瀏覽器的事件系統中。</p><p translation-origin=\"off\">A custom element <em>hosts</em> an Angular component, providing a bridge between the data and logic defined in the component and standard DOM APIs.\nComponent properties and logic maps directly into HTML attributes and the browser's event system.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">用於建立的 API 會解析該元件，以查詢輸入屬性（Property），並在這個自訂元素上定義相應的屬性（Attribute）。\n它把屬性名轉換成與自訂元素相容的形式（自訂元素不區分大小寫），產生的屬性名會使用中線分隔的小寫形式。\n比如，對於帶有 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('myInputProp') inputProp</code> 的元件，其對應的自訂元素會帶有一個 <code>my-input-prop</code> 屬性。</p><p translation-origin=\"off\">The creation API parses the component looking for input properties, and defines corresponding attributes for the custom element.\nIt transforms the property names to make them compatible with custom elements, which do not recognize case distinctions.\nThe resulting attribute names use dash-separated lowercase.\nFor example, for a component with <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('myInputProp') inputProp</code>, the corresponding custom element defines an attribute <code>my-input-prop</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">元件的輸出屬性會用 HTML <a href=\"https://developer.mozilla.org/docs/Web/API/CustomEvent\">自訂事件</a>的形式進行分發，自訂事件的名字就是這個輸出屬性的名字。\n比如，對於帶有 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() valueChanged = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>()</code> 屬性的元件，其相應的自訂元素將會分發名叫 \"valueChanged\" 的事件，事件中所攜帶的資料儲存在該事件物件的 <code>detail</code> 屬性中。\n如果你提供了別名，就改用這個別名。比如，<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>('myClick') clicks = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;string&gt;();</code> 會導致分發名為 \"myClick\" 事件。</p><p translation-origin=\"off\">Component outputs are dispatched as HTML <a href=\"https://developer.mozilla.org/docs/Web/API/CustomEvent\">Custom Events</a>, with the name of the custom event matching the output name.\nFor example, for a component with <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() valueChanged = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>()</code>, the corresponding custom element dispatches events with the name \"valueChanged\", and the emitted data is stored on the event's <code>detail</code> property.\nIf you provide an alias, that value is used; for example, <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>('myClick') clicks = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;string&gt;();</code> results in dispatch events with the name \"myClick\".</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">要了解更多，參閱 Web Component 的文件：<a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events#Creating_custom_events\">Creating custom events</a>。</p><p translation-origin=\"off\">For more information, see Web Component documentation for <a href=\"https://developer.mozilla.org/docs/Web/Guide/Events/Creating_and_triggering_events#Creating_custom_events\">Creating custom events</a>.</p>\n\n<p><a id=\"browser-support\"></a></p>\n<h2 id=\"browser-support-for-custom-elements\" translation-result=\"on\">自訂元素的瀏覽器支援<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#browser-support-for-custom-elements\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Browser support for custom elements<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#browser-support-for-custom-elements\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">最近開發的 Web 平台特性：<a href=\"https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements\">自訂元素</a>目前在一些瀏覽器中實現了原生支援，而其它瀏覽器或者尚未決定，或者已經制訂了計劃。</p><p translation-origin=\"off\">The recently-developed <a href=\"https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements\">custom elements</a> Web Platform feature is currently supported natively in a number of browsers.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">瀏覽器</nt-wrapper><nt-wrapper translation-origin=\"off\">Browser</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">自訂元素支援</nt-wrapper><nt-wrapper translation-origin=\"off\">Custom Element Support</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\">Chrome</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">原生支援。</nt-wrapper><nt-wrapper translation-origin=\"off\">Supported natively.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">Edge (基於 Chromium 的版本)</nt-wrapper><nt-wrapper translation-origin=\"off\">Edge (Chromium-based)</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">原生支援。</nt-wrapper><nt-wrapper translation-origin=\"off\">Supported natively.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\">Firefox</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">原生支援。</nt-wrapper><nt-wrapper translation-origin=\"off\">Supported natively.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\">Opera</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">原生支援。</nt-wrapper><nt-wrapper translation-origin=\"off\">Supported natively.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\">Safari</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">原生支援。</nt-wrapper><nt-wrapper translation-origin=\"off\">Supported natively.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">要往工作空間中新增 <code>@angular/elements</code> 套件，請執行如下命令：</p><p translation-origin=\"off\">To add the <code>@angular/elements</code> package to your workspace, run the following command:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @angular/elements --save\n\n</code-example>\n<h2 id=\"example-a-popup-service\" translation-result=\"on\">範例：彈窗服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#example-a-popup-service\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Example: A Popup Service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#example-a-popup-service\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">以前，如果你要在執行期間把一個元件新增到應用中，就得定義成<em>動態元件</em>，然後還要載入它、把它附加到 DOM 中的元素上，並且裝配所有的依賴、變更檢測和事件處理，詳見<a href=\"guide/dynamic-component-loader\">動態元件載入器</a>。</p><p translation-origin=\"off\">Previously, when you wanted to add a component to an application at runtime, you had to define a <em>dynamic component</em>, and then you would have to load it, attach it to an element in the DOM, and wire up all of the dependencies, change detection, and event handling, as described in <a href=\"guide/dynamic-component-loader\">Dynamic Component Loader</a>.</p>\n\n<p translation-result=\"on\">用 Angular 自訂元件會讓這個過程更簡單、更透明。它會自動提供所有基礎設施和框架，而你要做的就是定義所需的各種事件處理邏輯。（如果你不準備在應用中直接用它，還要把該元件在編譯時排除出去。）</p><p translation-origin=\"off\">Using an Angular custom element makes the process much simpler and more transparent, by providing all of the infrastructure and framework automatically —all you have to do is define the kind of event handling you want.\n(You do still have to exclude the component from compilation, if you are not going to use it in your application.)</p>\n\n<p translation-result=\"on\">這個彈窗服務的範例應用（見後面）定義了一個元件，你可以動態載入它也可以把它轉換成自訂元件。</p><p translation-origin=\"off\">The following Popup Service example application defines a component that you can either load dynamically or convert to a custom element.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">檔案</nt-wrapper><nt-wrapper translation-origin=\"off\">Files</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳細資訊</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>popup.component.ts</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">定義了一個簡單的彈窗元素，用於顯示一條輸入訊息，附帶一些動畫和樣式。</nt-wrapper><nt-wrapper translation-origin=\"off\">Defines a simple pop-up element that displays an input message, with some animation and styling.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>popup.service.ts</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">建立了一個可注入的服務，它提供了兩種方式來執行 <code>PopupComponent</code>：作為動態元件或作為自訂元素。注意動態元件的方式需要更多的程式碼來做搭建工作。</nt-wrapper><nt-wrapper translation-origin=\"off\">Creates an injectable service that provides two different ways to invoke the <code>PopupComponent</code>; as a dynamic component, or as a custom element Notice how much more setup is required for the dynamic-loading method.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>app.module.ts</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">把 <code>PopupComponent</code> 新增到模組的 <code>declarations</code> 列表中</nt-wrapper><nt-wrapper translation-origin=\"off\">Adds the <code>PopupComponent</code> in the module's <code>declarations</code> list.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>app.component.ts</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">定義了該應用的根元件，它藉助 <code>PopupService</code> 在執行時把這個彈窗新增到 DOM 中。在應用執行期間，根元件的建構函式會把 <code>PopupComponent</code> 轉換成自訂元素。</nt-wrapper><nt-wrapper translation-origin=\"off\">Defines the application's root component, which uses the <code>PopupService</code> to add the pop-up to the DOM at run time. When the application runs, the root component's constructor converts <code>PopupComponent</code> to a custom element.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">為了對比，這個範例中同時示範了這兩種方式。一個按鈕使用動態載入的方式新增彈窗，另一個按鈕使用自訂元素的方式。可以看到，兩者的結果是一樣的，其差別只是準備過程不同。</p><p translation-origin=\"off\">For comparison, the demo shows both methods.\nOne button adds the popup using the dynamic-loading method, and the other uses the custom element.\nThe result is the same; only the preparation is different.</p>\n\n<code-tabs>\n    <code-pane header=\"popup.component.ts\" path=\"elements/src/app/popup.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\nimport { <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>, state, <a href=\"api/animations/style\" class=\"code-anchor\">style</a>, <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>, <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> } from '@angular/animations';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-popup',\n  template: `\n    &lt;span&gt;Popup: {{message}}&lt;/span&gt;\n    &lt;button type=\"button\" (click)=\"closed.next()\"&gt;&amp;#x2716;&lt;/button&gt;\n  `,\n  animations: [\n    <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a>('state', [\n      state('opened', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({transform: 'translateY(0%)'})),\n      state('void, closed', <a href=\"api/animations/style\" class=\"code-anchor\">style</a>({transform: 'translateY(100%)', opacity: 0})),\n      <a href=\"api/animations/transition\" class=\"code-anchor\">transition</a>('* =&gt; *', <a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>('100ms ease-in')),\n    ])\n  ],\n  styles: [`\n    :host {\n      position: absolute;\n      bottom: 0;\n      left: 0;\n      right: 0;\n      background: #009cff;\n      height: 48px;\n      padding: 16px;\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      border-top: 1px solid black;\n      font-size: 24px;\n    }\n\n    button {\n      border-radius: 50%;\n    }\n  `]\n})\nexport class PopupComponent {\n  @<a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a>('@state')\n  state: 'opened' | 'closed' = 'closed';\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  get message(): string { return this._message; }\n  set message(message: string) {\n    this._message = message;\n    this.state = 'opened';\n  }\n  private _message = '';\n\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()\n  closed = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;void&gt;();\n}\n\n\n</code-pane>\n    <code-pane header=\"popup.service.ts\" path=\"elements/src/app/popup.service.ts\">\n\nimport { <a href=\"api/core/ApplicationRef\" class=\"code-anchor\">ApplicationRef</a>, <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>, <a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a>, <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a>, <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a> } from '@angular/elements';\nimport { PopupComponent } from './popup.component';\n\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class PopupService {\n  constructor(private injector: <a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a>,\n              private applicationRef: <a href=\"api/core/ApplicationRef\" class=\"code-anchor\">ApplicationRef</a>) {}\n\n  // Previous dynamic-loading method required you to set up infrastructure\n  // before adding the popup to the DOM.\n  showAsComponent(message: string) {\n    // Create element\n    const popup = document.createElement('popup-component');\n\n    // Create the component and wire it up with the element\n    const popupComponentRef = <a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>(PopupComponent, {environmentInjector: this.injector, hostElement: popup});\n\n    // Attach to the view so that the change detector knows to run\n    this.applicationRef.attachView(popupComponentRef.hostView);\n\n    // Listen to the close event\n    popupComponentRef.instance.closed.subscribe(() =&gt; {\n      document.body.removeChild(popup);\n      this.applicationRef.detachView(popupComponentRef.hostView);\n    });\n\n    // Set the message\n    popupComponentRef.instance.message = message;\n\n    // Add to the DOM\n    document.body.appendChild(popup);\n  }\n\n  // This uses the new custom-element method to add the popup to the DOM.\n  showAsElement(message: string) {\n    // Create element\n    const popupEl: <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;PopupComponent&gt; = document.createElement('popup-element') as any;\n\n    // Listen to the close event\n    popupEl.addEventListener('closed', () =&gt; document.body.removeChild(popupEl));\n\n    // Set the message\n    popupEl.message = message;\n\n    // Add to the DOM\n    document.body.appendChild(popupEl);\n  }\n}\n\n\n</code-pane>\n    <code-pane header=\"app.module.ts\" path=\"elements/src/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a> } from '@angular/platform-browser/animations';\n\nimport { AppComponent } from './app.component';\nimport { PopupComponent } from './popup.component';\nimport { PopupService } from './popup.service';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [<a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>, <a href=\"api/platform-browser/animations/BrowserAnimationsModule\" class=\"code-anchor\">BrowserAnimationsModule</a>],\n  providers: [PopupService],\n  declarations: [AppComponent, PopupComponent],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {\n}\n\n\n</code-pane>\n    <code-pane header=\"app.component.ts\" path=\"elements/src/app/app.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a> } from '@angular/core';\nimport { <a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a> } from '@angular/elements';\nimport { PopupService } from './popup.service';\nimport { PopupComponent } from './popup.component';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: `\n    &lt;input #input value=\"Message\"&gt;\n    &lt;button type=\"button\" (click)=\"popup.showAsComponent(input.value)\"&gt;Show as component&lt;/button&gt;\n    &lt;button type=\"button\" (click)=\"popup.showAsElement(input.value)\"&gt;Show as element&lt;/button&gt;\n  `,\n})\nexport class AppComponent {\n  constructor(injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>, public popup: PopupService) {\n    // Convert `PopupComponent` to a custom element.\n    const PopupElement = <a href=\"api/elements/createCustomElement\" class=\"code-anchor\">createCustomElement</a>(PopupComponent, {injector});\n    // Register the custom element with the browser.\n    customElements.define('popup-element', PopupElement);\n  }\n}\n\n\n</code-pane>\n</code-tabs>\n<h2 id=\"typings-for-custom-elements\" translation-result=\"on\">為自訂元素新增型別支援<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#typings-for-custom-elements\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Typings for custom elements<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/elements#typings-for-custom-elements\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">一般的 DOM API，比如 <code>document.createElement()</code> 或 <code>document.querySelector()</code>，會返回一個與指定的引數相匹配的元素型別。比如，呼叫 <code>document.createElement('a')</code> 會返回 <code>HTMLAnchorElement</code>，這樣 TypeScript 就會知道它有一個 <code>href</code> 屬性，而 <code>document.createElement('div')</code> 會返回 <code>HTMLDivElement</code>，這樣 TypeScript 就會知道它沒有 <code>href</code> 屬性。</p><p translation-origin=\"off\">Generic DOM APIs, such as <code>document.createElement()</code> or <code>document.querySelector()</code>, return an element type that is appropriate for the specified arguments.\nFor example, calling <code>document.createElement('a')</code> returns an <code>HTMLAnchorElement</code>, which TypeScript knows has an <code>href</code> property.\nSimilarly, <code>document.createElement('div')</code> returns an <code>HTMLDivElement</code>, which TypeScript knows has no <code>href</code> property.</p>\n\n<p translation-result=\"on\">當呼叫未知元素（比如自訂的元素名 <code>popup-element</code>）時，該方法會返回泛化型別，比如 <code>HTMLELement</code>，這時候 TypeScript 就無法推斷出所返回元素的正確型別。</p><p translation-origin=\"off\">When called with unknown elements, such as a custom element name (<code>popup-element</code> in our example), the methods return a generic type, such as <code>HTMLElement</code>, because TypeScript can't infer the correct type of the returned element.</p>\n\n<p translation-result=\"on\">用 Angular 建立的自訂元素會擴充 <code><a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a></code> 型別（而它擴充了 <code>HTMLElement</code>）。除此之外，這些自訂元素還擁有相應元件的每個輸入屬性。比如，<code>popup-element</code> 元素具有一個 <code>string</code> 型的 <code>message</code> 屬性。</p><p translation-origin=\"off\">Custom elements created with Angular extend <code><a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a></code> (which in turn extends <code>HTMLElement</code>).\nAdditionally, these custom elements will have a property for each input of the corresponding component.\nFor example, our <code>popup-element</code> has a <code>message</code> property of type <code>string</code>.</p>\n\n<p translation-result=\"on\">如果你要讓你的自訂元素獲得正確的型別，還可使用一些選項。假設你要建立一個基於下列元件的自訂元素 <code>my-dialog</code>：</p><p translation-origin=\"off\">There are a few options if you want to get correct types for your custom elements.\nAssume you create a <code>my-dialog</code> custom element based on the following component:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>(…)\nclass MyDialog {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() content: string;\n}\n\n</code-example>\n<p translation-result=\"on\">要獲得精確型別，最直白的方式是把相關 DOM 方法的返回值轉換成正確的型別。要做到這一點，可以使用 <code><a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a></code> 和 <code><a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a></code> 型別（都匯出自 <code>@angular/elements</code>）：</p><p translation-origin=\"off\">The most straightforward way to get accurate typings is to cast the return value of the relevant DOM methods to the correct type.\nFor that, use the <code><a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a></code> and <code><a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a></code> types (both exported from <code>@angular/elements</code>):</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst aDialog = document.createElement('my-dialog') as <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{content: string}&gt;;\naDialog.content = 'Hello, world!';\naDialog.content = 123;  // &lt;-- ERROR: TypeScript knows this should be a string.\naDialog.body = 'News';  // &lt;-- ERROR: TypeScript knows there is no `body` property on `aDialog`.\n\n</code-example>\n<p translation-result=\"on\">這是一種讓你的自訂元素快速獲得 TypeScript 特性（比如型別檢查和自動完成支援）的好辦法，不過如果你要在多個地方使用它，可能會有點囉嗦，因為不得不在每個地方對返回型別做轉換。</p><p translation-origin=\"off\">This is a good way to quickly get TypeScript features, such as type checking and autocomplete support, for your custom element.\nBut it can get cumbersome if you need it in several places, because you have to cast the return type on every occurrence.</p>\n\n<p translation-result=\"on\">另一種方式可以對每個自訂元素的型別只宣告一次。你可以擴充 <code>HTMLElementTagNameMap</code>，TypeScript 會在 DOM 方法（如 <code>document.createElement()</code>、<code>document.querySelector()</code> 等）中用它來根據標籤名推斷返回元素的型別。</p><p translation-origin=\"off\">An alternative way, that only requires defining each custom element's type once, is augmenting the <code>HTMLElementTagNameMap</code>, which TypeScript uses to infer the type of a returned element based on its tag name (for DOM methods such as <code>document.createElement()</code>, <code>document.querySelector()</code>, etc.):</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\ndeclare <a href=\"api/core/global\" class=\"code-anchor\">global</a> {\n  interface HTMLElementTagNameMap {\n    'my-dialog': <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{content: string}&gt;;\n    'my-other-element': <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{foo: 'bar'}&gt;;\n    …\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">現在，TypeScript 就可以像內建元素一樣推斷出它的正確型別了：</p><p translation-origin=\"off\">Now, TypeScript can infer the correct type the same way it does for built-in elements:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\ndocument.createElement('div')               //--&gt; HTMLDivElement (built-in element)\ndocument.querySelector('foo')               //--&gt; Element        (unknown element)\ndocument.createElement('my-dialog')         //--&gt; <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{content: string}&gt; (custom element)\ndocument.querySelector('my-other-element')  //--&gt; <a href=\"api/elements/NgElement\" class=\"code-anchor\">NgElement</a> &amp; <a href=\"api/elements/WithProperties\" class=\"code-anchor\">WithProperties</a>&lt;{foo: 'bar'}&gt;      (custom element)\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/elements\n - api/elements/NgElementConstructor\n - api/elements/createCustomElement\n - guide/architecture-next-steps\n - guide/example-apps-list\n - guide/glossary\n - guide/libraries\n-->\n<!-- links from this doc:\n - api/animations/animate\n - api/animations/style\n - api/animations/transition\n - api/animations/trigger\n - api/core/ApplicationRef\n - api/core/Component\n - api/core/Directive#selector\n - api/core/EnvironmentInjector\n - api/core/EventEmitter\n - api/core/HostBinding\n - api/core/Injectable\n - api/core/Injector\n - api/core/Input\n - api/core/NgModule\n - api/core/Output\n - api/core/createComponent\n - api/core/global\n - api/elements/NgElement\n - api/elements/NgElementConstructor\n - api/elements/WithProperties\n - api/elements/createCustomElement\n - api/platform-browser/BrowserModule\n - api/platform-browser/animations/BrowserAnimationsModule\n - guide/dynamic-component-loader\n - guide/elements#angular-elements-overview\n - guide/elements#angular-元素elements概覽\n - guide/elements#browser-support\n - guide/elements#browser-support-for-custom-elements\n - guide/elements#example-a-popup-service\n - guide/elements#how-it-works\n - guide/elements#mapping\n - guide/elements#transforming-components-to-custom-elements\n - guide/elements#typings-for-custom-elements\n - guide/elements#using-custom-elements\n - guide/elements#為自訂元素新增型別支援\n - guide/elements#使用自訂元素\n - guide/elements#工作原理\n - guide/elements#把元件轉換成自訂元素\n - guide/elements#對映\n - guide/elements#自訂元素的瀏覽器支援\n - guide/elements#範例彈窗服務\n - https://developer.mozilla.org/docs/Web/API/CustomElementRegistry\n - https://developer.mozilla.org/docs/Web/API/CustomElementRegistry/define\n - https://developer.mozilla.org/docs/Web/API/CustomEvent\n - https://developer.mozilla.org/docs/Web/Guide/Events/Creating_and_triggering_events#Creating_custom_events\n - https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements\n - https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events#Creating_custom_events\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/elements.md?message=docs%3A%20請簡述你的修改...\n - https://www.youtube.com/watch?v=Z1gLFPLVJjY&t=4s\n-->"}