{"id":"guide/user-input","title":"User input","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/user-input.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"user-input\" translation-result=\"on\">使用者輸入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#user-input\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">User input<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#user-input\"><i class=\"material-icons\">link</i></a></h1>\n\n<div class=\"callout is-critical\">\n<header ng-should-translate=\"\" translation-result=\"on\">標記為存檔</header><header ng-should-translate=\"\" translation-origin=\"off\">Marked for archiving</header>\n\n<p translation-result=\"on\">為確保你擁有最佳的體驗，本主題已標記為存檔，直到我們確定其清楚地傳達了最準確的資訊為止。</p><p translation-origin=\"off\">To ensure that you have the best experience possible, this topic is marked for archiving until it clearly conveys the most accurate information possible.</p>\n\n<p translation-result=\"on\">同時，本主題可能會有所幫助：<a href=\"guide/event-binding\">事件繫結</a>。</p><p translation-origin=\"off\">In the meantime, this topic might be helpful:\n<a href=\"guide/event-binding\">Event binding</a>.</p>\n\n<p translation-result=\"on\">如果你認為不應將此內容存檔，請提交 <a href=\"https://github.com/angular/angular/issues/new?template=3-docs-bug.md\">GitHub 問題</a>。</p><p translation-origin=\"off\">If you think this content should not be archived, please file a <a href=\"https://github.com/angular/angular/issues/new?template=3-docs-bug.md\">GitHub issue</a>.</p>\n\n</div>\n<p translation-result=\"on\">當用戶點選連結、按下按鈕或者輸入文字時，這些使用者動作都會產生 DOM 事件。本章解釋如何使用 Angular 事件繫結語法把這些事件繫結到事件處理器。</p><p translation-origin=\"off\">User actions such as clicking a link, pushing a button, and entering text raise DOM events.\nThis page explains how to bind those events to component event handlers using the Angular event binding syntax.</p>\n\n<p translation-result=\"on\">執行<live-example></live-example></p><p translation-origin=\"off\">Run the <live-example></live-example>.</p>\n\n<h2 id=\"binding-to-user-input-events\" translation-result=\"on\">繫結到使用者輸入事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#binding-to-user-input-events\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Binding to user input events<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#binding-to-user-input-events\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以使用 <a href=\"guide/event-binding\">Angular 事件繫結</a>機制來響應任何 <a href=\"https://developer.mozilla.org/docs/Web/Events\">DOM 事件</a>。\n許多 DOM 事件是由使用者輸入觸發的。繫結這些事件可以獲取使用者輸入。</p><p translation-origin=\"off\">You can use <a href=\"guide/event-binding\">Angular event bindings</a> to respond to any <a href=\"https://developer.mozilla.org/docs/Web/Events\">DOM event</a>.\nMany DOM events are triggered by user input.\nBinding to these events provides a way to get input from the user.</p>\n\n<p translation-result=\"on\">要繫結 DOM 事件，只要把 DOM 事件的名字包裹在圓括號中，然後用放在引號中的<a href=\"guide/template-statements\">範本陳述式</a>對它賦值就可以了。</p><p translation-origin=\"off\">To bind to a DOM event, surround the DOM event name in parentheses and assign a quoted <a href=\"guide/template-statements\">template statement</a> to it.</p>\n\n<p translation-result=\"on\">下例展示了一個事件繫結，它實現了一個點選事件處理器：</p><p translation-origin=\"off\">The following example shows an event binding that implements a click handler:</p>\n\n<!-- vale Angular.Google_WordListWarnings = NO -->\n<code-example header=\"src/app/click-me.component.ts\" path=\"user-input/src/app/click-me.component.ts\" region=\"click-me-button\">\n&lt;button type=\"button\" (click)=\"onClickMe()\"&gt;Click me!&lt;/button&gt;\n\n</code-example>\n<!-- vale Angular.Google_WordListWarnings = YES -->\n<p><a id=\"click\"></a></p>\n<p translation-result=\"on\">等號左邊的 <code>(click)</code> 表示把按鈕的點選事件作為<strong>繫結目標</strong>。等號右邊引號中的文字是<strong>範本陳述式</strong>，透過呼叫元件的 <code>onClickMe</code> 方法來響應這個點選事件。</p><p translation-origin=\"off\">The <code>(click)</code> to the left of the equals sign identifies the button's click event as the <strong>target of the binding</strong>.\nThe text in quotes to the right of the equals sign is the <strong>template statement</strong>. The statement responds to the click event by calling the component's <code>onClickMe</code> method.</p>\n\n<p translation-result=\"on\">寫繫結時，需要知道範本陳述式的<strong>執行上下文</strong>。出現在範本陳述式中的每個識別符號都屬於特定的上下文物件。這個物件通常都是控制此範本的 Angular 元件。上例中只顯示了一行 HTML，那段 HTML 片段屬於下面這個元件：</p><p translation-origin=\"off\">When writing a binding, be aware of a template statement's <strong>execution context</strong>.\nThe identifiers in a template statement belong to a specific context object, usually the Angular component controlling the template.\nThe preceding example shows a single line of HTML, but that HTML belongs to a larger component:</p>\n\n<code-example header=\"src/app/click-me.component.ts\" path=\"user-input/src/app/click-me.component.ts\" region=\"click-me-component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-click-me',\n  template: `\n    &lt;button type=\"button\" (click)=\"onClickMe()\"&gt;Click me!&lt;/button&gt;\n    {{clickMessage}}`\n})\nexport class ClickMeComponent {\n  clickMessage = '';\n\n  onClickMe() {\n    this.clickMessage = 'You are my hero!';\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">當用戶點選按鈕時，Angular 呼叫 <code>ClickMeComponent</code> 的 <code>onClickMe</code> 方法。</p><p translation-origin=\"off\">When the user clicks the button, Angular calls the <code>onClickMe</code> method from <code>ClickMeComponent</code>.</p>\n\n<h2 id=\"get-user-input-from-the-event-object\" translation-result=\"on\">透過 $event 物件取得使用者輸入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#get-user-input-from-the-event-object\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Get user input from the $event object<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#get-user-input-from-the-event-object\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">DOM 事件可以攜帶可能對元件有用的資訊。本節將展示如何繫結輸入框的 <code>keyup</code> 事件，在每個敲按鍵盤時獲取使用者輸入。</p><p translation-origin=\"off\">DOM events carry a payload of information that may be useful to the component.\nThis section shows how to bind to the <code>keyup</code> event of an input box to get the user's input after each keystroke.</p>\n\n<p translation-result=\"on\">下面的程式碼監聽 <code>keyup</code> 事件，並將整個事件載荷 （<code>$event</code>） 傳給元件的事件處理器。</p><p translation-origin=\"off\">The following code listens to the <code>keyup</code> event and passes the entire event payload (<code>$event</code>) to the component event handler.</p>\n\n<code-example header=\"src/app/keyup.components.ts (template v.1)\" path=\"user-input/src/app/keyup.components.ts\" region=\"key-up-component-1-template\">\ntemplate: `\n  &lt;input (keyup)=\"onKey($event)\"&gt;\n  &lt;p&gt;{{values}}&lt;/p&gt;\n`\n\n</code-example>\n<p translation-result=\"on\">當用戶按下並釋放一個按鍵時，觸發 <code>keyup</code> 事件，Angular 在 <code>$event</code> 變數提供一個相應的 DOM 事件物件，上面的程式碼將它作為引數傳給 <code>onKey()</code> 方法。</p><p translation-origin=\"off\">When a user presses and releases a key, the <code>keyup</code> event occurs. Angular then provides a corresponding DOM event object in the <code>$event</code> variable which this code passes as a parameter to the component's <code>onKey()</code> method.</p>\n\n<code-example header=\"src/app/keyup.components.ts (class v.1)\" path=\"user-input/src/app/keyup.components.ts\" region=\"key-up-component-1-class-no-type\">\nexport class KeyUpComponent_v1 {\n  values = '';\n\n  onKey(event: any) { // without type info\n    this.values += event.target.value + ' | ';\n  }\n}\n\n</code-example>\n<p translation-result=\"on\"><code>$event</code> 物件的屬性取決於 DOM 事件的型別。比如，滑鼠事件與輸入框編輯事件包含了不同的資訊。</p><p translation-origin=\"off\">The properties of an <code>$event</code> object vary depending on the type of DOM event.\nFor example, a mouse event includes different information than an input box editing event.</p>\n\n<p translation-result=\"on\">所有<a href=\"https://developer.mozilla.org/docs/Web/API/Event\">標準 DOM 事件物件</a>都有一個 <code>target</code> 屬性，\n參考觸發該事件的元素。\n在本例中，<code>target</code> 是<a href=\"https://developer.mozilla.org/docs/Web/API/HTMLInputElement\"><code>&lt;input&gt;</code> 元素</a>，\n<code>event.target.value</code> 返回該元素的當前內容。</p><p translation-origin=\"off\">All <a href=\"https://developer.mozilla.org/docs/Web/API/Event\">standard DOM event objects</a> have a <code>target</code> property, a reference to the element that raised the event.\nIn this case, <code>target</code> refers to the <a href=\"https://developer.mozilla.org/docs/Web/API/HTMLInputElement\"><code>&lt;input&gt;</code> element</a> and <code>event.target.value</code> returns the current contents of that element.</p>\n\n<p translation-result=\"on\">在元件的 <code>onKey()</code> 方法中，把輸入框的值和分隔符 （<code>|</code>） 追加元件的 <code>values</code> 屬性。\n使用<a href=\"guide/interpolation\">插值</a>來把存放累加結果的 <code>values</code> 屬性回顯到螢幕上。</p><p translation-origin=\"off\">After each call, the <code>onKey()</code> method appends the contents of the input box value to the list in the component's <code>values</code> property, followed by a separator character (<code>|</code>).\nThe <a href=\"guide/interpolation\">interpolation</a> displays the accumulating input box changes from the <code>values</code> property.</p>\n\n<!-- vale Angular.Angular_Spelling = NO -->\n<p translation-result=\"on\">假設使用者輸入字母“abc”，然後用退格鍵一個一個刪除它們。使用者介面將顯示：</p><p translation-origin=\"off\">Suppose the user enters the letters \"abc\" and then backspaces to remove them one by one.\nHere's what the UI displays:</p>\n\n<!-- vale Angular.Angular_Spelling = YES -->\n<code-example>\n\na | ab | abc | ab | a | |\n\n</code-example>\n<div class=\"lightbox\">\n<img alt=\"key up 1\" src=\"generated/images/guide/user-input/keyup1-anim.gif\" width=\"176\" height=\"100\">\n</div>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">或者，你可以用 <code>event.key</code> 替代 <code>event.target.value</code>，積累各個按鍵本身，這樣同樣的使用者輸入可以產生：</p><p translation-origin=\"off\">You could also accumulate the individual keys themselves by substituting <code>event.key</code> for <code>event.target.value</code> in which case the same user input would produce:</p>\n\n<code-example>\n\na | b | c | backspace | backspace | backspace |\n\n</code-example>\n</div>\n<p><a id=\"keyup1\"></a></p>\n<h3 id=\"type-the-event\" translation-result=\"on\"><code>$event</code> 的型別<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#type-the-event\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Type the <code>$event</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#type-the-event\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">上例將 <code>$event</code> 轉換為 <code>any</code> 型別。這樣簡化了程式碼，但是有成本。沒有任何型別資訊能夠揭示事件物件的屬性，防止簡單的錯誤。</p><p translation-origin=\"off\">The preceding example casts the <code>$event</code> as an <code>any</code> type.\nThat simplifies the code at a cost.\nThere is no type information that could reveal properties of the event object and prevent silly mistakes.</p>\n\n<p translation-result=\"on\">下面的例子，使用了帶型別方法：</p><p translation-origin=\"off\">The following example rewrites the method with types:</p>\n\n<code-example header=\"src/app/keyup.components.ts (class v.1 - typed )\" path=\"user-input/src/app/keyup.components.ts\" region=\"key-up-component-1-class\">\nexport class KeyUpComponent_v1 {\n  values = '';\n\n\n  onKey(event: KeyboardEvent) { // with type info\n    this.values += (event.target as HTMLInputElement).value + ' | ';\n  }\n}\n\n</code-example>\n<p translation-result=\"on\"><code>$event</code> 的型別現在是 <code>KeyboardEvent</code>。不是所有的元素都有 <code>value</code> 屬性，所以它將 <code>target</code> 轉換為輸入元素。<code>OnKey</code> 方法更加清晰地表達了它期望從範本得到什麼，以及它是如何解析事件的。</p><p translation-origin=\"off\">The <code>$event</code> is now a specific <code>KeyboardEvent</code>.\nNot all elements have a <code>value</code> property so it casts <code>target</code> to an input element.\nThe <code>OnKey</code> method more clearly expresses what it expects from the template and how it interprets the event.</p>\n\n<h3 id=\"passing-event-is-a-dubious-practice\" translation-result=\"on\">傳入 <code>$event</code> 是靠不住的做法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#passing-event-is-a-dubious-practice\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Passing <code>$event</code> is a dubious practice<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#passing-event-is-a-dubious-practice\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">型別化事件物件揭露了重要的一點，即反對把整個 DOM 事件傳到方法中，因為這樣元件會知道太多範本的資訊。只有當它知道更多它本不應瞭解的 HTML 實現細節時，它才能提取資訊。這就違反了範本（<em>使用者看到的</em>）和元件（<em>應用如何處理使用者資料</em>）之間的分離關注原則。</p><p translation-origin=\"off\">Typing the event object reveals a significant objection to passing the entire DOM event into the method. Namely, the component has too much awareness of the template details.\nIt can't extract information without knowing more than it should about the HTML implementation.\nThat breaks the separation of concerns between the template, <em>what the user sees</em>, and the component, <em>how the application processes user data</em>.</p>\n\n<p translation-result=\"on\">下面將介紹如何用範本參考變數來解決這個問題。</p><p translation-origin=\"off\">The next section shows how to use template reference variables to address this problem.</p>\n\n<h2 id=\"get-user-input-from-a-template-reference-variable\" translation-result=\"on\">從一個範本參考變數中獲得使用者輸入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#get-user-input-from-a-template-reference-variable\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Get user input from a template reference variable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#get-user-input-from-a-template-reference-variable\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">還有另一種獲取使用者資料的方式：使用 Angular 的<a href=\"guide/template-reference-variables\"><strong>範本參考變數</strong></a>。\n這些變數提供了從模組中直接存取元素的能力。\n在識別符號前加上井號 （<code>#</code>） 就能宣告一個範本參考變數。</p><p translation-origin=\"off\">There's another way to get the user data:\nuse Angular <a href=\"guide/template-reference-variables\"><strong>template reference variables</strong></a>.\nThese variables provide direct access to an element from within the template.\nTo declare a template reference variable, precede an identifier with a hash/pound character (<code>#</code>).</p>\n\n<p translation-result=\"on\">下面的例子使用了局部範本變數，在一個超簡單的範本中實現按鍵反饋功能。</p><p translation-origin=\"off\">The following example uses a template reference variable to implement a keystroke loopback in a simple template.</p>\n\n<code-example header=\"src/app/loop-back.component.ts\" path=\"user-input/src/app/loop-back.component.ts\" region=\"loop-back-component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-loop-back',\n  template: `\n    &lt;input #box (keyup)=\"0\"&gt;\n    &lt;p&gt;{{box.value}}&lt;/p&gt;\n  `\n})\nexport class LoopbackComponent { }\n\n</code-example>\n<p translation-result=\"on\">這個範本參考變數名叫 <code>box</code>，在 <code>&lt;input&gt;</code> 元素宣告，它參考 <code>&lt;input&gt;</code> 元素本身。程式碼使用 <code>box</code> 獲得輸入元素的 <code>value</code> 值，並透過插值把它顯示在 <code>&lt;p&gt;</code> 標籤中。</p><p translation-origin=\"off\">The template reference variable named <code>box</code>, declared on the <code>&lt;input&gt;</code> element, refers to the <code>&lt;input&gt;</code> element itself.\nThe code uses the <code>box</code> variable to get the input element's <code>value</code> and display it with interpolation between <code>&lt;p&gt;</code> tags.</p>\n\n<p translation-result=\"on\">這個範本完全是完全自包含的。它沒有繫結到元件，元件也沒做任何事情。</p><p translation-origin=\"off\">The template is completely self-contained.\nIt doesn't bind to the component, and the component does nothing.</p>\n\n<p translation-result=\"on\">在輸入框中輸入，就會看到每次按鍵時，顯示也隨之更新了。</p><p translation-origin=\"off\">Type something in the input box, and watch the display update with each keystroke.</p>\n\n<div class=\"lightbox\">\n<img alt=\"loop back\" src=\"generated/images/guide/user-input/keyup-loop-back-anim.gif\" width=\"204\" height=\"100\">\n</div>\n<div class=\"callout is-helpful\">\n<header ng-should-translate=\"\" translation-result=\"on\">除非你繫結一個事件，否則這將完全無法工作。</header><header ng-should-translate=\"\" translation-origin=\"off\">This won't work at all unless you bind to an event.</header>\n\n<p translation-result=\"on\">只有在應用做了些非同步事件（如按鍵），Angular 才更新繫結和螢幕顯示。本例程式碼將 <code>keyup</code> 事件繫結到了數字 0，這可能是最短的範本陳述式了。雖然這個陳述式不做什麼，但它滿足 Angular 的要求，所以 Angular 將更新螢幕。</p><p translation-origin=\"off\">Angular updates the bindings and screen only if the app does something in response to asynchronous events, such as keystrokes.\nThis example code binds the <code>keyup</code> event to the number 0, the shortest template statement possible.\nWhile the statement does nothing useful, it satisfies Angular's condition so that Angular updates the screen.</p>\n\n</div>\n<p translation-result=\"on\">從範本變數獲得輸入框比透過 <code>$event</code> 物件更加簡單。下面的程式碼重寫了之前 <code>keyup</code> 範例，它使用變數來獲得使用者輸入。</p><p translation-origin=\"off\">It's easier to get to the input box with the template reference variable than to go through the <code>$event</code> object.\nHere's a rewrite of the previous <code>keyup</code> example that uses a template reference variable to get the user's input.</p>\n\n<code-example header=\"src/app/keyup.components.ts (v2)\" path=\"user-input/src/app/keyup.components.ts\" region=\"key-up-component-2\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-key-up2',\n  template: `\n    &lt;input #box (keyup)=\"onKey(box.value)\"&gt;\n    &lt;p&gt;{{values}}&lt;/p&gt;\n  `\n})\nexport class KeyUpComponent_v2 {\n  values = '';\n  onKey(value: string) {\n    this.values += value + ' | ';\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">這個方法最漂亮的一點是：元件程式碼從檢視中獲得了乾淨的資料值。再也不用瞭解 <code>$event</code> 變數及其結構了。</p><p translation-origin=\"off\">A nice aspect of this approach is that the component gets clean data values from the view.\nIt no longer requires knowledge of the <code>$event</code> and its structure.</p>\n\n<p><a id=\"key-event\"></a></p>\n<h2 id=\"key-event-filtering-with-keyenter\" translation-result=\"on\">按鍵事件過濾（透過 <code>key.enter</code>）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#key-event-filtering-with-keyenter\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Key event filtering (with <code>key.enter</code>)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#key-event-filtering-with-keyenter\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code>(keyup)</code> 事件處理器監聽<em>每一次按鍵</em>。有時只在意<em>Enter</em>鍵，因為它標誌著使用者結束輸入。解決這個問題的一種方法是檢查每個 <code>$event.keyCode</code>，只有鍵值是<em>Enter</em>鍵時才採取行動。</p><p translation-origin=\"off\">The <code>(keyup)</code> event handler hears <em>every keystroke</em>.\nSometimes only the <em>Enter</em> key matters, because it signals that the user has finished typing.\nOne way to reduce the noise would be to examine every <code>$event.keyCode</code> and take action only when the key is <em>Enter</em>.</p>\n\n<p translation-result=\"on\">更簡單的方法是：繫結到 Angular 的 <code>keyup.enter</code> 模擬事件。然後，只有當用戶敲<em>Enter</em>鍵時，Angular 才會呼叫事件處理器。</p><p translation-origin=\"off\">There's an easier way:\nbind to Angular's <code>keyup.enter</code> pseudo-event.\nThen Angular calls the event handler only when the user presses <em>Enter</em>.</p>\n\n<code-example header=\"src/app/keyup.components.ts (v3)\" path=\"user-input/src/app/keyup.components.ts\" region=\"key-up-component-3\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-key-up3',\n  template: `\n    &lt;input #box (keyup.enter)=\"onEnter(box.value)\"&gt;\n    &lt;p&gt;{{value}}&lt;/p&gt;\n  `\n})\nexport class KeyUpComponent_v3 {\n  value = '';\n  onEnter(value: string) { this.value = value; }\n}\n\n</code-example>\n<p translation-result=\"on\">下面展示了它的工作原理。</p><p translation-origin=\"off\">Here's how it works.</p>\n\n<div class=\"lightbox\">\n<img alt=\"key up 3\" src=\"generated/images/guide/user-input/keyup3-anim.gif\" width=\"280\" height=\"100\">\n</div>\n<h2 id=\"on-blur\" translation-result=\"on\">失焦事件 （blur）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#on-blur\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">On blur<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#on-blur\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">前上例中，如果使用者沒有先按回車鍵，而是移開了滑鼠，點選了頁面中其它地方，輸入框的當前值就會丟失。只有當用戶按下了Enter鍵候，元件的 <code>value</code> 屬性才能更新。</p><p translation-origin=\"off\">In the previous example, the current state of the input box is lost if the user mouses away and clicks elsewhere without first pressing <em>Enter</em>.\nThe component's <code>value</code> property is updated only when the user presses <em>Enter</em>.</p>\n\n<p translation-result=\"on\">下面透過同時監聽輸入框的Enter鍵和 <code>blur</code> 事件來修正這個問題。</p><p translation-origin=\"off\">To fix this issue, listen to both the <em>Enter</em> key and the <code>blur</code> event.</p>\n\n<code-example header=\"src/app/keyup.components.ts (v4)\" path=\"user-input/src/app/keyup.components.ts\" region=\"key-up-component-4\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-key-up4',\n  template: `\n    &lt;input #box\n      (keyup.enter)=\"update(box.value)\"\n      (blur)=\"update(box.value)\"&gt;\n\n    &lt;p&gt;{{value}}&lt;/p&gt;\n  `\n})\nexport class KeyUpComponent_v4 {\n  value = '';\n  update(value: string) { this.value = value; }\n}\n\n</code-example>\n<h2 id=\"put-it-all-together\" translation-result=\"on\">把它們放在一起<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#put-it-all-together\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Put it all together<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#put-it-all-together\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本章展示了一些事件繫結技術。</p><p translation-origin=\"off\">This page demonstrated several event binding techniques.</p>\n\n<p translation-result=\"on\">現在，在一個微型應用中一起使用它們，應用能顯示一個英雄列表，並把新的英雄加到列表中。使用者可以透過輸入英雄名和點選“新增”按鈕來新增英雄。</p><p translation-origin=\"off\">Now, put it all together in a micro-app that can display a list of heroes and add new heroes to the list.\nThe user can add a hero by typing the hero's name in the input box and clicking <strong>Add</strong>.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Little Tour of Heroes\" src=\"generated/images/guide/user-input/little-tour-anim.gif\" width=\"472\" height=\"268\">\n</div>\n<p translation-result=\"on\">下面就是“簡版英雄之旅”元件。</p><p translation-origin=\"off\">Below is the \"Little Tour of Heroes\" component.</p>\n\n<code-example header=\"src/app/little-tour.component.ts\" path=\"user-input/src/app/little-tour.component.ts\" region=\"little-tour\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-little-tour',\n  template: `\n    &lt;input #newHero\n      (keyup.enter)=\"addHero(newHero.value)\"\n      (blur)=\"addHero(newHero.value); newHero.value='' \"&gt;\n\n    &lt;button type=\"button\" (click)=\"addHero(newHero.value)\"&gt;Add&lt;/button&gt;\n\n    &lt;ul&gt;&lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero}}&lt;/li&gt;&lt;/ul&gt;\n  `\n})\nexport class LittleTourComponent {\n  heroes = ['Windstorm', 'Bombasto', 'Magneta', 'Tornado'];\n  addHero(newHero: string) {\n    if (newHero) {\n      this.heroes.push(newHero);\n    }\n  }\n}\n\n</code-example>\n<h3 id=\"observations\" translation-result=\"on\">小結<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#observations\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Observations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#observations\"><i class=\"material-icons\">link</i></a></h3>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">小結</nt-wrapper><nt-wrapper translation-origin=\"off\">Observations</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">使用範本變數來參考元素</nt-wrapper><nt-wrapper translation-origin=\"off\">Use template variables to refer to elements</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><code>newHero</code> 範本變數參考了 <code>&lt;input&gt;</code> 元素。你可以在 <code>&lt;input&gt;</code> 的任何兄弟或子級元素中參考 <code>newHero</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">The <code>newHero</code> template variable refers to the <code>&lt;input&gt;</code> element. You can reference <code>newHero</code> from any sibling or child of the <code>&lt;input&gt;</code> element.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">傳遞數值，而非元素</nt-wrapper><nt-wrapper translation-origin=\"off\">Pass values, not elements</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">獲取輸入框的值並將<em>它</em>傳給元件的 <code>addHero</code>，而不要傳遞 <code>newHero</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Instead of passing the <code>newHero</code> into the component's <code>addHero</code> method, get the input box value and pass <em>that</em> to <code>addHero</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">保持範本陳述式簡單</nt-wrapper><nt-wrapper translation-origin=\"off\">Keep template statements simple</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><code>(blur)</code> 事件被繫結到兩個 JavaScript 陳述式。第一句呼叫 <code>addHero</code>。第二句 <code>newHero.value=''</code> 在新增新英雄到列表中後清除輸入框。</nt-wrapper><nt-wrapper translation-origin=\"off\">The <code>(blur)</code> event is bound to two JavaScript statements. The first statement calls <code>addHero</code>. The second statement, <code>newHero.value=''</code>, clears the input box after a new hero is added to the list.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<h2 id=\"source-code\" translation-result=\"on\">原始碼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#source-code\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Source code<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#source-code\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">下面是本章討論過的所有原始碼。</p><p translation-origin=\"off\">Following is all the code discussed in this page.</p>\n\n<code-tabs>\n    <code-pane header=\"click-me.component.ts\" path=\"user-input/src/app/click-me.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-click-me',\n  template: `\n    &lt;button type=\"button\" (click)=\"onClickMe()\"&gt;Click me!&lt;/button&gt;\n    {{clickMessage}}`\n})\nexport class ClickMeComponent {\n  clickMessage = '';\n\n  onClickMe() {\n    this.clickMessage = 'You are my hero!';\n  }\n}\n\n\n</code-pane>\n    <code-pane header=\"keyup.components.ts\" path=\"user-input/src/app/keyup.components.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-key-up1',\n  template: `\n    &lt;input (keyup)=\"onKey($event)\"&gt;\n    &lt;p&gt;{{values}}&lt;/p&gt;\n  `\n})\nexport class KeyUpComponent_v1 {\n  values = '';\n\n  /*\n  onKey(event: any) { // without type info\n    this.values += event.target.value + ' | ';\n  }\n  */\n\n  onKey(event: KeyboardEvent) { // with type info\n    this.values += (event.target as HTMLInputElement).value + ' | ';\n  }\n}\n\n//////////////////////////////////////////\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-key-up2',\n  template: `\n    &lt;input #box (keyup)=\"onKey(box.value)\"&gt;\n    &lt;p&gt;{{values}}&lt;/p&gt;\n  `\n})\nexport class KeyUpComponent_v2 {\n  values = '';\n  onKey(value: string) {\n    this.values += value + ' | ';\n  }\n}\n\n//////////////////////////////////////////\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-key-up3',\n  template: `\n    &lt;input #box (keyup.enter)=\"onEnter(box.value)\"&gt;\n    &lt;p&gt;{{value}}&lt;/p&gt;\n  `\n})\nexport class KeyUpComponent_v3 {\n  value = '';\n  onEnter(value: string) { this.value = value; }\n}\n\n//////////////////////////////////////////\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-key-up4',\n  template: `\n    &lt;input #box\n      (keyup.enter)=\"update(box.value)\"\n      (blur)=\"update(box.value)\"&gt;\n\n    &lt;p&gt;{{value}}&lt;/p&gt;\n  `\n})\nexport class KeyUpComponent_v4 {\n  value = '';\n  update(value: string) { this.value = value; }\n}\n\n\n</code-pane>\n    <code-pane header=\"loop-back.component.ts\" path=\"user-input/src/app/loop-back.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-loop-back',\n  template: `\n    &lt;input #box (keyup)=\"0\"&gt;\n    &lt;p&gt;{{box.value}}&lt;/p&gt;\n  `\n})\nexport class LoopbackComponent { }\n\n\n</code-pane>\n    <code-pane header=\"little-tour.component.ts\" path=\"user-input/src/app/little-tour.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-little-tour',\n  template: `\n    &lt;input #newHero\n      (keyup.enter)=\"addHero(newHero.value)\"\n      (blur)=\"addHero(newHero.value); newHero.value='' \"&gt;\n\n    &lt;button type=\"button\" (click)=\"addHero(newHero.value)\"&gt;Add&lt;/button&gt;\n\n    &lt;ul&gt;&lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero}}&lt;/li&gt;&lt;/ul&gt;\n  `\n})\nexport class LittleTourComponent {\n  heroes = ['Windstorm', 'Bombasto', 'Magneta', 'Tornado'];\n  addHero(newHero: string) {\n    if (newHero) {\n      this.heroes.push(newHero);\n    }\n  }\n}\n\n\n</code-pane>\n</code-tabs>\n<p translation-result=\"on\">Angular 還支援被動事件監聽器。比如，你可以使用以下步驟使滾動事件變為被動監聽。</p><p translation-origin=\"off\">Angular also supports passive event listeners.\nFor example, you can use the following steps to make the scroll event passive.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">在 <code>src</code> 目錄下建立一個檔案 <code>zone-flags.ts</code>。</p><p translation-origin=\"off\">Create a file <code>zone-flags.ts</code> under <code>src</code> directory.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">將以下行新增到此檔案中。</p><p translation-origin=\"off\">Add the following line into this file.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n(window as any)['__zone_symbol__PASSIVE_EVENTS'] = ['scroll'];\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">在 <code>src/polyfills.ts</code> 檔案中，在匯入 zone.js 之前，先匯入新建立的 <code>zone-flags</code>。</p><p translation-origin=\"off\">In the <code>src/polyfills.ts</code> file, before importing zone.js, import the newly created <code>zone-flags</code>.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nimport './zone-flags';\nimport 'zone.js';  // Included with Angular CLI.\n\n</code-example>\n</li>\n</ol>\n<p translation-result=\"on\">在這些步驟之後，如果你為 <code>scroll</code> 事件新增事件偵聽器，偵聽器就會是 <code>passive</code> 的。</p><p translation-origin=\"off\">After those steps, if you add event listeners for the <code>scroll</code> event, the listeners are going to be <code>passive</code>.</p>\n\n<h2 id=\"summary\" translation-result=\"on\">小結<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#summary\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Summary<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/user-input#summary\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你已經掌握了響應使用者輸入和操作的基礎技術。</p><p translation-origin=\"off\">You have mastered the basic primitives for responding to user input and gestures.</p>\n\n<p translation-result=\"on\">這些技術對小規模示範很實用，但是在處理大量使用者輸入時，很容易變得累贅和笨拙。要在資料輸入欄位和模型屬性之間傳遞資料，雙向資料繫結是更加優雅和簡潔的方式。下一章 <code>表單</code> 解釋瞭如何用 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 來進行雙向繫結。</p><p translation-origin=\"off\">These techniques are useful for small-scale demonstrations, but they quickly become verbose and clumsy when handling large amounts of user input.\nTwo-way data binding is a more elegant and compact way to move values between data entry fields and model properties.\nThe <a href=\"guide/forms-overview\"><code>Forms</code></a> page explains how to write two-way bindings with <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/architecture-components\n - guide/example-apps-list\n - guide/forms\n-->\n<!-- links from this doc:\n - api/common/NgFor\n - api/core/Component\n - api/forms/NgModel\n - guide/event-binding\n - guide/forms-overview\n - guide/interpolation\n - guide/template-reference-variables\n - guide/template-statements\n - guide/user-input#binding-to-user-input-events\n - guide/user-input#event-的型別\n - guide/user-input#get-user-input-from-a-template-reference-variable\n - guide/user-input#get-user-input-from-the-event-object\n - guide/user-input#key-event-filtering-with-keyenter\n - guide/user-input#observations\n - guide/user-input#on-blur\n - guide/user-input#passing-event-is-a-dubious-practice\n - guide/user-input#put-it-all-together\n - guide/user-input#source-code\n - guide/user-input#summary\n - guide/user-input#type-the-event\n - guide/user-input#user-input\n - guide/user-input#從一個範本參考變數中獲得使用者輸入\n - guide/user-input#傳入-event-是靠不住的做法\n - guide/user-input#失焦事件-blur\n - guide/user-input#小結\n - guide/user-input#小結-1\n - guide/user-input#把它們放在一起\n - guide/user-input#按鍵事件過濾透過-keyenter\n - guide/user-input#原始碼\n - guide/user-input#使用者輸入\n - guide/user-input#繫結到使用者輸入事件\n - guide/user-input#透過-event-物件取得使用者輸入\n - https://developer.mozilla.org/docs/Web/API/Event\n - https://developer.mozilla.org/docs/Web/API/HTMLInputElement\n - https://developer.mozilla.org/docs/Web/Events\n - https://github.com/angular/angular/issues/new?template=3-docs-bug.md\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/user-input.md?message=docs%3A%20請簡述你的修改...\n-->"}