{"id":"guide/static-query-migration","title":"Static query migration guide","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/static-query-migration.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"static-query-migration-guide\" translation-result=\"on\">靜態查詢（Static Query）遷移指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#static-query-migration-guide\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Static query migration guide<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#static-query-migration-guide\"><i class=\"material-icons\">link</i></a></h1>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><strong>重要</strong>：<br>\n庫的作者注意：\n這份遷移指南非常重要，可以方便他們的使用者升級到（Angular 的）版本 9（大約在 2019 年 10 月釋出）。</p><p translation-origin=\"off\"><strong>IMPORTANT</strong>: <br>\nFor library authors:\nThis migration is especially crucial for library authors to facilitate their users upgrading to version 9 when it becomes available.</p>\n\n</div>\n<p translation-result=\"on\">在版本 9 中，<code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 這兩個查詢的預設設定會改變，以修復查詢中的 BUG 和意外行為（詳情參閱<a href=\"guide/static-query-migration#what-does-this-flag-mean\">此處</a>）。</p><p translation-origin=\"off\">In version 9, the default setting for <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> and <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries is changing in order to fix buggy and surprising behavior in queries (read more about that <a href=\"guide/static-query-migration#what-does-this-flag-mean\">here</a>).</p>\n\n<p translation-result=\"on\">為了應對這個變化，我們從版本 8 開始就要開始遷移所有應用和庫，顯式指定 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查詢的解析策略。</p><p translation-origin=\"off\">In preparation for this change, in version 8, we are migrating all applications and libraries to explicitly specify the resolution strategy for <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> and <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries.</p>\n\n<p translation-result=\"on\">具體來說，這次遷移會新增一個顯式的 “static” 標誌，用來指出應該何時對該查詢的結果進行賦值。等升級到版本 9 的時候，這個標誌可以確保這些程式碼的工作方式都是一樣的。</p><p translation-origin=\"off\">Specifically, this migration adds an explicit \"static\" flag that dictates when that query's results should be assigned.\nAdding this flag will ensure your code works the same way when upgrading to version 9.</p>\n\n<p translation-result=\"on\">之前：</p><p translation-origin=\"off\">Before:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> results sometimes available in `ngOnInit`, sometimes in `ngAfterViewInit` (based on template)\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('foo') foo: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n</code-example>\n<p translation-result=\"on\">之後：</p><p translation-origin=\"off\">After:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> results available in ngOnInit\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('foo', {<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}) foo: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\nOR\n\n// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> results available in ngAfterViewInit\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>('foo', {<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}) foo: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>;\n\n</code-example>\n<p translation-result=\"on\">從版本 9 開始，<code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌將預設為 <code>false</code>。那時候，可以安全地刪除所有 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> 標誌，而且我們還會提供一個能幫你更新程式碼的原理圖（schematic）。</p><p translation-origin=\"off\">Starting with version 9, the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag will default to false.\nAt that time, any <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> flags can be safely removed, and we will have a schematic that will update your code for you.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n這個標誌只適用於 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 這兩個查詢，這是因為 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢都沒有靜態和動態的概念（它們總是“動態”解析）。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThis flag only applies to <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> and <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries specifically, as <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> and <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> queries do not have a concept of static and dynamic (they are always resolved as if they are \"dynamic\").</p>\n\n</div>\n<h2 id=\"faq\" translation-result=\"on\">常見問題<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#faq\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">FAQ<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#faq\"><i class=\"material-icons\">link</i></a></h2>\n\n<p><a id=\"what-to-do-with-todo\"></a></p>\n<h3 id=\"what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\" translation-result=\"on\">當看到由原理圖新增的 <code>/* TODO: add <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> flag */</code> 註釋時，我該怎麼辦？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#當看到由原理圖新增的--todo-add-static-flag--註釋時我該怎麼辦\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">What should I do if I see a <code>/* TODO: add <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> flag */</code> comment printed by the schematic?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你看到這個註釋，就意味著原理圖無法自己找到恰當的標誌。在這種情況下，你必須根據應用的行為新增正確的標誌。要了解如何進行選擇，請參閱<a href=\"guide/static-query-migration#how-do-i-choose\">下一個問題</a>。</p><p translation-origin=\"off\">If you see this comment, it means that the schematic couldn't statically figure out the correct flag.\nIn this case, you'll have to add the correct flag based on your application's behavior.\nFor more information on how to choose, see the <a href=\"guide/static-query-migration#how-do-i-choose\">next question</a>.</p>\n\n<p><a id=\"how-do-i-choose\"></a></p>\n<h3 id=\"how-do-i-choose-which-static-flag-value-to-use-true-or-false\" translation-result=\"on\">如何選擇 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌：<code>true</code> 還是 <code>false</code>？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#如何選擇-static-標誌true-還是-false\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">How do I choose which <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag value to use: <code>true</code> or <code>false</code>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#how-do-i-choose-which-static-flag-value-to-use-true-or-false\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在官方 API 文件中，我們建議對於<a href=\"api/core/ViewChild#description\">檢視查詢</a> 總是在 <code>ngAfterViewInit</code> 中獲取查詢結果，對於<a href=\"api/core/ContentChild#description\">內容查詢</a> 總是在 <code>ngAfterContentInit</code> 中獲取查詢結果。這是因為當這些生命週期鉤子執行時，相關節點的變更檢測已完成，我們可以確信收集到了所有可能的查詢結果。</p><p translation-origin=\"off\">In the official API docs, we have always recommended retrieving query results in <a href=\"api/core/ViewChild#description\"><code>ngAfterViewInit</code> for view queries</a> and <a href=\"api/core/ContentChild#description\"><code>ngAfterContentInit</code> for content queries</a>.\nThis is because by the time those lifecycle hooks run, change detection has completed for the relevant nodes and we can guarantee that we have collected all the possible query results.</p>\n\n<p translation-result=\"on\">由於這個原因，大多數應用都應該使用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>。這個設定可以確保找出那些依賴於繫結解析的查詢結果（比如 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 內的查詢）。</p><p translation-origin=\"off\">Most applications will want to use <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> for the same reason.\nThis setting will ensure query matches that are dependent on binding resolution (for example, results inside instances of <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>) will be found by the query.</p>\n\n<p translation-result=\"on\">在某些很少見的情況下，必須使用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code> 標誌（參閱<a href=\"guide/static-query-migration#should-i-use-static-true\">這裡的回答</a>）。</p><p translation-origin=\"off\">There are rarer cases where <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code> flag might be necessary (see <a href=\"guide/static-query-migration#should-i-use-static-true\">answer here</a>).</p>\n\n<p><a id=\"should-i-use-static-true\"></a></p>\n<h3 id=\"is-there-a-case-where-i-should-use-static-true\" translation-result=\"on\">什麼情況下我應該用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code>？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#什麼情況下我應該用-static-true\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Is there a case where I should use <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#is-there-a-case-where-i-should-use-static-true\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">這個選項的引入是為了支援動態建立嵌入式檢視。如果你要查詢一個 <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> 以便動態建立一個檢視，將無法在 <code>ngAfterViewInit</code> 中這樣做。這是因為變數檢測已在該檢視上執行過，所以這時候使用該範本建立一個新檢視就會丟擲 <code>ExpressionHasChangedAfterChecked</code> 錯誤。在這種情況下，你要把 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌設定為 <code>true</code>，並在 <code>ngOnInit</code> 中建立你的檢視。在其它大多數情況下，最好的做法是使用 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>。</p><p translation-origin=\"off\">This option was introduced to support creating embedded views on the fly.\nIf you need access to a <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> in a query to create a view dynamically, you won't be able to do so in <code>ngAfterViewInit</code>.\nChange detection has already run on that view, so creating a new view with the template will cause an <code>ExpressionHasChangedAfterChecked</code> error to be thrown.\nIn this case, you will want to set the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag to <code>true</code> and create your view in <code>ngOnInit</code>.\nIn most other cases, the best practice is to use <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>.</p>\n\n<p translation-result=\"on\">為了便於遷移到版本 8 中，如果你的元件程式碼期望這些查詢的結果在 <code>ngAfterViewInit</code>（對於檢視查詢）或 <code>ngAfterContentInit</code>（對於內容查詢）<strong>之前</strong>的某個時刻就已經可用，可能也要把 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌設定為 <code>true</code>。比如，如果你的元件期望在 <code>ngOnInit</code> 鉤子或 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 的 setter 中這些查詢結果已經就緒，就要把該標誌設定為 <code>true</code> 或者改寫你的元件以推遲它的執行時間。</p><p translation-origin=\"off\">However, to facilitate the migration to version 8, you may also want to set the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag to <code>true</code> if your component code already depends on the query results being available some time <strong>before</strong> <code>ngAfterViewInit</code> (for view queries) or <code>ngAfterContentInit</code> (for content queries).\nFor example, if your component relies on the query results being populated in the <code>ngOnInit</code> hook or in <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> setters, you will need to either set the flag to <code>true</code> or re-work your component to adjust to later timing.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n把 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 設定為 <code>true</code> 意味著此查詢將不會發現嵌在 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 中的查詢結果。只有在執行過變更檢測之後才能取得這些結果。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nSelecting the static option means that query results nested in <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> will not be found by the query.\nThese results are only retrievable after change detection runs.</p>\n\n</div>\n<p><a id=\"what-does-this-flag-mean\"></a></p>\n<h3 id=\"what-does-this-flag-mean-and-why-is-it-necessary\" translation-result=\"on\">這個標誌是什麼意思，它有什麼必要？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#what-does-this-flag-mean-and-why-is-it-necessary\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">What does this flag mean and why is it necessary?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#what-does-this-flag-mean-and-why-is-it-necessary\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">以前，預設的查詢行為一直沒有文件記載，這會令人困惑，而且也常導致難以除錯的問題。在版本 9 中，我們希望這種查詢行為更加一致，也更容易理解。</p><p translation-origin=\"off\">The default behavior for queries has historically been undocumented and confusing, and has also commonly led to issues that are difficult to debug.\nIn version 9, we would like to make query behavior more consistent and simple to understand.</p>\n\n<p translation-result=\"on\">為了解釋其原由，首先要弄清楚到目前為止這些查詢是如何工作的。</p><p translation-origin=\"off\">To explain why, first it's important to understand how queries have worked up until now.</p>\n\n<p translation-result=\"on\">當沒有 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌時，編譯器會自行決定每個查詢該如何解析。所有的 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> / <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查詢在編譯時都會被歸類為兩種方式之一：“static” 或 “dynamic”。當查詢結果可供使用者使用時，就會決定該使用何種方式。</p><p translation-origin=\"off\">Without the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag, the compiler decided when each query would be resolved on a case-by-case basis.\nAll <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code>/<code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries were categorized into one of two buckets at compile time: \"static\" or \"dynamic\".\nThis classification determined when query results would become available to users.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">查詢</nt-wrapper><nt-wrapper translation-origin=\"off\">Queries</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">靜態查詢</nt-wrapper><nt-wrapper translation-origin=\"off\">Static queries</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">查詢結果是可以靜態確定的，因為其結果並不依賴執行期間的值（比如資料繫結）。靜態查詢的結果在該檢視執行變更檢測之前就是可用的（可以在 <code>ngOnInit</code> 存取）。</nt-wrapper><nt-wrapper translation-origin=\"off\">The result could be determined statically because the result didn't depend on runtime values like bindings. Results from queries classified as static were available before change detection ran for that view (accessible in <code>ngOnInit</code>).</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">動態查詢</nt-wrapper><nt-wrapper translation-origin=\"off\">Dynamic queries</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">查詢結果是無法靜態確定的，因為其結果取決於執行期間的值（比如資料繫結）。動態查詢的結果在執行該檢視的變更檢測之前是不可用的（只能在 <code>ngAfterContentInit</code> 中存取內容查詢或在 <code>ngAfterViewInit</code> 中存取檢視查詢）。</nt-wrapper><nt-wrapper translation-origin=\"off\">the result could not be determined statically because the result depended on runtime values (bindings). Results from queries classified as dynamic were not available until after change detection ran for that view (accessible in <code>ngAfterContentInit</code> for content queries or <code>ngAfterViewInit</code> for view queries).</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">比如，假設我們有一個元件 <code>Comp</code>。在其中，我們有這樣一個查詢：</p><p translation-origin=\"off\">For example, let's say we have a component, <code>Comp</code>.\nInside it, we have this query:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(Foo) foo: Foo;\n\n</code-example>\n<p translation-result=\"on\">和這樣的範本：</p><p translation-origin=\"off\">and this template:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;div foo&gt;&lt;/div&gt;\n\n</code-example>\n<p translation-result=\"on\">這個 <code>Foo</code> 查詢會被歸類為靜態查詢，這是因為在編譯時，就已經知道 <code>&lt;div&gt;</code> 上的 <code>Foo</code> 例項是正確的查詢結果了。由於查詢結果並不依賴於執行時的值，所以在解析此查詢之前，我們不必等待範本上的變更檢測。因此，在 <code>ngOnInit</code> 中這些結果就已經可用了。</p><p translation-origin=\"off\">This <code>Foo</code> query would be categorized as static because at compile-time it's known that the <code>Foo</code> instance on the <code>&lt;div&gt;</code> is the correct result for the query.\nBecause the query result is not dependent on runtime values, we don't have to wait for change detection to run on the template before resolving the query.\nConsequently, results can be made available in <code>ngOnInit</code>.</p>\n\n<p translation-result=\"on\">假設查詢不變，但元件範本改成了這樣：</p><p translation-origin=\"off\">Let's say the query is the same, but the component template looks like this:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;div foo *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"showing\"&gt;&lt;/div&gt;\n\n</code-example>\n<p translation-result=\"on\">對於該範本，該查詢將被歸類為動態查詢。我們需要知道 <code>showing</code> 在執行期間的值以確定該查詢的正確結果應該是什麼。因此，必須首先執行變更檢測，其結果只能在 <code>ngAfterViewInit</code> 或該查詢屬性的 setter 中才能使用。</p><p translation-origin=\"off\">With that template, the query would be categorized as a dynamic query.\nWe would need to know the runtime value of <code>showing</code> before determining what the correct results are for the query.\nAs a result, change detection must run first, and results can only be made available in <code>ngAfterViewInit</code> or a setter for the query property.</p>\n\n<p translation-result=\"on\">這種實現方式的效果是，在查詢匹配的任何父級節點新增 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 會導致：當查詢結果可用之後，其匹配結果也會發生變化。</p><p translation-origin=\"off\">The effect of this implementation is that adding an <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> anywhere above a query match can change when that query's results become available.</p>\n\n<p translation-result=\"on\">請記住，這些類別只能用於 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 這兩種查詢。而 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢都沒有靜態和動態的概念，它們總是“動態”解析。</p><p translation-origin=\"off\">Keep in mind that these categories only applied to <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> and <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries specifically.\n<code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> and <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> queries did not have a concept of static and dynamic, so they were always resolved as if they were \"dynamic\".</p>\n\n<p translation-result=\"on\">這種策略會根據查詢所在的位置，在不同的時機進行解析，這引起了很大的困惑。即：</p><p translation-origin=\"off\">This strategy of resolving queries at different times based on the location of potential query matches has caused a lot of confusion.\nNamely:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">其查詢結果在 <code>ngOnInit</code> 中有時可用有時不可用，而且還不清楚為什麼（參閱 <a href=\"https://github.com/angular/angular/issues/21800\">21800</a> 或 <a href=\"https://github.com/angular/angular/issues/19872\">19872</a>）。</p><p translation-origin=\"off\">Sometimes query results are available in <code>ngOnInit</code>, but sometimes they aren't and it's not clear why (see <a href=\"https://github.com/angular/angular/issues/21800\">21800</a> or <a href=\"https://github.com/angular/angular/issues/19872\">19872</a>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 查詢和 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 查詢的解析時機不一樣，而 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查詢和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢的解析時機也不一樣。如果使用者把 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 查詢換成 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 查詢，那麼他們的程式碼就會突然崩潰，因為其解析時機已經變化了。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> queries are resolved at a different time from <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> queries, and <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries are resolved at a different time from <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> queries.\nIf a user turns a <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> query into a <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> query, their code can break suddenly because the timing has shifted.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">一旦往範本中添加了 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>，依賴於查詢結果的程式碼就會突然停止工作</p><p translation-origin=\"off\">Code depending on a query result can suddenly stop working as soon as an <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or an <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> is added to a template</p>\n\n</li>\n<li>\n<p translation-result=\"on\">當每次使用該元件時，針對同一個元件的 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查詢卻會在生命週期的不同時機進行解析。這導致了一些錯誤的行為，即：帶 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 的元件會以一種對元件作者來說很隱晦的、微妙的方式被破壞。</p><p translation-origin=\"off\">A <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> query for the same component will resolve at different times in the lifecycle for each usage of the component.\nThis leads to buggy behavior where using a component with <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> is broken in subtle ways that aren't obvious to the component author.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">在版本 9 中，我們準備簡化這種行為：預設情況下，每當執行變更檢測之後，都會解析所有查詢。範本中查詢的位置不會再影響查詢結果何時可用，也不會突然破壞你的程式碼，其預設行為總是一樣的。這樣，這種邏輯對於使用者來說就更加一致、更加可預測。</p><p translation-origin=\"off\">In version 9, we plan to simplify the behavior so all queries resolve after change detection runs by default.\nThe location of query matches in the template cannot affect when the query result will become available and suddenly break your code, and the default behavior is always the same.\nThis makes the logic more consistent and predictable for users.</p>\n\n<p translation-result=\"on\">也就是說，如果一個應用程式確實需要更早拿到查詢結果（比如，在建立嵌入式檢視時需要這種查詢結果），就可以新增 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code> 標誌來明確要求靜態解析。有了這個標誌，使用者就可以表明他們只關心那些靜態可用的結果，並且在 <code>ngOnInit</code> 之前就會填上查詢結果。</p><p translation-origin=\"off\">That said, if an application does need query results earlier (for example, the query result is needed to create an embedded view), it's possible to add the <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: true}</code> flag to explicitly ask for static resolution.\nWith this flag, users can indicate that they only care about results that are statically available and the query results will be populated before <code>ngOnInit</code>.</p>\n\n<p><a id=\"view-children-and-content-children\"></a></p>\n<h3 id=\"does-this-change-affect-viewchildren-or-contentchildren-queries\" translation-result=\"on\">這項變化是否會影響 <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 或 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#這項變化是否會影響-viewchildren-或-contentchildren-查詢\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Does this change affect <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> or <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> queries?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#does-this-change-affect-viewchildren-or-contentchildren-queries\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">不，這項變化只會影響 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 和 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 查詢。預設情況下，<code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢已經是“動態”的，並且不支援靜態解析。</p><p translation-origin=\"off\">No, this change only affects <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> and <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> queries specifically.\n<code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> and <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> queries are already \"dynamic\" by default and don't support static resolution.</p>\n\n<p><a id=\"why-specify-static-false\"></a></p>\n<h3 id=\"why-do-i-have-to-specify-static-false-isnt-that-the-default\" translation-result=\"on\">為什麼我還要指定 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>？它不是預設值嗎？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#為什麼我還要指定-static-false它不是預設值嗎\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">​Why do I have to specify <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code>? Isn't that the default?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#why-do-i-have-to-specify-static-false-isnt-that-the-default\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">本次遷移的目的是把現在的版本 9 之前的應用轉換為與版本 9 相容的查詢模式。然而，大多數應用都會用到庫，而其中某些庫可能還無法升級到版本 8（因而可能沒有指定合適的標誌值）。由於應用程式編譯時會用到當前的 Angular 版本，所以如果我們修改了預設值，庫裡元件的查詢行為就會變成版本 8 的這個預設值，這可能導致重大變更。而現在這種方式，應用程式的依賴項在轉換過程中的行為就和之前的版本是一樣的。</p><p translation-origin=\"off\">The goal of this migration is to transition apps that aren't yet on version 9 to a query pattern that is compatible with version 9.\nHowever, most applications use libraries, and it's likely that some of these libraries may not be upgraded to version 8 yet (and thus might not have the proper flags).\nSince the application's version of Angular will be used for compilation, if we change the default, the behavior of queries in the library's components will change to the version 8 default and possibly break.\nThis way, an application's dependencies will behave the same way during the transition as they did in the previous version.</p>\n\n<p translation-result=\"on\">在 Angular 9 及更高版本中，任意刪除 <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> 標誌都是安全的，屆時，我們會在原理圖中為你完成這個清理工作。</p><p translation-origin=\"off\">In Angular version 9 and later, it will be safe to remove any <code>{<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>: false}</code> flags and we will do this cleanup for you in a schematic.</p>\n\n<p><a id=\"libraries\"></a></p>\n<h3 id=\"can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\" translation-result=\"on\">我還可以繼續使用尚未更新到版本 8 的 Angular 函式庫嗎？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Can I keep on using Angular libraries that haven't yet updated to version 8 yet?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">絕對沒問題！\n因為我們沒有改變版本 8 中的預設查詢行為（比如編譯器在沒有設定任何標誌的情況下仍然會自己選擇一個合適的時機），所以當你的應用執行時，如果你的函式庫沒有更新到版本 8，該函式庫的執行方式就和版本 7 中是一樣的。這樣就可以保證你的應用在版本 8 中仍然可以工作，不過這些庫的開發者就需要花費更長的時間來修改程式碼了。</p><p translation-origin=\"off\">Yes, absolutely.\nBecause we have not changed the default query behavior in version 8 (such as the compiler still chooses a timing if no flag is set), when your application runs with a library that has not updated to version 8, the library will run the same way it did in version 7.\nThis guarantees your app will work in version 8 even if libraries take longer to update their code.</p>\n\n<p><a id=\"update-library-to-use-static-flag\"></a></p>\n<h3 id=\"can-i-update-my-library-to-version-8-by-adding-the-static-flag-to-view-queries-while-still-being-compatible-with-angular-version-7-apps\" translation-result=\"on\">我可以透過為檢視查詢新增 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌來把我的函式庫更新到版本 8，那它還能同時和 Angular 7 應用相容嗎？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#我可以透過為檢視查詢新增-static-標誌來把我的函式庫更新到版本-8那它還能同時和-angular-7-應用相容嗎\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Can I update my library to version 8 by adding the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag to view queries, while still being compatible with Angular version 7 apps?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/static-query-migration#can-i-update-my-library-to-version-8-by-adding-the-static-flag-to-view-queries-while-still-being-compatible-with-angular-version-7-apps\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">是的，Angular 團隊對庫的建議是更新到版本 8 並新增 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 標誌。Angular 7 的應用可以繼續使用那些帶有此標誌的函式庫。</p><p translation-origin=\"off\">Yes, the Angular team's recommendation for libraries is to update to version 8 and add the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> flag.\nAngular version 7 apps will continue to work with libraries that have this flag.</p>\n\n<p translation-result=\"on\">但是，如果你把你的函式庫更新到 Angular 8，並希望利用新的第 8 版 API，或者你想要新版依賴項（比如 Typescript 或 RxJS），你的函式庫就會變得與 Angular 7 的應用不相容。如果你的目標是同時與 Angular 7 和 8 相容，那你就不應該更新你的函式庫，只有 <code>package.json</code> 中的 <code>peerDependencies</code> 除外。</p><p translation-origin=\"off\">However, if you update your library to Angular version 8 and want to take advantage of the new version 8 APIs, or you want more recent dependencies (such as Typescript or RxJS) your library will become incompatible with Angular version 7 apps.\nIf your goal is to make your library compatible with Angular versions 7 and 8, you should not update your lib at all —except for <code>peerDependencies</code> in <code>package.json</code>.</p>\n\n<p translation-result=\"on\">一般來說，最有效的計劃是讓庫採用 6 個月的主版本計劃，並在每次 Angular 升級之後適配主版本。這樣，庫就可以和 Angular 保持同樣的釋出節奏了。</p><p translation-origin=\"off\">In general, the most efficient plan is for libraries to adopt a 6-month major version schedule and bump the major version after each Angular update.\nThat way, libraries stay in the same release cadence as Angular.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/deprecations\n - guide/migration-dynamic-flag\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/NgFor\n - api/common/NgIf\n - api/core/ContentChild\n - api/core/ContentChild#description\n - api/core/ContentChildren\n - api/core/ElementRef\n - api/core/Input\n - api/core/TemplateRef\n - api/core/ViewChild\n - api/core/ViewChild#description\n - api/core/ViewChildren\n - api/upgrade/static\n - guide/static-query-migration#can-i-keep-on-using-angular-libraries-that-havent-yet-updated-to-version-8-yet\n - guide/static-query-migration#can-i-update-my-library-to-version-8-by-adding-the-static-flag-to-view-queries-while-still-being-compatible-with-angular-version-7-apps\n - guide/static-query-migration#does-this-change-affect-viewchildren-or-contentchildren-queries\n - guide/static-query-migration#faq\n - guide/static-query-migration#how-do-i-choose\n - guide/static-query-migration#how-do-i-choose-which-static-flag-value-to-use-true-or-false\n - guide/static-query-migration#is-there-a-case-where-i-should-use-static-true\n - guide/static-query-migration#should-i-use-static-true\n - guide/static-query-migration#static-query-migration-guide\n - guide/static-query-migration#what-does-this-flag-mean\n - guide/static-query-migration#what-does-this-flag-mean-and-why-is-it-necessary\n - guide/static-query-migration#what-should-i-do-if-i-see-a--todo-add-static-flag--comment-printed-by-the-schematic\n - guide/static-query-migration#why-do-i-have-to-specify-static-false-isnt-that-the-default\n - guide/static-query-migration#為什麼我還要指定-static-false它不是預設值嗎\n - guide/static-query-migration#什麼情況下我應該用-static-true\n - guide/static-query-migration#如何選擇-static-標誌true-還是-false\n - guide/static-query-migration#常見問題\n - guide/static-query-migration#當看到由原理圖新增的--todo-add-static-flag--註釋時我該怎麼辦\n - guide/static-query-migration#我可以透過為檢視查詢新增-static-標誌來把我的函式庫更新到版本-8那它還能同時和-angular-7-應用相容嗎\n - guide/static-query-migration#我還可以繼續使用尚未更新到版本-8-的-angular-庫嗎\n - guide/static-query-migration#這個標誌是什麼意思它有什麼必要\n - guide/static-query-migration#這項變化是否會影響-viewchildren-或-contentchildren-查詢\n - guide/static-query-migration#靜態查詢static-query遷移指南\n - https://github.com/angular/angular/issues/19872\n - https://github.com/angular/angular/issues/21800\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/static-query-migration.md?message=docs%3A%20請簡述你的修改...\n-->"}