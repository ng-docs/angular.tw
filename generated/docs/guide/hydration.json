{"id":"guide/hydration","title":"Hydration","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/hydration.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"hydration\" translation-result=\"on\">水合（Hydration）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#hydration\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Hydration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#hydration\"><i class=\"material-icons\">link</i></a></h1>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">水合（Hydration）特性已經可以供<a href=\"/guide/releases#developer-preview\">開發者預覽</a>了。你可以試用它，但是在穩定之前還可能發生變化。</p><p translation-origin=\"off\">The hydration feature is available for <a href=\"/guide/releases#developer-preview\">developer preview</a>. It's ready for you to try, but it might change before it is stable.</p>\n\n</div>\n<h2 id=\"what-is-hydration\" translation-result=\"on\">什麼是水合<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#what-is-hydration\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What is hydration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#what-is-hydration\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">水合是指在客戶端恢復伺服器端渲染出的應用程式的過程。這包括複用伺服器端渲染的 DOM 結構、持久化應用程式狀態、傳輸伺服器端已經獲取到的應用程式資料，還有一些其他過程。</p><p translation-origin=\"off\">Hydration is the process that restores the server side rendered application on the client. This includes things like reusing the server rendered DOM structures, persisting the application state, transferring application data that was retrieved already by the server, and other processes.</p>\n\n<h2 id=\"why-is-hydration-important\" translation-result=\"on\">為什麼水合很重要？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#why-is-hydration-important\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Why is hydration important?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#why-is-hydration-important\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">水合透過避免重新建立 DOM 節點的額外工作來提高應用程式效能。而 Angular 會試圖在執行時將現有的 DOM 元素與應用程式結構相匹配，只在可能的情況下複用 DOM 節點。這能改進效能，可以使用<a href=\"https://web.dev/learn-core-web-vitals/\">核心 Web 體驗（CWV）</a>這組統計資料來衡量，例如減少首次輸入延遲（<a href=\"https://web.dev/fid/\">FID</a>）和最大內容繪製（<a href=\"https://web.dev/lcp/\">LCP</a>），以及累積佈局偏移（<a href=\"https://web.dev/cls/\">CLS</a>）。改善這些資料也會影響諸如 SEO 效能之類別的指標。</p><p translation-origin=\"off\">Hydration improves application performance by avoiding extra work to re-create DOM nodes. Instead, Angular tries to match existing DOM elements to the applications structure at runtime and reuses DOM nodes when possible. This results in a performance improvement that can be measured using <a href=\"https://web.dev/learn-core-web-vitals/\">Core Web Vitals (CWV)</a> statistics, such as reducing the First Input Delay (<a href=\"https://web.dev/fid/\">FID</a>) and Largest Contentful Paint (<a href=\"https://web.dev/lcp/\">LCP</a>), as well as Cumulative Layout Shift (<a href=\"https://web.dev/cls/\">CLS</a>). Improving these numbers also affects things like SEO performance.</p>\n\n<p translation-result=\"on\">如果不啟用水合，伺服器端渲染的 Angular 應用程式將銷燬並重新渲染應用程式的 DOM，這可能會導致可見的 UI 閃爍。這種重新渲染會對像 <a href=\"https://web.dev/lcp/\">LCP</a> 這樣的 <a href=\"https://web.dev/learn-core-web-vitals/\">核心 Web 體驗</a>產生負面影響，並導致佈局變化。啟用水合能讓你複用現有的 DOM 並防止閃爍。</p><p translation-origin=\"off\">Without hydration enabled, server side rendered Angular applications will destroy and re-render the application's DOM, which may result in a visible UI flicker. This re-rendering can negatively impact <a href=\"https://web.dev/learn-core-web-vitals/\">Core Web Vitals</a> like <a href=\"https://web.dev/lcp/\">LCP</a> and cause a layout shift. Enabling hydration allows the existing DOM to be re-used and prevents a flicker.</p>\n\n<p><a id=\"how-to-enable\"></a></p>\n<h2 id=\"how-do-you-enable-hydration-in-angular\" translation-result=\"on\">如何在 Angular 中啟用水合<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#how-do-you-enable-hydration-in-angular\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">How do you enable hydration in Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#how-do-you-enable-hydration-in-angular\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在開始水合之前，你必須有一個伺服器端渲染（SSR）的應用程式。首先按照 <a href=\"/guide/universal\">Angular Univeral 指南</a>啟用伺服器端渲染。一旦你的應用程式使用了 SSR，就可以透過為主要元件或模組從 <code>@angular/platform-browser</code> 匯入 <code><a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a></code> 來啟用水合。然後，你還要把 <code><a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a></code> 返回的提供者新增到應用程式的載入程式提供者列表中。</p><p translation-origin=\"off\">Before you can get started with hydration, you must have a server side rendered (SSR) application. Follow the <a href=\"/guide/universal\">Angular Universal Guide</a> to enable server side rendering first. Once you have SSR working with your application, you can enable hydration by visiting your main app component or module and importing <code><a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a></code> from <code>@angular/platform-browser</code>. You'll then add that provider to your app's bootstrapping providers list.</p>\n\n<code-example language=\"typescript\">\nimport {\n  <a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>,\n  <a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a>,\n} from '@angular/platform-browser';\n...\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(RootCmp, {\n  providers: [<a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a>()]\n});\n</code-example>\n<p translation-result=\"on\">或者，如果你在使用 NgModules，可以將 <code><a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a></code> 新增到根應用程式模組的提供者列表中。</p><p translation-origin=\"off\">Alternatively if you are using NgModules, you would add <code><a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a></code> to your root app module's provider list.</p>\n\n<code-example language=\"typescript\">\nimport {<a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a>} from '@angular/platform-browser';\nimport {<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>} from '@angular/core';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [RootCmp],\n  exports: [RootCmp],\n  bootstrap: [RootCmp],\n  providers: [<a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a>()],\n})\nexport class AppModule {}\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>重要提示</strong>：確保 <code><a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a>()</code> 呼叫也包含在用於在<strong>伺服器端</strong>引導應用程式的提供者列表中。在具有預設專案結構的應用程式中（由<code>ng new</code>命令產生）加入對根 <code>AppModule</code> 的呼叫應該就夠了，因為該模組已被伺服器端模組匯入。如果你使用自訂設定，請將 <code><a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a>()</code> 呼叫新增到伺服器端啟動配置中的提供者列表中。</p><p translation-origin=\"off\"><strong>Important note</strong>: make sure that the <code><a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a>()</code> call is also included into\na set of providers that is used to bootstrap an application on the <strong>server</strong>. In applications with the default project structure (generated by\nthe <code>ng new</code> command), adding a call to the root <code>AppModule</code> should be sufficient, since this module is imported by the server module. If you use a custom setup, add the <code><a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a>()</code> call to the providers list in the server bootstrap configuration.</p>\n\n</div>\n<p translation-result=\"on\">完成這些步驟並啟動伺服器端後，在瀏覽器中載入你的應用程式。</p><p translation-origin=\"off\">After you've followed these steps and have started up your server, load your application in the browser.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">在啟用水合之前，你可能需要修復直接操縱 DOM 的例項，可以透過切換到 Angular 式的構造或使用 <code>ngSkipHydration</code> 來完成。詳見<a href=\"guide/hydration#constraints\">約束條件</a>、<a href=\"guide/hydration#dom-manipulation\">直接 DOM 操作</a>和<a href=\"guide/hydration#ngskiphydration\">如何在水合時跳過特定元件</a>。</p><p translation-origin=\"off\">You will likely need to fix instances of Direct DOM Manipulation before hydration will fully work either by switching to Angular constructs or by using <code>ngSkipHydration</code>. See <a href=\"guide/hydration#constraints\">Constraints</a>, <a href=\"guide/hydration#dom-manipulation\">Direct DOM Manipulation</a>, and <a href=\"guide/hydration#ngskiphydration\">How to skip hydration for particular components</a> for more details.</p>\n\n</div>\n<p translation-result=\"on\">在開發模式下執行應用程式時，你可以透過在瀏覽器中開啟開發者工具並檢視控制檯來確認已啟用水合。你應該會看到一條訊息，其中包含與水合相關的統計資訊，例如水合的元件數和節點數。注意：Angular 會根據頁面上渲染的所有元件計算統計資訊，包括那些來自第三方函式庫的元件。</p><p translation-origin=\"off\">While running an application in dev mode, you can confirm hydration is enabled by opening the Developer Tools in your browser and viewing the console. You should see a message that includes hydration-related stats, such as the number of components and nodes hydrated. Note: Angular calculates the stats based on all components rendered on a page, including those that come from third-party libraries.</p>\n\n<p><a id=\"constraints\"></a></p>\n<h2 id=\"constraints\" translation-result=\"on\">約束條件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#constraints\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Constraints<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#constraints\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">水合對你的應用程式施加了一些限制，這些限制在沒有啟用水合的情況下是不存在的。你的應用程式必須在伺服器端和客戶端具有相同的產生的 DOM 結構。水合過程期望 DOM 樹在兩個地方具有相同的結構。這還包括 Angular 在伺服器端渲染期間產生的空白和註釋節點。這些空白和註釋節點必須出現在伺服器端渲染過程產生的 HTML 中。</p><p translation-origin=\"off\">Hydration imposes a few constraints on your application that are not present without hydration enabled. Your application must have the same generated DOM structure on both the server and the client. The process of hydration expects the DOM tree to have the same structure in both places. This also includes whitespaces and comment nodes that Angular produces during the rendering on the server. Those whitespaces and nodes must be present in the HTML generated by the server-side rendering process.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">伺服器端渲染操作產生的 HTML 在伺服器端和客戶端之間<strong>不能</strong>有任何區別。</p><p translation-origin=\"off\">The HTML produced by the server side rendering operation <strong>must not</strong> be altered between the server and the client.</p>\n\n</div>\n<p translation-result=\"on\">如果伺服器端和客戶端的 DOM 樹結構不匹配，當水合過程試圖將預期的內容與 DOM 中實際存在的內容相匹配時就會遇到問題。使用原生 DOM API 進行直接 DOM 操作的元件是最常見的罪魁禍首。</p><p translation-origin=\"off\">If there is a mismatch between server and client DOM tree structures, the hydration process will encounter problems attempting to match up what was expected to what is actually present in the DOM. Components that do direct DOM manipulation using native DOM APIs are the most common culprit.</p>\n\n<p><a id=\"dom-manipulation\"></a></p>\n<h3 id=\"direct-dom-manipulation\" translation-result=\"on\">直接 DOM 操作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#direct-dom-manipulation\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Direct DOM Manipulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#direct-dom-manipulation\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你有使用原生 DOM API 操作 DOM 的元件，水合過程將遇到錯誤。DOM 操作出問題的具體情況包括存取 <code>document</code> 、查詢特定元素以及使用 <code>appendChild</code> 注入其他節點等。分離 DOM 節點並將它們移動到其他位置也會導致錯誤。</p><p translation-origin=\"off\">If you have components that manipulate the DOM using native DOM APIs, the hydration process will encounter errors. Specific cases where DOM manipulation is a problem are situations like accessing the <code>document</code>, querying for specific elements, and injecting additional nodes using <code>appendChild</code>. Detaching DOM nodes and moving them to other locations will also result in errors.</p>\n\n<p translation-result=\"on\">這是因為 Angular 不瞭解這些 DOM 變化，並且無法在水合過程中解決它們。Angular 本來期望某種結構，但在嘗試水合時遇到了另一種結構。這種差異將導致水合失敗並引發 DOM 不匹配錯誤（<a href=\"guide/hydration#errors\">見下文</a>）。</p><p translation-origin=\"off\">This is because Angular is unaware of these DOM changes and cannot resolve them during the hydration process. Angular will expect a certain structure, but it will encounter a different structure when attempting to hydrate. This mismatch will result in hydration failure and throw a DOM mismatch error (<a href=\"guide/hydration#errors\">see below</a>).</p>\n\n<p translation-result=\"on\">最好重構你的元件以避免此類 DOM 操作。如果可以，請嘗試使用 Angular API 來完成這項工作。如果你無法重構此行為，請使用 <code>ngSkipHydration</code> 屬性（<a href=\"guide/hydration#ngskiphydration\">如下所述</a>），直到你可以把它重構為對水合友好的解決方案。</p><p translation-origin=\"off\">It is best to refactor your component to avoid this sort of DOM manipulation. Try to use Angular APIs to do this work, if you can. If you cannot refactor this behavior, use the <code>ngSkipHydration</code> attribute (<a href=\"guide/hydration#ngskiphydration\">described below</a>) until you can refactor into a hydration friendly solution.</p>\n\n<h3 id=\"valid-html-structure\" translation-result=\"on\">有效的 HTML 結構<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#valid-html-structure\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Valid HTML structure<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#valid-html-structure\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在某些情況下，如果你的元件範本沒有有效的 HTML 結構，可能會導致在水合期間出現 DOM 不匹配錯誤。</p><p translation-origin=\"off\">There are a few cases where if you have a component template that does not have valid HTML structure, this could result in a DOM mismatch error during hydration.</p>\n\n<p translation-result=\"on\">例如，以下是此問題的一些最常見案例。</p><p translation-origin=\"off\">As an example, here are some of the most common cases of this issue.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>&lt;table&gt;</code> 標籤中沒有 <code>&lt;tbody&gt;</code></p><p translation-origin=\"off\"><code>&lt;table&gt;</code> without a <code>&lt;tbody&gt;</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>&lt;div&gt;</code>標籤 位於 <code>&lt;p&gt;</code> 中</p><p translation-origin=\"off\"><code>&lt;div&gt;</code> inside a <code>&lt;p&gt;</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>&lt;a&gt;</code>標籤 位於 <code>&lt;h1&gt;</code> 中</p><p translation-origin=\"off\"><code>&lt;a&gt;</code> inside an <code>&lt;h1&gt;</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>&lt;a&gt;</code> 標籤位於另一個 <code>&lt;a&gt;</code> 中</p><p translation-origin=\"off\"><code>&lt;a&gt;</code> inside another <code>&lt;a&gt;</code></p>\n\n</li>\n</ul>\n<p translation-result=\"on\">如果你不確定你的 HTML 是否有效，可以使用<a href=\"https://validator.w3.org/\">語法驗證器</a>來檢查它。</p><p translation-origin=\"off\">If you are uncertain about whether your HTML is valid, you can use a <a href=\"https://validator.w3.org/\">syntax validator</a> to check it.</p>\n\n<p><a id=\"preserve-whitespaces\"></a></p>\n<h3 id=\"preserve-whitespaces-configuration\" translation-result=\"on\">保留空白字元配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#preserve-whitespaces-configuration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Preserve Whitespaces Configuration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#preserve-whitespaces-configuration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">使用水合功能時，我們建議對 <code>preserveWhitespaces</code> 使用預設設定 <code>false</code>。如果你的 tsconfig 中沒有進行此設定，則該值將為 <code>false</code> 而無需更改。如果你選擇透過將 <code>preserveWhitespaces: true</code> 新增到你的 tsconfig 中來啟用保留空格，就可能會遇到水合問題。這在目前還不是一個受到完全支援的配置。</p><p translation-origin=\"off\">When using the hydration feature, we recommend using the default setting of <code>false</code> for <code>preserveWhitespaces</code>. If this setting is not in your tsconfig, the value will be <code>false</code> and no changes are required. If you choose to enable preserving whitespaces by adding <code>preserveWhitespaces: true</code> to your tsconfig, it is possible you may encounter issues with hydration. This is not yet a fully supported configuration.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">請確保在伺服器端和瀏覽器端的建構中，<code>tsconfig.server.json</code> 和 <code>tsconfig.app.json</code> 檔案中設定的這個選項是<strong>一致的</strong>。如果不一致就會導致水合失敗。</p><p translation-origin=\"off\">Make sure that this setting is set <strong>consistently</strong> in <code>tsconfig.server.json</code> for your server and <code>tsconfig.app.json</code> for your browser builds. A mismatched value will cause hydration to break.</p>\n\n<p translation-result=\"on\">如果你選擇在 <code>tsconfig</code> 中設定此選項，我們建議僅在 <code>tsconfig.app.json</code> 中設定它，因為預設情況下 <code>tsconfig.server.json</code> 會從 <code>tsconfig.app.json</code> 中繼承此選項。</p><p translation-origin=\"off\">If you choose to set this setting in your tsconfig, we recommend to set it only in <code>tsconfig.app.json</code> which by default the <code>tsconfig.server.json</code> will inherit it from.</p>\n\n</div>\n<h3 id=\"custom-or-noop-zonejs-are-not-yet-supported\" translation-result=\"on\">尚不支援自訂或 Noop Zone.js<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#custom-or-noop-zonejs-are-not-yet-supported\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Custom or Noop Zone.js are not yet supported<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#custom-or-noop-zonejs-are-not-yet-supported\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">水合要依賴於來自 Zone.js 的訊號來確定應用程式何時變得穩定，以便 Angular 可以在伺服器端上啟動序列化過程或在客戶端啟動水合後進行清理工作（以刪除無主的 DOM 節點）。</p><p translation-origin=\"off\">Hydration relies on a signal from Zone.js when it becomes stable inside an application, so that Angular can start the serialization process on the server or post-hydration cleanup on the client to remove DOM nodes that remained unclaimed.</p>\n\n<p translation-result=\"on\">提供自訂或 “noop” Zone.js 實現可能會導致“穩定”事件發生在不同的時間點，從而過早或過晚觸發序列化或清理。這還不是已受完全支援的配置，你可能需要在自訂 Zone.js 實現中調整 <code>onStable</code> 事件的時間。</p><p translation-origin=\"off\">Providing a custom or a \"noop\" Zone.js implementation may lead to a different timing of the \"stable\" event, thus triggering the serialization or the cleanup too early or too late. This is not yet a fully supported configuration and you may need to adjust the timing of the <code>onStable</code> event in the custom Zone.js implementation.</p>\n\n<p><a id=\"errors\"></a></p>\n<h2 id=\"errors\" translation-result=\"on\">錯誤<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#errors\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Errors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#errors\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可能會遇到多種與水合相關的錯誤，從節點不匹配，到在無效宿主節點上使用 <code>ngSkipHydration</code> 等情況。可能發生的最常見錯誤情況是由於使用了原生 API 直接進行 DOM 操作導致水合無法在客戶端上找到或匹配上伺服器端渲染的預期 DOM 樹結構。另一種情況已在前面有關有效 HTML 結構的部分中提到過。因此，請確保你範本中的 HTML 使用了有效結構，這樣就可以避免這種錯誤情況。</p><p translation-origin=\"off\">There are several hydration related errors you may encounter ranging from node mismatches to cases when the <code>ngSkipHydration</code> was used on an invalid host node. The most common error case that may occur is due to direct DOM manipulation using native APIs that results in hydration being unable to find or match the expected DOM tree structure on the client that was rendered by the server. The other case you may encounter this type of error was mentioned in the prior section on Valid HTML structures. So, make sure the HTML in your templates are using valid structure, and you'll avoid that error case.</p>\n\n<p translation-result=\"on\">有關水合相關錯誤的完整參考，請存取<a href=\"/errors\">錯誤參考指南</a>。</p><p translation-origin=\"off\">For a full reference on hydration related errors, visit the <a href=\"/errors\">Errors Reference Guide</a>.</p>\n\n<p><a id=\"ngskiphydration\"></a></p>\n<h2 id=\"how-to-skip-hydration-for-particular-components\" translation-result=\"on\">如何跳過特定元件的水合<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#how-to-skip-hydration-for-particular-components\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">How to skip hydration for particular components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#how-to-skip-hydration-for-particular-components\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">由於上述某些問題（例如直接操作 DOM），某些元件可能在啟用水合的情況下無法正常工作。作為一種變通方法，你可以將 <code>ngSkipHydration</code> 屬性新增到元件的標籤中，以跳過對整個元件進行水合處理。</p><p translation-origin=\"off\">Some components may not work properly with hydration enabled due to some of the aforementioned issues, like direct DOM manipulation. As a workaround, you can add the <code>ngSkipHydration</code> attribute to a component's tag in order to skip hydrating the entire component.</p>\n\n<code-example language=\"html\">\n&lt;example-cmp ngSkipHydration /&gt;\n</code-example>\n<p translation-result=\"on\">或者，你可以在宿主繫結中使用 <code>ngSkipHydration</code>。</p><p translation-origin=\"off\">Alternatively you can set <code>ngSkipHydration</code> as a host binding.</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  host: {ngSkipHydration: 'true'},\n})\nclass ExampleCmp {}\n</code-example>\n<p translation-result=\"on\"><code>ngSkipHydration</code> 屬性將強制 Angular 跳過對整個元件及其子元件的水合。使用此屬性意味著該元件的行為就像未啟用水合一樣，這意味著它將自行銷燬並重新渲染。</p><p translation-origin=\"off\">The <code>ngSkipHydration</code> attribute will force Angular to skip hydrating the entire component and its children. Using this attribute means that the component will behave as if hydration is not enabled, meaning it will destroy and re-render itself.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">這將解決渲染問題，但也意味著對於此元件（及其子元件），你將無法從水合中受益。你應該儘量調整元件的實現以避免破壞水合的模式（即直接 DOM 操作），以便能刪除跳過水合的註釋。</p><p translation-origin=\"off\">This will fix rendering issues, but it means that for this component (and its children), you don't get the benefits of hydration. You will need to adjust your component's implementation to avoid hydration-breaking patterns (i.e. Direct DOM Manipulation) to be able to remove the skip hydration annotation.</p>\n\n</div>\n<p translation-result=\"on\"><code>ngSkipHydration</code> 屬性只能在元件的宿主節點上使用。如果將此屬性新增到其他節點，Angular 就會丟擲錯誤。</p><p translation-origin=\"off\">The <code>ngSkipHydration</code> attribute can only be used on component host nodes. Angular throws an error if this attribute is added to other nodes.</p>\n\n<p translation-result=\"on\">請記住，將 <code>ngSkipHydration</code> 屬性新增到根應用程式元件將有效地禁用對整個應用程式的水合。因此使用此屬性時要小心謹慎，它只能作為最後的解決方案。那些破壞水合的元件應被視為需要修復的錯誤。</p><p translation-origin=\"off\">Keep in mind that adding the <code>ngSkipHydration</code> attribute to your root application component would effectively disable hydration for your entire application. Be careful and thoughtful about using this attribute. It is intended as a last resort workaround. Components that break hydration should be considered bugs that need to be fixed.</p>\n\n<p><a id=\"i18n\"></a></p>\n<h2 id=\"i18n\">I18N<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#i18n\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\">我們還不支援水合的國際化，但很快就會支援。目前，Angular 會跳過對使用了 i18n 塊的元件的水合，有效地從頭開始重新渲染這些元件。</p><p translation-origin=\"off\">We don't yet support internationalization with hydration, but support is coming.\nCurrently, Angular would skip hydration for components that use i18n blocks, effectively\nre-rendering those components from scratch.</p>\n\n<h2 id=\"third-party-libraries-with-dom-manipulation\" translation-result=\"on\">具有 DOM 操作的第三方函式庫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#third-party-libraries-with-dom-manipulation\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Third Party Libraries with DOM Manipulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hydration#third-party-libraries-with-dom-manipulation\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">有許多依賴於 DOM 操作才能渲染的第三方函式庫。D3 圖表就是典型。這些庫在沒有水合的情況下能正常工作，但在啟用水合時可能會導致 DOM 不匹配錯誤。現在，如果你在使用這些庫之一時遇到了 DOM 不匹配的錯誤，可以將 <code>ngSkipHydration</code> 屬性新增到使用該庫渲染的元件。</p><p translation-origin=\"off\">There are a number of third party libraries that depend on DOM manipulation to be able to render. D3 charts is a prime example. These libraries worked without hydration, but they may cause DOM mismatch errors when hydration is enabled. For now, if you encounter DOM mismatch errors using one of these libraries, you can add the <code>ngSkipHydration</code> attribute to the component that renders using that library.</p>\n\n\n  \n</div>\n\n\n<!-- links to this doc:\n - errors/NG0500\n - errors/NG0503\n - errors/NG0504\n - errors/NG0505\n - errors/NG0912\n - errors/NG5000\n - guide/angular-compiler-options\n - guide/roadmap\n - guide/universal\n-->\n<!-- links from this doc:\n - /errors\n - /guide/releases#developer-preview\n - /guide/universal\n - api/core/Component\n - api/core/NgModule\n - api/platform-browser/bootstrapApplication\n - api/platform-browser/provideClientHydration\n - guide/hydration#constraints\n - guide/hydration#custom-or-noop-zonejs-are-not-yet-supported\n - guide/hydration#direct-dom-manipulation\n - guide/hydration#dom-manipulation\n - guide/hydration#errors\n - guide/hydration#how-do-you-enable-hydration-in-angular\n - guide/hydration#how-to-skip-hydration-for-particular-components\n - guide/hydration#hydration\n - guide/hydration#i18n\n - guide/hydration#ngskiphydration\n - guide/hydration#preserve-whitespaces-configuration\n - guide/hydration#third-party-libraries-with-dom-manipulation\n - guide/hydration#valid-html-structure\n - guide/hydration#what-is-hydration\n - guide/hydration#why-is-hydration-important\n - guide/hydration#為什麼水合很重要\n - guide/hydration#什麼是水合\n - guide/hydration#保留空白字元配置\n - guide/hydration#具有-dom-操作的第三方函式庫\n - guide/hydration#如何在-angular-中啟用水合\n - guide/hydration#如何跳過特定元件的水合\n - guide/hydration#尚不支援自訂或-noop-zonejs\n - guide/hydration#有效的-html-結構\n - guide/hydration#水合hydration\n - guide/hydration#直接-dom-操作\n - guide/hydration#約束條件\n - guide/hydration#錯誤\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/hydration.md?message=docs%3A%20請簡述你的修改...\n - https://validator.w3.org/\n - https://web.dev/cls/\n - https://web.dev/fid/\n - https://web.dev/lcp/\n - https://web.dev/learn-core-web-vitals/\n-->"}