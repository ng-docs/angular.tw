{"id":"guide/lightweight-injection-tokens","title":"Optimizing client application size with lightweight injection tokens","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/lightweight-injection-tokens.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"optimizing-client-application-size-with-lightweight-injection-tokens\" translation-result=\"on\">使用輕量級注入令牌最佳化客戶應用的大小<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#optimizing-client-application-size-with-lightweight-injection-tokens\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Optimizing client application size with lightweight injection tokens<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#optimizing-client-application-size-with-lightweight-injection-tokens\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本頁面會提供一個概念性的概述，它介紹了一種建議庫開發者使用的依賴注入技術。<em>使用輕量級注入令牌</em>設計你的函式庫，這有助於最佳化那些用到你庫的客戶應用的釋出包體積。</p><p translation-origin=\"off\">This page provides a conceptual overview of a dependency injection technique that is recommended for library developers.\nDesigning your library with <em>lightweight injection tokens</em> helps optimize the bundle size of client applications that use your library.</p>\n\n<p translation-result=\"on\">你可以使用<a href=\"guide/architecture-services#introduction-to-services-and-dependency-injection\">可搖樹最佳化的提供者</a>來管理元件和可注入服務之間的依賴結構，以最佳化釋出包體積。這通常會確保如果提供的元件或服務從未被應用實際使用過，那麼編譯器就可以從釋出套件中移除它的程式碼。</p><p translation-origin=\"off\">You can manage the dependency structure among your components and injectable services to optimize bundle size by using <a href=\"guide/architecture-services#introduction-to-services-and-dependency-injection\">tree-shakable providers</a>.\nThis normally ensures that if a provided component or service is never actually used by the application, the compiler can remove its code from the bundle.</p>\n\n<p translation-result=\"on\">但是，由於 Angular 儲存注入令牌的方式，可能會導致未用到的元件或服務最終進入釋出套件中。本頁描述了依賴注入的一種設計模式，它透過使用輕量級注入令牌來支援正確的搖樹最佳化。</p><p translation-origin=\"off\">Due to the way Angular stores injection tokens, it is possible that such an unused component or service can end up in the bundle anyway.\nThis page describes a dependency-injection design pattern that supports proper tree-shaking by using lightweight injection tokens.</p>\n\n<p translation-result=\"on\">這種輕量級注入令牌設計模式對於庫開發者來說尤其重要。它可以確保當應用只用到了你庫中的某些功能時，可以從客戶應用的釋出套件中刪除未使用過的程式碼。</p><p translation-origin=\"off\">The lightweight injection token design pattern is especially important for library developers.\nIt ensures that when an application uses only some of your library's capabilities, the unused code can be eliminated from the client's application bundle.</p>\n\n<p translation-result=\"on\">當某應用用到了你的函式庫時，你的函式庫中可能會提供一些客戶應用未用到的服務。在這種情況下，應用開發人員會期望該服務是可搖樹最佳化的，不讓這部分程式碼增加應用的編譯後大小。由於應用開發人員既無法瞭解也無法解決庫的搖樹最佳化問題，因此這是庫開發人員的責任。為了防止未使用的元件被保留下來，你的函式庫應該使用輕量級注入令牌這種設計模式。</p><p translation-origin=\"off\">When an application uses your library, there might be some services that your library supplies which the client application doesn't use.\nIn this case, the application developer should expect that service to be tree-shaken, and not contribute to the size of the compiled application.\nBecause the application developer cannot know about or remedy a tree-shaking problem in the library, it is the responsibility of the library developer to do so.\nTo prevent the retention of unused components, your library should use the lightweight injection token design pattern.</p>\n\n<h2 id=\"when-tokens-are-retained\" translation-result=\"on\">什麼時候令牌會被保留<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#when-tokens-are-retained\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">When tokens are retained<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#when-tokens-are-retained\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">為了更好地解釋令牌被保留的條件，我們考慮一個提供卡片元件的函式庫。該元件包含一個卡片體，還可以包含一個可選的卡片頭。</p><p translation-origin=\"off\">To better explain the condition under which token retention occurs, consider a library that provides a library-card component. This component contains a body and can contain an optional header.</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;lib-card&gt;\n  &lt;lib-header&gt;…&lt;/lib-header&gt;\n&lt;/lib-card&gt;\n\n</code-example>\n<p translation-result=\"on\">在一個可能的實現中，<code>&lt;lib-card&gt;</code> 元件使用 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> 或者 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>()</code> 來獲取 <code>&lt;lib-header&gt;</code> 和 <code>&lt;lib-body&gt;</code>，如下所示。</p><p translation-origin=\"off\">In a likely implementation, the <code>&lt;lib-card&gt;</code> component uses <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> or <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>()</code> to get <code>&lt;lib-header&gt;</code> and <code>&lt;lib-body&gt;</code>, as in the following.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-header',\n  …,\n})\nclass LibHeaderComponent {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-card',\n  …,\n})\nclass LibCardComponent {\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderComponent)\n  header: LibHeaderComponent|null = null;\n}\n\n</code-example>\n<p translation-result=\"on\">因為 <code>&lt;lib-header&gt;</code> 是可選的，所以元素可以用最小化的形式 <code>&lt;lib-card&gt;&lt;/lib-card&gt;</code> 出現在範本中。在這個例子中，<code>&lt;lib-header&gt;</code> 沒有用過，你可能期望它會被搖樹最佳化掉，但事實並非如此。這是因為 <code>LibCardComponent</code> 實際上包含兩個對 <code>LibHeaderComponent</code> 參考。</p><p translation-origin=\"off\">Because <code>&lt;lib-header&gt;</code> is optional, the element can appear in the template in its minimal form, <code>&lt;lib-card&gt;&lt;/lib-card&gt;</code>.\nIn this case, <code>&lt;lib-header&gt;</code> is not used and you would expect it to be tree-shaken, but that is not what happens.\nThis is because <code>LibCardComponent</code> actually contains two references to the <code>LibHeaderComponent</code>.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderComponent) header: LibHeaderComponent;\n\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\">其中一個參考位於<em>型別位置上</em> - 即，它把 <code>LibHeaderComponent</code> 用作了型別：<code>header: LibHeaderComponent;</code>。</p><p translation-origin=\"off\">One of these reference is in the <em>type position</em>-- that is, it specifies <code>LibHeaderComponent</code> as a type: <code>header: LibHeaderComponent;</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">另一個參考位於<em>值的位置</em> - 即，LibHeaderComponent 是 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> 引數裝飾器的值：<code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderComponent)</code>。</p><p translation-origin=\"off\">The other reference is in the <em>value position</em>-- that is, LibHeaderComponent is the value of the <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> parameter decorator: <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderComponent)</code>.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">編譯器對這些位置的令牌參考的處理方式也不同。</p><p translation-origin=\"off\">The compiler handles token references in these positions differently.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">編譯器在從 TypeScript 轉換完後會刪除這些<em>型別位置上</em>的參考，所以它們對於搖樹最佳化沒什麼影響。</p><p translation-origin=\"off\">The compiler erases <em>type position</em> references after conversion from TypeScript, so they have no impact on tree-shaking.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">編譯器必須在執行時保留<em>值位置上</em>的參考，這就會阻止該元件被搖樹最佳化掉。</p><p translation-origin=\"off\">The compiler must keep <em>value position</em> references at runtime, which prevents the component from being tree-shaken.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">在這個例子中，編譯器保留了 <code>LibHeaderComponent</code> 令牌，它出現在了值位置上，這就會防止所參考的元件被搖樹最佳化掉，即使應用開發者實際上沒有在任何地方用過 <code>&lt;lib-header&gt;</code>。如果 <code>LibHeaderComponent</code> 的程式碼、範本和樣式變得很大，把它包含進來就會不必要地大大增加客戶應用的大小。</p><p translation-origin=\"off\">In the example, the compiler retains the <code>LibHeaderComponent</code> token that occurs in the value position. This prevents the referenced component from being tree-shaken, even if the application developer does not actually use <code>&lt;lib-header&gt;</code> anywhere.\nIf <code>LibHeaderComponent</code> 's code, template, and styles combined becomes too large, including it unnecessarily can significantly increase the size of the client application.</p>\n\n<h2 id=\"when-to-use-the-lightweight-injection-token-pattern\" translation-result=\"on\">什麼時候使用輕量級注入令牌模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#when-to-use-the-lightweight-injection-token-pattern\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">When to use the lightweight injection token pattern<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#when-to-use-the-lightweight-injection-token-pattern\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">當一個元件被用作注入令牌時，就會出現搖樹最佳化的問題。有兩種情況可能會發生。</p><p translation-origin=\"off\">The tree-shaking problem arises when a component is used as an injection token.\nThere are two cases when that can happen.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">令牌用在<a href=\"guide/lifecycle-hooks#using-aftercontent-hooks\" title=\"詳細瞭解如何使用內容查詢。\">內容查詢</a>中值的位置上。</p><p translation-origin=\"off\">The token is used in the value position of a <a href=\"guide/lifecycle-hooks#using-aftercontent-hooks\" title=\"See more about using content queries.\">content query</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">該令牌用作建構函式注入的型別說明符。</p><p translation-origin=\"off\">The token is used as a type specifier for constructor injection.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">在下面的例子中，兩處對 <code>OtherComponent</code> 令牌的使用導致 <code>OtherComponent</code> 被保留下來，防止它在未用到時被搖樹最佳化掉。</p><p translation-origin=\"off\">In the following example, both uses of the <code>OtherComponent</code> token cause retention of <code>OtherComponent</code>, preventing it from being tree-shaken when it is not used.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass MyComponent {\n  constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() other: OtherComponent) {}\n\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(OtherComponent)\n  other: OtherComponent|null;\n}\n\n</code-example>\n<p translation-result=\"on\">雖然轉換為 JavaScript 時只會刪除那些只用作型別說明符的令牌，但在執行時依賴注入需要所有這些令牌。這些工作把 <code>constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() other: OtherComponent)</code> 改成了 <code>constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(OtherComponent) other)</code>。該令牌現在處於值的位置，並使該搖樹最佳化器保留該參考。</p><p translation-origin=\"off\">Although tokens used only as type specifiers are removed when converted to JavaScript, all tokens used for dependency injection are needed at runtime.\nThese effectively change <code>constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() other: OtherComponent)</code> to <code>constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(OtherComponent) other)</code>.\nThe token is now in a value position, and causes the tree shaker to keep the reference.</p>\n\n<div class=\"alert is helpful\">\n<p translation-result=\"on\">對於所有服務，庫都應該使用<a href=\"guide/architecture-services#introduction-to-services-and-dependency-injection\">可搖樹最佳化的提供者</a>，在根級而不是元件建構函式中提供依賴。</p><p translation-origin=\"off\">For all services, a library should use <a href=\"guide/architecture-services#introduction-to-services-and-dependency-injection\">tree-shakable providers</a>, providing dependencies at the root level rather than in component constructors.</p>\n\n</div>\n<h2 id=\"using-lightweight-injection-tokens\" translation-result=\"on\">使用輕量級注入令牌<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#using-lightweight-injection-tokens\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Using lightweight injection tokens<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#using-lightweight-injection-tokens\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">輕量級注入令牌設計模式包括：使用一個小的抽象類別作為注入令牌，並在稍後為它提供實際實現。該抽象類別固然會被留下（不會被搖樹最佳化掉），但它很小，對應用程式的大小沒有任何重大影響。</p><p translation-origin=\"off\">The lightweight injection token design pattern consists of using a small abstract class as an injection token, and providing the actual implementation at a later stage.\nThe abstract class is retained, not tree-shaken, but it is small and has no material impact on the application size.</p>\n\n<p translation-result=\"on\">下例舉例說明了這個 <code>LibHeaderComponent</code> 的工作原理。</p><p translation-origin=\"off\">The following example shows how this works for the <code>LibHeaderComponent</code>.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nabstract class LibHeaderToken {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-header',\n  providers: [\n    {provide: LibHeaderToken, useExisting: LibHeaderComponent}\n  ]\n  …,\n})\nclass LibHeaderComponent extends LibHeaderToken {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-card',\n  …,\n})\nclass LibCardComponent {\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderToken) header: LibHeaderToken|null = null;\n}\n\n</code-example>\n<p translation-result=\"on\">在這個例子中，<code>LibCardComponent</code> 的實現裡，<code>LibHeaderComponent</code> 既不會出現在型別的位置也不會出現在值的位置。這樣就可以讓 <code>LibHeaderComponent</code> 完全被搖樹最佳化掉。<code>LibHeaderToken</code> 被留下了，但它只是一個類別宣告，沒有具體的實現。它很小，並且在編譯後保留時對應用程式的大小沒有實質影響。</p><p translation-origin=\"off\">In this example, the <code>LibCardComponent</code> implementation no longer refers to <code>LibHeaderComponent</code> in either the type position or the value position.\nThis lets full tree shaking of <code>LibHeaderComponent</code> take place.\nThe <code>LibHeaderToken</code> is retained, but it is only a class declaration, with no concrete implementation.\nIt is small and does not materially impact the application size when retained after compilation.</p>\n\n<p translation-result=\"on\">不過，<code>LibHeaderComponent</code> 本身實現了抽象類別 <code>LibHeaderToken</code>。你可以放心使用這個令牌作為元件定義中的提供者，讓 Angular 能夠正確地注入具體型別。</p><p translation-origin=\"off\">Instead, <code>LibHeaderComponent</code> itself implements the abstract <code>LibHeaderToken</code> class.\nYou can safely use that token as the provider in the component definition, allowing Angular to correctly inject the concrete type.</p>\n\n<p translation-result=\"on\">總結一下，輕量級注入令牌模式由以下幾部分組成。</p><p translation-origin=\"off\">To summarize, the lightweight injection token pattern consists of the following.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">一個輕量級的注入令牌，它表現為一個抽象類別。</p><p translation-origin=\"off\">A lightweight injection token that is represented as an abstract class.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">一個實現該抽象類別的元件定義。</p><p translation-origin=\"off\">A component definition that implements the abstract class.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">注入這種輕量級模式時使用 <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> 或者 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>()</code>。</p><p translation-origin=\"off\">Injection of the lightweight pattern, using <code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> or <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>()</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">實現輕量級注入令牌的提供者，它將輕量級注入令牌和它的實現關聯起來。</p><p translation-origin=\"off\">A provider in the implementation of the lightweight injection token which associates the lightweight injection token with the implementation.</p>\n\n</li>\n</ol>\n<h3 id=\"use-the-lightweight-injection-token-for-api-definition\" translation-result=\"on\">使用輕量級注入令牌進行 API 定義<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#use-the-lightweight-injection-token-for-api-definition\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Use the lightweight injection token for API definition<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#use-the-lightweight-injection-token-for-api-definition\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">那些注入了輕量級注入令牌的元件可能要呼叫注入的類中的方法。因為令牌現在是一個抽象類別，並且可注入元件實現了那個抽象類別，所以你還必須在作為輕量級注入令牌的抽象類別中宣告一個抽象方法。該方法的實現程式碼（及其所有相關程式碼）都會留在可注入元件中，但這個元件本身仍可被搖樹最佳化。這樣就能讓父元件以型別安全的方式與子元件（如果存在）進行通訊。</p><p translation-origin=\"off\">A component that injects a lightweight injection token might need to invoke a method in the injected class.\nThe token is now an abstract class. Since the injectable component implements that class, you must also declare an abstract method in the abstract lightweight injection token class.\nThe implementation of the method, with all its code overhead, resides in the injectable component that can be tree-shaken.\nThis lets the parent communicate with the child, if it is present, in a type-safe manner.</p>\n\n<p translation-result=\"on\">比如，<code>LibCardComponent</code> 現在要查詢 <code>LibHeaderToken</code> 而不是 <code>LibHeaderComponent</code>。這個例子展示了該模式如何讓 <code>LibCardComponent</code> 與 <code>LibHeaderComponent</code> 通訊，卻不用實際參考 <code>LibHeaderComponent</code>。</p><p translation-origin=\"off\">For example, the <code>LibCardComponent</code> now queries <code>LibHeaderToken</code> rather than <code>LibHeaderComponent</code>.\nThe following example shows how the pattern lets <code>LibCardComponent</code> communicate with the <code>LibHeaderComponent</code> without actually referring to <code>LibHeaderComponent</code>.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nabstract class LibHeaderToken {\n  abstract doSomething(): void;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-header',\n  providers: [\n    {provide: LibHeaderToken, useExisting: LibHeaderComponent}\n  ]\n  …,\n})\nclass LibHeaderComponent extends LibHeaderToken {\n  doSomething(): void {\n    // Concrete implementation of `doSomething`\n  }\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lib-card',\n  …,\n})\nclass LibCardComponent implement <a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a> {\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(LibHeaderToken)\n  header: LibHeaderToken|null = null;\n\n  ngAfterContentInit(): void {\n    this.header &amp;&amp; this.header.doSomething();\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">在這個例子中，父元件會查詢令牌以獲取子元件，並持有結果元件的參考（如果存在）。在呼叫子元件中的方法之前，父元件會檢查子元件是否存在。如果子元件已經被搖樹最佳化掉，那執行期間就沒有對它的參考，當然也沒有呼叫它的方法。</p><p translation-origin=\"off\">In this example the parent  queries the token to get the child component, and stores the resulting component reference if it is present.\nBefore calling a method in the child, the parent component checks to see if the child component is present.\nIf the child component has been tree-shaken, there is no runtime reference to it, and no call to its method.</p>\n\n<h3 id=\"naming-your-lightweight-injection-token\" translation-result=\"on\">為你的輕量級注入令牌命名<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#naming-your-lightweight-injection-token\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Naming your lightweight injection token<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lightweight-injection-tokens#naming-your-lightweight-injection-token\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">輕量級注入令牌只對元件有用。Angular 風格指南中建議你使用“Component”字尾命名元件。比如“LibHeaderComponent”就遵循這個約定。</p><p translation-origin=\"off\">Lightweight injection tokens are only useful with components.\nThe Angular style guide suggests that you name components using the \"Component\" suffix.\nThe example \"LibHeaderComponent\" follows this convention.</p>\n\n<p translation-result=\"on\">為了維護元件及其令牌之間的對應關係，同時又要區分它們，推薦的寫法是使用元件基本名加上字尾“<code>Token</code>”來命名你的輕量級注入令牌：“<code>LibHeaderToken</code>”。</p><p translation-origin=\"off\">You should maintain the relationship between the component and its token while still distinguishing between them. The recommended style is to use the component base name with the suffix \"<code>Token</code>\" to name your lightweight injection tokens: \"<code>LibHeaderToken</code>.\"</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/creating-libraries\n-->\n<!-- links from this doc:\n - api/core/AfterContentInit\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Inject\n - api/core/Optional\n - guide/architecture-services#introduction-to-services-and-dependency-injection\n - guide/lifecycle-hooks#using-aftercontent-hooks\n - guide/lightweight-injection-tokens#naming-your-lightweight-injection-token\n - guide/lightweight-injection-tokens#optimizing-client-application-size-with-lightweight-injection-tokens\n - guide/lightweight-injection-tokens#use-the-lightweight-injection-token-for-api-definition\n - guide/lightweight-injection-tokens#using-lightweight-injection-tokens\n - guide/lightweight-injection-tokens#when-to-use-the-lightweight-injection-token-pattern\n - guide/lightweight-injection-tokens#when-tokens-are-retained\n - guide/lightweight-injection-tokens#為你的輕量級注入令牌命名\n - guide/lightweight-injection-tokens#什麼時候令牌會被保留\n - guide/lightweight-injection-tokens#什麼時候使用輕量級注入令牌模式\n - guide/lightweight-injection-tokens#使用輕量級注入令牌\n - guide/lightweight-injection-tokens#使用輕量級注入令牌最佳化客戶應用的大小\n - guide/lightweight-injection-tokens#使用輕量級注入令牌進行-api-定義\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/lightweight-injection-tokens.md?message=docs%3A%20請簡述你的修改...\n-->"}