{"id":"guide/migration-renderer","title":"Renderer to Renderer2 migration","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/migration-renderer.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"renderer-to-renderer2-migration\" translation-result=\"on\"><code>Renderer</code> 到 <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code> 的遷移<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#renderer-到-renderer2-的遷移\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\"><code>Renderer</code> to <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code> migration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#renderer-to-renderer2-migration\"><i class=\"material-icons\">link</i></a></h1>\n\n<h2 id=\"migration-overview\" translation-result=\"on\">遷移概述<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#migration-overview\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Migration Overview<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#migration-overview\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">自 Angular 版本 4 開始，<code>Renderer</code> 類就被標記為已棄用。本節提供了一些指導，幫助你把這個已棄用的 API 遷移到更新的 <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code> API，並解釋了它對你的應用而言意味著什麼。</p><p translation-origin=\"off\">The <code>Renderer</code> class has been marked as deprecated since Angular version 4.\nThis section provides guidance on migrating from this deprecated API to the newer <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code> API and what it means for your app.</p>\n\n<h2 id=\"why-should-i-migrate-to-renderer2\" translation-result=\"on\">為什麼要遷移到 Renderer2？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#why-should-i-migrate-to-renderer2\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Why should I migrate to Renderer2?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#why-should-i-migrate-to-renderer2\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">已棄用的 <code>Renderer</code> 類已經在 Angular 的 9 中刪除了，所以有必要遷移到支援的 API。建議使用 <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code> 策略，因為它支援與 <code>Renderer</code> 很相似的一組功能。這個 API 非常龐大，有 19 種方法，但原理圖會幫你簡化這個過程。</p><p translation-origin=\"off\">The deprecated <code>Renderer</code> class has been removed in version 9 of Angular, so it's necessary to migrate to a supported API.\nUsing <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code> is the recommended strategy because it supports a similar set of functionality to <code>Renderer</code>.\nWith 19 methods, the API surface is quite large, but the schematic should simplify this process for your applications.</p>\n\n<h2 id=\"is-there-action-required-on-my-end\" translation-result=\"on\">完成後我還要採取什麼行動嗎？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#is-there-action-required-on-my-end\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Is there action required on my end?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#is-there-action-required-on-my-end\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">這個原理圖應該可以處理大多數情況，僅僅不支援 <code>Renderer.animate()</code> 和 <code>Renderer.setDebugInfo()</code>。</p><p translation-origin=\"off\">No.\nThe schematic should handle most cases with the exception of <code>Renderer.animate()</code> and <code>Renderer.setDebugInfo()</code>, which already aren't supported.</p>\n\n<h2 id=\"what-are-the-__ngrendererx-methods-why-are-they-necessary\" translation-result=\"on\">什麼是 <code>__ngRendererX</code> 方法族？為什麼要用它們？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#what-are-the-__ngrendererx-methods-why-are-they-necessary\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What are the <code>__ngRendererX</code> methods? Why are they necessary?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#what-are-the-__ngrendererx-methods-why-are-they-necessary\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">有些方法在 <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code> 沒有完全等價的東西，或者對應於多個表示式。比如，這兩種渲染器都有 <code>createElement()</code> 的方法，但它們是不相等的，比如在 <code>Renderer</code> 中呼叫 <code>renderer.createElement(parentNode, namespaceAndName)</code> 時對應 <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code> 中的如下程式碼塊：</p><p translation-origin=\"off\">Some methods either don't have exact equivalents in <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code>, or they correspond to more than one expression.\nFor example, both renderers have a <code>createElement()</code> method, but they're not equal because a call such as <code>renderer.createElement(parentNode, namespaceAndName)</code> in the <code>Renderer</code> corresponds to the following block of code in <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst [namespace, name] = splitNamespace(namespaceAndName);\nconst el = renderer.createElement(name, namespace);\nif (parentNode) {\n  renderer.appendChild(parentNode, el);\n}\nreturn el;\n\n</code-example>\n<p translation-result=\"on\">遷移必須保證函式和變數型別的返回值不變。此原理圖會安全地處理大多數情況，它會在使用者檔案的底部宣告一些輔助函式。這些輔助函式封裝了你自己的邏輯，把程式碼中要被替換的內容放到單個函式呼叫中。這裡是 <code>createElement()</code> 遷移工作原理的一個例子：</p><p translation-origin=\"off\">Migration has to guarantee that the return values of functions and types of variables stay the same.\nTo handle the majority of cases safely, the schematic declares helper functions at the bottom of the user's file.\nThese helpers encapsulate your own logic and keep the replacements inside your code down to a single function call.\nHere's an example of how the <code>createElement()</code> migration looks:</p>\n\n<p translation-result=\"on\"><strong>之前</strong>：</p><p translation-origin=\"off\"><strong>Before</strong>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\npublic createAndAppendElement() {\n  const el = this.renderer.createElement('span');\n  el.textContent = 'hello world';\n  return el;\n}\n\n</code-example>\n<p translation-result=\"on\"><strong>之後</strong>：</p><p translation-origin=\"off\"><strong>After</strong>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\npublic createAndAppendElement() {\n  const el = __ngRendererCreateElement(this.renderer, this.element, 'span');\n  el.textContent = 'hello world';\n  return el;\n}\n// Generated code at the bottom of the file\n__ngRendererCreateElement(renderer: any, parentNode: any, nameAndNamespace: any) {\n  const [namespace, name] = __ngRendererSplitNamespace(namespaceAndName);\n  const el = renderer.createElement(name, namespace);\n  if (parentNode) {\n    renderer.appendChild(parentNode, el);\n  }\n  return el;\n}\n__ngRendererSplitNamespace(nameAndNamespace: any) {\n  // returns the split name and namespace\n}\n\n</code-example>\n<p translation-result=\"on\">當實現了這些輔助函式時，此原理圖會確保它們在每個檔案中都只宣告一次，並且它們的名字是唯一的，因此和你的程式碼中已經存在的函式幾乎不可能衝突。該原理圖還會把它們的引數型別設為 <code>any</code>，使其不必插入額外的邏輯就能確保它們的值有正確的型別。</p><p translation-origin=\"off\">When implementing these helper functions, the schematic ensures that they're only declared once per file and that their names are unique enough that there's a small chance of colliding with pre-existing functions in your code.\nThe schematic also keeps their parameter types as <code>any</code> so that it doesn't have to insert extra logic that ensures that their values have the correct type.</p>\n\n<h3 id=\"im-a-library-author-should-i-run-this-migration\" translation-result=\"on\">我是庫作者。我應該執行這次遷移嗎？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#im-a-library-author-should-i-run-this-migration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">I'm a library author. Should I run this migration?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#im-a-library-author-should-i-run-this-migration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><strong>庫的作者肯定要做這種遷移來遠離 <code>Renderer</code>。</strong> <strong>否則，這些庫將不再適用於用版本 9 建構的應用。</strong></p><p translation-origin=\"off\"><strong>Library authors should definitely use this migration to move away from the <code>Renderer</code>.</strong>\n<strong>Otherwise, the libraries won't work with applications built with version 9.</strong></p>\n\n<h3 id=\"full-list-of-method-migrations\" translation-result=\"on\">方法遷移的完整列表<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#full-list-of-method-migrations\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Full list of method migrations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-renderer#full-list-of-method-migrations\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">下表列出了從 <code>Renderer</code> 到 <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code> 要遷移的所有方法。</p><p translation-origin=\"off\">The following table shows all methods that the migration maps from <code>Renderer</code> to <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code>.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">Renderer</th>\n<th align=\"left\">Renderer2</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>listen(renderElement, name, callback)</code></td>\n<td align=\"left\"><code>listen(renderElement, name, callback)</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>setElementProperty(renderElement, propertyName, propertyValue)</code></td>\n<td align=\"left\"><code>setProperty(renderElement, propertyName, propertyValue)</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>setText(renderNode, text)</code></td>\n<td align=\"left\"><code>setValue(renderNode, text)</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>listenGlobal(target, name, callback)</code></td>\n<td align=\"left\"><code>listen(target, name, callback)</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>selectRootElement(selectorOrNode, debugInfo?)</code></td>\n<td align=\"left\"><code>selectRootElement(selectorOrNode)</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>createElement(parentElement, name, debugInfo?)</code></td>\n<td align=\"left\"><code>appendChild(parentElement, createElement(name))</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>setElementStyle(el, <a href=\"api/animations/style\" class=\"code-anchor\">style</a>, value?)</code></td>\n<td align=\"left\"><code>value == null ? removeStyle(el, <a href=\"api/animations/style\" class=\"code-anchor\">style</a>) : setStyle(el, <a href=\"api/animations/style\" class=\"code-anchor\">style</a>, value)</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>setElementAttribute(el, name, value?)</code></td>\n<td align=\"left\"><code>attributeValue == null ? removeAttribute(el, name) : setAttribute(el, name, value)</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>createText(parentElement, value, debugInfo?)</code></td>\n<td align=\"left\"><code>appendChild(parentElement, createText(value))</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>createTemplateAnchor(parentElement)</code></td>\n<td align=\"left\"><code>appendChild(parentElement, createComment(''))</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>setElementClass(renderElement, className, isAdd)</code></td>\n<td align=\"left\"><code>isAdd ? addClass(renderElement, className) : removeClass(renderElement, className)</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>projectNodes(parentElement, nodes)</code></td>\n<td align=\"left\"><code>for (let i = 0; i &lt; nodes.length; i++) { appendChild(parentElement, nodes[i]); }</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>attachViewAfter(node, viewRootNodes)</code></td>\n<td align=\"left\"><code>const parentElement = parentNode(node); const nextSibling = nextSibling(node); for (let i = 0; i &lt; viewRootNodes.length; i++) { insertBefore(parentElement, viewRootNodes[i], nextSibling);}</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>detachView(viewRootNodes)</code></td>\n<td align=\"left\"><code>for (let i = 0; i &lt; viewRootNodes.length; i++) {const node = viewRootNodes[i]; const parentElement = parentNode(node); removeChild(parentElement, node);}</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>destroyView(hostElement, viewAllNodes)</code></td>\n<td align=\"left\"><code>for (let i = 0; i &lt; viewAllNodes.length; i++) { destroyNode(viewAllNodes[i]); }</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>setBindingDebugInfo()</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">該函式在 <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code> 中無用。</nt-wrapper><nt-wrapper translation-origin=\"off\">This function is a noop in <code><a href=\"api/core/Renderer2\" class=\"code-anchor\">Renderer2</a></code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>createViewRoot(hostElement)</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">應該替換成到 <code>hostElement</code> 的參考</nt-wrapper><nt-wrapper translation-origin=\"off\">Should be replaced with a reference to <code>hostElement</code></nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>invokeElementMethod(renderElement, methodName, args?)</code></td>\n<td align=\"left\"><code>(renderElement as any)[methodName].apply(renderElement, args);</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code><a href=\"api/animations/animate\" class=\"code-anchor\">animate</a>(element, startingStyles, <a href=\"api/animations/keyframes\" class=\"code-anchor\">keyframes</a>, duration, delay, easing, previousPlayers?)</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">丟擲一個錯誤（和 <code>Renderer.animate()</code> 一樣）</nt-wrapper><nt-wrapper translation-origin=\"off\">Throws an error (same behavior as <code>Renderer.animate()</code>)</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/animations/animate\n - api/animations/keyframes\n - api/animations/style\n - api/core/Renderer2\n - guide/migration-renderer#full-list-of-method-migrations\n - guide/migration-renderer#im-a-library-author-should-i-run-this-migration\n - guide/migration-renderer#is-there-action-required-on-my-end\n - guide/migration-renderer#migration-overview\n - guide/migration-renderer#renderer-to-renderer2-migration\n - guide/migration-renderer#renderer-到-renderer2-的遷移\n - guide/migration-renderer#what-are-the-__ngrendererx-methods-why-are-they-necessary\n - guide/migration-renderer#why-should-i-migrate-to-renderer2\n - guide/migration-renderer#為什麼要遷移到-renderer2\n - guide/migration-renderer#什麼是-__ngrendererx-方法族為什麼要用它們\n - guide/migration-renderer#完成後我還要採取什麼行動嗎\n - guide/migration-renderer#我是庫作者我應該執行這次遷移嗎\n - guide/migration-renderer#方法遷移的完整列表\n - guide/migration-renderer#遷移概述\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/migration-renderer.md?message=docs%3A%20請簡述你的修改...\n-->"}