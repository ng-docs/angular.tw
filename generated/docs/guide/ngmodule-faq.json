{"id":"guide/ngmodule-faq","title":"NgModule FAQ","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/ngmodule-faq.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"ngmodule-faq\" translation-result=\"on\">NgModule 常見問題解答<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#ngmodule-faq\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">NgModule FAQ<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#ngmodule-faq\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">NgModules 可以幫你把應用組織成一些緊密相關的程式碼塊。</p><p translation-origin=\"off\">NgModules help organize an application into cohesive blocks of functionality.</p>\n\n<p translation-result=\"on\">這裡回答的是開發者常問起的關於 NgModule 的設計與實現問題。</p><p translation-origin=\"off\">This page answers the questions many developers ask about NgModule design and implementation.</p>\n\n<h2 id=\"what-classes-should-i-add-to-the-declarations-array\" translation-result=\"on\">我應該把哪些類加到 <em>declarations</em> 中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-classes-should-i-add-to-the-declarations-array\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What classes should I add to the <code>declarations</code> array?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-classes-should-i-add-to-the-declarations-array\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">把<a href=\"guide/bootstrapping#the-declarations-array\">可宣告</a>的類（元件、指令和管道）新增到 <code>declarations</code> 列表中。</p><p translation-origin=\"off\">Add <a href=\"guide/bootstrapping#the-declarations-array\">declarable</a> classes —components, directives, and pipes— to a <code>declarations</code> list.</p>\n\n<p translation-result=\"on\">這些類只能在應用程式的<em>一個並且只有一個</em>模組中宣告。只有當它們<em>從屬於</em>某個模組時，才能把在<em>此</em>模組中宣告它們。</p><p translation-origin=\"off\">Declare these classes in <em>exactly one</em> module of the application.\nDeclare them in a module if they belong to that particular module.</p>\n\n<p><a id=\"q-declarable\"></a></p>\n<h2 id=\"what-is-a-declarable\" translation-result=\"on\">什麼是可宣告物件（<code>declarable</code>）？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-a-declarable\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What is a <code>declarable</code>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-a-declarable\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><em>可宣告的</em>就是元件、指令和管道這些可以被加到模組的 <code>declarations</code> 列表中的類別。它們也是<em>所有</em>能被加到 <code>declarations</code> 中的類別。</p><p translation-origin=\"off\">Declarables are the class types —components, directives, and pipes— that you can add to a module's <code>declarations</code> list.\nThey're the only classes that you can add to <code>declarations</code>.</p>\n\n<h2 id=\"what-classes-should-i-not-add-to-declarations\" translation-result=\"on\">哪些類<em>不</em>應該加到 <code>declarations</code> 中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-classes-should-i-not-add-to-declarations\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What classes should I <em>not</em> add to <code>declarations</code>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-classes-should-i-not-add-to-declarations\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">只有<a href=\"guide/bootstrapping#the-declarations-array\">可宣告的</a>類才能加到模組的 <code>declarations</code> 列表中。</p><p translation-origin=\"off\">Add only <a href=\"guide/bootstrapping#the-declarations-array\">declarable</a> classes to an NgModule's <code>declarations</code> list.</p>\n\n<p translation-result=\"on\"><em>不要</em>宣告：</p><p translation-origin=\"off\">Do <em>not</em> declare the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">已經在其它模組中宣告過的類別。無論它來自應用自己的模組（<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>）還是第三方模組。</p><p translation-origin=\"off\">A class that's already declared in another module, whether an application module, <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>, or third-party module.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">從其它模組中匯入的指令。比如，不要宣告來自 <code>@angular/forms</code> 的 FORMS_DIRECTIVES，因為 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 已經宣告過它們了。</p><p translation-origin=\"off\">An array of directives imported from another module.\nFor example, don't declare <code>FORMS_DIRECTIVES</code> from <code>@angular/forms</code> because the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> already declares it.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">模組類別。</p><p translation-origin=\"off\">Module classes.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">服務類別。</p><p translation-origin=\"off\">Service classes.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">非 Angular 的類和物件，比如：字串、數字、函式、實體模型、配置、業務邏輯和輔助類別。</p><p translation-origin=\"off\">Non-Angular classes and objects, such as strings, numbers, functions, entity models, configurations, business logic, and helper classes.</p>\n\n</li>\n</ul>\n<h2 id=\"why-list-the-same-component-in-multiple-ngmodule-properties\" translation-result=\"on\">為什麼要把同一個元件宣告在不同的 <em>NgModule</em> 屬性中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/core/NgModule\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Why list the same component in multiple <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> properties?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-list-the-same-component-in-multiple-ngmodule-properties\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code>AppComponent</code> 經常同時列在 <code>declarations</code> 和 <code>bootstrap</code> 中。另外你還可能看到它同時列在 <code>declarations</code> 和 <code>exports</code> 中。</p><p translation-origin=\"off\"><code>AppComponent</code> is often listed in both <code>declarations</code> and <code>bootstrap</code>.\nYou might see the same component listed in <code>declarations</code> and <code>exports</code>.</p>\n\n<p translation-result=\"on\">這<em>看起來</em>是多餘的，不過這些函式具有不同的功能，從它出現在一個列表中無法推斷出它也應該在另一個列表中。</p><p translation-origin=\"off\">While that seems redundant, these properties have different functions.\nMembership in one list doesn't imply membership in another list.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>AppComponent</code> 可能被宣告在此模組中，但可能不是引導元件。</p><p translation-origin=\"off\"><code>AppComponent</code> could be declared in this module but not bootstrapped.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>AppComponent</code> 可能在此模組中引導，但可能是由另一個特性模組宣告的。</p><p translation-origin=\"off\"><code>AppComponent</code> could be bootstrapped in this module but declared in a different feature module.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">某個元件可能是從另一個應用模組中匯入的（所以你沒法宣告它）並且被當前模組重新匯出。</p><p translation-origin=\"off\">A component could be imported from another application module (so you can't declare it) and re-exported by this module.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">某個元件可能被匯出，以便用在外部元件的範本中，也可能同時被一個彈出式對話方塊載入。</p><p translation-origin=\"off\">A component could be exported for inclusion in an external component's template as well as dynamically loaded in a pop-up dialog.</p>\n\n</li>\n</ul>\n<h2 id=\"what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\" translation-result=\"on\">\"<em>Can't bind to 'x' since it isn't a known property of 'y'</em>\"是什麼意思？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What does \"Can't bind to 'x' since it isn't a known property of 'y'\" mean?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">這個錯誤通常意味著你或者忘了宣告指令“x”，或者你沒有匯入“x”所屬的模組。</p><p translation-origin=\"off\">This error often means that you haven't declared the directive \"x\" or haven't imported the NgModule to which \"x\" belongs.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果“x”其實不是屬性，或者是元件的私有屬性（比如它不帶 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 或 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 裝飾器），那麼你也同樣會遇到這個錯誤。</p><p translation-origin=\"off\">Perhaps you declared \"x\" in an application submodule but forgot to export it.\nThe \"x\" class isn't visible to other modules until you add it to the <code>exports</code> list.</p>\n\n</div>\n<h2 id=\"what-should-i-import\" translation-result=\"on\">我應該匯入什麼？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-import\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What should I import?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-import\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">匯入你需要在當前模組的元件範本中使用的那些公開的（被匯出的）<a href=\"guide/bootstrapping#the-declarations-array\">可宣告類</a>。</p><p translation-origin=\"off\">Import NgModules whose public (exported) <a href=\"guide/bootstrapping#the-declarations-array\">declarable classes</a>\nyou need to reference in this module's component templates.</p>\n\n<p translation-result=\"on\">這意味著要從 <code>@angular/common</code> 中匯入 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> 才能存取 Angular 的內建指令，比如 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 和 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>。你可以直接匯入它或者從<a href=\"guide/ngmodule-faq#q-reexport\">重新匯出</a>過該模組的其它模組中匯入它。</p><p translation-origin=\"off\">This always means importing <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> from <code>@angular/common</code> for access to\nthe Angular directives such as <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> and <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>.\nYou can import it directly or from another NgModule that <a href=\"guide/ngmodule-faq#q-reexport\">re-exports</a> it.</p>\n\n<p translation-result=\"on\">如果你的元件有 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 雙向繫結表示式，就要從 <code>@angular/forms</code> 中匯入 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>。</p><p translation-origin=\"off\">Import <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> from <code>@angular/forms</code>\nif your components have <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> two-way binding expressions.</p>\n\n<p translation-result=\"on\">如果當前模組中的元件包含了<em>共享</em>模組和<em>特性</em>模組中的元件、指令和管道，就匯入這些模組。</p><p translation-origin=\"off\">Import <em>shared</em> and <em>feature</em> modules when this module's components incorporate their\ncomponents, directives, and pipes.</p>\n\n<p translation-result=\"on\">只能在根模組 <code>AppModule</code> 中<a href=\"guide/ngmodule-faq#q-browser-vs-common-module\">匯入 <em>BrowserModule</em></a>。</p><p translation-origin=\"off\">Import <a href=\"guide/ngmodule-faq#q-browser-vs-common-module\">BrowserModule</a> only in the root <code>AppModule</code>.</p>\n\n<p><a id=\"q-browser-vs-common-module\"></a></p>\n<h2 id=\"should-i-import-browsermodule-or-commonmodule\" translation-result=\"on\">我應該匯入 <em>BrowserModule</em> 還是 <em>CommonModule</em>？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/platform-browser/BrowserModule\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Should I import <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> or <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-import-browsermodule-or-commonmodule\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">幾乎所有要在瀏覽器中使用的應用的<strong>根模組</strong>（<code>AppModule</code>）都應該從 <code>@angular/platform-browser</code> 中匯入 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>。</p><p translation-origin=\"off\">The root application module, <code>AppModule</code>, of almost every browser application should import <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> from <code>@angular/platform-browser</code>.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 提供了啟動和執行瀏覽器應用的那些基本的服務提供者。</p><p translation-origin=\"off\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> provides services that are essential to launch and run a browser application.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 還從 <code>@angular/common</code> 中重新匯出了 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>，這意味著 <code>AppModule</code> 中的元件也同樣可以存取那些每個應用都需要的 Angular 指令，如 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 和 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>。</p><p translation-origin=\"off\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> also re-exports <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> from <code>@angular/common</code>,\nwhich means that components in the <code>AppModule</code> also have access to\nthe Angular directives every application needs, such as <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> and <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>.</p>\n\n<p translation-result=\"on\">在其它任何模組中都<em>不要匯入</em><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>。<em>特性模組</em>和<em>延遲載入模組</em>應該改成匯入 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>。它們需要通用的指令。它們不需要重新初始化全應用級的提供者。</p><p translation-origin=\"off\">Do not import <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> in any other module.\n<em>Feature modules</em> and <em>lazy-loaded modules</em> should import <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> instead.\nThey need the common directives.\nThey don't need to re-install the app-wide providers.</p>\n\n<p translation-result=\"on\">特性模組中匯入 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> 可以讓它能用在任何目標平臺上，不僅是瀏覽器。那些跨平臺庫的作者應該喜歡這種方式的。</p><p translation-origin=\"off\">Importing <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> also frees feature modules for use on <em>any</em> target platform, not just browsers.</p>\n\n<p><a id=\"q-reimport\"></a></p>\n<h2 id=\"what-if-i-import-the-same-module-twice\" translation-result=\"on\">如果我兩次匯入同一個模組會怎麼樣？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-if-i-import-the-same-module-twice\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What if I import the same module twice?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-if-i-import-the-same-module-twice\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">沒有任何問題。當三個模組全都匯入模組'A'時，Angular 只會首次遇到時載入一次模組'A'，之後就不會這麼做了。</p><p translation-origin=\"off\">That's not a problem.\nWhen three modules all import Module 'A', Angular evaluates Module 'A' once, the first time it encounters it, and doesn't do so again.</p>\n\n<p translation-result=\"on\">無論 <code>A</code> 出現在所匯入模組的哪個層級，都會如此。如果模組'B'匯入模組'A'、模組'C'匯入模組'B'，模組'D'匯入 <code>[C, B, A]</code>，那麼'D'會觸發模組'C'的載入，'C'會觸發'B'的載入，而'B'會載入'A'。當 Angular 在'D'中想要獲取'B'和'A'時，這兩個模組已經被快取過了，可以立即使用。</p><p translation-origin=\"off\">That's true at whatever level <code>A</code> appears in a hierarchy of imported NgModules.\nWhen Module 'B' imports Module 'A', Module 'C' imports 'B', and Module 'D' imports <code>[C, B, A]</code>, then 'D' triggers the evaluation of 'C', which triggers the evaluation of 'B', which evaluates 'A'.\nWhen Angular gets to the 'B' and 'A' in 'D', they're already cached and ready to go.</p>\n\n<p translation-result=\"on\">Angular 不允許模組之間出現迴圈依賴，所以不要讓模組'A'匯入模組'B'，而模組'B'又匯入模組'A'。</p><p translation-origin=\"off\">Angular doesn't like NgModules with circular references, so don't let Module 'A' import Module 'B', which imports Module 'A'.</p>\n\n<p><a id=\"q-reexport\"></a></p>\n<h2 id=\"what-should-i-export\" translation-result=\"on\">我應該匯出什麼？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-export\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What should I export?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-export\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">匯出那些<em>其它模組</em>希望在自己的範本中參考的<a href=\"guide/bootstrapping#the-declarations-array\">可宣告類</a>。這些也是你的<em>公共</em>類別。如果你不匯出某個類，它就是<em>私有的</em>，只對當前模組中宣告的其它元件可見。</p><p translation-origin=\"off\">Export <a href=\"guide/bootstrapping#the-declarations-array\">declarable</a> classes that components in <em>other</em> NgModules are able to reference in their templates.\nThese are your <em>public</em> classes.\nIf you don't export a declarable class, it stays <em>private</em>, visible only to other components declared in this NgModule.</p>\n\n<p translation-result=\"on\">你<em>可以</em>匯出任何可宣告類（元件、指令和管道），而不用管它是宣告在當前模組中還是某個匯入的模組中。</p><p translation-origin=\"off\">You <em>can</em> export any declarable class —components, directives, and pipes— whether\nit's declared in this NgModule or in an imported NgModule.</p>\n\n<p translation-result=\"on\">你<em>可以</em>重新匯出整個匯入過的模組，這將導致重新匯出它們匯出的所有類別。重新匯出的模組甚至不用先匯入。</p><p translation-origin=\"off\">You <em>can</em> re-export entire imported NgModules, which effectively re-export all of their exported classes.\nAn NgModule can even export a module that it doesn't import.</p>\n\n<h2 id=\"what-should-i-not-export\" translation-result=\"on\">我<em>不應該</em>匯出什麼？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-not-export\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What should I <em>not</em> export?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-not-export\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><em>不要</em>匯出：</p><p translation-origin=\"off\">Don't export the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">那些你只想在當前模組中宣告的那些元件中使用的私有元件、指令和管道。如果你不希望任何模組看到它，就不要匯出。</p><p translation-origin=\"off\">Private components, directives, and pipes that you need only within components declared in this NgModule.\nIf you don't want another NgModule to see it, don't export it.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">不可宣告的物件，比如服務、函式、配置、實體模型等。</p><p translation-origin=\"off\">Non-declarable objects such as services, functions, configurations, and entity models.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">那些只被路由器或引導函式動態載入的元件。比如那些從來不會在其它元件的範本中出現的元件。匯出它們沒有壞處，但也沒有好處。</p><p translation-origin=\"off\">Components that are only loaded dynamically by the router or by bootstrapping.\nSuch components can never be selected in another component's template.\nWhile there's no harm in exporting them, there's also no benefit.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">純服務模組沒有公開（匯出）的宣告。比如，沒必要重新匯出 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，因為它不匯出任何東西。它唯一的用途是一起把 http 的那些服務提供者新增到應用中。</p><p translation-origin=\"off\">Pure service modules that don't have public (exported) declarations.\nFor example, there's no point in re-exporting <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> because it doesn't export anything.\nIts only purpose is to add http service providers to the application as a whole.</p>\n\n</li>\n</ul>\n<h2 id=\"can-i-re-export-classes-and-modules\" translation-result=\"on\">我可以重新匯出類和模組嗎？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#can-i-re-export-classes-and-modules\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Can I re-export classes and modules?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#can-i-re-export-classes-and-modules\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">毫無疑問。</p><p translation-origin=\"off\">Absolutely.</p>\n\n<p translation-result=\"on\">模組是從其它模組中選取類並把它們重新匯出成統一、便利的新模組的最佳方式。</p><p translation-origin=\"off\">NgModules are a great way to selectively aggregate classes from other NgModules and re-export them in a consolidated, convenience module.</p>\n\n<p translation-result=\"on\">模組可以重新匯出其它模組，這會導致重新匯出它們匯出的所有類別。Angular 自己的 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 就重新匯出了一組模組，比如：</p><p translation-origin=\"off\">An NgModule can re-export entire NgModules, which effectively re-exports all of their exported classes.\nAngular's own <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> exports a couple of NgModules like this:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nexports: [<a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/core/ApplicationModule\" class=\"code-anchor\">ApplicationModule</a>]\n\n</code-example>\n<p translation-result=\"on\">模組還能匯出一個組合，它可以包含自己的宣告、某些匯入的類以及匯入的模組。</p><p translation-origin=\"off\">An NgModule can export a combination of its own declarations, selected imported classes, and imported NgModules.</p>\n\n<p translation-result=\"on\">不要費心去匯出純服務類別。純服務類別的模組不會匯出任何可供其它模組使用的<a href=\"guide/bootstrapping#the-declarations-array\">可宣告類</a>。比如，不用重新匯出 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，因為它沒有匯出任何東西。它唯一的用途是把那些 http 服務提供者一起新增到應用中。</p><p translation-origin=\"off\">Don't bother re-exporting pure service modules.\nPure service modules don't export <a href=\"guide/bootstrapping#the-declarations-array\">declarable</a> classes that another NgModule could use.\nFor example, there's no point in re-exporting <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> because it doesn't export anything.\nIts only purpose is to add http service providers to the application as a whole.</p>\n\n<h2 id=\"what-is-the-forroot-method\" translation-result=\"on\"><code>forRoot()</code> 方法是什麼？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-the-forroot-method\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What is the <code>forRoot()</code> method?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-the-forroot-method\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">靜態方法 <code>forRoot()</code> 是一個約定，它可以讓開發人員更輕鬆的配置模組的想要單例使用的服務及其提供者。<code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 就是一個很好的例子。</p><p translation-origin=\"off\">The <code>forRoot()</code> static method is a convention that makes it easy for developers to configure services and providers that are intended to be singletons.\nA good example of <code>forRoot()</code> is the <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> method.</p>\n\n<p translation-result=\"on\">應用把一個 <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 物件傳給 <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code>，為的就是使用路由配置全應用級的 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 服務。<code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 返回一個<a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>物件。你把這個結果新增到根模組 <code>AppModule</code> 的 <code>imports</code> 列表中。</p><p translation-origin=\"off\">Applications pass a <code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> array to <code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> in order to configure the app-wide <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> service with routes.\n<code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> returns a <a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>.\nYou add that result to the <code>imports</code> list of the root <code>AppModule</code>.</p>\n\n<p translation-result=\"on\">只能在應用的根模組 <code>AppModule</code> 中呼叫並匯入 <code>forRoot()</code> 的結果。在其它模組，特別是延遲載入模組中，不要匯入它。要了解關於 <code>forRoot()</code> 的更多資訊，參閱<a href=\"guide/singleton-services\">單例服務</a>一章的 <a href=\"guide/singleton-services#the-forroot-pattern\">the <code>forRoot()</code> 模式</a>部分。</p><p translation-origin=\"off\">Only call and import a <code>forRoot()</code> result in the root application module, <code>AppModule</code>.\nAvoid importing it in any other module, particularly in a lazy-loaded module.\nFor more information on <code>forRoot()</code> see <a href=\"guide/singleton-services#the-forroot-pattern\">the <code>forRoot()</code> pattern</a> section of the <a href=\"guide/singleton-services\">Singleton Services</a> guide.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意：</strong><br>\n<code>forRoot()</code> 匯入可以用於除 <code>AppModule</code> 之外的模組中。最重要的是，<code>forRoot()</code> 只應該被呼叫一次，而且匯入 <code>forRoot()</code> 的模組應該可以在根 <code>ModuleInjector</code> 中可用。\n欲知詳情，參見<a href=\"guide/hierarchical-dependency-injection#moduleinjector\">多級注入器</a>指南。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThe <code>forRoot()</code> import can be used in a module other than <code>AppModule</code>.\nImportantly, <code>forRoot()</code> should only be called once, and the module that imports the <code>forRoot()</code> needs to be available to the root <code>ModuleInjector</code>.\nFor more information, refer to the guide on <a href=\"guide/hierarchical-dependency-injection#moduleinjector\">Hierarchical injectors</a>.</p>\n\n</div>\n<p translation-result=\"on\">對於服務來說，除了可以使用 <code>forRoot()</code> 外，更好的方式是在該服務的 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 裝飾器中指定 <code>providedIn: 'root'</code>，它讓該服務自動在全應用級可用，這樣它也就預設是單例的。</p><p translation-origin=\"off\">For a service, instead of using <code>forRoot()</code>,  specify <code>providedIn: 'root'</code> on the service's <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator, which makes the service automatically available to the whole application and thus singleton by default.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 也提供了靜態方法 <code>forChild()</code>，用於配置延遲載入模組的路由。</p><p translation-origin=\"off\"><code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> also offers a <code>forChild()</code> static method for configuring the routes of lazy-loaded modules.</p>\n\n<p translation-result=\"on\"><code>forRoot()</code> 和 <code>forChild()</code> 都是約定俗成的方法名，它們分別用於在根模組和特性模組中配置服務。</p><p translation-origin=\"off\"><code>forRoot()</code> and <code>forChild()</code> are conventional names for methods that configure services in root and feature modules respectively.</p>\n\n<p translation-result=\"on\">當你寫類似的需要可配置的服務提供者時，請遵循這個約定。</p><p translation-origin=\"off\">Follow this convention when you write similar modules with configurable service providers.</p>\n\n<h2 id=\"why-is-a-service-provided-in-a-feature-module-visible-everywhere\" translation-result=\"on\">為什麼服務提供者在特性模組中的任何地方都是可見的？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-a-service-provided-in-a-feature-module-visible-everywhere\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Why is a service provided in a feature module visible everywhere?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-a-service-provided-in-a-feature-module-visible-everywhere\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">列在引導模組的 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 中的服務提供者具有<strong>全應用級作用域</strong>。往 <code><a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 中新增服務提供者將導致該服務被髮布到整個應用中。</p><p translation-origin=\"off\">Providers listed in the <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> of a bootstrapped module have application scope.\nAdding a service provider to <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> effectively publishes the service to the entire application.</p>\n\n<p translation-result=\"on\">當你匯入一個模組時，Angular 就會把該模組的服務提供者（也就是它的 <code>providers</code> 列表中的內容）加入該應用的<em>根注入器</em>中。</p><p translation-origin=\"off\">When you import an NgModule,\nAngular adds the module's service providers (the contents of its <code>providers</code> list) to the application root injector.</p>\n\n<p translation-result=\"on\">這會讓該提供者對應用中所有知道該提供者令牌（token）的類都可見。</p><p translation-origin=\"off\">This makes the provider visible to every class in the application that knows the provider's lookup token, or name.</p>\n\n<p translation-result=\"on\">透過 NgModule 匯入來實現可擴充性是 NgModule 體系的主要設計目標。把 NgModule 的提供者併入應用程式的注入器可以讓庫模組使用新的服務來強化應用程式變得更容易。只要新增一次 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，那麼應用中的每個元件就都可以發起 Http 請求了。</p><p translation-origin=\"off\">Extensibility through NgModule imports is a primary goal of the NgModule system.\nMerging NgModule providers into the application injector makes it easy for a module library to enrich the entire application with new services.\nBy adding the <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> once, every application component can make HTTP requests.</p>\n\n<p translation-result=\"on\">不過，如果你期望模組的服務只對那個特性模組內部宣告的元件可見，那麼這可能會帶來一些不受歡迎的意外。如果 <code>HeroModule</code> 提供了一個 <code>HeroService</code>，並且根模組 <code>AppModule</code> 匯入了 <code>HeroModule</code>，那麼任何知道 <code>HeroService</code><em>型別</em>的類都可能注入該服務，而不僅是在 <code>HeroModule</code> 中宣告的那些類別。</p><p translation-origin=\"off\">However, this might feel like an unwelcome surprise if you expect the module's services to be visible only to the components declared by that feature module.\nIf the <code>HeroModule</code> provides the <code>HeroService</code> and the root <code>AppModule</code> imports <code>HeroModule</code>, any class that knows the <code>HeroService</code> <em>type</em> can inject that service, not just the classes declared in the <code>HeroModule</code>.</p>\n\n<p translation-result=\"on\">要限制對某個服務的存取，可以考慮延遲載入提供該服務的 NgModule。參閱<a href=\"guide/ngmodule-faq#service-scope\">我要如何把服務的範圍限定為某個模組？</a>。</p><p translation-origin=\"off\">To limit access to a service, consider lazy loading the NgModule that provides that service.\nSee <a href=\"guide/ngmodule-faq#service-scope\">How do I restrict service scope to a module?</a> for more information.</p>\n\n<p><a id=\"q-lazy-loaded-module-provider-visibility\"></a></p>\n<h2 id=\"why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\" translation-result=\"on\">為什麼在延遲載入模組中宣告的服務提供者只對該模組自身可見？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Why is a service provided in a lazy-loaded module visible only to that module?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">和啟動時就載入的模組中的提供者不同，延遲載入模組中的提供者是<em>侷限於模組</em>的。</p><p translation-origin=\"off\">Unlike providers of the modules loaded at launch, providers of lazy-loaded modules are <em>module-scoped</em>.</p>\n\n<p translation-result=\"on\">當 Angular 路由器延遲載入一個模組時，它建立了一個新的執行環境。那個環境<a href=\"guide/ngmodule-faq#q-why-child-injector\" title=\"為什麼 Angular 會建立子注入器\">擁有自己的注入器</a>，它是應用注入器的直屬子級。</p><p translation-origin=\"off\">When the Angular router lazy-loads a module, it creates a new execution context.\nThat <a href=\"guide/ngmodule-faq#q-why-child-injector\" title=\"Why Angular creates a child injector\">context has its own injector</a>, which is a direct child of the application injector.</p>\n\n<p translation-result=\"on\">路由器把該延遲載入模組的提供者和它匯入的模組的提供者新增到這個子注入器中。</p><p translation-origin=\"off\">The router adds the lazy module's providers and the providers of its imported NgModules to this child injector.</p>\n\n<p translation-result=\"on\">這些提供者不會被擁有相同令牌的應用級別提供者的變化所影響。當路由器在延遲載入環境中建立元件時，Angular 優先使用延遲載入模組中的服務例項，而不是來自應用的根注入器的。</p><p translation-origin=\"off\">These providers are insulated from changes to application providers with the same lookup token.\nWhen the router creates a component within the lazy-loaded context,\nAngular prefers service instances created from these providers to the service instances of the application root injector.</p>\n\n<h2 id=\"what-if-two-modules-provide-the-same-service\" translation-result=\"on\">如果兩個模組提供了<em>同一個</em>服務會怎麼樣？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-if-two-modules-provide-the-same-service\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What if two modules provide the same service?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-if-two-modules-provide-the-same-service\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">當同時載入了兩個匯入的模組，它們都列出了使用同一個令牌的提供者時，後匯入的模組會“獲勝”，這是因為這兩個提供者都被新增到了同一個注入器中。</p><p translation-origin=\"off\">When two imported modules, loaded at the same time, list a provider with the same token, the second module's provider \"wins\".\nThat's because both providers are added to the same injector.</p>\n\n<p translation-result=\"on\">當 Angular 嘗試根據令牌注入服務時，它使用第二個提供者來建立並交付服務例項。</p><p translation-origin=\"off\">When Angular looks to inject a service for that token, it creates and delivers the instance created by the second provider.</p>\n\n<p translation-result=\"on\"><em>每個</em>注入了該服務的類獲得的都是由第二個提供者建立的例項。即使是宣告在第一個模組中的類，它取得的例項也是來自第二個提供者的。</p><p translation-origin=\"off\"><em>Every</em> class that injects this service gets the instance created by the second provider.\nEven classes declared within the first module get the instance created by the second provider.</p>\n\n<p translation-result=\"on\">如果模組 A 提供了一個使用令牌'X'的服務，並且匯入的模組 B 也用令牌'X'提供了一個服務，那麼模組 A 中定義的服務“獲勝”了。</p><p translation-origin=\"off\">If NgModule A provides a service for token 'X' and imports an NgModule B that also provides a service for token 'X', then NgModule A's service definition \"wins\".</p>\n\n<p translation-result=\"on\">由根 <code>AppModule</code> 提供的服務相對於所匯入模組中提供的服務有優先權。換句話說：<code>AppModule</code> 總會獲勝。</p><p translation-origin=\"off\">The service provided by the root <code>AppModule</code> takes precedence over services provided by imported NgModules.\nThe <code>AppModule</code> always wins.</p>\n\n<p><a id=\"service-scope\"></a></p>\n<h2 id=\"how-do-i-restrict-service-scope-to-a-module\" translation-result=\"on\">我應該如何把服務的範圍限制到模組中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-do-i-restrict-service-scope-to-a-module\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">How do I restrict service scope to a module?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-do-i-restrict-service-scope-to-a-module\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果一個模組在應用程式啟動時就載入，它的 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 具有<strong><em>全應用級作用域</em></strong>。它們也可用於整個應用的注入中。</p><p translation-origin=\"off\">When a module is loaded at application launch, its <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> have <em>application-wide scope</em>; that is, they are available for injection throughout the application.</p>\n\n<p translation-result=\"on\">匯入的提供者很容易被由其它匯入模組中的提供者替換掉。這雖然是故意這樣設計的，但是也可能引起意料之外的結果。</p><p translation-origin=\"off\">Imported providers are easily replaced by providers from another imported NgModule.\nSuch replacement might be by design.\nIt could be unintentional and have adverse consequences.</p>\n\n<p translation-result=\"on\">作為一個通用的規則，應該<em>只匯入一次</em>帶提供者的模組，最好在應用的<em>根模組</em>中。那裡也是配置、包裝和改寫這些服務的最佳位置。</p><p translation-origin=\"off\">As a general rule, import modules with providers <em>exactly once</em>, preferably in the application's <em>root module</em>.\nThat's also usually the best place to configure, wrap, and override them.</p>\n\n<p translation-result=\"on\">假設模組需要一個客製過的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>，它為所有的 Http 請求新增一個特別的請求頭。如果應用中其它地方的另一個模組也客製了 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 或僅僅匯入了 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，它就會改寫當前模組的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 提供者，丟掉了這個特別的請求頭。這樣伺服器就會拒絕來自該模組的請求。</p><p translation-origin=\"off\">Suppose a module requires a customized <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> that adds a special header for all Http requests.\nIf another module elsewhere in the application also customizes <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> or merely imports the <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>, it could override this module's <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> provider, losing the special header.\nThe server will reject http requests from this module.</p>\n\n<p translation-result=\"on\">要消除這個問題，就只能在應用的根模組 <code>AppModule</code> 中匯入 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>。</p><p translation-origin=\"off\">To avoid this problem, import the <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> only in the <code>AppModule</code>, the application <em>root module</em>.</p>\n\n<p translation-result=\"on\">如果你必須防範這種“提供者腐化”現象，那就<em>不要依賴於“啟動時載入”模組的 <code>providers</code></em>。</p><p translation-origin=\"off\">If you must guard against this kind of \"provider corruption\", <em>don't rely on a launch-time module's <code>providers</code></em>.</p>\n\n<p translation-result=\"on\">只要可能，就讓模組延遲載入。Angular 給了<a href=\"guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\">延遲載入模組</a>自己的子注入器。該模組中的提供者只對由該注入器建立的元件樹可見。</p><p translation-origin=\"off\">Load the module lazily if you can.\nAngular gives a <a href=\"guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\">lazy-loaded module</a> its own child injector.\nThe module's providers are visible only within the component tree created with this injector.</p>\n\n<p translation-result=\"on\">如果你必須在應用程式啟動時主動載入該模組，<strong><em>就改成在元件中提供該服務</em></strong>。</p><p translation-origin=\"off\">If you must load the module eagerly, when the application starts, <em>provide the service in a component instead.</em></p>\n\n<p translation-result=\"on\">繼續看這個例子，假設某個模組的元件真的需要一個私有的、自訂的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>。</p><p translation-origin=\"off\">Continuing with the same example, suppose the components of a module truly require a private, custom <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>.</p>\n\n<p translation-result=\"on\">那就建立一個“最上層元件”來扮演該模組中所有元件的根。把這個自訂的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 提供者新增到這個最上層元件的 <code>providers</code> 列表中，而不是該模組的 <code>providers</code> 中。回憶一下，Angular 會為每個元件例項建立一個子注入器，並使用元件自己的 <code>providers</code> 來配置這個注入器。</p><p translation-origin=\"off\">Create a \"top component\" that acts as the root for all of the module's components.\nAdd the custom <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> provider to the top component's <code>providers</code> list rather than the module's <code>providers</code>.\nRecall that Angular creates a child injector for each component instance and populates the injector with the component's own providers.</p>\n\n<p translation-result=\"on\">當該元件的子元件<em>想要</em>一個 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 服務時，Angular 會提供一個區域性的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 服務，而不是應用的根注入器建立的那個。子元件將正確發起 http 請求，而不管其它模組對 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 做了什麼。</p><p translation-origin=\"off\">When a child of this component asks for the <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> service,\nAngular provides the local <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> service, not the version provided in the application root injector.\nChild components make proper HTTP requests no matter what other modules do to <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>.</p>\n\n<p translation-result=\"on\">確保把模組中的元件都建立成這個最上層元件的子元件。</p><p translation-origin=\"off\">Be sure to create module components as children of this module's top component.</p>\n\n<p translation-result=\"on\">你可以把這些子元件都嵌在最上層元件的範本中。或者，給最上層元件一個 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>，讓它作為路由的宿主。定義子路由，並讓路由器把模組中的元件載入進該路由出口（outlet）中。</p><p translation-origin=\"off\">You can embed the child components in the top component's template.\nAlternatively, make the top component a routing host by giving it a <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>.\nDefine child routes and let the router load module components into that outlet.</p>\n\n<p translation-result=\"on\">雖然透過在延遲載入模組中或元件中提供某個服務來限制它的存取都是可行的方式，但在元件中提供服務可能導致這些服務出現多個例項。因此，應該優先使用延遲載入的方式。</p><p translation-origin=\"off\">Though you can limit access to a service by providing it in a lazy loaded module or providing it in a component, providing services in a component can lead to multiple instances of those services.\nThus, the lazy loading is preferable.</p>\n\n<p><a id=\"q-root-component-or-module\"></a></p>\n<h2 id=\"should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\" translation-result=\"on\">我應該把全應用級提供者新增到根模組 <code>AppModule</code> 中還是根元件 <code>AppComponent</code> 中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Should I add application-wide providers to the root <code>AppModule</code> or the root <code>AppComponent</code>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">透過在服務的 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 裝飾器中（比如服務）指定 <code>providedIn: 'root'</code> 來定義全應用級提供者，或者 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 的構造器（比如提供令牌的地方），都可以定義全應用級提供者。透過這種方式建立的服務提供者會自動在整個應用中可用，而不用把它列在任何模組中。</p><p translation-origin=\"off\">Define application-wide providers by specifying <code>providedIn: 'root'</code> on its <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator (in the case of services) or at <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> construction (in the case where tokens are provided).\nProviders that are created this way automatically are made available to the entire application and don't need to be listed in any module.</p>\n\n<p translation-result=\"on\">如果某個提供者不能用這種方式配置（可能因為它沒有有意義的預設值），那就在根模組 <code>AppModule</code> 中註冊這些全應用級服務，而不是在 <code>AppComponent</code> 中。</p><p translation-origin=\"off\">If a provider cannot be configured in this way (perhaps because it has no sensible default value), then register application-wide providers in the root <code>AppModule</code>, not in the <code>AppComponent</code>.</p>\n\n<p translation-result=\"on\">延遲載入模組及其元件可以注入 <code>AppModule</code> 中的服務，卻不能注入 <code>AppComponent</code> 中的。</p><p translation-origin=\"off\">Lazy-loaded modules and their components can inject <code>AppModule</code> services; they can't inject <code>AppComponent</code> services.</p>\n\n<p translation-result=\"on\"><em>只有</em>當該服務必須對 <code>AppComponent</code> 元件樹之外的元件不可見時，才應該把服務註冊進 <code>AppComponent</code> 的 <code>providers</code> 中。這是一個非常罕見的例外用法。</p><p translation-origin=\"off\">Register a service in <code>AppComponent</code> providers <em>only</em> if the service must be hidden\nfrom components outside the <code>AppComponent</code> tree.\nThis is a rare use case.</p>\n\n<p translation-result=\"on\">更一般地說，<a href=\"guide/ngmodule-faq#q-component-or-module\">優先把提供者註冊進模組中</a>，而不是元件中。</p><p translation-origin=\"off\">More generally, <a href=\"guide/ngmodule-faq#q-component-or-module\">prefer registering providers in NgModules</a> to registering in components.</p>\n\n<h3 id=\"discussion\" translation-result=\"on\">討論<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#discussion\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Discussion<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#discussion\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 把所有啟動期模組的提供者都註冊進了應用的根注入器中。這些服務是由根注入器中的提供者建立的，並且在整個應用中都可用。它們具有<em>應用級作用域</em>。</p><p translation-origin=\"off\">Angular registers all startup module providers with the application root injector.\nThe services that root injector providers create have application scope, which means they are available to the entire application.</p>\n\n<p translation-result=\"on\">某些服務（比如 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>）只有當註冊進應用的根注入器時才能正常工作。</p><p translation-origin=\"off\">Certain services, such as the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>, only work when you register them in the application root injector.</p>\n\n<p translation-result=\"on\">相反，Angular 使用 <code>AppComponent</code> 自己的注入器註冊了 <code>AppComponent</code> 的提供者。<code>AppComponent</code> 服務只在該元件及其子元件樹中才能使用。它們具有<em>元件級作用域</em>。</p><p translation-origin=\"off\">By contrast, Angular registers <code>AppComponent</code> providers with the <code>AppComponent</code>'s own injector.\n<code>AppComponent</code> services are available only to that component and its component tree.\nThey have component scope.</p>\n\n<p translation-result=\"on\"><code>AppComponent</code> 的注入器是根注入器的<em>子級</em>，注入器層次中的下一級。這對於沒有路由器的應用來說<em>幾乎是</em>整個應用了。但對那些帶路由的應用，路由操作位於最上層，那裡不存在 <code>AppComponent</code> 服務。這意味著延遲載入模組不能使用它們。</p><p translation-origin=\"off\">The <code>AppComponent</code>'s injector is a child of the root injector, one down in the injector hierarchy.\nFor applications that don't use the router, that's almost the entire application.\nBut in routed applications, routing operates at the root level where <code>AppComponent</code> services don't exist.\nThis means that lazy-loaded modules can't reach them.</p>\n\n<p><a id=\"q-component-or-module\"></a></p>\n<h2 id=\"should-i-add-other-providers-to-a-module-or-a-component\" translation-result=\"on\">我應該把其它提供者註冊到模組中還是元件中？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-add-other-providers-to-a-module-or-a-component\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Should I add other providers to a module or a component?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-add-other-providers-to-a-module-or-a-component\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">提供者應該使用 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 語法進行配置。只要可能，就應該把它們在應用的根注入器中提供（<code>providedIn: 'root'</code>）。如果它們只被延遲載入的上下文中使用，那麼這種方式配置的服務就是延遲載入的。</p><p translation-origin=\"off\">Providers should be configured using <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> syntax.\nIf possible, they should be provided in the application root (<code>providedIn: 'root'</code>).\nServices that are configured this way are lazily loaded if they are only used from a lazily loaded context.</p>\n\n<p translation-result=\"on\">如果要由消費方來決定是否把它作為全應用級提供者，那麼就要在模組中（<code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>）註冊提供者，而不是元件中（<code>@Component.providers</code>）。</p><p translation-origin=\"off\">If it's the consumer's decision whether a provider is available application-wide or not, then register providers in modules (<code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>) instead of registering in components (<code>@Component.providers</code>).</p>\n\n<p translation-result=\"on\">當你<em>必須</em>把服務例項的範圍限制到某個元件及其子元件樹時，就把提供者註冊到該元件中。指令的提供者也同樣照此處理。</p><p translation-origin=\"off\">Register a provider with a component when you <em>must</em> limit the scope of a service instance to that component and its component tree.\nApply the same reasoning to registering a provider with a directive.</p>\n\n<p translation-result=\"on\">比如，如果英雄編輯元件需要自己私有的快取英雄服務例項，那就應該在本元件中註冊此服務。這樣，本元件的每個新例項都會得到一份自己的快取服務例項。編輯器的改動只會作用於它自己的服務，而不會影響到應用中其它地方的英雄例項。</p><p translation-origin=\"off\">For example, an editing component that needs a private copy of a caching service should register the service with the component.\nThen each new instance of the component gets its own cached service instance.\nThe changes that editor makes in its service don't touch the instances elsewhere in the application.</p>\n\n<p translation-result=\"on\"><a href=\"guide/ngmodule-faq#q-root-component-or-module\">總是在根模組 <code>AppModule</code> 中註冊<em>全應用級</em>服務</a>，而不要在根元件 <code>AppComponent</code> 中。</p><p translation-origin=\"off\"><a href=\"guide/ngmodule-faq#q-root-component-or-module\">Always register <em>application-wide</em> services with the root <code>AppModule</code></a>, not the root <code>AppComponent</code>.</p>\n\n<p><a id=\"q-why-bad\"></a></p>\n<h2 id=\"why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\" translation-result=\"on\">為什麼在共享模組中為延遲載入模組提供服務是個餿主意？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Why is it bad if a shared module provides a service to a lazy-loaded module?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"the-eagerly-loaded-scenario\" translation-result=\"on\">急性載入的場景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#the-eagerly-loaded-scenario\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">The eagerly loaded scenario<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#the-eagerly-loaded-scenario\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當急性載入的模組提供了服務時，比如 <code>UserService</code>，該服務是在全應用級可用的。如果根模組提供了 <code>UserService</code>，並匯入了另一個也提供了同一個 <code>UserService</code> 的模組，Angular 就會把它們中的一個註冊進應用的根注入器中（參閱<a href=\"guide/ngmodule-faq#q-reimport\">如果兩次匯入了同一個模組會怎樣？</a>）。</p><p translation-origin=\"off\">When an eagerly loaded module provides a service, for example a <code>UserService</code>, that service is available application-wide.\nIf the root module provides <code>UserService</code> and imports another module that provides the same <code>UserService</code>, Angular registers one of them in the root application injector (see <a href=\"guide/ngmodule-faq#q-reimport\">What if I import the same module twice?</a>).</p>\n\n<p translation-result=\"on\">然後，當某些元件注入 <code>UserService</code> 時，Angular 就會發現它已經在應用的根注入器中了，並交付這個全應用級的單例服務。這樣不會出現問題。</p><p translation-origin=\"off\">Then, when some component injects <code>UserService</code>, Angular finds it in the application root injector, and delivers the app-wide singleton service.\nNo problem.</p>\n\n<h3 id=\"the-lazy-loaded-scenario\" translation-result=\"on\">延遲載入場景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#the-lazy-loaded-scenario\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">The lazy loaded scenario<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#the-lazy-loaded-scenario\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">現在，考慮一個延遲載入的模組，它也提供了一個名叫 <code>UserService</code> 的服務。</p><p translation-origin=\"off\">Now consider a lazy loaded module that also provides a service called <code>UserService</code>.</p>\n\n<p translation-result=\"on\">當路由器準備延遲載入某個模組的時候，它會建立一個子注入器，並且把 <code>UserService</code> 的提供者註冊到那個子注入器中。子注入器和根注入器是<em>不同</em>的。</p><p translation-origin=\"off\">When the router lazy loads a module, it creates a child injector and registers the <code>UserService</code> provider with that child injector.\nThe child injector is <em>not</em> the root injector.</p>\n\n<p translation-result=\"on\">當 Angular 建立一個延遲載入的元件並注入 <code>UserService</code> 時。這次，它會從此延遲載入模組的<em>子注入器</em>中查詢 <code>UserService</code> 的提供者，並用它建立一個 <code>UserService</code> 的新例項。這個 <code>UserService</code> 例項與 Angular 在急性載入的元件中注入的那個全應用級單例物件截然不同。</p><p translation-origin=\"off\">When Angular creates a lazy component for that module and injects <code>UserService</code>, it finds a <code>UserService</code> provider in the lazy module's <em>child injector</em>\nand creates a <em>new</em> instance of the <code>UserService</code>.\nThis is an entirely different <code>UserService</code> instance than the app-wide singleton version that Angular injected in one of the eagerly loaded components.</p>\n\n<p translation-result=\"on\">這個場景導致你的應用每次都建立一個新的服務例項，而不是使用單例的服務。</p><p translation-origin=\"off\">This scenario causes your application to create a new instance every time, instead of using the singleton.</p>\n\n<!--todo: KW--What does this cause? I wasn't able to get the suggestion of this to work from\nthe current FAQ:\nTo demonstrate, run the <live-example name=\"ngmodule\">live example</live-example>.\nModify the `SharedModule` so that it provides the `UserService` rather than the `CoreModule`.\nThen toggle between the \"Contact\" and \"Heroes\" links a few times.\nThe username goes bonkers as the Angular creates a new `UserService` instance each time.\nI'd like to see the error so I can include it.-->\n<p><a id=\"q-why-child-injector\"></a></p>\n<h2 id=\"why-does-lazy-loading-create-a-child-injector\" translation-result=\"on\">為什麼延遲載入模組會建立一個子注入器？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-does-lazy-loading-create-a-child-injector\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Why does lazy loading create a child injector?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-does-lazy-loading-create-a-child-injector\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 會把 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 中的提供者新增到應用的根注入器中…… 除非該模組是延遲載入的，這種情況下，Angular 會建立一<em>子注入器</em>，並且把該模組的提供者新增到這個子注入器中。</p><p translation-origin=\"off\">Angular adds <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> to the application root injector, unless the NgModule is lazy-loaded.\nFor a lazy-loaded NgModule, Angular creates a <em>child injector</em> and adds the module's providers to the child injector.</p>\n\n<p translation-result=\"on\">這意味著模組的行為將取決於它是在應用啟動期間載入的還是後來延遲載入的。如果疏忽了這一點，可能導致<a href=\"guide/ngmodule-faq#q-why-bad\">嚴重後果</a>。</p><p translation-origin=\"off\">This means that an NgModule behaves differently depending on whether it's loaded during application start or lazy-loaded later.\nNeglecting that difference can lead to <a href=\"guide/ngmodule-faq#q-why-bad\">adverse consequences</a>.</p>\n\n<p translation-result=\"on\">為什麼 Angular 不能像主動載入模組那樣把延遲載入模組的提供者也新增到應用程式的根注入器中呢？為什麼會出現這種不一致？</p><p translation-origin=\"off\">Why doesn't Angular add lazy-loaded providers to the application root injector as it does for eagerly loaded NgModules?</p>\n\n<p translation-result=\"on\">歸根結底，這來自於 Angular 依賴注入系統的一個基本特徵：在注入器還沒有被第一次使用之前，可以不斷為其新增提供者。一旦注入器已經建立和開始交付服務，它的提供者列表就被凍結了，不再接受新的提供者。</p><p translation-origin=\"off\">The answer is grounded in a fundamental characteristic of the Angular dependency-injection system.\nAn injector can add providers <em>until it's first used</em>.\nOnce an injector starts creating and delivering services, its provider list is frozen; no new providers are allowed.</p>\n\n<p translation-result=\"on\">當應用啟動時，Angular 會首先使用所有主動載入模組中的提供者來配置根注入器，這發生在它建立第一個元件以及注入任何服務之前。一旦應用開始工作，應用的根注入器就不再接受新的提供者了。</p><p translation-origin=\"off\">When an application starts, Angular first configures the root injector with the providers of all eagerly loaded NgModules <em>before</em> creating its first component and injecting any of the provided services.\nOnce the application begins, the application root injector is closed to new providers.</p>\n\n<p translation-result=\"on\">之後，應用邏輯開始延遲載入某個模組。Angular 必須把這個延遲載入模組中的提供者新增到<em>某個</em>注入器中。但是它無法將它們新增到應用的根注入器中，因為根注入器已經不再接受新的提供者了。於是，Angular 在延遲載入模組的上下文中建立了一個新的子注入器。</p><p translation-origin=\"off\">Time passes and application logic triggers lazy loading of an NgModule.\nAngular must add the lazy-loaded module's providers to an injector somewhere.\nIt can't add them to the application root injector because that injector is closed to new providers.\nSo Angular creates a new child injector for the lazy-loaded module context.</p>\n\n<p><a id=\"q-is-it-loaded\"></a></p>\n<h2 id=\"how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\" translation-result=\"on\">我要如何知道一個模組或服務是否已經載入過了？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">How can I tell if an NgModule or service was previously loaded?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">某些模組及其服務只能被根模組 <code>AppModule</code> 載入一次。在延遲載入模組中再次匯入這個模組會<a href=\"guide/ngmodule-faq#q-why-bad\">導致錯誤的行為</a>，這個錯誤可能非常難於檢測和診斷。</p><p translation-origin=\"off\">Some NgModules and their services should be loaded only once by the root <code>AppModule</code>.\nImporting the module a second time by lazy loading a module could <a href=\"guide/ngmodule-faq#q-why-bad\">produce errant behavior</a> that may be difficult to detect and diagnose.</p>\n\n<p translation-result=\"on\">為了防範這種風險，可以寫一個建構函式，它會嘗試從應用的根注入器中注入該模組或服務。如果這種注入成功了，那就說明這個類是被第二次載入的，你就可以丟擲一個錯誤，或者採取其它挽救措施。</p><p translation-origin=\"off\">To prevent this issue, write a constructor that attempts to inject the module or service from the root application injector.\nIf the injection succeeds, the class has been loaded a second time.\nYou can throw an error or take other remedial action.</p>\n\n<p translation-result=\"on\">某些 NgModule（比如 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>）就實現了那樣一個守衛。下面是一個名叫 <code>GreetingModule</code> 的 NgModule 的 自訂建構函式。</p><p translation-origin=\"off\">Certain NgModules, such as <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>, implement such a guard.\nHere is a custom constructor for an NgModule called <code>GreetingModule</code>.</p>\n\n<code-example header=\"src/app/greeting/greeting.module.ts (Constructor)\" path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"ctor\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule?: GreetingModule) {\n  if (parentModule) {\n    throw new Error(\n      'GreetingModule is already loaded. Import it in the AppModule only');\n  }\n}\n\n</code-example>\n<h2 id=\"what-kinds-of-modules-should-i-have-and-how-should-i-use-them\" translation-result=\"on\">有哪些型別的模組？我應該如何使用它們？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-kinds-of-modules-should-i-have-and-how-should-i-use-them\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What kinds of modules should I have and how should I use them?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-kinds-of-modules-should-i-have-and-how-should-i-use-them\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">每個應用都不一樣。根據不同程度的經驗，開發者會做出不同的選擇。下列建議和指導原則廣受歡迎。</p><p translation-origin=\"off\">Every application is different.\nDevelopers have various levels of experience and comfort with the available choices.\nSome suggestions and guidelines appear to have wide appeal.</p>\n\n<h3 id=\"sharedmodule\"><code>SharedModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#sharedmodule\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">為那些可能會在應用中到處使用的元件、指令和管道建立 <code>SharedModule</code>。這種模組應該只包含 <code>declarations</code>，並且應該匯出幾乎所有 <code>declarations</code> 裡面的宣告。</p><p translation-origin=\"off\"><code>SharedModule</code> is a conventional name for an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> with the components, directives, and pipes that you use everywhere in your application.\nThis module should consist entirely of <code>declarations</code>, most of them exported.</p>\n\n<p translation-result=\"on\"><code>SharedModule</code> 可以重新匯出其它小部件模組，比如 <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>、<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 和提供你廣泛使用的 UI 控制項的那些模組。</p><p translation-origin=\"off\">The <code>SharedModule</code> may re-export other widget modules, such as <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>, <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>, and NgModules with the UI controls that you use most widely.</p>\n\n<p translation-result=\"on\"><code>SharedModule</code><strong><em>不應該</em></strong>帶有 <code>providers</code>，原因<a href=\"guide/ngmodule-faq#q-why-bad\">在前面解釋過了</a>。它的匯入或重新匯出的模組中也不應該有 <code>providers</code>。如果你要違背這條指導原則，請務必想清楚你在做什麼，並要有充分的理由。</p><p translation-origin=\"off\">The <code>SharedModule</code> should not have <code>providers</code> for reasons <a href=\"guide/ngmodule-faq#q-why-bad\">explained previously</a>.\nNor should any of its imported or re-exported modules have <code>providers</code>.</p>\n\n<p translation-result=\"on\">在任何特性模組中（無論是你在應用啟動時主動載入的模組還是之後延遲載入的模組），你都可以隨意匯入這個 <code>SharedModule</code>。</p><p translation-origin=\"off\">Import the <code>SharedModule</code> in your <em>feature</em> modules, both those loaded when the application starts and those you lazy load later.</p>\n\n<h3 id=\"feature-modules\" translation-result=\"on\">特性模組<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#feature-modules\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Feature Modules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#feature-modules\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">特性模組是你圍繞特定的應用業務領域建立的模組，比如使用者工作流、小工具集等。它們包含指定的特性，併為你的應用提供支援，比如路由、服務、視窗部件等。要對你的應用中可能會有哪些特性模組有個概念，考慮如果你要把與特定功能（比如搜尋）有關的檔案放進一個目錄下，該目錄的內容就可能是一個名叫 <code>SearchModule</code> 的特性模組。它將會包含構成搜尋功能的全部元件、路由和範本。</p><p translation-origin=\"off\">Feature modules are modules you create around specific application business domains, user workflows, and utility collections.\nThey support your application by containing a particular feature, such as routes, services, widgets, etc.\nTo conceptualize what a feature module might be in your app, consider that if you would put the files related to a certain functionality, like a search, in one folder, that the contents of that folder would be a feature module that you might call your <code>SearchModule</code>.\nIt would contain all of the components, routing, and templates that would make up the search functionality.</p>\n\n<p translation-result=\"on\">要了解更多，參閱<a href=\"guide/feature-modules\">特性模組</a>和<a href=\"guide/module-types\">模組的分類</a>。</p><p translation-origin=\"off\">For more information, see <a href=\"guide/feature-modules\">Feature Modules</a> and <a href=\"guide/module-types\">Module Types</a></p>\n\n<h2 id=\"whats-the-difference-between-ngmodules-and-javascript-modules\" translation-result=\"on\">在 NgModule 和 JavaScript 模組之間有什麼不同？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#whats-the-difference-between-ngmodules-and-javascript-modules\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What's the difference between NgModules and JavaScript Modules?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#whats-the-difference-between-ngmodules-and-javascript-modules\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在 Angular 應用中，NgModule 會和 JavaScript 的模組一起工作。</p><p translation-origin=\"off\">In an Angular app, NgModules and JavaScript modules work together.</p>\n\n<p translation-result=\"on\">在現代 JavaScript 中，每個檔案都是模組（參閱<a href=\"http://exploringjs.com/es6/ch_modules.html\">模組</a>）。在每個檔案中，你要寫一個 <code>export</code> 陳述式將模組的一部分公開。</p><p translation-origin=\"off\">In modern JavaScript, every file is a module (see the <a href=\"https://exploringjs.com/es6/ch_modules.html\">Modules</a> page of the Exploring ES6 website).\nWithin each file you write an <code>export</code> statement to make parts of the module public.</p>\n\n<p translation-result=\"on\">Angular 模組是一個帶有 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 裝飾器的類，而 JavaScript 模組則沒有。Angular 的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 有自己的 <code>imports</code> 和 <code>exports</code> 來達到類似的目的。</p><p translation-origin=\"off\">An Angular NgModule is a class with the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator —JavaScript modules don't have to have the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator.\nAngular's <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> has <code>imports</code> and <code>exports</code> and they serve a similar purpose.</p>\n\n<p translation-result=\"on\">你可以<em>匯入</em>其它 NgModules，以便在當前模組的元件範本中使用它們匯出的類別。你可以<em>匯出</em>當前 NgModules 中的類，以便<em>其它</em> NgModules 可以匯入它們，並用在自己的元件範本中。</p><p translation-origin=\"off\">You <em>import</em> other NgModules so you can use their exported classes in component templates.\nYou <em>export</em> this NgModule's classes so they can be imported and used by components of <em>other</em> NgModules.</p>\n\n<p translation-result=\"on\">要了解更多，參閱 <a href=\"guide/ngmodule-vs-jsmodule\">JavaScript 模組 vs. NgModules</a> 一章。</p><p translation-origin=\"off\">For more information, see <a href=\"guide/ngmodule-vs-jsmodule\">JavaScript Modules vs. NgModules</a>.</p>\n\n<p><a id=\"q-template-reference\"></a></p>\n<h2 id=\"how-does-angular-find-components-directives-and-pipes-in-a-template-what-is-a-template-reference\" translation-result=\"on\">Angular 如何查詢範本中的元件、指令和管道？什麼是 <strong>範本參考</strong> ？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-does-angular-find-components-directives-and-pipes-in-a-template-what-is-a-template-reference\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">How does Angular find components, directives, and pipes in a template? What is a <strong>template reference</strong>?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-does-angular-find-components-directives-and-pipes-in-a-template-what-is-a-template-reference\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><a href=\"guide/ngmodule-faq#q-angular-compiler\">Angular 編譯器</a>在元件範本內查詢其它元件、指令和管道。一旦找到了，那就是一個“範本參考”。</p><p translation-origin=\"off\">The <a href=\"guide/ngmodule-faq#q-angular-compiler\">Angular compiler</a> looks inside component templates for other components, directives, and pipes.\nWhen it finds one, that's a template reference.</p>\n\n<p translation-result=\"on\">Angular 編譯器透過在範本中匹配元件或指令的<strong>選擇器（selector）</strong>，來查詢元件或指令。</p><p translation-origin=\"off\">The Angular compiler finds a component or directive in a template when it can match the <em>selector</em> of that component or directive to some HTML in that template.</p>\n\n<p translation-result=\"on\">編譯器透過分析範本 HTML 中的管道語法中是否出現了特定的管道名來查詢對應的管道。</p><p translation-origin=\"off\">The compiler finds a pipe if the pipe's <em>name</em> appears within the pipe syntax of the template HTML.</p>\n\n<p translation-result=\"on\">Angular 只會在當前模組中宣告過的那些類或被當前模組匯入的模組所匯出的那些類中匹配這些選擇器和管道名。</p><p translation-origin=\"off\">Angular only matches selectors and pipe names for classes that are declared by this module or exported by a module that this module imports.</p>\n\n<p><a id=\"q-angular-compiler\"></a></p>\n<h2 id=\"what-is-the-angular-compiler\" translation-result=\"on\">什麼是 Angular 編譯器？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-the-angular-compiler\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What is the Angular compiler?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-the-angular-compiler\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><em>Angular 編譯器</em>會把你所編寫的應用程式碼轉換成高效能的 JavaScript 程式碼。在編譯過程中，<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的元資料扮演了很重要的角色。</p><p translation-origin=\"off\">The Angular compiler converts the application code you write into highly performant JavaScript code.\nThe <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> metadata plays an important role in guiding the compilation process.</p>\n\n<p translation-result=\"on\">你寫的程式碼是無法直接執行的。比如<strong>元件</strong>。元件有一個範本，其中包含了自訂元素、屬性型指令、Angular 繫結宣告和一些顯然不屬於原生 HTML 的古怪語法。</p><p translation-origin=\"off\">The code you write isn't immediately executable.\nFor example, components have templates that contain custom elements, attribute directives, Angular binding declarations, and some peculiar syntax that clearly isn't native HTML.</p>\n\n<p translation-result=\"on\"><em>Angular 編譯器</em>讀取範本的 HTML，把它和相應的元件類程式碼組合在一起，併產出<em>元件工廠</em>。</p><p translation-origin=\"off\">The Angular compiler reads the template markup, combines it with the corresponding component class code, and emits <em>component factories</em>.</p>\n\n<p translation-result=\"on\">元件工廠為元件建立純粹的、100% JavaScript 的表示形式，它包含了 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 元資料中描述的一切：HTML、繫結指令、附屬的樣式等。</p><p translation-origin=\"off\">A component factory creates a pure, 100% JavaScript representation of the component that incorporates everything described in its <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> metadata:\nThe HTML, the binding instructions, the attached styles.</p>\n\n<p translation-result=\"on\">由於<strong>指令</strong>和<strong>管道</strong>都出現在元件範本中，*Angular 編譯器**也同樣會把它們組合進編譯後的元件程式碼中。</p><p translation-origin=\"off\">Because directives and pipes appear in component templates, the Angular compiler incorporates them into compiled component code too.</p>\n\n<p translation-result=\"on\"><code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 元資料告訴<em>Angular 編譯器</em>要為當前模組編譯哪些元件，以及如何把當前模組和其它模組連結起來。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> metadata tells the Angular compiler what components to compile for this module and how to link this module with other modules.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/ngmodule-api\n - guide/providers\n - guide/singleton-services\n-->\n<!-- links from this doc:\n - api/common/CommonModule\n - api/common/NgFor\n - api/common/NgIf\n - api/common/http/HttpBackend\n - api/common/http/HttpClientModule\n - api/core/ApplicationModule\n - api/core/Component\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Input\n - api/core/ModuleWithProviders\n - api/core/NgModule\n - api/core/NgModule#providers\n - api/core/Optional\n - api/core/Output\n - api/core/SkipSelf\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/router/Router\n - api/router/RouterModule\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/router/Routes\n - guide/bootstrapping#the-declarations-array\n - guide/feature-modules\n - guide/hierarchical-dependency-injection#moduleinjector\n - guide/module-types\n - guide/ngmodule-faq#angular-如何查詢範本中的元件指令和管道什麼是-範本參考-\n - guide/ngmodule-faq#can-i-re-export-classes-and-modules\n - guide/ngmodule-faq#cant-bind-to-x-since-it-isnt-a-known-property-of-y是什麼意思\n - guide/ngmodule-faq#discussion\n - guide/ngmodule-faq#feature-modules\n - guide/ngmodule-faq#forroot-方法是什麼\n - guide/ngmodule-faq#how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\n - guide/ngmodule-faq#how-do-i-restrict-service-scope-to-a-module\n - guide/ngmodule-faq#how-does-angular-find-components-directives-and-pipes-in-a-template-what-is-a-template-reference\n - guide/ngmodule-faq#ngmodule-faq\n - guide/ngmodule-faq#ngmodule-常見問題解答\n - guide/ngmodule-faq#q-angular-compiler\n - guide/ngmodule-faq#q-browser-vs-common-module\n - guide/ngmodule-faq#q-component-or-module\n - guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\n - guide/ngmodule-faq#q-reexport\n - guide/ngmodule-faq#q-reimport\n - guide/ngmodule-faq#q-root-component-or-module\n - guide/ngmodule-faq#q-why-bad\n - guide/ngmodule-faq#q-why-child-injector\n - guide/ngmodule-faq#service-scope\n - guide/ngmodule-faq#sharedmodule\n - guide/ngmodule-faq#should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\n - guide/ngmodule-faq#should-i-add-other-providers-to-a-module-or-a-component\n - guide/ngmodule-faq#should-i-import-browsermodule-or-commonmodule\n - guide/ngmodule-faq#the-eagerly-loaded-scenario\n - guide/ngmodule-faq#the-lazy-loaded-scenario\n - guide/ngmodule-faq#what-classes-should-i-add-to-the-declarations-array\n - guide/ngmodule-faq#what-classes-should-i-not-add-to-declarations\n - guide/ngmodule-faq#what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\n - guide/ngmodule-faq#what-if-i-import-the-same-module-twice\n - guide/ngmodule-faq#what-if-two-modules-provide-the-same-service\n - guide/ngmodule-faq#what-is-a-declarable\n - guide/ngmodule-faq#what-is-the-angular-compiler\n - guide/ngmodule-faq#what-is-the-forroot-method\n - guide/ngmodule-faq#what-kinds-of-modules-should-i-have-and-how-should-i-use-them\n - guide/ngmodule-faq#what-should-i-export\n - guide/ngmodule-faq#what-should-i-import\n - guide/ngmodule-faq#what-should-i-not-export\n - guide/ngmodule-faq#whats-the-difference-between-ngmodules-and-javascript-modules\n - guide/ngmodule-faq#why-does-lazy-loading-create-a-child-injector\n - guide/ngmodule-faq#why-is-a-service-provided-in-a-feature-module-visible-everywhere\n - guide/ngmodule-faq#why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\n - guide/ngmodule-faq#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\n - guide/ngmodule-faq#why-list-the-same-component-in-multiple-ngmodule-properties\n - guide/ngmodule-faq#為什麼在共享模組中為延遲載入模組提供服務是個餿主意\n - guide/ngmodule-faq#為什麼在延遲載入模組中宣告的服務提供者只對該模組自身可見\n - guide/ngmodule-faq#為什麼延遲載入模組會建立一個子注入器\n - guide/ngmodule-faq#為什麼服務提供者在特性模組中的任何地方都是可見的\n - guide/ngmodule-faq#為什麼要把同一個元件宣告在不同的-ngmodule-屬性中\n - guide/ngmodule-faq#什麼是-angular-編譯器\n - guide/ngmodule-faq#什麼是可宣告物件declarable\n - guide/ngmodule-faq#哪些類不應該加到-declarations-中\n - guide/ngmodule-faq#在-ngmodule-和-javascript-模組之間有什麼不同\n - guide/ngmodule-faq#如果兩個模組提供了同一個服務會怎麼樣\n - guide/ngmodule-faq#如果我兩次匯入同一個模組會怎麼樣\n - guide/ngmodule-faq#急性載入的場景\n - guide/ngmodule-faq#延遲載入場景\n - guide/ngmodule-faq#我不應該匯出什麼\n - guide/ngmodule-faq#我可以重新匯出類和模組嗎\n - guide/ngmodule-faq#我應該如何把服務的範圍限制到模組中\n - guide/ngmodule-faq#我應該匯入-browsermodule-還是-commonmodule\n - guide/ngmodule-faq#我應該匯入什麼\n - guide/ngmodule-faq#我應該匯出什麼\n - guide/ngmodule-faq#我應該把全應用級提供者新增到根模組-appmodule-中還是根元件-appcomponent-中\n - guide/ngmodule-faq#我應該把其它提供者註冊到模組中還是元件中\n - guide/ngmodule-faq#我應該把哪些類加到-declarations-中\n - guide/ngmodule-faq#我要如何知道一個模組或服務是否已經載入過了\n - guide/ngmodule-faq#有哪些型別的模組我應該如何使用它們\n - guide/ngmodule-faq#特性模組\n - guide/ngmodule-faq#討論\n - guide/ngmodule-vs-jsmodule\n - guide/singleton-services\n - guide/singleton-services#the-forroot-pattern\n - http://exploringjs.com/es6/ch_modules.html\n - https://exploringjs.com/es6/ch_modules.html\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/ngmodule-faq.md?message=docs%3A%20請簡述你的修改...\n-->"}