{"id":"guide/practical-observable-usage","title":"Practical observable usage","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/practical-observable-usage.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"practical-observable-usage\" translation-result=\"on\">可觀察物件用法實戰<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#practical-observable-usage\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Practical observable usage<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#practical-observable-usage\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">這裡示範了一些在某種領域中可觀察物件會特別有用的例子。</p><p translation-origin=\"off\">Here are some examples of domains in which observables are particularly useful.</p>\n\n<h2 id=\"type-ahead-suggestions\" translation-result=\"on\">輸入提示（type-ahead）建議<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#type-ahead-suggestions\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Type-ahead suggestions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#type-ahead-suggestions\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">可觀察物件可以簡化輸入提示建議的實現方式。典型的輸入提示要完成一系列獨立的任務：</p><p translation-origin=\"off\">Observables can simplify the implementation of type-ahead suggestions.\nTypically, a type-ahead has to do a series of separate tasks:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">從輸入中監聽資料</p><p translation-origin=\"off\">Listen for data from an input</p>\n\n</li>\n<li>\n<p translation-result=\"on\">移除輸入值前後的空白字元，並確認它達到了最小長度</p><p translation-origin=\"off\">Trim the value (remove whitespace) and make sure it's a minimum length</p>\n\n</li>\n<li>\n<p translation-result=\"on\">防抖（這樣才能防止連續按鍵時每次按鍵都發起 API 請求，而應該等到按鍵出現停頓時才發起）</p><p translation-origin=\"off\">Debounce (so as not to send off API requests for every keystroke, but instead wait for a break in keystrokes)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果輸入值沒有變化，則不要發起請求（比如按某個字元，然後快速按退格）</p><p translation-origin=\"off\">Don't send a request if the value stays the same (rapidly hit a character, then backspace, for instance)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果已發出的 AJAX 請求的結果會因為後續的修改而變得無效，那就取消它</p><p translation-origin=\"off\">Cancel ongoing AJAX requests if their results will be invalidated by the updated results</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">完全用 JavaScript 的傳統寫法實現這個功能可能需要大量的工作。使用可觀察物件，你可以使用這樣一個 RxJS 運運算元的簡單序列：</p><p translation-origin=\"off\">Writing this in full JavaScript can be quite involved.\nWith observables, you can use a simple series of RxJS operators:</p>\n\n<code-example header=\"Typeahead\" path=\"practical-observable-usage/src/typeahead.ts\">\nimport { fromEvent, Observable } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { debounceTime, distinctUntilChanged, filter, map, switchMap } from 'rxjs/operators';\n\nconst searchBox = document.getElementById('search-box') as HTMLInputElement;\n\nconst typeahead = fromEvent(searchBox, 'input').pipe(\n  map(e =&gt; (e.target as HTMLInputElement).value),\n  filter(text =&gt; text.length &gt; 2),\n  debounceTime(10),\n  distinctUntilChanged(),\n  switchMap(searchTerm =&gt; ajax(`/api/endpoint?search=${searchTerm}`))\n);\n\ntypeahead.subscribe(data =&gt; {\n  // Handle the data from the API\n});\n\n\n</code-example>\n<h2 id=\"exponential-backoff\" translation-result=\"on\">指數化退避<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#exponential-backoff\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Exponential backoff<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/practical-observable-usage#exponential-backoff\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">指數化退避是一種失敗後重試 API 的技巧，它會在每次連續的失敗之後讓重試時間逐漸變長，超過最大重試次數之後就會徹底放棄。如果使用 Promise 物件和其它追蹤 AJAX 呼叫的方法會非常複雜，而使用可觀察物件，這非常簡單：</p><p translation-origin=\"off\">Exponential backoff is a technique in which you retry an API after failure, making the time in between retries longer after each consecutive failure, with a maximum number of retries after which the request is considered to have failed.\nThis can be quite complex to implement with promises and other methods of tracking AJAX calls.\nWith observables, it is very easy:</p>\n\n<code-example header=\"Exponential backoff\" path=\"practical-observable-usage/src/backoff.ts\">\nimport { timer } from 'rxjs';\nimport { ajax } from 'rxjs/ajax';\nimport { retry } from 'rxjs/operators';\n\nexport function backoff(maxTries: number, initialDelay: number) {\n    return retry({\n        count: maxTries,\n        delay: (error, retryCount) =&gt; timer(initialDelay * retryCount ** 2),\n      });\n  }\n\najax('/api/endpoint')\n  .pipe(backoff(3, 250))\n  .subscribe(function handleData(data) { /* ... */ });\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - guide/practical-observable-usage#exponential-backoff\n - guide/practical-observable-usage#practical-observable-usage\n - guide/practical-observable-usage#type-ahead-suggestions\n - guide/practical-observable-usage#可觀察物件用法實戰\n - guide/practical-observable-usage#指數化退避\n - guide/practical-observable-usage#輸入提示type-ahead建議\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/practical-observable-usage.md?message=docs%3A%20請簡述你的修改...\n-->"}