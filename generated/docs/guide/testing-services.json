{"id":"guide/testing-services","title":"Testing services","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/testing-services.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"testing-services\" translation-result=\"on\">測試服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-services\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Testing services<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-services\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">為了檢查你的服務是否正常工作，你可以專門為它們編寫測試。</p><p translation-origin=\"off\">To check that your services are working as you intend, you can write tests specifically for them.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果你要試驗本指南中所講的應用，請<live-example name=\"testing\" nodownload=\"\">在瀏覽器中執行它</live-example>或<live-example name=\"testing\" downloadonly=\"\">下載並在本地執行它</live-example>。</p><p translation-origin=\"off\">If you'd like to experiment with the application that this guide describes, <live-example name=\"testing\" nodownload=\"\">run it in your browser</live-example> or <live-example name=\"testing\" downloadonly=\"\">download and run it locally</live-example>.</p>\n\n</div>\n<p translation-result=\"on\">服務往往是最容易進行單元測試的檔案。下面是一些針對 <code>ValueService</code> 的同步和非同步單元測試，甚至不需要 Angular 測試工具的幫助。</p><p translation-origin=\"off\">Services are often the smoothest files to unit test.\nHere are some synchronous and asynchronous unit tests of the <code>ValueService</code> written without assistance from Angular testing utilities.</p>\n\n<code-example header=\"app/demo/demo.spec.ts\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"ValueService\">\n// Straight Jasmine testing without Angular's testing support\ndescribe('ValueService', () =&gt; {\n  let service: ValueService;\n  beforeEach(() =&gt; { service = new ValueService(); });\n\n  it('#getValue should return real value', () =&gt; {\n    expect(service.getValue()).toBe('real value');\n  });\n\n  it('#getObservableValue should return value from observable',\n    (done: DoneFn) =&gt; {\n    service.getObservableValue().subscribe(value =&gt; {\n      expect(value).toBe('observable value');\n      done();\n    });\n  });\n\n  it('#getPromiseValue should return value from a promise',\n    (done: DoneFn) =&gt; {\n    service.getPromiseValue().then(value =&gt; {\n      expect(value).toBe('promise value');\n      done();\n    });\n  });\n});\n\n</code-example>\n<p><a id=\"services-with-dependencies\"></a></p>\n<h2 id=\"services-with-dependencies\" translation-result=\"on\">有依賴的服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#services-with-dependencies\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Services with dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#services-with-dependencies\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">服務通常依賴於 Angular 在建構函式中注入的其它服務。在很多情況下，呼叫服務的建構函式時，很容易手動建立和<em>注入</em>這些依賴。</p><p translation-origin=\"off\">Services often depend on other services that Angular injects into the constructor.\nIn many cases, you can create and <em>inject</em> these dependencies by hand while calling the service's constructor.</p>\n\n<p translation-result=\"on\"><code>MasterService</code> 就是一個簡單的例子：</p><p translation-origin=\"off\">The <code>MasterService</code> is a simple example:</p>\n\n<code-example header=\"app/demo/demo.ts\" path=\"testing/src/app/demo/demo.ts\" region=\"MasterService\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class MasterService {\n  constructor(private valueService: ValueService) { }\n  getValue() { return this.valueService.getValue(); }\n}\n\n</code-example>\n<p translation-result=\"on\"><code>MasterService</code> 只把它唯一的方法 <code>getValue</code> 委託給了所注入的 <code>ValueService</code>。</p><p translation-origin=\"off\"><code>MasterService</code> delegates its only method, <code>getValue</code>, to the injected <code>ValueService</code>.</p>\n\n<p translation-result=\"on\">這裡有幾種測試方法。</p><p translation-origin=\"off\">Here are several ways to test it.</p>\n\n<code-example header=\"app/demo/demo.spec.ts\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"MasterService\">\ndescribe('MasterService without Angular testing support', () =&gt; {\n  let masterService: MasterService;\n\n  it('#getValue should return real value from the real service', () =&gt; {\n    masterService = new MasterService(new ValueService());\n    expect(masterService.getValue()).toBe('real value');\n  });\n\n  it('#getValue should return faked value from a fakeService', () =&gt; {\n    masterService = new MasterService(new FakeValueService());\n    expect(masterService.getValue()).toBe('faked service value');\n  });\n\n  it('#getValue should return faked value from a fake object', () =&gt; {\n    const fake =  { getValue: () =&gt; 'fake value' };\n    masterService = new MasterService(fake as ValueService);\n    expect(masterService.getValue()).toBe('fake value');\n  });\n\n  it('#getValue should return stubbed value from a spy', () =&gt; {\n    // create `getValue` spy on an object representing the ValueService\n    const valueServiceSpy =\n      jasmine.createSpyObj('ValueService', ['getValue']);\n\n    // set the value to return when the `getValue` spy is called.\n    const stubValue = 'stub value';\n    valueServiceSpy.getValue.and.returnValue(stubValue);\n\n    masterService = new MasterService(valueServiceSpy);\n\n    expect(masterService.getValue())\n      .withContext('service returned stub value')\n      .toBe(stubValue);\n    expect(valueServiceSpy.getValue.calls.count())\n      .withContext('spy method was called once')\n      .toBe(1);\n    expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n      .toBe(stubValue);\n  });\n});\n\n</code-example>\n<p translation-result=\"on\">第一個測試使用 <code>new</code> 建立了一個 <code>ValueService</code>，並把它傳給了 <code>MasterService</code> 的建構函式。</p><p translation-origin=\"off\">The first test creates a <code>ValueService</code> with <code>new</code> and passes it to the <code>MasterService</code> constructor.</p>\n\n<p translation-result=\"on\">然而，注入真實服務很難工作良好，因為大多數被依賴的服務都很難建立和控制。</p><p translation-origin=\"off\">However, injecting the real service rarely works well as most dependent services are difficult to create and control.</p>\n\n<p translation-result=\"on\">相反，可以模擬依賴、使用仿製品，或者在相關的服務方法上<a href=\"https://jasmine.github.io/tutorials/your_first_suite#section-Spies\">建立一個測試間諜</a>。</p><p translation-origin=\"off\">Instead, mock the dependency, use a dummy value, or create a <a href=\"https://jasmine.github.io/tutorials/your_first_suite#section-Spies\">spy</a> on the pertinent service method.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">我更喜歡用測試間諜，因為它們通常是模擬服務的最佳途徑。</p><p translation-origin=\"off\">Prefer spies as they are usually the best way to mock services.</p>\n\n</div>\n<p translation-result=\"on\">這些標準的測試技巧非常適合對服務進行單獨測試。</p><p translation-origin=\"off\">These standard testing techniques are great for unit testing services in isolation.</p>\n\n<p translation-result=\"on\">但是，你幾乎總是使用 Angular 依賴注入機制來將服務注入到應用類中，你應該有一些測試來體現這種使用模式。Angular 測試實用工具可以讓你輕鬆調查這些注入服務的行為。</p><p translation-origin=\"off\">However, you almost always inject services into application classes using Angular dependency injection and you should have tests that reflect that usage pattern.\nAngular testing utilities make it straightforward to investigate how injected services behave.</p>\n\n<h2 id=\"testing-services-with-the-testbed\" translation-result=\"on\">使用 <em>TestBed</em> 測試服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/core/testing/TestBed\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Testing services with the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-services-with-the-testbed\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你的應用依靠 Angular 的<a href=\"guide/dependency-injection\">依賴注入（DI）</a>來建立服務。當服務有依賴時，DI 會查詢或建立這些被依賴的服務。如果該被依賴的服務還有自己的依賴，DI 也會查詢或建立它們。</p><p translation-origin=\"off\">Your application relies on Angular <a href=\"guide/dependency-injection\">dependency injection (DI)</a> to create services.\nWhen a service has a dependent service, DI finds or creates that dependent service.\nAnd if that dependent service has its own dependencies, DI finds-or-creates them as well.</p>\n\n<p translation-result=\"on\">作為服務的<em>消費者</em>，你不應該關心這些。你不應該關心建構函式引數的順序或它們是如何建立的。</p><p translation-origin=\"off\">As service <em>consumer</em>, you don't worry about any of this.\nYou don't worry about the order of constructor arguments or how they're created.</p>\n\n<p translation-result=\"on\">作為服務的<em>測試人員</em>，你至少要考慮第一層的服務依賴，但當你用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 測試實用工具來提供和建立服務時，你<em>可以</em>讓 Angular DI 來建立服務並處理建構函式的引數順序。</p><p translation-origin=\"off\">As a service <em>tester</em>, you must at least think about the first level of service dependencies but you <em>can</em> let Angular DI do the service creation and deal with constructor argument order when you use the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> testing utility to provide and create services.</p>\n\n<p><a id=\"testbed\"></a></p>\n<h2 id=\"angular-testbed\">Angular <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#angular-testbed\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 是 Angular 測試實用工具中最重要的。<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 建立了一個動態構造的 Angular <em>測試</em>模組，用來模擬一個 Angular 的 <a href=\"guide/ngmodules\"><code>@NgModule</code></a>。</p><p translation-origin=\"off\">The <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> is the most important of the Angular testing utilities.\nThe <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> creates a dynamically-constructed Angular <em>test</em> module that emulates an Angular <a href=\"guide/ngmodules\"><code>@NgModule</code></a>.</p>\n\n<p translation-result=\"on\"><code>TestBed.configureTestingModule()</code> 方法接受一個元資料物件，它可以擁有<a href=\"guide/ngmodules\"><code>@NgModule</code></a>的大部分屬性。</p><p translation-origin=\"off\">The <code>TestBed.configureTestingModule()</code> method takes a metadata object that can have most of the properties of an <a href=\"guide/ngmodules\"><code>@NgModule</code></a>.</p>\n\n<p translation-result=\"on\">要測試某個服務，你可以在元資料屬性 <code>providers</code> 中設定一個要測試或模擬的服務陣列。</p><p translation-origin=\"off\">To test a service, you set the <code>providers</code> metadata property with an array of the services that you'll test or mock.</p>\n\n<code-example header=\"app/demo/demo.testbed.spec.ts (provide ValueService in beforeEach)\" path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-before-each\">\nlet service: ValueService;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n});\n\n</code-example>\n<p translation-result=\"on\">將服務類作為引數呼叫 <code>TestBed.inject()</code>，將它注入到測試中。</p><p translation-origin=\"off\">Then inject it inside a test by calling <code>TestBed.inject()</code> with the service class as the argument.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n<code>TestBed.get()</code> 已在 Angular 9 中棄用。為了幫助減少重大變更，Angular 引入了一個名為 <code>TestBed.inject()</code> 的新函式，你可以改用它。關於刪除 <code>TestBed.get()</code> 的資訊，請參閱<a href=\"guide/deprecations#index\">棄用索引</a>中的條目。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\n<code>TestBed.get()</code> was deprecated as of Angular version 9.\nTo help minimize breaking changes, Angular introduces a new function called <code>TestBed.inject()</code>, which you should use instead.\nFor information on the removal of <code>TestBed.get()</code>, see its entry in the <a href=\"guide/deprecations#index\">Deprecations index</a>.</p>\n\n</div>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-it\">\nit('should use ValueService', () =&gt; {\n  service = TestBed.inject(ValueService);\n  expect(service.getValue()).toBe('real value');\n});\n\n</code-example>\n<p translation-result=\"on\">或者，如果你喜歡把這個服務作為設定程式碼的一部分進行注入，也可以在 <code>beforeEach()</code> 中做。</p><p translation-origin=\"off\">Or inside the <code>beforeEach()</code> if you prefer to inject the service as part of your setup.</p>\n\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-before-each\">\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n  service = TestBed.inject(ValueService);\n});\n\n</code-example>\n<p translation-result=\"on\">測試帶依賴的服務時，需要在 <code>providers</code> 陣列中提供 mock。</p><p translation-origin=\"off\">When testing a service with a dependency, provide the mock in the <code>providers</code> array.</p>\n\n<p translation-result=\"on\">在下面的例子中，mock 是一個間諜物件。</p><p translation-origin=\"off\">In the following example, the mock is a spy object.</p>\n\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-before-each\">\nlet masterService: MasterService;\nlet valueServiceSpy: jasmine.SpyObj&lt;ValueService&gt;;\n\nbeforeEach(() =&gt; {\n  const spy = jasmine.createSpyObj('ValueService', ['getValue']);\n\n  TestBed.configureTestingModule({\n    // Provide both the service-to-test and its (spy) dependency\n    providers: [\n      MasterService,\n      { provide: ValueService, useValue: spy }\n    ]\n  });\n  // <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> both the service-to-test and its (spy) dependency\n  masterService = TestBed.inject(MasterService);\n  valueServiceSpy = TestBed.inject(ValueService) as jasmine.SpyObj&lt;ValueService&gt;;\n});\n\n</code-example>\n<p translation-result=\"on\">該測試會像以前一樣使用該間諜。</p><p translation-origin=\"off\">The test consumes that spy in the same way it did earlier.</p>\n\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-it\">\nit('#getValue should return stubbed value from a spy', () =&gt; {\n  const stubValue = 'stub value';\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n\n  expect(masterService.getValue())\n    .withContext('service returned stub value')\n    .toBe(stubValue);\n  expect(valueServiceSpy.getValue.calls.count())\n    .withContext('spy method was called once')\n    .toBe(1);\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n    .toBe(stubValue);\n});\n\n</code-example>\n<p><a id=\"no-before-each\"></a></p>\n<h2 id=\"testing-without-beforeeach\" translation-result=\"on\">沒有 <code>beforeEach()</code> 的測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-without-beforeeach\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Testing without <code>beforeEach()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-without-beforeeach\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本指南中的大多數測試套件都會呼叫 <code>beforeEach()</code> 來為每一個 <code>it()</code> 測試設定前置條件，並依賴 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 來建立類和注入服務。</p><p translation-origin=\"off\">Most test suites in this guide call <code>beforeEach()</code> to set the preconditions for each <code>it()</code> test and rely on the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> to create classes and inject services.</p>\n\n<p translation-result=\"on\">還有另一種測試，它們從不呼叫 <code>beforeEach()</code>，而是更喜歡明確地建立類，而不是使用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>。</p><p translation-origin=\"off\">There's another school of testing that never calls <code>beforeEach()</code> and prefers to create classes explicitly rather than use the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>.</p>\n\n<p translation-result=\"on\">你可以用這種風格重寫 <code>MasterService</code> 中的一個測試。</p><p translation-origin=\"off\">Here's how you might rewrite one of the <code>MasterService</code> tests in that style.</p>\n\n<p translation-result=\"on\">首先，在 <em>setup</em> 函式中放入可供複用的預備程式碼，而不用 <code>beforeEach()</code>。</p><p translation-origin=\"off\">Begin by putting re-usable, preparatory code in a <em>setup</em> function instead of <code>beforeEach()</code>.</p>\n\n<code-example header=\"app/demo/demo.spec.ts (setup)\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup\">\nfunction setup() {\n  const valueServiceSpy =\n    jasmine.createSpyObj('ValueService', ['getValue']);\n  const stubValue = 'stub value';\n  const masterService = new MasterService(valueServiceSpy);\n\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n  return { masterService, stubValue, valueServiceSpy };\n}\n\n</code-example>\n<p translation-result=\"on\"><code>setup()</code> 函式返回一個包含測試可能參考的變數（如 <code>masterService</code>）的物件字面量。你並沒有在 <code>describe()</code> 的函式體中定義<em>半全域</em>變數（比如 <code>let masterService: MasterService</code>）。</p><p translation-origin=\"off\">The <code>setup()</code> function returns an object literal with the variables, such as <code>masterService</code>, that a test might reference.\nYou don't define <em>semi-global</em> variables (for example, <code>let masterService: MasterService</code>) in the body of the <code>describe()</code>.</p>\n\n<p translation-result=\"on\">然後，每個測試都會在第一行呼叫 <code>setup()</code>，然後繼續執行那些操縱被測主體和斷言期望值的步驟。</p><p translation-origin=\"off\">Then each test invokes <code>setup()</code> in its first line, before continuing with steps that manipulate the test subject and assert expectations.</p>\n\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-test\">\nit('#getValue should return stubbed value from a spy', () =&gt; {\n  const { masterService, stubValue, valueServiceSpy } = setup();\n  expect(masterService.getValue())\n    .withContext('service returned stub value')\n    .toBe(stubValue);\n  expect(valueServiceSpy.getValue.calls.count())\n    .withContext('spy method was called once')\n    .toBe(1);\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n    .toBe(stubValue);\n});\n\n</code-example>\n<p translation-result=\"on\">請注意測試如何使用<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\"><em>解構賦值</em></a>來提取它需要的設定變數。</p><p translation-origin=\"off\">Notice how the test uses <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\"><em>destructuring assignment</em></a> to extract the setup variables that it needs.</p>\n\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup-call\">\nconst { masterService, stubValue, valueServiceSpy } = setup();\n\n</code-example>\n<p translation-result=\"on\">許多開發人員都覺得這種方法比傳統的 <code>beforeEach()</code> 風格更清晰明瞭。</p><p translation-origin=\"off\">Many developers feel this approach is cleaner and more explicit than the traditional <code>beforeEach()</code> style.</p>\n\n<p translation-result=\"on\">雖然這個測試指南遵循傳統的樣式，並且預設的<a href=\"https://github.com/angular/angular-cli\">CLI 原理圖</a>會產生帶有 <code>beforeEach()</code> 和 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的測試檔案，但你可以在自己的專案中採用<em>這種替代方式</em>。</p><p translation-origin=\"off\">Although this testing guide follows the traditional style and the default <a href=\"https://github.com/angular/angular-cli\">CLI schematics</a> generate test files with <code>beforeEach()</code> and <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>, feel free to adopt <em>this alternative approach</em> in your own projects.</p>\n\n<h2 id=\"testing-http-services\" translation-result=\"on\">測試 HTTP 服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-http-services\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Testing HTTP services<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#testing-http-services\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">對遠端伺服器進行 HTTP 呼叫的資料服務通常會注入並委託給 Angular 的 <a href=\"guide/http\"><code>HttpClient</code></a>服務進行 XHR 呼叫。</p><p translation-origin=\"off\">Data services that make HTTP calls to remote servers typically inject and delegate to the Angular <a href=\"guide/http\"><code>HttpClient</code></a> service for XHR calls.</p>\n\n<p translation-result=\"on\">你可以測試一個注入了 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 間諜的資料服務，就像測試所有帶依賴的服務一樣。</p><p translation-origin=\"off\">You can test a data service with an injected <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> spy as you would test any service with a dependency.</p>\n\n<code-example header=\"app/model/hero.service.spec.ts (tests with spies)\" path=\"testing/src/app/model/hero.service.spec.ts\" region=\"test-with-spies\">\nlet httpClientSpy: jasmine.SpyObj&lt;<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>&gt;;\nlet heroService: HeroService;\n\nbeforeEach(() =&gt; {\n  // TODO: spy on other methods too\n  httpClientSpy = jasmine.createSpyObj('<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>', ['get']);\n  heroService = new HeroService(httpClientSpy);\n});\n\nit('should return expected heroes (<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> called once)', (done: DoneFn) =&gt; {\n  const expectedHeroes: Hero[] =\n    [{ id: 1, name: 'A' }, { id: 2, name: 'B' }];\n\n  httpClientSpy.get.and.returnValue(asyncData(expectedHeroes));\n\n  heroService.getHeroes().subscribe({\n    next: heroes =&gt; {\n      expect(heroes)\n        .withContext('expected heroes')\n        .toEqual(expectedHeroes);\n      done();\n    },\n    error: done.fail\n  });\n  expect(httpClientSpy.get.calls.count())\n    .withContext('one call')\n    .toBe(1);\n});\n\nit('should return an error when the server returns a 404', (done: DoneFn) =&gt; {\n  const errorResponse = new <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>({\n    error: 'test 404 error',\n    status: 404, statusText: 'Not Found'\n  });\n\n  httpClientSpy.get.and.returnValue(asyncError(errorResponse));\n\n  heroService.getHeroes().subscribe({\n    next: heroes =&gt; done.fail('expected an error, not heroes'),\n    error: error  =&gt; {\n      expect(error.message).toContain('test 404 error');\n      done();\n    }\n  });\n});\n\n</code-example>\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><code>HeroService</code> 方法會返回 <code>Observables</code>。你必須<em>訂閱</em>一個可觀察物件（a）讓它執行，（b）斷言該方法成功或失敗。</p><p translation-origin=\"off\">The <code>HeroService</code> methods return <code>Observables</code>.\nYou must <em>subscribe</em> to an observable to (a) cause it to execute and (b) assert that the method succeeds or fails.</p>\n\n<p translation-result=\"on\"><code>subscribe()</code> 方法會接受成功（<code>next</code>）和失敗（<code>error</code>）回呼(Callback)。確保你會同時提供<em>這兩個</em>回呼(Callback)函式，以便捕獲錯誤。如果不這樣做就會產生一個非同步的、沒有被捕獲的可觀察物件的錯誤，測試執行器可能會把它歸因於一個完全不相關的測試。</p><p translation-origin=\"off\">The <code>subscribe()</code> method takes a success (<code>next</code>) and fail (<code>error</code>) callback.\nMake sure you provide <em>both</em> callbacks so that you capture errors.\nNeglecting to do so produces an asynchronous uncaught observable error that the test runner will likely attribute to a completely different test.</p>\n\n</div>\n<h2 id=\"httpclienttestingmodule\"><code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-services#httpclienttestingmodule\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\">資料服務和 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 之間的擴充互動可能比較複雜，並且難以透過間諜進行模擬。</p><p translation-origin=\"off\">Extended interactions between a data service and the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> can be complex and difficult to mock with spies.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> 可以讓這些測試場景更易於管理。</p><p translation-origin=\"off\">The <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> can make these testing scenarios more manageable.</p>\n\n<p translation-result=\"on\">雖然本指南附帶的<em>範例程式碼</em>示範了 <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>，但是本頁面還是要參考一下 <a href=\"guide/http#testing-http-requests\">Http 指南</a>，那份指南中詳細介紹了 <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>。</p><p translation-origin=\"off\">While the <em>code sample</em> accompanying this guide demonstrates <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>, this page defers to the <a href=\"guide/http#testing-http-requests\">Http guide</a>, which covers testing with the <code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> in detail.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/testing\n - guide/testing-components-basics\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse\n - api/common/http/testing/HttpClientTestingModule\n - api/core/Inject\n - api/core/Injectable\n - api/core/testing/TestBed\n - guide/dependency-injection\n - guide/deprecations#index\n - guide/http\n - guide/http#testing-http-requests\n - guide/ngmodules\n - guide/testing-services#angular-testbed\n - guide/testing-services#httpclienttestingmodule\n - guide/testing-services#services-with-dependencies\n - guide/testing-services#testing-http-services\n - guide/testing-services#testing-services\n - guide/testing-services#testing-services-with-the-testbed\n - guide/testing-services#testing-without-beforeeach\n - guide/testing-services#使用-testbed-測試服務\n - guide/testing-services#有依賴的服務\n - guide/testing-services#沒有-beforeeach-的測試\n - guide/testing-services#測試-http-服務\n - guide/testing-services#測試服務\n - https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n - https://github.com/angular/angular-cli\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/testing-services.md?message=docs%3A%20請簡述你的修改...\n - https://jasmine.github.io/tutorials/your_first_suite#section-Spies\n-->"}