{"id":"guide/rxjs-interop","title":"RxJS Interop","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/rxjs-interop.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"rxjs-interop\" translation-result=\"on\">RxJS 互操作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#rxjs-interop\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">RxJS Interop<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#rxjs-interop\"><i class=\"material-icons\">link</i></a></h1>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">RxJS 互操作性包已經提供了<a href=\"/guide/releases#developer-preview\">開發者預覽版</a>。你已經可以嘗試使用它，但在穩定之前可能會發生變化。</p><p translation-origin=\"off\">The RxJS Interop package is available for <a href=\"/guide/releases#developer-preview\">developer preview</a>. It's ready for you to try, but it might change before it is stable.</p>\n\n</div>\n<p translation-result=\"on\">Angular 的 <code>@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a></code> 套件，它提供了有用的實用程式來將 <a href=\"/guide/signals\">Angular 訊號（Signal）</a> 與 RxJS 可觀察物件（Observable）整合起來。</p><p translation-origin=\"off\">Angular's <code>@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a></code> package which provides useful utilities to integrate <a href=\"/guide/signals\">Angular Signals</a> with RxJS Observables.</p>\n\n<h2 id=\"tosignal\"><code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#tosignal\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\"><code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 函式建立一個追蹤 Observable 值的訊號。它的行為類似於範本中的 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 管道，但更靈活，可以在應用程式的任何地方使用。</p><p translation-origin=\"off\">The <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> function creates a signal which tracks the value of an Observable. It behaves similarly to the <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> pipe in templates, but is more flexible and can be used anywhere in an application.</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a> } from '@angular/common';\nimport { interval } from 'rxjs';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  template: `{{ counter() }}`,\n})\nexport class Ticker {\n  counterObservable = interval(1000);\n\n  // Get a `<a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>` representing the `counterObservable`'s value.\n  counter = <a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a>(this.counterObservable, {initialValue: 0});\n}\n</code-example>\n<p translation-result=\"on\">與 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 管道一樣，<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 會立即訂閱 Observable，這可能會引發副作用。<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 建立的訂閱會在銷燬呼叫 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 的元件時自動取消對給定 Observable 的訂閱。</p><p translation-origin=\"off\">Like the <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> pipe, <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> subscribes to the Observable immediately, which may trigger side effects. The subscription created by\n<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> automatically unsubscribes from the given Observable upon destruction of the the component in which <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> is called.</p>\n\n<h3 id=\"initial-values\" translation-result=\"on\">初始值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#initial-values\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Initial values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#initial-values\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Observable 可能不會在訂閱時同步產生一個值，但訊號總是需要一個當前值。有幾種方法可以處理 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 訊號的這個“初始”值。</p><p translation-origin=\"off\">Observables may not produce a value synchronously on subscription, but signals always require a current value. There are several ways to deal with this \"initial\" value of <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> signals.</p>\n\n<h4 id=\"the-initialvalue-option\" translation-result=\"on\"><code>initialValue</code> 選項<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-initialvalue-option\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">The <code>initialValue</code> option<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-initialvalue-option\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">如上例所示，<code>initialValue</code> 選項指定訊號在 Observable 首次發射之前應返回的值。</p><p translation-origin=\"off\">As in the example above, the <code>initialValue</code> option specifies the value the signal should return before the Observable emits for the first time.</p>\n\n<h4 id=\"undefined-initial-values\" translation-result=\"on\"><code>undefined</code> 初始值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#undefined-initial-values\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\"><code>undefined</code> initial values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#undefined-initial-values\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">如果省略了 <code>initialValue</code>，則 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 返回的訊號將返回 <code>undefined</code> 直到 Observable 發出為止。這類似於 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 管道返回 <code>null</code> 的行為。</p><p translation-origin=\"off\">If <code>initialValue</code> is omitted, the signal returned by <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> returns <code>undefined</code> until the Observable emits. This is similar to the <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> pipe's behavior of returning <code>null</code>.</p>\n\n<h4 id=\"the-requiresync-option\" translation-result=\"on\"><code>requireSync</code> 選項<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-requiresync-option\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">The <code>requireSync</code> option<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#the-requiresync-option\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">已知一些 Observable 是同步發出的，例如 <code>BehaviorSubject</code>。在這些情況下，你可以指定 <code>requireSync: true</code> 選項。</p><p translation-origin=\"off\">Some Observables are known to emit synchronously, such as <code>BehaviorSubject</code>. In those cases, you can specify the <code>requireSync: true</code> option.</p>\n\n<p translation-result=\"on\">當 <code>requiredSync</code> 為 <code>true</code> 時，<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 強制 Observable 在訂閱時同步發出值。這保證了訊號總是有一個值，並且不需要用 <code>undefined</code> 型別或初始值。</p><p translation-origin=\"off\">When <code>requiredSync</code> is <code>true</code>, <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> enforces that the Observable emits synchronously on subscription. This guarantees that the signal always has a value, and no <code>undefined</code> type or initial value is required.</p>\n\n<h3 id=\"manualcleanup\"><code>manualCleanup</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#manualcleanup\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">預設情況下，<code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 在建立它的上下文被銷燬時自動取消訂閱 Observable。例如，如果在元件建立期間呼叫 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code>，它會在元件銷燬時清除其訂閱。</p><p translation-origin=\"off\">By default, <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> automatically unsubscribes from the Observable upon destruction of the context in which it's created. For example, if <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> is called during creation of a component, it cleans up its subscription when the component is destroyed.</p>\n\n<p translation-result=\"on\"><code>manualCleanup</code> 選項會禁用此自動清理。你可以將此設定用於會自然結束的 Observable。</p><p translation-origin=\"off\">The <code>manualCleanup</code> option disables this automatic cleanup. You can use this setting for Observables that complete themselves naturally.</p>\n\n<h3 id=\"error-and-completion\" translation-result=\"on\">出錯與結束<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#error-and-completion\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Error and Completion<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#error-and-completion\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果在 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 中使用的 Observable 產生了錯誤，則在讀取訊號時就會丟擲該錯誤。</p><p translation-origin=\"off\">If an Observable used in <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> produces an error, that error is thrown when the signal is read.</p>\n\n<p translation-result=\"on\">如果 <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> 中使用的 Observable 結束了，則訊號會繼續返回結束前最近發出的值。</p><p translation-origin=\"off\">If an Observable used in <code><a href=\"api/core/rxjs-interop/toSignal\" class=\"code-anchor\">toSignal</a></code> completes, the signal continues to return the most recently emitted value before completion.</p>\n\n<h2 id=\"toobservable\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#toobservable\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 實用程式會建立一個追蹤訊號值的 <code>Observable</code>。訊號的值由一個 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 監控，它會在值發生變化時將值傳送給 Observable。</p><p translation-origin=\"off\">The <code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> utility creates an <code>Observable</code> which tracks the value of a signal. The signal's value is monitored with an <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>, which emits the value to the Observable when it changes.</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/signal\" class=\"code-anchor\">signal</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>(...)\nexport class SearchResults {\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: <a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>&lt;string&gt; = inject(QueryService).query;\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>$ = <a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a>(this.query);\n\n  results$ = this.query$.pipe(\n    switchMap(<a href=\"api/animations/query\" class=\"code-anchor\">query</a> =&gt; this.http.get('/search?q=' + <a href=\"api/animations/query\" class=\"code-anchor\">query</a> ))\n  );\n}\n</code-example>\n<p translation-result=\"on\">隨著 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> 訊號的變化，<code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>$</code> Observable 發出最新的查詢並觸發一個新的 HTTP 請求。</p><p translation-origin=\"off\">As the <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code> signal changes, the <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>$</code> Observable emits the latest query and triggers a new HTTP request.</p>\n\n<h3 id=\"injection-context\" translation-result=\"on\">注入上下文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#injection-context\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Injection context<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#injection-context\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 預設情況下需要在注入上下文中執行，例如在建構元件或服務期間。如果注入上下文不可用，則可以顯式指定 <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code>。</p><p translation-origin=\"off\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> by default needs to run in an injection context, such as during construction of a component or service. If an injection context is not available, an <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> can instead be explicitly specified.</p>\n\n<h3 id=\"timing-of-toobservable\" translation-result=\"on\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 的時序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#toobservable-的時序\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Timing of <code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rxjs-interop#timing-of-toobservable\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> 使用 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 來追蹤 <code>ReplaySubject</code> 中的訊號值。在訂閱時，第一個值（如果可用）可以同步發出，所有後續值都將是非同步的。</p><p translation-origin=\"off\"><code><a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a></code> uses an effect to track the value of the signal in a <code>ReplaySubject</code>. On subscription, the first value (if available) may be emitted synchronously, and all subsequent values will be asynchronous.</p>\n\n<p translation-result=\"on\">與 Observable 不同，訊號從來不會提供同步的變化通知。即使你的程式碼多次更新訊號值，依賴於訊號值的 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 也只會在訊號“穩定”後執行。</p><p translation-origin=\"off\">Unlike Observables, signals never provide a synchronous notification of changes. Even if your code updates a signal's value multiple times, effects which depend on its value run only after the signal has \"settled\".</p>\n\n<code-example language=\"ts\">\nconst obs$ = <a href=\"api/core/rxjs-interop/toObservable\" class=\"code-anchor\">toObservable</a>(mySignal);\nobs$.subscribe(value =&gt; console.log(value));\n\nmySignal.set(1);\nmySignal.set(2);\nmySignal.set(3);\n</code-example>\n<p translation-result=\"on\">在這裡，只會記錄最後一個值（3）。</p><p translation-origin=\"off\">Here, only the last value (3) will be logged.</p>\n\n\n  \n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /guide/releases#developer-preview\n - /guide/signals\n - api/animations/query\n - api/common/AsyncPipe\n - api/core/Component\n - api/core/Injector\n - api/core/Signal\n - api/core/effect\n - api/core/rxjs-interop\n - api/core/rxjs-interop/toObservable\n - api/core/rxjs-interop/toSignal\n - api/core/signal\n - guide/rxjs-interop#error-and-completion\n - guide/rxjs-interop#initial-values\n - guide/rxjs-interop#initialvalue-選項\n - guide/rxjs-interop#injection-context\n - guide/rxjs-interop#manualcleanup\n - guide/rxjs-interop#requiresync-選項\n - guide/rxjs-interop#rxjs-interop\n - guide/rxjs-interop#rxjs-互操作\n - guide/rxjs-interop#the-initialvalue-option\n - guide/rxjs-interop#the-requiresync-option\n - guide/rxjs-interop#timing-of-toobservable\n - guide/rxjs-interop#toobservable\n - guide/rxjs-interop#toobservable-的時序\n - guide/rxjs-interop#tosignal\n - guide/rxjs-interop#undefined-initial-values\n - guide/rxjs-interop#undefined-初始值\n - guide/rxjs-interop#出錯與結束\n - guide/rxjs-interop#初始值\n - guide/rxjs-interop#注入上下文\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/rxjs-interop.md?message=docs%3A%20請簡述你的修改...\n-->"}