{"id":"guide/directive-composition-api","title":"Directive composition API","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/directive-composition-api.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"directive-composition-api\" translation-result=\"on\">指令組合 API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-composition-api\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Directive composition API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-composition-api\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">Angular 指令提供了一種封裝可複用行為的好方法 —— 指令可以將屬性、CSS 類和事件偵聽器應用於元素。</p><p translation-origin=\"off\">Angular directives offer a great way to encapsulate reusable behaviors— directives can apply\nattributes, CSS classes, and event listeners to an element.</p>\n\n<p translation-result=\"on\"><em>指令組合 API</em> 允許你從元件的 TypeScript 類<strong>內部</strong>將指令應用於元件的宿主元素。</p><p translation-origin=\"off\">The <em>directive composition API</em> lets you apply directives to a component's host element from\n<em>within</em> the component TypeScript class.</p>\n\n<h2 id=\"adding-directives-to-a-component\" translation-result=\"on\">向元件新增指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-a-component\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Adding directives to a component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-a-component\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以透過將 <code>hostDirectives</code> 屬性新增到元件的裝飾器來將指令應用於元件。我們稱這樣的指令為<em>宿主指令</em>。</p><p translation-origin=\"off\">You apply directives to a component by adding a <code>hostDirectives</code> property to a component's\ndecorator. We call such directives <em>host directives</em>.</p>\n\n<p translation-result=\"on\">在此範例中，我們將指令 <code>MenuBehavior</code> 應用於 <code>AdminMenu</code> 的宿主元素。這類似於將 <code>MenuBehavior</code> 應用於範本中的 <code>&lt;admin-menu&gt;</code> 元素。</p><p translation-origin=\"off\">In this example, we apply the directive <code>MenuBehavior</code> to the host element of <code>AdminMenu</code>. This\nworks similarly to applying the <code>MenuBehavior</code> to the <code>&lt;admin-menu&gt;</code> element in a template.</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n</code-example>\n<p translation-result=\"on\">當框架渲染元件時，Angular 還會建立每個宿主指令的例項。指令的宿主繫結被應用於元件的宿主元素。預設情況下，宿主指令的輸入和輸出不會作為元件公共 API 的一部分公開。有關更多資訊，請參閱下面的<a href=\"guide/directive-composition-api#including-inputs-and-outputs\">包含輸入屬性和輸出屬性</a>。</p><p translation-origin=\"off\">When the framework renders a component, Angular also creates an instance of each host directive. The\ndirectives' host bindings apply to the component's host element. By default, host directive inputs\nand outputs are not exposed as part of the component's public API. See\n<a href=\"guide/directive-composition-api#including-inputs-and-outputs\">Including inputs and outputs</a> below for more information.</p>\n\n<p translation-result=\"on\"><strong>Angular 會在編譯時靜態應用宿主指令</strong>。你不能在執行時動態新增指令。</p><p translation-origin=\"off\"><strong>Angular applies host directives statically at compile time.</strong> You cannot dynamically add\ndirectives at runtime.</p>\n\n<p translation-result=\"on\"><strong><code>hostDirectives</code> 中使用的指令必須是 <code>standalone: true</code> 的。</strong></p><p translation-origin=\"off\"><strong>Directives used in <code>hostDirectives</code> must be <code>standalone: true</code>.</strong></p>\n\n<p translation-result=\"on\"><strong>Angular 會忽略 <code>hostDirectives</code> 屬性中所應用的那些指令的 <code>selector</code>。</strong></p><p translation-origin=\"off\"><strong>Angular ignores the <code>selector</code> of directives applied in the <code>hostDirectives</code> property.</strong></p>\n\n<h2 id=\"including-inputs-and-outputs\" translation-result=\"on\">包含輸入屬性和輸出屬性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#including-inputs-and-outputs\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Including inputs and outputs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#including-inputs-and-outputs\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">預設情況下，當你將 <code>hostDirectives</code> 應用於元件時，宿主指令的輸入屬性和輸出屬性不會包含在元件的 API 中。你可以透過擴充 <code>hostDirectives</code> 中的條目來在元件的 API 中顯式包含輸入和輸出：</p><p translation-origin=\"off\">When you apply <code>hostDirectives</code> to your component, the inputs and outputs from the host directives\nare not included in your component's API by default. You can explicitly include inputs and outputs\nin your component's API by expanding the entry in <code>hostDirectives</code>:</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId'],\n    outputs: ['menuClosed'],\n  }],\n})\nexport class AdminMenu { }\n</code-example>\n<p translation-result=\"on\">透過顯式指定輸入和輸出，使用 <code>hostDirective</code> 的元件的使用者可以將它們繫結在範本中：</p><p translation-origin=\"off\">By explicitly specifying the inputs and outputs, consumers of the component with <code>hostDirective</code> can\nbind them in a template:</p>\n\n<code-example language=\"html\">\n&lt;admin-menu menuId=\"top-menu\" (menuClosed)=\"logMenuClosed()\"&gt;\n</code-example>\n<p translation-result=\"on\">此外，你可以為 <code>hostDirective</code> 的輸入和輸出起別名來自訂元件的 API：</p><p translation-origin=\"off\">Furthermore, you can alias inputs and outputs from <code>hostDirective</code> to customize the API of your\ncomponent:</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId: id'],\n    outputs: ['menuClosed: closed'],\n  }],\n})\nexport class AdminMenu { }\n</code-example>\n<code-example language=\"html\">\n&lt;admin-menu id=\"top-menu\" (closed)=\"logMenuClosed()\"&gt;\n</code-example>\n<h2 id=\"adding-directives-to-another-directive\" translation-result=\"on\">將指令新增到另一個指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-another-directive\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Adding directives to another directive<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-another-directive\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">除了元件之外，你還可以將 <code>hostDirectives</code> 新增到其他指令。這啟用了多個行為的可傳遞聚合能力。</p><p translation-origin=\"off\">You can also add <code>hostDirectives</code> to other directives, in addition to components. This enables the\ntransitive aggregation of multiple behaviors.</p>\n\n<p translation-result=\"on\">在以下範例中，我們定義了兩個指令，<code>Menu</code> 和 <code>Tooltip</code>。然後，我們會在 <code>MenuWithTooltip</code> 中組合這兩個指令的行為。最後，我們將 <code>MenuWithTooltip</code> 應用到 <code>SpecializedMenuWithTooltip</code> 上。</p><p translation-origin=\"off\">In the following example, we define two directives, <code>Menu</code> and <code>Tooltip</code>. We then compose the behavior\nof these two directives in <code>MenuWithTooltip</code>. Finally, we apply <code>MenuWithTooltip</code>\nto <code>SpecializedMenuWithTooltip</code>.</p>\n\n<p translation-result=\"on\">在範本中使用 <code>SpecializedMenuWithTooltip</code> 時，它會建立 <code>Menu</code>、<code>Tooltip</code> 和 <code>MenuWithTooltip</code> 的所有例項。這些指令的宿主繫結中的每一個都會應用於 <code>SpecializedMenuWithTooltip</code> 的宿主元素。</p><p translation-origin=\"off\">When <code>SpecializedMenuWithTooltip</code> is used in a template, it creates instances of all of <code>Menu</code>\n, <code>Tooltip</code>, and <code>MenuWithTooltip</code>. Each of these directives' host bindings apply to the host\nelement of <code>SpecializedMenuWithTooltip</code>.</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Menu { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Tooltip { }\n\n// MenuWithTooltip can compose behaviors from <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> other directives\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  hostDirectives: [Tooltip, Menu],\n})\nexport class MenuWithTooltip { }\n\n// CustomWidget can apply the already-composed behaviors from MenuWithTooltip\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  hostDirectives: [MenuWithTooltip],\n})\nexport class SpecializedMenuWithTooltip { }\n</code-example>\n<h2 id=\"host-directive-semantics\" translation-result=\"on\">宿主指令語義<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#host-directive-semantics\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Host directive semantics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#host-directive-semantics\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"directive-execution-order\" translation-result=\"on\">指令的執行順序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-execution-order\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Directive execution order<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-execution-order\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">宿主指令和直接在範本中使用的元件和指令會經歷相同的生命週期。但是，宿主指令總是會在應用它們的元件或指令<em>之前</em>執行它們的建構函式、生命週期鉤子和繫結。</p><p translation-origin=\"off\">Host directives go through the same lifecycle as components and directives used directly in a\ntemplate. However, host directives always execute their constructor, lifecycle hooks, and bindings <em>\nbefore</em> the component or directive on which they are applied.</p>\n\n<p translation-result=\"on\">以下範例顯示了宿主指令的最小化使用：</p><p translation-origin=\"off\">The following example shows minimal use of a host directive:</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n</code-example>\n<p translation-result=\"on\">這裡的執行順序是：</p><p translation-origin=\"off\">The order of execution here is:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\"><code>MenuBehavior</code> 例項化</p><p translation-origin=\"off\"><code>MenuBehavior</code> instantiated</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>AdminMenu</code> 例項化</p><p translation-origin=\"off\"><code>AdminMenu</code> instantiated</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>MenuBehavior</code> 接收輸入（ <code>ngOnInit</code> ）</p><p translation-origin=\"off\"><code>MenuBehavior</code> receives inputs (<code>ngOnInit</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>AdminMenu</code> 接收輸入（<code>ngOnInit</code>）</p><p translation-origin=\"off\"><code>AdminMenu</code> receives inputs (<code>ngOnInit</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>MenuBehavior</code> 應用宿主繫結</p><p translation-origin=\"off\"><code>MenuBehavior</code> applies host bindings</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>AdminMenu</code> 應用宿主繫結</p><p translation-origin=\"off\"><code>AdminMenu</code> applies host bindings</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">這種操作順序意味著帶有 <code>hostDirectives</code> 的元件可以改寫（override）宿主指令指定的任何宿主繫結。</p><p translation-origin=\"off\">This order of operations means that components with <code>hostDirectives</code> can override any host bindings\nspecified by a host directive.</p>\n\n<p translation-result=\"on\">展開宿主指令的巢狀(Nesting)鏈的操作順序，如下例所示。</p><p translation-origin=\"off\">This order of operations extends to nested chains of host directives, as shown in the following\nexample.</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Tooltip { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  hostDirectives: [Tooltip],\n})\nexport class CustomTooltip { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  hostDirectives: [CustomTooltip],\n})\nexport class EvenMoreCustomTooltip { }\n</code-example>\n<p translation-result=\"on\">在上面的範例中，執行順序是：</p><p translation-origin=\"off\">In the example above, the order of execution is:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\"><code>Tooltip</code> 例項化</p><p translation-origin=\"off\"><code>Tooltip</code> instantiated</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>CustomTooltip</code> 例項化</p><p translation-origin=\"off\"><code>CustomTooltip</code> instantiated</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>EvenMoreCustomTooltip</code> 例項化</p><p translation-origin=\"off\"><code>EvenMoreCustomTooltip</code> instantiated</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>Tooltip</code> 接收輸入（<code>ngOnInit</code>）</p><p translation-origin=\"off\"><code>Tooltip</code> receives inputs (<code>ngOnInit</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>CustomTooltip</code> 接收輸入（<code>ngOnInit</code>）</p><p translation-origin=\"off\"><code>CustomTooltip</code> receives inputs (<code>ngOnInit</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>EvenMoreCustomTooltip</code> 接收輸入（<code>ngOnInit</code>）</p><p translation-origin=\"off\"><code>EvenMoreCustomTooltip</code> receives inputs (<code>ngOnInit</code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>Tooltip</code> 應用宿主繫結</p><p translation-origin=\"off\"><code>Tooltip</code> applies host bindings</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>CustomTooltip</code> 應用宿主繫結</p><p translation-origin=\"off\"><code>CustomTooltip</code> applies host bindings</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>EvenMoreCustomTooltip</code> 應用宿主繫結</p><p translation-origin=\"off\"><code>EvenMoreCustomTooltip</code> applies host bindings</p>\n\n</li>\n</ol>\n<h3 id=\"dependency-injection\" translation-result=\"on\">依賴注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#dependency-injection\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Dependency injection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#dependency-injection\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">指定了 <code>hostDirectives</code> 的元件或指令可以注入這些宿主指令的例項，反之亦然。</p><p translation-origin=\"off\">A component or directive that specifies <code>hostDirectives</code> can inject the instances of those host\ndirectives and vice versa.</p>\n\n<p translation-result=\"on\">當把宿主指令應用於元件時，元件和宿主指令都可以定義提供者。</p><p translation-origin=\"off\">When applying host directives to a component, both the component and host directives can define\nproviders.</p>\n\n<p translation-result=\"on\">如果帶有 <code>hostDirectives</code> 的元件或指令以及這些宿主指令都提供相同的注入令牌，則帶有 <code>hostDirectives</code> 的類定義的提供者會優先於宿主指令定義的提供者。</p><p translation-origin=\"off\">If a component or directive with <code>hostDirectives</code> and those host directives both provide the same\ninjection token, the providers defined by class with <code>hostDirectives</code> take precedence over providers\ndefined by the host directives.</p>\n\n<h3 id=\"performance\" translation-result=\"on\">效能<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#performance\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Performance<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#performance\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">雖然指令組合 API 提供了一個強大的工具來複用常見行為，但過度使用宿主指令會影響應用程式的記憶體使用。如果你建立使用<em>許多個</em>宿主指令的元件或指令，你可能會無意中讓應用程式佔用的記憶體膨脹。</p><p translation-origin=\"off\">While the directive composition API offers a powerful tool for reusing common behaviors, excessive\nuse of host directives can impact your application's memory use. If you create components or\ndirectives that use <em>many</em> host directives, you may inadvertently balloon the memory used by your\napplication.</p>\n\n<p translation-result=\"on\">以下範例顯示了一個應用多個宿主指令的元件。</p><p translation-origin=\"off\">The following example shows a component that applies several host directives.</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  hostDirectives: [\n    DisabledState,\n    RequiredState,\n    ValidationState,\n    ColorState,\n    RippleBehavior,\n  ],\n})\nexport class CustomCheckbox { }\n</code-example>\n<p translation-result=\"on\">此範例聲明瞭一個自訂複選框元件，其中包含五個宿主指令。這意味著每次 <code>CustomCheckbox</code> 渲染時，Angular 將建立六個物件 —— 元件用一個，每個宿主指令用一個。對於頁面上的少量複選框，這不會構成任何重大問題。但是，如果你的頁面渲染<em>數百個</em>複選框（例如在表格中），那麼你可能會開始看到額外物件分配的影響。始終確保對你的應用程式進行效能剖析，以便為你的使用案例確定正確的組合模式。</p><p translation-origin=\"off\">This example declares a custom checkbox component that includes five host directives. This\nmeans that Angular will create six objects each time a <code>CustomCheckbox</code> renders— one for the\ncomponent and one for each host directive. For a few checkboxes on a page, this won't pose any\nsignificant issues. However, if your page renders <em>hundreds</em> of checkboxes, such as in a table, then\nyou could start to see an impact of the additional object allocations. Always be sure to profile\nyour application to determine the right composition pattern for your use case.</p>\n\n\n  <div class=\"reviewed\">最後複查時間：12/11/2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/Directive\n - api/forms/SelectMultipleControlValueAccessor\n - guide/directive-composition-api#adding-directives-to-a-component\n - guide/directive-composition-api#adding-directives-to-another-directive\n - guide/directive-composition-api#dependency-injection\n - guide/directive-composition-api#directive-composition-api\n - guide/directive-composition-api#directive-execution-order\n - guide/directive-composition-api#host-directive-semantics\n - guide/directive-composition-api#including-inputs-and-outputs\n - guide/directive-composition-api#performance\n - guide/directive-composition-api#依賴注入\n - guide/directive-composition-api#包含輸入屬性和輸出屬性\n - guide/directive-composition-api#向元件新增指令\n - guide/directive-composition-api#宿主指令語義\n - guide/directive-composition-api#將指令新增到另一個指令\n - guide/directive-composition-api#效能\n - guide/directive-composition-api#指令的執行順序\n - guide/directive-composition-api#指令組合-api\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/directive-composition-api.md?message=docs%3A%20請簡述你的修改...\n-->"}