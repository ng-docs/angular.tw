{"id":"guide/upgrade","title":"Upgrading from AngularJS to Angular","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/upgrade.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"upgrading-from-angularjs-to-angular\" translation-result=\"on\">從 AngularJS 升級到 Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-from-angularjs-to-angular\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Upgrading from AngularJS to Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-from-angularjs-to-angular\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\"><em>Angular</em>是現在和未來的 Angular 名稱。</p><p translation-origin=\"off\"><em>Angular</em> is the name for the Angular of today and tomorrow.</p>\n\n<p translation-result=\"on\"><em>AngularJS</em>是所有 1.x 版本的 Angular 的名稱。</p><p translation-origin=\"off\"><em>AngularJS</em> is the name for all 1.x versions of Angular.</p>\n\n<p translation-result=\"on\">有很多大型 AngularJS 應用。在遷移到 Angular 之前，請始終考慮其業務案例。該案例的一個重要部分是遷移的時間和精力。本指南描述了用於將 AngularJS 專案高效遷移到 Angular 平台的內建工具，一次一個。</p><p translation-origin=\"off\">AngularJS applications are great.\nAlways consider the business case before moving to Angular.\nAn important part of that case is the time and effort to get there.\nThis guide describes the built-in tools for efficiently migrating AngularJS projects over to the Angular platform, a piece at a time.</p>\n\n<p translation-result=\"on\">有些應用可能比其它的升級起來簡單，還有一些方法能讓把這項工作變得更簡單。即使在正式開始升級過程之前，可以提前準備 AngularJS 的程式，讓它向 Angular 看齊。這些準備步驟幾乎都是關於如何讓程式碼更加松耦合、更有可維護性，以及用現代開發工具提高速度的。這意味著，這種準備工作不僅能讓最終的升級變得更簡單，而且還能提升 AngularJS 程式的品質。</p><p translation-origin=\"off\">Some applications will be easier to upgrade than others, and there are many ways to make it easier for yourself.\nIt is possible to prepare and align AngularJS applications with Angular even before beginning the upgrade process.\nThese preparation steps are all about making the code more decoupled, more maintainable, and better aligned with modern development tools.\nThat means in addition to making the upgrade easier, you will also improve the existing AngularJS applications.</p>\n\n<p translation-result=\"on\">成功升級的關鍵之一是增量式的實現它，透過在同一個應用中一起執行這兩個框架，並且逐個把 AngularJS 的元件遷移到 Angular 中。這意味著可以在不必打斷其它業務的前提下，升級更大、更復雜的應用程式，因為這項工作可以多人協作完成，在一段時間內逐漸鋪開。Angular <code>upgrade</code> 模組的設計目標就是讓你漸進、無縫的完成升級。</p><p translation-origin=\"off\">One of the keys to a successful upgrade is to do it incrementally, by running the two frameworks side by side in the same application, and porting AngularJS components to Angular one by one.\nThis makes it possible to upgrade even large and complex applications without disrupting other business, because the work can be done collaboratively and spread over a period of time.\nThe <code>upgrade</code> module in Angular has been designed to make incremental upgrading seamless.</p>\n\n<h2 id=\"preparation\" translation-result=\"on\">準備工作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#preparation\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Preparation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#preparation\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">AngularJS 應用程式的組織方式有很多種。當你想把它們升級到 Angular 的時候，有些做起來會比其它的更容易些。即使在開始升級之前，也有一些關鍵的技術和模式可以讓你將來升級時更輕鬆。</p><p translation-origin=\"off\">There are many ways to structure AngularJS applications.\nWhen you begin to upgrade these applications to Angular, some will turn out to be much easier to work with than others.\nThere are a few key techniques and patterns that you can apply to future-proof applications even before you begin the migration.</p>\n\n<h3 id=\"follow-the-angularjs-style-guide\" translation-result=\"on\">遵循 AngularJS 風格指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#follow-the-angularjs-style-guide\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Follow the AngularJS Style Guide<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#follow-the-angularjs-style-guide\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\" title=\"Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">AngularJS 風格指南</a>收集了一些已證明能寫出乾淨且可維護的 AngularJS 程式的模式與實踐。\n它包含了很多關於如何書寫和組織 AngularJS 程式碼的有價值資訊，同樣重要的是，<strong>不應該</strong>採用的書寫和組織 AngularJS 程式碼的方式。</p><p translation-origin=\"off\">The <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\" title=\"Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">AngularJS Style Guide</a> collects patterns and practices that have been proven to result in cleaner and more maintainable AngularJS applications.\nIt contains a wealth of information about how to write and organize AngularJS code —and equally importantly— how <strong>not</strong> to write and organize AngularJS code.</p>\n\n<p translation-result=\"on\">Angular 是一個基於 AngularJS 中最好的部分構思出來的版本。在這種意義上，它的目標和 AngularJS 風格指南是一樣的：保留 AngularJS 中好的部分，去掉壞的部分。當然，Angular 還做了更多。說這些的意思是：<em>遵循這個風格指南可以讓你寫出更接近 Angular 程式的 AngularJS 程式</em>。</p><p translation-origin=\"off\">Angular is a reimagined version of the best parts of AngularJS.\nIn that sense, its goals are the same as the Style Guide for AngularJS:\nTo preserve the good parts of AngularJS, and to avoid the bad parts.\nThere is a lot more to Angular than that of course, but this does mean that <em>following the style guide helps make your AngularJS application more closely aligned with Angular</em>.</p>\n\n<p translation-result=\"on\">有一些特別的規則可以讓使用 Angular 的 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 模組進行<em>增量升級</em>變得更簡單：</p><p translation-origin=\"off\">There are a few rules in particular that will make it much easier to do <em>an incremental upgrade</em> using the Angular <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> module:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">規則</nt-wrapper><nt-wrapper translation-origin=\"off\">Rules</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\" title=\"Single Responsibility - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">單一規則</a></nt-wrapper><nt-wrapper translation-origin=\"off\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\" title=\"Single Responsibility - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Rule of 1</a></nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">每個檔案應該只放一個元件。這不僅讓元件更容易瀏覽和查詢，而且還讓你能逐個遷移它們的語言和框架。在這個範例程式中，每個控制器、工廠和過濾器都位於各自的原始檔中。</nt-wrapper><nt-wrapper translation-origin=\"off\">There should be one component per file. This not only makes components easy to navigate and find, but will also allow us to migrate them between languages and frameworks one at a time. In this example application, each controller, component, service, and filter is in its own source file.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\" title=\"Folders-by-Feature Structure - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">按特性分目錄的結構</a> <br> <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\" title=\"Modularity - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">模組化</a></nt-wrapper><nt-wrapper translation-origin=\"off\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\" title=\"Folders-by-Feature Structure - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Folders-by-Feature Structure</a> <br> <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\" title=\"Modularity - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Modularity</a></nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在較高的抽象層定義了一些相似的原則：應用程式中的不同部分應該被分到不同的目錄和 NgModule 中。</nt-wrapper><nt-wrapper translation-origin=\"off\">Define similar principles on a higher level of abstraction: Different parts of the application should reside in different directories and NgModules.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">如果應用程式能用這種方式把每個特性分到一個獨立目錄中，它也就能每次遷移一個特性。對於那些還沒有這麼做的程式，強烈建議把應用這條規則作為準備步驟。而且這也不僅僅對升級有價值，它還是一個通用的規則，可以讓你的程式更“堅實”。</p><p translation-origin=\"off\">When an application is laid out feature per feature in this way, it can also be migrated one feature at a time.\nFor applications that don't already look like this, applying the rules in the AngularJS style guide is a highly recommended preparation step.\nAnd this is not just for the sake of the upgrade - it is just solid advice in general!</p>\n\n<h3 id=\"using-a-module-loader\" translation-result=\"on\">使用模組載入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-a-module-loader\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Using a Module Loader<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-a-module-loader\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當你把應用程式碼分解到每個檔案中只放一個元件的粒度後，通常會得到一個由大量相對較小的檔案組成的專案結構。這比組織成少量大檔案要整潔得多，但如果你不得不透過 <code>&lt;script&gt;</code> 標籤在 HTML 頁面中載入所有這些檔案，那就不好玩了。尤其是當你不得不自己按正確的順序維護這些標籤時更是如此，就要開始使用<em>模組載入器</em>了。</p><p translation-origin=\"off\">When you break application code down into one component per file, you often end up with a project structure with a large number of relatively small files.\nThis is a much neater way to organize things than a small number of large files, but it doesn't work that well if you have to load all those files to the HTML page with <code>&lt;script&gt;</code> tags.\nEspecially when you also have to maintain those tags in the correct order.\nThat is why it is a good idea to start using a <em>module loader</em>.</p>\n\n<p translation-result=\"on\">使用模組載入器，比如<a href=\"https://github.com/systemjs/systemjs\" title=\"systemjs/systemjs | GitHub\">SystemJS</a>、\n<a href=\"https://webpack.github.io\" title=\"webpack module bundler | GitHub\">Webpack</a>或<a href=\"http://browserify.org\" title=\"Browserify\">Browserify</a>，\n可以讓你在程式中使用 TypeScript 或 ES2015 語言內建的模組系統。\n你可以使用 <code>import</code> 和 <code>export</code> 特性來明確指定哪些程式碼應該以及將會被在程式的不同部分之間共享。\n對於 ES5 程式來說，可以改用 CommonJS 風格的 <code>require</code> 和 <code>module.exports</code> 特性代替。\n無是論哪種情況，模組載入器都會按正確的順序載入程式中用到的所有程式碼。</p><p translation-origin=\"off\">Using a module loader such as <a href=\"https://github.com/systemjs/systemjs\" title=\"systemjs/systemjs | GitHub\">SystemJS</a>, <a href=\"https://webpack.github.io\" title=\"webpack module bundler | GitHub\">Webpack</a>, or <a href=\"http://browserify.org\" title=\"Browserify\">Browserify</a> allows us to use the built-in module systems of TypeScript or ES2015.\nYou can use the <code>import</code> and <code>export</code> features that explicitly specify what code can and will be shared between different parts of the application.\nFor ES5 applications you can use CommonJS style <code>require</code> and <code>module.exports</code> features.\nIn both cases, the module loader will then take care of loading all the code the application needs in the correct order.</p>\n\n<p translation-result=\"on\">當要把應用程式投入生產環境時，模組載入器也會讓你把所有這些檔案打成完整的產品包變得容易一些。</p><p translation-origin=\"off\">When moving applications into production, module loaders also make it easier to package them all up into production bundles with batteries included.</p>\n\n<h3 id=\"migrating-to-typescript\" translation-result=\"on\">遷移到 TypeScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#migrating-to-typescript\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Migrating to TypeScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#migrating-to-typescript\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 升級計劃的一部分是引入 TypeScript，即使在開始升級之前，引入 TypeScript 編譯器也是有意義的。這意味著等真正升級的時候需要學習和思考的東西會更少，並且你可以在 AngularJS 程式碼中開始使用 TypeScript 的特性。</p><p translation-origin=\"off\">If part of the Angular upgrade plan is to also take TypeScript into use, it makes sense to bring in the TypeScript compiler even before the upgrade itself begins.\nThis means there is one less thing to learn and think about during the actual upgrade.\nIt also means you can start using TypeScript features in your AngularJS code.</p>\n\n<p translation-result=\"on\">TypeScript 是 ECMAScript 2015 的超集，而 ES2015 又是 ECMAScript 5 的超集。這意味著除了安裝一個 TypeScript 編譯器，並把檔名都從 <code>*.js</code> 改成 <code>*.ts</code> 之外，其實什麼都不用做。當然，如果僅僅這樣做也沒什麼大用，也沒什麼有意思的地方。下面這些額外的步驟可以讓你打起精神：</p><p translation-origin=\"off\">Since TypeScript is a superset of ECMAScript 2015, which in turn is a superset of ECMAScript 5, \"switching\" to TypeScript doesn't necessarily require anything more than installing the TypeScript compiler and renaming files from <code>*.js</code> to <code>*.ts</code>.\nBut just doing that is not hugely useful or exciting, of course.\nAdditional steps like the following can give us much more bang for the buck:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">對那些使用了模組載入器的程式，TypeScript 的匯入和匯出語法（實際上是 ECMAScript 2015 的匯入和匯出）可以把程式碼組織成模組。</p><p translation-origin=\"off\">For applications that use a module loader, TypeScript imports and exports (which are really ECMAScript 2015 imports and exports) can be used to organize code into modules.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">可以逐步把型別註解新增到現有函式和變數上，以固定它們的型別，並獲得其優點：比如編譯期錯誤檢查、更好的支援自動完成，以及內聯式文件等。</p><p translation-origin=\"off\">Type annotations can be gradually added to existing functions and variables to pin down their types and get benefits like build-time error checking, great autocompletion support and inline documentation.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">那些 ES2015 中新增的特性，比如箭頭函式、<code>let</code>、<code>const</code>、預設函式引數、解構賦值等也可以逐漸新增進來，讓程式碼更有表現力。</p><p translation-origin=\"off\">JavaScript features new to ES2015, like arrow functions, <code>let</code>s and <code>const</code>s, default function parameters, and destructuring assignments can also be gradually added to make the code more expressive.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">服務和控制器可以轉成<em>類</em>。這樣它們就能一步步接近 Angular 的服務和元件類了，也會讓升級變得簡單一點。</p><p translation-origin=\"off\">Services and controllers can be turned into <em>classes</em>.\nThat way they'll be a step closer to becoming Angular service and component classes, which will make life easier after the upgrade.</p>\n\n</li>\n</ul>\n<h3 id=\"using-component-directives\" translation-result=\"on\">使用元件型指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-component-directives\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Using Component Directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-component-directives\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 Angular 中，元件是用來建構使用者介面的主要元素。你把 UI 中的不同部分定義成元件，然後在範本中使用這些元件合成出最終的 UI。</p><p translation-origin=\"off\">In Angular, components are the main primitive from which user interfaces are built.\nYou define the different portions of the UI as components and compose them into a full user experience.</p>\n\n<p translation-result=\"on\">你在 AngularJS 中也能這麼做。那就是一種定義了自己的範本、控制器和輸入/輸出繫結的指令 —— 跟 Angular 中對元件的定義是一樣的。要遷移到 Angular，透過元件型指令建構的應用程式會比直接用 <code>ng-controller</code>、<code>ng-include</code> 和作用域繼承等底層特性建構的要容易得多。</p><p translation-origin=\"off\">You can also do this in AngularJS, using <em>component directives</em>.\nThese are directives that define their own templates, controllers, and input/output bindings - the same things that Angular components define.\nApplications built with component directives are much easier to migrate to Angular than applications built with lower-level features like <code>ng-controller</code>,  <code>ng-include</code>, and scope inheritance.</p>\n\n<p translation-result=\"on\">要與 Angular 相容，AngularJS 的元件型指令應該配置下列屬性：</p><p translation-origin=\"off\">To be Angular compatible, an AngularJS component directive should configure these attributes:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">屬性</nt-wrapper><nt-wrapper translation-origin=\"off\">Attributes</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>restrict: 'E'</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元件通常會以元素的方式使用。</nt-wrapper><nt-wrapper translation-origin=\"off\">Components are usually used as elements.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>scope: {}</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">一個獨立作用域。在 Angular 中，元件永遠是從它們的環境中被隔離出來的，在 AngularJS 中也同樣如此。</nt-wrapper><nt-wrapper translation-origin=\"off\">An isolate scope. In Angular, components are always isolated from their surroundings, and you should do this in AngularJS too.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>bindToController: {}</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元件的輸入和輸出應該繫結到控制器，而不是 <code>$scope</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Component inputs and outputs should be bound to the controller instead of using the <code>$scope</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>controller</code> <br> <code>controllerAs</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元件要有自己的控制器。</nt-wrapper><nt-wrapper translation-origin=\"off\">Components have their own controllers.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>template</code> <br> <code>templateUrl</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元件要有自己的範本。</nt-wrapper><nt-wrapper translation-origin=\"off\">Components have their own templates.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">元件型指令還可能使用下列屬性：</p><p translation-origin=\"off\">Component directives may also use the following attributes:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">屬性</nt-wrapper><nt-wrapper translation-origin=\"off\">Attributes</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>transclude: true/{}</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果元件需要從其它地方透傳內容，就設定它。</nt-wrapper><nt-wrapper translation-origin=\"off\">If the component needs to transclude content from elsewhere.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>require</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果元件需要和父元件的控制器通訊，就設定它。</nt-wrapper><nt-wrapper translation-origin=\"off\">If the component needs to communicate with the controller of some parent component.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">元件型指令<strong>不能</strong>使用下列屬性：</p><p translation-origin=\"off\">Component directives <strong>should not</strong> use the following attributes:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">不能使用的屬性</nt-wrapper><nt-wrapper translation-origin=\"off\">Attributes (avoid)</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>compile</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">Angular 不再支援它。</nt-wrapper><nt-wrapper translation-origin=\"off\">This will not be supported in Angular.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>replace: true</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">Angular 永遠不會用元件範本替換一個元件元素。這個特性在 AngularJS 中也同樣不建議使用了。</nt-wrapper><nt-wrapper translation-origin=\"off\">Angular never replaces a component element with the component template. This attribute is also deprecated in AngularJS.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>priority</code> <br> <code>terminal</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">雖然 AngularJS 的元件可能使用這些，但它們在 Angular 中已經沒用了，並且最好不要再寫依賴它們的程式碼。</nt-wrapper><nt-wrapper translation-origin=\"off\">While AngularJS components may use these, they are not used in Angular and it is better not to write code that relies on them.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">AngularJS 中一個完全向 Angular 架構對齊過的元件型指令是這樣的：</p><p translation-origin=\"off\">An AngularJS component directive that is fully aligned with the Angular architecture may look something like this:</p>\n\n<code-example header=\"hero-detail.directive.ts\" path=\"upgrade-module/src/app/hero-detail.directive.ts\">\nexport function heroDetailDirective() {\n  return {\n    restrict: 'E',\n    scope: {},\n    bindToController: {\n      hero: '=',\n      deleted: '&amp;'\n    },\n    template: `\n      &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt;\n      &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt;\n      &lt;button type=\"button\" ng-click=\"$ctrl.onDelete()\"&gt;Delete&lt;/button&gt;\n    `,\n    controller: function HeroDetailController() {\n      this.onDelete = () =&gt; {\n        this.deleted({hero: this.hero});\n      };\n    },\n    controllerAs: '$ctrl'\n  };\n}\n\n\n</code-example>\n<p translation-result=\"on\">AngularJS 1.5 引入了<a href=\"https://docs.angularjs.org/api/ng/type/angular.Module#component\" title=\"component(name, options); - angular.Module | API | AngularJS\">元件 API</a>，它讓定義指令變得更簡單了。\n為元件型指令使用這個 API 是一個好主意，因為：</p><p translation-origin=\"off\">AngularJS 1.5 introduces the <a href=\"https://docs.angularjs.org/api/ng/type/angular.Module#component\" title=\"component(name, options); - angular.Module | API | AngularJS\">component API</a> that makes it easier to define component directives like these.\nIt is a good idea to use this API for component directives for several reasons:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">它需要更少的樣板程式碼。</p><p translation-origin=\"off\">It requires less boilerplate code.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它強制你遵循元件的最佳實踐，比如 <code>controllerAs</code>。</p><p translation-origin=\"off\">It enforces the use of component best practices like <code>controllerAs</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">指令中像 <code>scope</code> 和 <code>restrict</code> 這樣的屬性應該有良好的預設值。</p><p translation-origin=\"off\">It has good default values for directive attributes like <code>scope</code> and <code>restrict</code>.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">如果使用這個元件 API 進行表示，那麼上面看到的元件型指令就變成了這樣：</p><p translation-origin=\"off\">The component directive example from above looks like this when expressed using the component API:</p>\n\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&lt;',\n    deleted: '&amp;'\n  },\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt;\n    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt;\n    &lt;button type=\"button\" ng-click=\"$ctrl.onDelete()\"&gt;Delete&lt;/button&gt;\n  `,\n  controller: function HeroDetailController() {\n    this.onDelete = () =&gt; {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<p translation-result=\"on\">控制器的生命週期鉤子 <code>$onInit()</code>、<code>$onDestroy()</code> 和 <code>$onChanges()</code> 是 AngularJS 1.5 引入的另一些便利特性。\n它們都很像<a href=\"guide/lifecycle-hooks\" title=\"Lifecycle hooks | Angular\">Angular 中的等價物</a>，所以，圍繞它們組織元件生命週期的邏輯在升級到 Angular 時會更容易。</p><p translation-origin=\"off\">Controller lifecycle hook methods <code>$onInit()</code>, <code>$onDestroy()</code>, and <code>$onChanges()</code> are another convenient feature that AngularJS 1.5 introduces.\nThey all have nearly exact <a href=\"guide/lifecycle-hooks\" title=\"Lifecycle hooks | Angular\">equivalents in Angular</a>, so organizing component lifecycle logic around them will ease the eventual Angular upgrade process.</p>\n\n<h2 id=\"upgrading-with-ngupgrade\" translation-result=\"on\">使用 ngUpgrade 升級<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-with-ngupgrade\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Upgrading with ngUpgrade<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-with-ngupgrade\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">不管要升級什麼，Angular 中的 <code>ngUpgrade</code> 庫都會是一個非常有用的工具 —— 除非是小到沒功能的應用。藉助它，你可以在同一個應用程式中混用並匹配 AngularJS 和 Angular 的元件，並讓它們實現無縫的互操作。這意味著你不用被迫一次性做完所有的升級工作，因為在整個演進過程中，這兩個框架可以很自然的和睦相處。</p><p translation-origin=\"off\">The ngUpgrade library in Angular is a very useful tool for upgrading anything but the smallest of applications.\nWith it you can mix and match AngularJS and Angular components in the same application and have them interoperate seamlessly.\nThat means you don't have to do the upgrade work all at once, since there is a natural coexistence between the two frameworks during the transition period.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">由於 <a href=\"https://blog.angular.io/finding-a-path-forward-with-angularjs-7e186fdd4429\" title=\"Finding a Path Forward with AngularJS | Angular Blog\">AngularJS 即將停止維護</a>，ngUpgrade 現在處於特性開發完畢的狀態。我們將會繼續釋出安全補丁和 BUG 修復，直到 2023-12-31。</p><p translation-origin=\"off\">The <a href=\"https://blog.angular.io/finding-a-path-forward-with-angularjs-7e186fdd4429\" title=\"Finding a Path Forward with AngularJS | Angular Blog\">end of life of AngularJS</a> is December 31st, 2021.\nWith this event, ngUpgrade is now in a feature complete state.\nWe will continue publishing security and bug fixes for ngUpgrade at least until December 31st, 2023.</p>\n\n</div>\n<h3 id=\"how-ngupgrade-works\" translation-result=\"on\">ngUpgrade 的工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#how-ngupgrade-works\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">How ngUpgrade Works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#how-ngupgrade-works\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>ngUpgrade</code> 提供的主要工具之一被稱為 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>。這是一個服務，它可以啟動並管理一個能同時支援 Angular 和 AngularJS 的混合式應用。</p><p translation-origin=\"off\">One of the primary tools provided by ngUpgrade is called the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>.\nThis is a module that contains utilities for bootstrapping and managing hybrid applications that support both Angular and AngularJS code.</p>\n\n<p translation-result=\"on\">當使用 ngUpgrade 時，你實際上在<em>同時執行 AngularJS 和 Angular</em>。所有 Angular 的程式碼執行在 Angular 框架中，而 AngularJS 的程式碼執行在 AngularJS 框架中。所有這些都是真實的、全功能的框架版本。沒有進行任何模擬，所以你可以認為同時存在著這兩個框架的所有特性和自然行為。</p><p translation-origin=\"off\">When you use ngUpgrade, what you're really doing is <em>running both AngularJS and Angular at the same time</em>.\nAll Angular code is running in the Angular framework, and AngularJS code in the AngularJS framework.\nBoth of these are the actual, fully featured versions of the frameworks.\nThere is no emulation going on, so you can expect to have all the features and natural behavior of both frameworks.</p>\n\n<p translation-result=\"on\">所有這些事情的背後，本質上是一個框架中管理的元件和服務能和來自另一個框架的進行互操作。這些主要體現在三個方面：依賴注入、DOM 和變更檢測。</p><p translation-origin=\"off\">What happens on top of this is that components and services managed by one framework can interoperate with those from the other framework.\nThis happens in three main areas:\nDependency injection, the DOM, and change detection.</p>\n\n<h4 id=\"dependency-injection\" translation-result=\"on\">依賴注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#dependency-injection\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Dependency Injection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#dependency-injection\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">無論是在 AngularJS 中還是在 Angular 中，依賴注入都位於前沿和中心的位置，但在兩個框架的工作原理上，卻存在著一些關鍵的不同之處。</p><p translation-origin=\"off\">Dependency injection is front and center in both AngularJS and Angular, but there are some key differences between the two frameworks in how it actually works.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">AngularJS</th>\n<th align=\"left\">Angular</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">依賴注入的令牌（Token）永遠是字串（譯註：指服務名稱）。</nt-wrapper><nt-wrapper translation-origin=\"off\">Dependency injection tokens are always strings</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">令牌<a href=\"guide/dependency-injection\" title=\"Dependency injection in Angular | Angular\">可以有不同的型別</a>。<br> 通常是類別。<br>也可能是字串。</nt-wrapper><nt-wrapper translation-origin=\"off\">Tokens <a href=\"guide/dependency-injection\" title=\"Dependency injection in Angular | Angular\">can have different types</a>. <br> They are often classes. <br> They may also be strings.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">只有一個注入器。<br>即使在多模組的應用程式中，每樣東西也都會被裝入一個巨大的名稱空間中。</nt-wrapper><nt-wrapper translation-origin=\"off\">There is exactly one injector. <br> Even in multi-module applications, everything is poured into one big namespace.</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">這是一個<a href=\"guide/hierarchical-dependency-injection\" title=\"Hierarchical injectors | Angular\">樹狀多級注入器</a>：有一個根注入器，而且每個元件也有一個自己的注入器。</nt-wrapper><nt-wrapper translation-origin=\"off\">There is a <a href=\"guide/hierarchical-dependency-injection\" title=\"Hierarchical injectors | Angular\">tree hierarchy of injectors</a>, with a root injector and an additional injector for each component.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">就算有這麼多不同點，也並不妨礙你在依賴注入時進行互操作。<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 解決了這些差異，並讓它們無縫的對接：</p><p translation-origin=\"off\">Even accounting for these differences you can still have dependency injection interoperability.\n<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> resolves the differences and makes everything work seamlessly:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">透過升級它們，你就能讓那些在 AngularJS 中能被注入的服務也可用於 Angular 的程式碼中。在框架之間共享的是服務的同一個單例物件。在 Angular 中，這些外來服務總是被放在<em>根注入器</em>中，並可用於所有元件。它們總是具有<em>字串令牌</em> —— 跟它們在 AngularJS 中的令牌相同。</p><p translation-origin=\"off\">You can make AngularJS services available for injection to Angular code by <em>upgrading</em> them.\nThe same singleton instance of each service is shared between the frameworks.\nIn Angular these services will always be in the <em>root injector</em> and available to all components.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">透過降級它們，你也能讓那些在 Angular 中能被注入的服務在 AngularJS 的程式碼中可用。只有那些來自 Angular 根注入器的服務才能被降級。同樣的，在框架之間共享的是同一個單例物件。當你註冊一個要降級的服務時，要明確指定一個打算在 AngularJS 中使用的<em>字串令牌</em>。</p><p translation-origin=\"off\">You can also make Angular services available for injection to AngularJS code by <em>downgrading</em> them.\nOnly services from the Angular root injector can be downgraded.\nAgain, the same singleton instances are shared between the frameworks.\nWhen you register a downgraded service, you must explicitly specify a <em>string token</em> that you want to use in AngularJS.</p>\n\n</li>\n</ul>\n<div class=\"lightbox\">\n<img alt=\"The two injectors in a hybrid application\" src=\"generated/images/guide/upgrade/injectors.png\" width=\"700\" height=\"262\">\n</div>\n<h4 id=\"components-and-the-dom\" translation-result=\"on\">元件與 DOM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#components-and-the-dom\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Components and the DOM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#components-and-the-dom\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在混合式應用中，同時存在來自 AngularJS 和 Angular 中元件和指令的 DOM。這些元件透過它們各自框架中的輸入和輸出繫結來互相通訊，它們由 ngUpgrade 橋接在一起。它們也能透過共享被注入的依賴彼此通訊，就像前面所說的那樣。</p><p translation-origin=\"off\">In the DOM of a hybrid ngUpgrade application are components and directives from both AngularJS and Angular.\nThese components communicate with each other by using the input and output bindings of their respective frameworks, which ngUpgrade bridges together.\nThey may also communicate through shared injected dependencies, as described above.</p>\n\n<p translation-result=\"on\">理解混合式應用的關鍵在於，DOM 中的每一個元素都只能屬於這兩個框架之一，而另一個框架則會忽略它。如果一個元素屬於 AngularJS，那麼 Angular 就會當它不存在，反之亦然。</p><p translation-origin=\"off\">The key thing to understand about a hybrid application is that every element in the DOM is owned by exactly one of the two frameworks.\nThe other framework ignores it.\nIf an element is owned by AngularJS, Angular treats it as if it didn't exist, and vice versa.</p>\n\n<p translation-result=\"on\">所以，混合式應用總是像 AngularJS 程式那樣啟動，處理根範本的也是 AngularJS. 然後，當這個應用的範本中使用到了 Angular 的元件時，Angular 才開始參與。這個元件的檢視由 Angular 進行管理，而且它還可以使用一系列的 Angular 元件和指令。</p><p translation-origin=\"off\">So normally a hybrid application begins life as an AngularJS application, and it is AngularJS that processes the root template, for example, the index.html.\nAngular then steps into the picture when an Angular component is used somewhere in an AngularJS template.\nThe template of that component will then be managed by Angular, and it may contain any number of Angular components and directives.</p>\n\n<p translation-result=\"on\">更進一步說，你可以按照需要，任意穿插使用這兩個框架。使用下面的兩種方式之一，你可以在這兩個框架之間自由穿梭：</p><p translation-origin=\"off\">Beyond that, you may interleave the two frameworks.\nYou always cross the boundary between the two frameworks by one of two ways:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">透過使用來自另一個框架的元件：AngularJS 的範本中用到了 Angular 的元件，或者 Angular 的範本中使用了 AngularJS 的元件。</p><p translation-origin=\"off\">By using a component from the other framework:\nAn AngularJS template using an Angular component, or an Angular template using an AngularJS component.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">透過透傳（transclude）或投影（project）來自另一個框架的內容。<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 牽線搭橋，把 AngularJS 的透傳概念和 Angular 的內容投影概念關聯起來。</p><p translation-origin=\"off\">By transcluding or projecting content from the other framework.\nngUpgrade bridges the related concepts of AngularJS transclusion and Angular content projection together.</p>\n\n</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"DOM element ownership in a hybrid application\" src=\"generated/images/guide/upgrade/dom.png\" width=\"500\" height=\"294\">\n</div>\n<p translation-result=\"on\">當你使用一個屬於另一個框架的元件時，就會發生一次跨框架邊界的切換。不過，這種切換隻發生在該元件元素的<em>子節點</em>上。考慮一個場景，你從 AngularJS 中使用一個 Angular 元件，就像這樣：</p><p translation-origin=\"off\">Whenever you use a component that belongs to the other framework, a switch between framework boundaries occurs.\nHowever, that switch only happens to the elements in the template of that component.\nConsider a situation where you use an Angular component from AngularJS like this:</p>\n\n<code-example language=\"html\" escape=\"html\">\n\n&lt;a-component&gt;&lt;/a-component&gt;\n\n</code-example>\n<p translation-result=\"on\">此時，<code>&lt;a-component&gt;</code> 這個 DOM 元素仍然由 AngularJS 管理，因為它是在 AngularJS 的範本中定義的。這也意味著你可以往它上面新增別的 AngularJS 指令，卻<em>不能</em>新增 Angular 的指令。只有在 <code>&lt;a-component&gt;</code> 元件的範本中才是 Angular 的天下。同樣的規則也適用於在 Angular 中使用 AngularJS 元件型指令的情況。</p><p translation-origin=\"off\">The DOM element <code>&lt;a-component&gt;</code> will remain to be an AngularJS managed element, because it is defined in an AngularJS template.\nThat also means you can apply additional AngularJS directives to it, but <em>not</em> Angular directives.\nIt is only in the template of the <code>&lt;a-component&gt;</code> where Angular steps in.\nThis same rule also applies when you use AngularJS component directives from Angular.</p>\n\n<h4 id=\"change-detection\" translation-result=\"on\">變更檢測<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#change-detection\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Change Detection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#change-detection\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">AngularJS 中的變更檢測全是關於 <code>scope.$apply()</code> 的。在每個事件發生之後，<code>scope.$apply()</code> 就會被呼叫。這或者由框架自動呼叫，或者在某些情況下由你自己的程式碼手動呼叫。</p><p translation-origin=\"off\">The <code>scope.$apply()</code> is how AngularJS detects changes and updates data bindings.\nAfter every event that occurs, <code>scope.$apply()</code> gets called.\nThis is done either automatically by the framework, or manually by you.</p>\n\n<p translation-result=\"on\">在 Angular 中，事情有點不一樣。雖然變更檢測仍然會在每一個事件之後發生，卻不再需要每次呼叫 <code>scope.$apply()</code> 了。\n這是因為所有 Angular 程式碼都執行在一個叫做 <a href=\"api/core/NgZone\" title=\"NgZone | Core - API | Angular\">Angular zone</a> 的地方。\nAngular 總是知道什麼時候程式碼執行完了，也就知道了它什麼時候應該觸發變更檢測。程式碼本身並不需要呼叫 <code>scope.$apply()</code> 或其它類似的東西。</p><p translation-origin=\"off\">In Angular things are different.\nWhile change detection still occurs after every event, no one needs to call <code>scope.$apply()</code> for that to happen.\nThis is because all Angular code runs inside something called the <a href=\"api/core/NgZone\" title=\"NgZone | Core - API | Angular\">Angular zone</a>.\nAngular always knows when the code finishes, so it also knows when it should kick off change detection.\nThe code itself doesn't have to call <code>scope.$apply()</code> or anything like it.</p>\n\n<p translation-result=\"on\">在這種混合式應用的案例中，<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 在 AngularJS 的方法和 Angular 的方法之間建立了橋樑。發生了什麼呢？</p><p translation-origin=\"off\">In the case of hybrid applications, the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> bridges the AngularJS and Angular approaches.\nHere is what happens:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">應用中發生的每件事都執行在 Angular 的 zone 裡。無論事件發生在 AngularJS 還是 Angular 的程式碼中，都是如此。這個 zone 會在每個事件之後觸發 Angular 的變更檢測。</p><p translation-origin=\"off\">Everything that happens in the application runs inside the Angular zone.\nThis is true whether the event originated in AngularJS or Angular code.\nThe zone triggers Angular change detection after every event.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 將在每一次離開 Angular zone 時呼叫 AngularJS 的 <code>$rootScope.$apply()</code>。這樣也就同樣會在每個事件之後觸發 AngularJS 的變更檢測。</p><p translation-origin=\"off\">The <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> will invoke the AngularJS <code>$rootScope.$apply()</code> after every turn of the Angular zone.\nThis also triggers AngularJS change detection after every event.</p>\n\n</li>\n</ul>\n<div class=\"lightbox\">\n<img alt=\"Change detection in a hybrid application\" src=\"generated/images/guide/upgrade/change_detection.png\" width=\"600\" height=\"163\">\n</div>\n<p translation-result=\"on\">在實踐中，你不用在自己的程式碼中呼叫 <code>$apply()</code>，而不用管這段程式碼是在 AngularJS 還是 Angular 中。<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 都替你做了。你仍然<em>可以</em>呼叫 <code>$apply()</code>，也就是說你不必從現有程式碼中移除此呼叫。在混合式應用中，這些呼叫只會觸發一次額外的 AngularJS 變更檢測。</p><p translation-origin=\"off\">In practice, you do not need to call <code>$apply()</code>, regardless of whether it is in AngularJS or Angular.\nThe <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> does it for us.\nYou <em>can</em> still call <code>$apply()</code> so there is no need to remove such calls from existing code.\nThose calls just trigger additional AngularJS change detection checks in a hybrid application.</p>\n\n<p translation-result=\"on\">當你降級一個 Angular 元件，然後把它用於 AngularJS 中時，元件的輸入屬性就會被 AngularJS 的變更檢測體系監視起來。\n當那些輸入屬性發生變化時，元件中相應的屬性就會被設定。你也能透過實現<a href=\"api/core/OnChanges\" title=\"OnChanges | Core - API | Angular\">OnChanges</a>\n介面來掛鉤到這些更改，就像它未被降級時一樣。</p><p translation-origin=\"off\">When you downgrade an Angular component and then use it from AngularJS, the inputs of the component will be watched using AngularJS change detection.\nWhen those inputs change, the corresponding properties in the component are set.\nYou can also hook into the changes by implementing the <a href=\"api/core/OnChanges\" title=\"OnChanges | Core - API | Angular\">OnChanges</a> interface in the component, just like you could if it hadn't been downgraded.</p>\n\n<p translation-result=\"on\">相應的，當你把 AngularJS 的元件升級給 Angular 使用時，在這個元件型指令的 <code>scope</code>（或 <code>bindToController</code>）中定義的所有繫結，都將被掛鉤到 Angular 的變更檢測體系中。它們將和標準的 Angular 輸入屬性被同等對待，並當它們發生變化時設定回 scope（或控制器）上。</p><p translation-origin=\"off\">Correspondingly, when you upgrade an AngularJS component and use it from Angular, all the bindings defined for <code>scope</code> (or <code>bindToController</code>) of the component directive will be hooked into Angular change detection.\nThey will be treated as regular Angular inputs.\nTheir values will be written to the scope (or controller) of the upgraded component when they change.</p>\n\n<h3 id=\"using-upgrademodule-with-angular-ngmodules\" translation-result=\"on\">透過 Angular 的 <em>NgModule</em> 來使用 UpgradeModule<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-upgrademodule-with-angular-ngmodules\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Using UpgradeModule with Angular <em>NgModules</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-upgrademodule-with-angular-ngmodules\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">AngularJS 和 Angular 都有自己的模組概念，來幫你把應用按功能組織成內聚的程式碼塊。</p><p translation-origin=\"off\">Both AngularJS and Angular have their own concept of modules to help organize an application into cohesive blocks of functionality.</p>\n\n<p translation-result=\"on\">它們在架構和實現的細節上有著顯著的不同。在 AngularJS 中，你要把 AngularJS 的資源新增到 <code>angular.module</code> 屬性上。在 Angular 中，你要建立一個或多個帶有 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 裝飾器的類，這些裝飾器用來在元資料中描述 Angular 資源。差異主要來自這裡。</p><p translation-origin=\"off\">Their details are quite different in architecture and implementation.\nIn AngularJS, you add Angular assets to the <code>angular.module</code> property.\nIn Angular, you create one or more classes adorned with an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator that describes Angular assets in metadata.\nThe differences blossom from there.</p>\n\n<p translation-result=\"on\">在混合式應用中，你同時運行了兩個版本的 Angular。這意味著你至少需要 AngularJS 和 Angular 各提供一個模組。當你使用 AngularJS 的模組進行引導時，就得把 Angular 的模組傳給 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>。</p><p translation-origin=\"off\">In a hybrid application you run both versions of Angular at the same time.\nThat means that you need at least one module each from both AngularJS and Angular.\nYou will import <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> inside the NgModule, and then use it for bootstrapping the AngularJS module.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">要了解更多，請參閱<a href=\"guide/ngmodules\" title=\"NgModules | Angular\">NgModules</a>頁。</p><p translation-origin=\"off\">For more information, see <a href=\"guide/ngmodules\" title=\"NgModules | Angular\">NgModules</a>.</p>\n\n</div>\n<h3 id=\"bootstrapping-hybrid-applications\" translation-result=\"on\">引導混合應用程式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-hybrid-applications\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Bootstrapping hybrid applications<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-hybrid-applications\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要想引導混合式應用，就必須在應用中分別引導 Angular 和 AngularJS 應用的一部分。你必須先引導 Angular，然後再呼叫 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 來引導 AngularJS。</p><p translation-origin=\"off\">To bootstrap a hybrid application, you must bootstrap each of the Angular and\nAngularJS parts of the application.\nYou must bootstrap the Angular bits first and then ask the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> to bootstrap the AngularJS bits next.</p>\n\n<p translation-result=\"on\">在 AngularJS 應用中有一個 AngularJS 的根模組，它用於引導 AngularJS 應用。</p><p translation-origin=\"off\">In an AngularJS application you have a root AngularJS module, which will also be used to bootstrap the AngularJS application.</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"ng1module\">\nangular.module('heroApp', [])\n  .controller('MainCtrl', function() {\n    this.message = 'Hello world';\n  });\n\n</code-example>\n<p translation-result=\"on\">單純的 AngularJS 應用可以在 HTML 頁面中使用 <code>ng-app</code> 指令進行引導，但對於混合式應用你要透過 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 模組進行手動引導。因此，在切換成混合式應用之前，最好先把 AngularJS 改寫成使用 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\"><code>angular.bootstrap</code></a> 進行手動引導的方式。</p><p translation-origin=\"off\">Pure AngularJS applications can be automatically bootstrapped by using an <code>ng-app</code> directive somewhere on the HTML page.\nBut for hybrid applications, you manually bootstrap using the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>.\nTherefore, it is a good preliminary step to switch AngularJS applications to use the manual JavaScript <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\"><code>angular.bootstrap</code></a> method even before switching them to hybrid mode.</p>\n\n<p translation-result=\"on\">比如你現在有這樣一個透過 <code>ng-app</code> 進行引導的應用：</p><p translation-origin=\"off\">Say you have an <code>ng-app</code> driven bootstrap such as this one:</p>\n\n<code-example path=\"upgrade-module/src/index-ng-app.html\">\n&lt;!DOCTYPE HTML&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;base href=\"/\"&gt;\n    &lt;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.5.3/angular.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"app/ajs-ng-app/app.module.js\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n\n  &lt;body ng-app=\"heroApp\" ng-strict-di&gt;\n    &lt;div id=\"message\" ng-controller=\"MainCtrl as mainCtrl\"&gt;\n      {{ mainCtrl.message }}\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n</code-example>\n<p translation-result=\"on\">你可以從 HTML 中移除 <code>ng-app</code> 和 <code>ng-strict-di</code> 指令，改為從 JavaScript 中呼叫 <code>angular.bootstrap</code>，它能達到同樣效果：</p><p translation-origin=\"off\">You can remove the <code>ng-app</code> and <code>ng-strict-di</code> directives from the HTML and instead switch to calling <code>angular.bootstrap</code> from JavaScript, which will result in the same thing:</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"bootstrap\">\nangular.bootstrap(document.body, ['heroApp'], { strictDi: true });\n\n</code-example>\n<p translation-result=\"on\">要想把 AngularJS 應用變成 Hybrid 應用，就要先載入 Angular 框架。\n根據<a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">準備升級到 AngularJS</a> 中給出的步驟，選擇性的把<a href=\"https://github.com/angular/quickstart\" title=\"angular/quickstart | GitHub\">快速入門 GitHub 程式碼倉</a>中的程式碼複製過來。</p><p translation-origin=\"off\">To begin converting your AngularJS application to a hybrid, you need to load the Angular framework.\nYou can see how this can be done with SystemJS by following the instructions in <a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">Setup for Upgrading to AngularJS</a> for selectively copying code from the <a href=\"https://github.com/angular/quickstart\" title=\"angular/quickstart | GitHub\">QuickStart GitHub repository</a>.</p>\n\n<p translation-result=\"on\">你還需要用 <code>npm install @angular/upgrade --save</code> 安裝 <code>@angular/upgrade</code> 套件，並新增一個指向 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 套件的對映：</p><p translation-origin=\"off\">You also need to install the <code>@angular/upgrade</code> package using <code>npm install @angular/upgrade --save</code> and add a mapping for the <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> package:</p>\n\n<code-example header=\"systemjs.config.js (map)\" path=\"upgrade-module/src/systemjs.config.1.js\" region=\"upgrade-static-package\">\n'@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/fesm2022/static.mjs',\n\n</code-example>\n<p translation-result=\"on\">接下來，建立一個 <code>app.module.ts</code> 檔案，並新增下列 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 類：</p><p translation-origin=\"off\">Next, create an <code>app.module.ts</code> file and add the following <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> class:</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"ngmodule\">\nimport { <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">最小化的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 匯入了 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>，它是每個基於瀏覽器的 Angular 應用必備的。它還從 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 中匯入了 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，它匯出了一些服務提供者，這些提供者會用於升級、降級服務和元件。</p><p translation-origin=\"off\">This bare minimum <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> imports <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>, the module every Angular browser-based application must have.\nIt also imports <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> from <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code>, which exports providers that will be used for upgrading and downgrading services and components.</p>\n\n<p translation-result=\"on\">在 <code>AppModule</code> 的建構函式中，使用依賴注入技術獲取了一個 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 例項，並用它在 <code>AppModule.ngDoBootstrap</code> 方法中啟動 AngularJS 應用。\n<code>upgrade.bootstrap</code> 方法接受和 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\">angular.bootstrap</a> 完全相同的引數。</p><p translation-origin=\"off\">In the constructor of the <code>AppModule</code>, use dependency injection to get a hold of the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> instance, and use it to bootstrap the AngularJS application in the <code>AppModule.ngDoBootstrap</code> method.\nThe <code>upgrade.bootstrap</code> method takes the exact same arguments as <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\">angular.bootstrap</a>:</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n你不需要在 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中加入 <code>bootstrap</code> 宣告，因為 AngularJS 控制著該應用的根範本。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nYou do not add a <code>bootstrap</code> declaration to the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator, since AngularJS will own the root template of the application.</p>\n\n</div>\n<p translation-result=\"on\">現在，你就可以使用 <code>platformBrowserDynamic.bootstrapModule</code> 方法來啟動 <code>AppModule</code> 了。</p><p translation-origin=\"off\">Now you can bootstrap <code>AppModule</code> using the <code>platformBrowserDynamic.bootstrapModule</code> method.</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"bootstrap\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n</code-example>\n<p translation-result=\"on\">恭喜！你就要開始執行這個混合式應用了！所有現存的 AngularJS 程式碼會像以前一樣正常工作，但是你現在也同樣可以執行 Angular 程式碼了。</p><p translation-origin=\"off\">Congratulations.\nYou're running a hybrid application.\nThe existing AngularJS code works as before <em>and</em> you're ready to start adding Angular code.</p>\n\n<h3 id=\"using-angular-components-from-angularjs-code\" translation-result=\"on\">從 AngularJS 程式碼中使用 Angular 元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angular-components-from-angularjs-code\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Using Angular Components from AngularJS Code<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angular-components-from-angularjs-code\"><i class=\"material-icons\">link</i></a></h3>\n\n<div class=\"lightbox\">\n<img alt=\"Using an Angular component from AngularJS code\" class=\"left\" src=\"generated/images/guide/upgrade/ajs-to-a.png\" width=\"250\" height=\"44\">\n</div>\n<p translation-result=\"on\">一旦你開始執行混合式應用，你就可以開始逐漸升級程式碼了。一種更常見的工作模式就是在 AngularJS 的上下文中使用 Angular 的元件。該元件可能是全新的，也可能是把原本 AngularJS 的元件用 Angular 重寫而成的。</p><p translation-origin=\"off\">Once you're running a hybrid app, you can start the gradual process of upgrading code.\nOne of the more common patterns for doing that is to use an Angular component in an AngularJS context.\nThis could be a completely new component or one that was previously AngularJS but has been rewritten for Angular.</p>\n\n<p translation-result=\"on\">假設你有一個用來顯示英雄資訊的 Angular 元件：</p><p translation-origin=\"off\">Say you have an Angular component that shows information about a hero:</p>\n\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/downgrade-static/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &lt;h2&gt;Windstorm details!&lt;/h2&gt;\n    &lt;div&gt;id: 1&lt;/div&gt;\n  `\n})\nexport class HeroDetailComponent { }\n\n\n</code-example>\n<p translation-result=\"on\">如果你想在 AngularJS 中使用這個元件，就得用 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 方法把它<em>降級</em>。其結果是一個 AngularJS 的<em>指令</em>，你可以把它註冊到 AngularJS 的模組中：</p><p translation-origin=\"off\">If you want to use this component from AngularJS, you need to <em>downgrade</em> it using the <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> method.\nThe result is an AngularJS <em>directive</em>, which you can then register in the AngularJS module:</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"downgradecomponent\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n/* . . . */\n\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('heroApp', [])\n  .directive(\n    'heroDetail',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({ component: HeroDetailComponent }) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">預設情況下，Angular 變更檢測也會在 AngularJS 的每個 <code>$digest</code> 週期中執行。如果你希望只在輸入屬性發生變化時才執行變更檢測，可以在呼叫 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 時把 <code>propagateDigest</code> 設定為 <code>false</code>。</p><p translation-origin=\"off\">By default, Angular change detection will also run on the component for everyAngularJS <code>$digest</code> cycle.\nIf you want to only have change detection run when the inputs change, you can set <code>propagateDigest</code> to <code>false</code> when calling <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code>.</p>\n\n</div>\n<p translation-result=\"on\">由於 <code>HeroDetailComponent</code> 是一個 Angular 元件，所以你必須同時把它加入 <code>AppModule</code> 的 <code>declarations</code> 欄位中。</p><p translation-origin=\"off\">Because <code>HeroDetailComponent</code> is an Angular component, you must also add it to the <code>declarations</code> in the <code>AppModule</code>.</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"ngmodule\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  declarations: [\n    HeroDetailComponent\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">所有 Angular 元件、指令和管道都必須宣告在 NgModule 中。</p><p translation-origin=\"off\">All Angular components, directives, and pipes must be declared in an NgModule.</p>\n\n</div>\n<p translation-result=\"on\">最終的結果是一個叫做 <code>heroDetail</code> 的 AngularJS 指令，你可以像用其它指令一樣把它用在 AngularJS 範本中。</p><p translation-origin=\"off\">The net result is an AngularJS directive called <code>heroDetail</code>, that you can use like any other directive in AngularJS templates.</p>\n\n<code-example path=\"upgrade-module/src/index-downgrade-static.html\" region=\"usecomponent\">\n&lt;hero-detail&gt;&lt;/hero-detail&gt;\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n它在 AngularJS 中是一個名叫 <code>heroDetail</code> 的元素型指令（<code>restrict: 'E'</code>）。\nAngularJS 的元素型指令是基於它的<em>名字</em>匹配的。\n<em>Angular 元件中的 <code>selector</code> 元資料，在降級後的版本中會被忽略。</em></p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThis AngularJS is an element directive (<code>restrict: 'E'</code>) called <code>heroDetail</code>.\nAn AngularJS element directive is matched based on its <em>name</em>.\n<em>The <code>selector</code> metadata of the downgraded Angular component is ignored</em>.</p>\n\n</div>\n<p translation-result=\"on\">當然，大多陣列件都不像這個這麼簡單。它們中很多都有<em>輸入屬性和輸出屬性</em>，來把它們連線到外部世界。Angular 的英雄詳情元件帶有像這樣的輸入屬性與輸出屬性：</p><p translation-origin=\"off\">Most components are not quite this simple, of course.\nMany of them have <em>inputs and outputs</em> that connect them to the outside world.\nAn Angular hero detail component with inputs and outputs might look like this:</p>\n\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/downgrade-io/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\nimport { Hero }&nbsp;from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;\n    &lt;div&gt;id: {{hero.id}}&lt;/div&gt;\n    &lt;button type=\"button\" (click)=\"onDelete()\"&gt;Delete&lt;/button&gt;\n  `\n})\nexport class HeroDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleted = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;();\n  onDelete() {\n    this.deleted.emit(this.hero);\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">這些輸入屬性和輸出屬性的值來自於 AngularJS 的範本，而 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 方法負責橋接它們：</p><p translation-origin=\"off\">These inputs and outputs can be supplied from the AngularJS template, and the <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> method takes care of wiring them up:</p>\n\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"usecomponent\">\n&lt;div ng-controller=\"MainController as mainCtrl\"&gt;\n  &lt;hero-detail [hero]=\"mainCtrl.hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\"&gt;\n  &lt;/hero-detail&gt;\n&lt;/div&gt;\n\n</code-example>\n<p translation-result=\"on\">注意，雖然你正在 AngularJS 的範本中，<strong>但卻在使用 Angular 的屬性（Attribute）語法來繫結到輸入屬性與輸出屬性</strong>。這是降級的元件本身要求的。而表示式本身仍然是標準的 AngularJS 表示式。</p><p translation-origin=\"off\">Even though you are in an AngularJS template, <strong>you are using Angular attribute syntax to bind the inputs and outputs</strong>.\nThis is a requirement for downgraded components.\nThe expressions themselves are still regular AngularJS expressions.</p>\n\n<div class=\"callout is-important\">\n<header ng-should-translate=\"\" translation-result=\"on\">在降級過的元件屬性中使用中線命名法</header><header ng-should-translate=\"\" translation-origin=\"off\">Use kebab-case for downgraded component attributes</header>\n\n<p translation-result=\"on\">為降級過的元件使用 Angular 的屬性(Attribute)語法規則時有一個值得注意的例外。它適用於由多個單片語成的輸入或輸出屬性。在 Angular 中，你要使用小駝峰命名法繫結這些屬性：</p><p translation-origin=\"off\">There is one notable exception to the rule of using Angular attribute syntax for downgraded components.\nIt has to do with input or output names that consist of multiple words.\nIn Angular, you would bind these attributes using camelCase:</p>\n\n<code-example language=\"html\">\n\n[myHero]=\"hero\"\n(heroDeleted)=\"handleHeroDeleted($event)\"\n\n</code-example>\n<p translation-result=\"on\">但是從 AngularJS 的範本中使用它們時，你得使用中線命名法：</p><p translation-origin=\"off\">But when using them from AngularJS templates, you must use kebab-case:</p>\n\n<code-example language=\"html\">\n\n[my-hero]=\"hero\"\n(hero-deleted)=\"handleHeroDeleted($event)\"\n\n</code-example>\n</div>\n<p translation-result=\"on\"><code>$event</code> 變數能被用在輸出屬性裡，以存取這個事件所發出的物件。這個案例中它是 <code>Hero</code> 物件，因為 <code>this.deleted.emit()</code> 函式曾把它傳了出來。</p><p translation-origin=\"off\">The <code>$event</code> variable can be used in outputs to gain access to the object that was emitted.\nIn this case it will be the <code>Hero</code> object, because that is what was passed to <code>this.deleted.emit()</code>.</p>\n\n<p translation-result=\"on\">由於這是一個 AngularJS 範本，雖然它已經有了 Angular 中繫結的屬性（Attribute），你仍可以在這個元素上使用其它 AngularJS 指令。比如，你可以用 <code>ng-repeat</code> 簡單的製作該元件的多份複製：</p><p translation-origin=\"off\">Since this is an AngularJS template, you can still use other AngularJS directives on the element, even though it has Angular binding attributes on it.\nFor example, you can easily make multiple copies of the component using <code>ng-repeat</code>:</p>\n\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"userepeatedcomponent\">\n&lt;div ng-controller=\"MainController as mainCtrl\"&gt;\n  &lt;hero-detail [hero]=\"hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\"\n               ng-repeat=\"hero in mainCtrl.heroes\"&gt;\n  &lt;/hero-detail&gt;\n&lt;/div&gt;\n\n</code-example>\n<h3 id=\"using-angularjs-component-directives-from-angular-code\" translation-result=\"on\">從 Angular 程式碼使用 AngularJS 元件指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angularjs-component-directives-from-angular-code\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Using AngularJS Component Directives from Angular Code<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angularjs-component-directives-from-angular-code\"><i class=\"material-icons\">link</i></a></h3>\n\n<div class=\"lightbox\">\n<img alt=\"Using an AngularJS component from Angular code\" class=\"left\" src=\"generated/images/guide/upgrade/a-to-ajs.png\" width=\"250\" height=\"44\">\n</div>\n<p translation-result=\"on\">現在，你已經能在 Angular 中寫一個元件，並把它用於 AngularJS 程式碼中了。當你從低階元件開始移植，並往上走時，這非常有用。但在另外一些情況下，從相反的方向進行移植會更加方便：從高階元件開始，然後往下走。這也同樣能用 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 完成。你可以<em>升級</em>AngularJS 元件型指令，然後從 Angular 中用它們。</p><p translation-origin=\"off\">So, you can write an Angular component and then use it from AngularJS code.\nThis is useful when you start to migrate from lower-level components and work your way up.\nBut in some cases it is more convenient to do things in the opposite order:\nTo start with higher-level components and work your way down.\nThis too can be done using the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code>.\nYou can <em>upgrade</em> AngularJS component directives and then use them from Angular.</p>\n\n<p translation-result=\"on\">不是所有種類別的 AngularJS 指令都能升級。該指令必須是一個嚴格的<em>元件型指令</em>，具有<a href=\"guide/upgrade#using-component-directives\" title=\"Using Component Directives - Upgrading from AngularJS to Angular | Angular\">上面的準備指南中描述的</a>那些特徵。\n確保相容性的最安全的方式是 AngularJS 1.5 中引入的<a href=\"https://docs.angularjs.org/api/ng/type/angular.Module\" title=\"angular.Module | API | AngularJS\">元件 API</a>。</p><p translation-origin=\"off\">Not all kinds of AngularJS directives can be upgraded.\nThe directive really has to be a <em>component directive</em>, with the characteristics <a href=\"guide/upgrade#using-component-directives\" title=\"Using Component Directives - Upgrading from AngularJS to Angular | Angular\">described in the preparation guide above</a>.\nThe safest bet for ensuring compatibility is using the <a href=\"https://docs.angularjs.org/api/ng/type/angular.Module\" title=\"angular.Module | API | AngularJS\">component API</a> introduced in AngularJS 1.5.</p>\n\n<p translation-result=\"on\">可升級元件的簡單例子是隻有一個範本和一個控制器的指令：</p><p translation-origin=\"off\">An example of an upgradeable component is one that just has a template and a controller:</p>\n\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail\">\nexport const heroDetail = {\n  template: `\n    &lt;h2&gt;Windstorm details!&lt;/h2&gt;\n    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;1&lt;/div&gt;\n  `,\n  controller: function HeroDetailController() {\n  }\n};\n\n</code-example>\n<p translation-result=\"on\">你可以使用 <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code> 方法來把這個元件<em>升級</em>到 Angular。具體方法是建立一個 Angular<strong>指令</strong>，繼承 <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code>，在其建構函式中進行 <code>super</code> 呼叫，這樣你就得到一個完全升級的 AngularJS 元件，並且可以 Angular 中使用。剩下是工作就是把它加入到 <code>AppModule</code> 的 <code>declarations</code> 陣列。</p><p translation-origin=\"off\">You can <em>upgrade</em> this component to Angular using the <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code> class.\nBy creating a new Angular <strong>directive</strong> that extends <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code> and doing a <code>super</code> call inside its constructor, you have a fully upgraded AngularJS component to be used inside Angular.\nAll that is left is to add it to the <code>declarations</code> array of <code>AppModule</code>.</p>\n\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail-upgrade\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>, <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a> } from '@angular/core';\nimport { <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> {\n  constructor(elementRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/upgrade-static/app.module.ts\" region=\"hero-detail-upgrade\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  declarations: [\n    HeroDetailDirective,\n  /* . . . */\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">升級後的元件是 Angular 的<strong>指令</strong>，而不是<strong>元件</strong>，因為 Angular 不知道 AngularJS 將在它下面建立元素。Angular 所知道的是升級後的元件只是一個指令（一個標籤），Angular 不需要關心元件本身及其子元素。</p><p translation-origin=\"off\">Upgraded components are Angular <strong>directives</strong>, instead of <strong>components</strong>, because Angular is unaware that AngularJS will create elements under it.\nAs far as Angular knows, the upgraded component is just a directive —a tag— and Angular doesn't have to concern itself with its children.</p>\n\n</div>\n<p translation-result=\"on\">升級後的元件也可能有輸入屬性和輸出屬性，它們是在原 AngularJS 元件型指令的 scope/controller 繫結中定義的。當你從 Angular 範本中使用該元件時，就要使用<strong>Angular 範本語法</strong>來提供這些輸入屬性和輸出屬性，但要遵循下列規則：</p><p translation-origin=\"off\">An upgraded component may also have inputs and outputs, as defined by the scope/controller bindings of the original AngularJS component directive.\nWhen you use the component from an Angular template, provide the inputs and outputs using <strong>Angular template syntax</strong>, observing the following rules:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">繫結</nt-wrapper><nt-wrapper translation-origin=\"off\">Bindings</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">繫結定義</nt-wrapper><nt-wrapper translation-origin=\"off\">Binding definition</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">範本語法</nt-wrapper><nt-wrapper translation-origin=\"off\">Template syntax</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">屬性繫結</nt-wrapper><nt-wrapper translation-origin=\"off\">Attribute binding</nt-wrapper></td>\n<td align=\"left\"><code>myAttribute: '@myAttribute'</code></td>\n<td align=\"left\"><code>&lt;my-component myAttribute=\"value\"&gt;</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">表示式繫結</nt-wrapper><nt-wrapper translation-origin=\"off\">Expression binding</nt-wrapper></td>\n<td align=\"left\"><code>myOutput: '&amp;myOutput'</code></td>\n<td align=\"left\"><code>&lt;my-component (myOutput)=\"action()\"&gt;</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">單向繫結</nt-wrapper><nt-wrapper translation-origin=\"off\">One-way binding</nt-wrapper></td>\n<td align=\"left\"><code>myValue: '&lt;myValue'</code></td>\n<td align=\"left\"><code>&lt;my-component [myValue]=\"anExpression\"&gt;</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">雙向繫結</nt-wrapper><nt-wrapper translation-origin=\"off\">Two-way binding</nt-wrapper></td>\n<td align=\"left\"><code>myValue: '=myValue'</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">用作雙向繫結：<code>&lt;my-component [(myValue)]=\"anExpression\"&gt;</code>。<br> 由於大多數 AngularJS 的雙向繫結實際上只是單向繫結，因此通常寫成 <code>&lt;my-component [myValue]=\"anExpression\"&gt;</code> 也夠用了。</nt-wrapper><nt-wrapper translation-origin=\"off\">As a two-way binding: <br> <code>&lt;my-component [(myValue)]=\"anExpression\"&gt;</code> <br> Since most AngularJS two-way bindings actually only need a one-way binding in practice, <code>&lt;my-component [myValue]=\"anExpression\"&gt;</code> is often enough.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">舉個例子，假設 AngularJS 中有一個表示“英雄詳情”的元件型指令，它帶有一個輸入屬性和一個輸出屬性：</p><p translation-origin=\"off\">For example, imagine a hero detail AngularJS component directive with one input and one output:</p>\n\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&lt;',\n    deleted: '&amp;'\n  },\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt;\n    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt;\n    &lt;button type=\"button\" ng-click=\"$ctrl.onDelete()\"&gt;Delete&lt;/button&gt;\n  `,\n  controller: function HeroDetailController() {\n    this.onDelete = () =&gt; {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<p translation-result=\"on\">你可以把這個元件升級到 Angular，然後使用 Angular 的範本語法提供這個輸入屬性和輸出屬性：</p><p translation-origin=\"off\">You can upgrade this component to Angular, annotate inputs and outputs in the upgrade directive, and then provide the input and output using Angular template syntax:</p>\n\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io-upgrade\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a> } from '@angular/core';\nimport { <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleted: <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;;\n\n  constructor(elementRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example header=\"container.component.ts\" path=\"upgrade-module/src/app/upgrade-io/container.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-container',\n  template: `\n    &lt;h1&gt;Tour of Heroes&lt;/h1&gt;\n    &lt;hero-detail [hero]=\"hero\"\n                 (deleted)=\"heroDeleted($event)\"&gt;\n    &lt;/hero-detail&gt;\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm');\n  heroDeleted(hero: Hero) {\n    hero.name = 'Ex-' + hero.name;\n  }\n}\n\n\n</code-example>\n<h3 id=\"projecting-angularjs-content-into-angular-components\" translation-result=\"on\">把 AngularJS 的內容投影到 Angular 元件中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#projecting-angularjs-content-into-angular-components\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Projecting AngularJS Content into Angular Components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#projecting-angularjs-content-into-angular-components\"><i class=\"material-icons\">link</i></a></h3>\n\n<div class=\"lightbox\">\n<img alt=\"Projecting AngularJS content into Angular\" class=\"left\" src=\"generated/images/guide/upgrade/ajs-to-a-with-projection.png\" width=\"250\" height=\"48\">\n</div>\n<p translation-result=\"on\">如果你在 AngularJS 範本中使用降級後的 Angular 元件時，可能會需要把範本中的一些內容投影進那個元件。這也是可能的，雖然在 Angular 中並沒有透傳（transclude）這樣的東西，但它有一個非常相似的概念，叫做<em>內容投影</em>。<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 也能讓這兩個特性實現互操作。</p><p translation-origin=\"off\">When you are using a downgraded Angular component from an AngularJS template, the need may arise to <em>transclude</em> some content into it.\nThis is also possible.\nWhile there is no such thing as transclusion in Angular, there is a very similar concept called <em>content projection</em>.\n<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> is able to make these two features interoperate.</p>\n\n<p translation-result=\"on\">Angular 的元件透過使用 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 標籤來支援內容投影。下面是這類元件的一個例子：</p><p translation-origin=\"off\">Angular components that support content projection make use of an <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> tag within them.\nHere is an example of such a component:</p>\n\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/ajs-to-a-projection/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &lt;h2&gt;{{hero.name}}&lt;/h2&gt;\n    &lt;div&gt;\n      &lt;ng-content&gt;&lt;/ng-content&gt;\n    &lt;/div&gt;\n  `\n})\nexport class HeroDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n}\n\n\n</code-example>\n<p translation-result=\"on\">當從 AngularJS 中使用該元件時，你可以為它提供內容。正如它們將在 AngularJS 中被透傳一樣，它們也在 Angular 中被投影到了 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 標籤所在的位置：</p><p translation-origin=\"off\">When using the component from AngularJS, you can supply contents for it.\nJust like they would be transcluded in AngularJS, they get projected to the location of the <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> tag in Angular:</p>\n\n<code-example path=\"upgrade-module/src/index-ajs-to-a-projection.html\" region=\"usecomponent\">\n&lt;div ng-controller=\"MainController as mainCtrl\"&gt;\n  &lt;hero-detail [hero]=\"mainCtrl.hero\"&gt;\n    &lt;!-- Everything here will get projected --&gt;\n    &lt;p&gt;{{mainCtrl.hero.description}}&lt;/p&gt;\n  &lt;/hero-detail&gt;\n&lt;/div&gt;\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">當 AngularJS 的內容被投影到 Angular 元件中時，它仍然留在“AngularJS 王國”中，並被 AngularJS 框架管理著。</p><p translation-origin=\"off\">When AngularJS content gets projected inside an Angular component, it still remains in \"AngularJS land\" and is managed by the AngularJS framework.</p>\n\n</div>\n<h3 id=\"transcluding-angular-content-into-angularjs-component-directives\" translation-result=\"on\">把 Angular 的內容透傳進 AngularJS 的元件型指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Transcluding Angular Content into AngularJS Component Directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\"><i class=\"material-icons\">link</i></a></h3>\n\n<div class=\"lightbox\">\n<img alt=\"Projecting Angular content into AngularJS\" class=\"left\" src=\"generated/images/guide/upgrade/a-to-ajs-with-transclusion.png\" width=\"250\" height=\"48\">\n</div>\n<p translation-result=\"on\">就像可以把 AngularJS 的內容投影進 Angular 元件一樣，你也能把 Angular 的內容<em>透傳</em>進 AngularJS 的元件，但不管怎樣，你都要使用它們升級過的版本。</p><p translation-origin=\"off\">Just as you can project AngularJS content into Angular components, you can <em>transclude</em> Angular content into AngularJS components, whenever you are using upgraded versions from them.</p>\n\n<p translation-result=\"on\">如果一個 AngularJS 元件型指令支援透傳，它就會在自己的範本中使用 <code>ng-transclude</code> 指令標記出透傳到的位置：</p><p translation-origin=\"off\">When an AngularJS component directive supports transclusion, it may use the <code>ng-transclude</code> directive in its template to mark the transclusion point:</p>\n\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/a-to-ajs-transclusion/hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: '='\n  },\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.name}}&lt;/h2&gt;\n    &lt;div&gt;\n      &lt;ng-transclude&gt;&lt;/ng-transclude&gt;\n    &lt;/div&gt;\n  `,\n  transclude: true\n};\n\n</code-example>\n<p translation-result=\"on\">如果你升級這個元件，並把它用在 Angular 中，你就能把準備透傳的內容放進這個元件的標籤中。</p><p translation-origin=\"off\">If you upgrade this component and use it from Angular, you can populate the component tag with contents that will then get transcluded:</p>\n\n<code-example header=\"container.component.ts\" path=\"upgrade-module/src/app/a-to-ajs-transclusion/container.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-container',\n  template: `\n    &lt;hero-detail [hero]=\"hero\"&gt;\n      &lt;!-- Everything here will get transcluded --&gt;\n      &lt;p&gt;{{hero.description}}&lt;/p&gt;\n    &lt;/hero-detail&gt;\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm', 'Specific powers of controlling winds');\n}\n\n\n</code-example>\n<h3 id=\"making-angularjs-dependencies-injectable-to-angular\" translation-result=\"on\">讓 AngularJS 中的依賴可被注入到 Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Making AngularJS Dependencies Injectable to Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當執行一個混合式應用時，可能會遇到這種情況：你需要把某些 AngularJS 的依賴注入到 Angular 程式碼中。這可能是因為某些業務邏輯仍然在 AngularJS 服務中，或者需要某些 AngularJS 的內建服務，比如 <code>$location</code> 或 <code>$timeout</code>。</p><p translation-origin=\"off\">When running a hybrid app, you may encounter situations where you need to inject some AngularJS dependencies into your Angular code.\nMaybe you have some business logic still in AngularJS services.\nMaybe you want access to built-in services of AngularJS like <code>$location</code> or <code>$timeout</code>.</p>\n\n<p translation-result=\"on\">在這些情況下，把一個 AngularJS 提供者<em>升級到</em>Angular 也是有可能的。這就讓它將來有可能被注入到 Angular 程式碼中的某些地方。比如，你可能在 AngularJS 中有一個名叫 <code>HeroesService</code> 的服務：</p><p translation-origin=\"off\">In these situations, it is possible to <em>upgrade</em> an AngularJS provider to Angular.\nThis makes it possible to then inject it somewhere in Angular code.\nFor example, you might have a service called <code>HeroesService</code> in AngularJS:</p>\n\n<code-example header=\"heroes.service.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/heroes.service.ts\">\nimport { Hero }&nbsp;from '../hero';\n\nexport class HeroesService {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">你可以用 Angular 的[工廠提供者][AioGuideDependencyInjectionProvidersFactoryProviders]升級該服務，\n它從 AngularJS 的 <code>$injector</code> 請求服務。</p><p translation-origin=\"off\">You can upgrade the service using an Angular [factory provider][AioGuideDependencyInjectionProvidersFactoryProviders] that requests the service from the AngularJS <code>$injector</code>.</p>\n\n<p translation-result=\"on\">很多開發者都喜歡在一個獨立的 <code>ajs-upgraded-providers.ts</code> 中宣告這個工廠提供者，以便把它們都放在一起，這樣便於參考、建立新的以及在升級完畢時刪除它們。</p><p translation-origin=\"off\">Many developers prefer to declare the factory provider in a separate <code>ajs-upgraded-providers.ts</code> file so that they are all together, making it easier to reference them, create new ones and delete them once the upgrade is over.</p>\n\n<p translation-result=\"on\">同時，建議匯出 <code>heroesServiceFactory</code> 函式，以便 AOT 編譯器可以拿到它們。</p><p translation-origin=\"off\">It is also recommended to export the <code>heroesServiceFactory</code> function so that Ahead-of-Time compilation can pick it up.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n這個工廠中的字串 'heroes' 指向的是 AngularJS 的 <code>HeroesService</code>。\nAngularJS 應用中通常使用服務名作為令牌，比如 'heroes'，併為其追加 'Service' 字尾來建立其類別名稱。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThe 'heroes' string inside the factory refers to the AngularJS <code>HeroesService</code>.\nIt is common in AngularJS applications to choose a service name for the token, for example \"heroes\", and append the \"Service\" suffix to create the class name.</p>\n\n</div>\n<code-example header=\"ajs-upgraded-providers.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/ajs-upgraded-providers.ts\">\nimport { HeroesService } from './heroes.service';\n\nexport function heroesServiceFactory(i: any) {\n  return i.get('heroes');\n}\n\nexport const heroesServiceProvider = {\n  provide: HeroesService,\n  useFactory: heroesServiceFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<p translation-result=\"on\">然後，你就可以把這個服務新增到 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中來把它暴露給 Angular：</p><p translation-origin=\"off\">You can then provide the service to Angular by adding it to the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>:</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/app.module.ts\" region=\"register\">\nimport { heroesServiceProvider } from './ajs-upgraded-providers';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  providers: [\n    heroesServiceProvider\n  ],\n/* . . . */\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">然後在元件的建構函式中使用該服務的類別名稱作為型別註解注入到元件中，從而在元件中使用它：</p><p translation-origin=\"off\">Then use the service inside your component by injecting it in the component constructor using its class as a type annotation:</p>\n\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HeroesService } from './heroes.service';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &lt;h2&gt;{{hero.id}}: {{hero.name}}&lt;/h2&gt;\n  `\n})\nexport class HeroDetailComponent {\n  hero: Hero;\n  constructor(heroes: HeroesService) {\n    this.hero = heroes.get()[0];\n  }\n}\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">在這個例子中，你升級了服務類別。當注入它時，你可以使用 TypeScript 型別註解來獲得這些額外的好處。它沒有影響該依賴的處理過程，同時還得到了啟用靜態型別檢查的好處。任何 AngularJS 中的服務、工廠和提供者都能被升級 —— 儘管這不是必須的。</p><p translation-origin=\"off\">In this example you upgraded a service class.\nYou can use a TypeScript type annotation when you inject it.\nWhile it doesn't affect how the dependency is handled, it enables the benefits of static type checking.\nThis is not required though, and any AngularJS service, factory, or provider can be upgraded.</p>\n\n</div>\n<h3 id=\"making-angular-dependencies-injectable-to-angularjs\" translation-result=\"on\">讓 Angular 的依賴能被注入到 AngularJS 中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angular-dependencies-injectable-to-angularjs\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Making Angular Dependencies Injectable to AngularJS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angular-dependencies-injectable-to-angularjs\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">除了能升級 AngularJS 依賴之外，你還能<em>降級</em>Angular 的依賴，以便在 AngularJS 中使用它們。當你已經開始把服務移植到 Angular 或在 Angular 中建立新服務，但同時還有一些用 AngularJS 寫成的元件時，這會非常有用。</p><p translation-origin=\"off\">In addition to upgrading AngularJS dependencies, you can also <em>downgrade</em> Angular dependencies, so that you can use them from AngularJS.\nThis can be useful when you start migrating services to Angular or creating new services in Angular while retaining components written in AngularJS.</p>\n\n<p translation-result=\"on\">比如，你可能有一個 Angular 的 <code>Heroes</code> 服務：</p><p translation-origin=\"off\">For example, you might have an Angular service called <code>Heroes</code>:</p>\n\n<code-example header=\"heroes.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/heroes.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Hero }&nbsp;from '../hero';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Heroes {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">仿照 Angular 元件，把該提供者加入 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>providers</code> 列表中，以註冊它。</p><p translation-origin=\"off\">Again, as with Angular components, register the provider with the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> by adding it to the <code>providers</code> list of the module.</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"ngmodule\">\nimport { Heroes } from './heroes';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  providers: [ Heroes ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">現在，用 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> 來把 Angular 的 <code>Heroes</code> 包裝成<em>AngularJS 的工廠函式</em>，並把這個工廠註冊進 AngularJS 的模組中。依賴在 AngularJS 中的名字你可以自己定：</p><p translation-origin=\"off\">Now wrap the Angular <code>Heroes</code> in an <em>AngularJS factory function</em> using <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> and plug the factory into an AngularJS module.\nThe name of the AngularJS dependency is up to you:</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"register\">\nimport { Heroes } from './heroes';\n/* . . . */\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('heroApp', [])\n  .factory('heroes', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Heroes))\n  .component('heroDetail', heroDetailComponent);\n\n</code-example>\n<p translation-result=\"on\">此後，該服務就能被注入到 AngularJS 程式碼中的任何地方了：</p><p translation-origin=\"off\">After this, the service is injectable anywhere in AngularJS code:</p>\n\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/hero-detail.component.ts\">\nexport const heroDetailComponent = {\n  template: `\n    &lt;h2&gt;{{$ctrl.hero.id}}: {{$ctrl.hero.name}}&lt;/h2&gt;\n  `,\n  controller: ['heroes', function(heroes: Heroes) {\n    this.hero = heroes.get()[0];\n  }]\n};\n\n\n</code-example>\n<h2 id=\"lazy-loading-angularjs\" translation-result=\"on\">延遲載入 AngularJS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#lazy-loading-angularjs\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Lazy Loading AngularJS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#lazy-loading-angularjs\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在建構應用時，你需要確保只在必要的時候才載入所需的資源，無論是載入靜態資產（Asset）還是程式碼。要確保任何事都儘量推遲到必要時才去做，以便讓應用更高效的執行。當要在同一個應用中執行不同的框架時，更是如此。</p><p translation-origin=\"off\">When building applications, you want to ensure that only the required resources are loaded when necessary.\nWhether that be loading of assets or code, making sure everything that can be deferred until needed keeps your application running efficiently.\nThis is especially true when running different frameworks in the same application.</p>\n\n<p translation-result=\"on\"><a href=\"guide/glossary#lazy-loading\" title=\"lazy loading - Glossary | Angular\">延遲載入</a>是一項技術，它會推遲到使用時才載入所需靜態資產和程式碼資源。這可以減少啟動時間、提高效率，特別是要在同一個應用中執行不同的框架時。</p><p translation-origin=\"off\"><a href=\"guide/glossary#lazy-loading\" title=\"lazy loading - Glossary | Angular\">Lazy loading</a> is a technique that defers the loading of required assets and code resources until they are actually used.\nThis reduces startup time and increases efficiency, especially when running different frameworks in the same application.</p>\n\n<p translation-result=\"on\">當你採用混合式應用的方式將大型應用從 AngularJS 遷移到 Angular 時，你首先要遷移一些最常用的特性，並且只在必要的時候才使用那些不太常用的特性。這樣做有助於確保應用程式在遷移過程中仍然能為使用者提供無縫的體驗。</p><p translation-origin=\"off\">When migrating large applications from AngularJS to Angular using a hybrid approach, you want to migrate some of the most commonly used features first, and only use the less commonly used features if needed.\nDoing so helps you ensure that the application is still providing a seamless experience for your users while you are migrating.</p>\n\n<p translation-result=\"on\">在大多數需要同時用 Angular 和 AngularJS 渲染應用的環境中，這兩個框架都會包含在傳送給客戶端的初始釋出套件中。這會導致釋出套件的體積增大、效能降低。</p><p translation-origin=\"off\">In most environments where both Angular and AngularJS are used to render the application, both frameworks are loaded in the initial bundle being sent to the client.\nThis results in both increased bundle size and possible reduced performance.</p>\n\n<p translation-result=\"on\">當用戶停留在由 Angular 渲染的頁面上時，應用的整體效能也會受到影響。這是因為 AngularJS 的框架和應用仍然被載入並運行了 —— 即使它們從未被存取過。</p><p translation-origin=\"off\">Overall application performance is affected in cases where the user stays on Angular-rendered pages because the AngularJS framework and application are still loaded and running, even if they are never accessed.</p>\n\n<p translation-result=\"on\">你可以採取一些措施來緩解這些套件的大小和效能問題。透過把 AngularJS 應用程式分離到一個單獨的釋出套件中，你就可以利用<a href=\"guide/glossary#lazy-loading\" title=\"lazy loading - Glossary | Angular\">延遲載入</a>技術來只在必要的時候才載入、引導和渲染這個 AngularJS 應用。這種策略減少了你的初始釋出包大小，推遲了同時載入兩個框架的潛在影響 —— 直到絕對必要時才載入，以便讓你的應用盡可能高效地執行。</p><p translation-origin=\"off\">You can take steps to mitigate both bundle size and performance issues.\nBy isolating your AngularJS application to a separate bundle, you can take advantage of <a href=\"guide/glossary#lazy-loading\" title=\"lazy loading - Glossary | Angular\">lazy loading</a> to load, bootstrap, and render the AngularJS application only when needed.\nThis strategy reduces your initial bundle size, defers any potential impact from loading both frameworks until absolutely necessary, and keeps your application running as efficiently as possible.</p>\n\n<p translation-result=\"on\">下面的步驟介紹了應該如何去做：</p><p translation-origin=\"off\">The steps below show you how to do the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">為 AngularJS 釋出包設定一個回呼(Callback)函式。</p><p translation-origin=\"off\">Setup a callback function for your AngularJS bundle.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">建立一個服務，以便延遲載入並引導你的 AngularJS 應用。</p><p translation-origin=\"off\">Create a service that lazy loads and bootstraps your AngularJS app.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">為 AngularJS 內容建立一個可路由的元件</p><p translation-origin=\"off\">Create a routable component for AngularJS content</p>\n\n</li>\n<li>\n<p translation-result=\"on\">為 AngularJS 特有的 URL 建立自訂的 <code>matcher</code> 函式，併為 AngularJS 的各個路由配上帶有自訂匹配器的 Angular 路由器。</p><p translation-origin=\"off\">Create a custom <code>matcher</code> function for AngularJS-specific URLs and configure the Angular <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> with the custom matcher for AngularJS routes.</p>\n\n</li>\n</ul>\n<h3 id=\"create-a-service-to-lazy-load-angularjs\" translation-result=\"on\">為延遲載入 AngularJS 建立一個服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-a-service-to-lazy-load-angularjs\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Create a service to lazy load AngularJS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-a-service-to-lazy-load-angularjs\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 Angular 的版本 8 中，延遲載入程式碼只需使用動態匯入語法 <code>import('...')</code> 即可。在這個應用中，你建立了一個新服務，它使用動態匯入技術來延遲載入 AngularJS。</p><p translation-origin=\"off\">As of Angular version 8, lazy loading code can be accomplished by using the dynamic import syntax <code>import('...')</code>.\nIn your application, you create a new service that uses dynamic imports to lazy load AngularJS.</p>\n\n<code-example header=\"src/app/lazy-loader.service.ts\" path=\"upgrade-lazy-load-ajs/src/app/lazy-loader.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport * as angular from 'angular';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class LazyLoaderService {\n  private app: angular.auto.IInjectorService | undefined;\n\n  load(el: HTMLElement): void {\n    import('./angularjs-app').then(app =&gt; {\n      try {\n        this.app = app.bootstrap(el);\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n\n  destroy() {\n    if (this.app) {\n      this.app.get('$rootScope').$destroy();\n    }\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">該服務使用 <code>import()</code> 方法延遲載入打包好的 AngularJS 應用。這會減少應用初始套件的大小，因為你尚未載入使用者目前不需要的程式碼。你還要提供一種方法，在載入完畢後手動<em>啟動</em>它。AngularJS 提供了一種使用 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\"><code>angular.bootstrap()</code></a> 方法並傳入一個 HTML 元素來手動引導應用的方法。你的 AngularJS 應用也應該公開一個用來引導 AngularJS 應用的 <code>bootstrap</code> 方法。</p><p translation-origin=\"off\">The service uses the <code>import()</code> method to load your bundled AngularJS application lazily.\nThis decreases the initial bundle size of your application as you're not loading code your user doesn't need yet.\nYou also need to provide a way to <em>bootstrap</em> the application manually after it has been loaded.\nAngularJS provides a way to manually bootstrap an application using the <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\"><code>angular.bootstrap()</code></a> method with a provided HTML element.\nYour AngularJS application should also expose a <code>bootstrap</code> method that bootstraps the AngularJS app.</p>\n\n<p translation-result=\"on\">要確保 AngularJS 應用中的任何清理工作都觸發過（比如移除全域監聽器），你還可以實現一個方法來呼叫 <code>$rootScope.destroy()</code> 方法。</p><p translation-origin=\"off\">To ensure any necessary teardown is triggered in the AngularJS app, such as removal of global listeners, you also implement a method to call the <code>$rootScope.destroy()</code> method.</p>\n\n<code-example header=\"angularjs-app\" path=\"upgrade-lazy-load-ajs/src/app/angularjs-app/index.ts\">\nimport * as angular from 'angular';\nimport 'angular-route';\n\nconst appModule = angular.module('myApp', [\n  'ngRoute'\n])\n.config(['$routeProvider', '$locationProvider',\n  function config($routeProvider: angular.route.IRouteProvider,\n                  $locationProvider: angular.ILocationProvider) {\n    $locationProvider.html5Mode(true);\n\n    $routeProvider.\n      when('/users', {\n        template: `\n          &lt;p&gt;\n            Users Page\n          &lt;/p&gt;\n        `\n      }).\n      otherwise({\n        template: ''\n      });\n  }]\n);\n\nexport function bootstrap(el: HTMLElement) {\n  return angular.bootstrap(el,  [appModule.name]);\n}\n\n\n</code-example>\n<p translation-result=\"on\">你的 AngularJS 應用只配置了渲染內容所需的那部分路由。而 Angular 路由器會處理應用中其餘的路由。你的 Angular 應用中會呼叫公開的 <code>bootstrap</code> 方法，讓它在載入完釋出包之後引導 AngularJS 應用。</p><p translation-origin=\"off\">Your AngularJS application is configured with only the routes it needs to render content.\nThe remaining routes in your application are handled by the Angular Router.\nThe exposed <code>bootstrap</code> method is called in your Angular application to bootstrap the AngularJS application after the bundle is loaded.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><strong>注意：</strong>當 AngularJS 載入並引導完畢後，監聽器（比如路由配置中的那些監聽器）會繼續監聽路由的變化。為了確保當 AngularJS 尚未顯示時先關閉監聽器，請在 <a href=\"https://docs.angularjs.org/api/ngRoute/provider/$routeProvider\" title=\"$routeProvider | API | AngularJS\">$routeProvider</a> 中配置一個渲染空範本 <code>otherwise</code> 選項。這裡假設 Angular 將處理所有其它路由。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nAfter AngularJS is loaded and bootstrapped, listeners such as those wired up in your route configuration will continue to listen for route changes.\nTo ensure listeners are shut down when AngularJS isn't being displayed, configure an <code>otherwise</code> option with the <a href=\"https://docs.angularjs.org/api/ngRoute/provider/$routeProvider\" title=\"$routeProvider | API | AngularJS\">$routeProvider</a> that renders an empty template.\nThis assumes all other routes will be handled by Angular.</p>\n\n</div>\n<h3 id=\"create-a-component-to-render-angularjs-content\" translation-result=\"on\">建立一個用來渲染 AngularJS 內容的元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-a-component-to-render-angularjs-content\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Create a component to render AngularJS content<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-a-component-to-render-angularjs-content\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 Angular 應用中，你需要一個元件作為 AngularJS 內容的佔位符。該元件使用你建立的服務，並在元件初始化完成後載入並引導你的 AngularJS 應用。</p><p translation-origin=\"off\">In your Angular application, you need a component as a placeholder for your AngularJS content.\nThis component uses the service you create to load and bootstrap your AngularJS application after the component is initialized.</p>\n\n<code-example header=\"src/app/angular-js/angular-js.component.ts\" path=\"upgrade-lazy-load-ajs/src/app/angular-js/angular-js.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\nimport { LazyLoaderService } from '../lazy-loader.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-angular-js',\n  template: '&lt;div ng-view&gt;&lt;/div&gt;'\n})\nexport class AngularJSComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n  constructor(\n    private lazyLoader: LazyLoaderService,\n    private elRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>\n  ) {}\n\n  ngOnInit() {\n    this.lazyLoader.load(this.elRef.nativeElement);\n  }\n\n\n  ngOnDestroy() {\n    this.lazyLoader.destroy();\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">當 Angular 的路由器匹配到使用 AngularJS 的路由時，會渲染 <code>AngularJSComponent</code>，並在 AngularJS 的 <a href=\"https://docs.angularjs.org/api/ngRoute/directive/ngView\" title=\"ngView | API | AngularJS\"><code>ng-view</code></a> 指令中渲染內容。當用戶導航離開本路由時，<code>$rootScope</code> 會在 AngularJS 應用中被銷燬。</p><p translation-origin=\"off\">When the Angular Router matches a route that uses AngularJS, the <code>AngularJSComponent</code> is rendered, and the content is rendered within the AngularJS <a href=\"https://docs.angularjs.org/api/ngRoute/directive/ngView\" title=\"ngView | API | AngularJS\"><code>ng-view</code></a> directive.\nWhen the user navigates away from the route, the <code>$rootScope</code> is destroyed on the AngularJS application.</p>\n\n<h3 id=\"configure-a-custom-route-matcher-for-angularjs-routes\" translation-result=\"on\">為那些 AngularJS 路由配置自訂路由匹配器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#configure-a-custom-route-matcher-for-angularjs-routes\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Configure a custom route matcher for AngularJS routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#configure-a-custom-route-matcher-for-angularjs-routes\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">為了配置 Angular 的路由器，你必須為 AngularJS 的 URL 定義路由。要匹配這些 URL，你需要新增一個使用 <code>matcher</code> 屬性的路由配置。這個 <code>matcher</code> 允許你使用自訂模式來匹配這些 URL 路徑。Angular 的路由器會首先嚐試匹配更具體的路由，比如靜態路由和可變路由。當它找不到匹配項時，就會求助於路由配置中的自訂匹配器。如果自訂匹配器與某個路由不匹配，它就會轉到用於 \"捕獲所有\"（catch-all）的路由，比如 404 頁面。</p><p translation-origin=\"off\">To configure the Angular Router, you must define a route for AngularJS URLs.\nTo match those URLs, you add a route configuration that uses the <code>matcher</code> property.\nThe <code>matcher</code> allows you to use custom pattern matching for URL paths.\nThe Angular Router tries to match on more specific routes such as static and variable routes first.\nWhen it doesn't find a match, it then looks at custom matchers defined in your route configuration.\nIf the custom matchers don't match a route, it then goes to catch-all routes, such as a 404 page.</p>\n\n<p translation-result=\"on\">下面的例子給 AngularJS 路由定義了一個自訂匹配器函式。</p><p translation-origin=\"off\">The following example defines a custom matcher function for AngularJS routes.</p>\n\n<code-example header=\"src/app/app-routing.module.ts\" path=\"upgrade-lazy-load-ajs/src/app/app-routing.module.ts\" region=\"matcher\">\nexport function isAngularJSUrl(url: <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a>[]) {\n  return url.length &gt; 0 &amp;&amp; url[0].path.startsWith('users') ? ({consumed: url}) : null;\n}\n\n</code-example>\n<p translation-result=\"on\">下列程式碼往你的路由配置中添加了一個路由物件，其 <code>matcher</code> 屬性是這個自訂匹配器，而 <code>component</code> 屬性為 <code>AngularJSComponent</code>。</p><p translation-origin=\"off\">The following code adds a route object to your routing configuration using the <code>matcher</code> property and custom matcher, and the <code>component</code> property with <code>AngularJSComponent</code>.</p>\n\n<code-example header=\"src/app/app-routing.module.ts\" path=\"upgrade-lazy-load-ajs/src/app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a> } from '@angular/router';\nimport { AngularJSComponent } from './angular-js/angular-js.component';\nimport { HomeComponent } from './home/home.component';\nimport { App404Component } from './app404/app404.component';\n\n// Match any URL that starts with `users`\nexport function isAngularJSUrl(url: <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a>[]) {\n  return url.length &gt; 0 &amp;&amp; url[0].path.startsWith('users') ? ({consumed: url}) : null;\n}\n\nexport const routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  // <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> rendered by Angular\n  { path: '', component: HomeComponent },\n\n  // AngularJS routes\n  { matcher: isAngularJSUrl, component: AngularJSComponent },\n\n  // Catch-all route\n  { path: '**', component: App404Component }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p translation-result=\"on\">當你的應用匹配上需要 AngularJS 的路由時，AngularJS 應用就會被載入並引導。AngularJS 路由會匹配必要的 URL 以渲染它們的內容，而接下來你的應用就會同時執行 AngularJS 和 Angular 框架。</p><p translation-origin=\"off\">When your application matches a route that needs AngularJS, the AngularJS application is loaded and bootstrapped, the AngularJS routes match the necessary URL to render their content, and your application continues to run with both AngularJS and Angular frameworks.</p>\n\n<h2 id=\"using-the-unified-angular-location-service\" translation-result=\"on\">使用統一的 Angular 位置服務（Location）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-the-unified-angular-location-service\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Using the Unified Angular Location Service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-the-unified-angular-location-service\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在 AngularJS 中，<a href=\"https://docs.angularjs.org/api/ng/service/$location\" title=\"$location | API | AngularJS\">$location 服務</a>會處理所有路由配置和導航工作，並對各個 URL 進行編碼和解碼、重新導向、以及與瀏覽器 API 互動。Angular 在所有這些任務中都使用了自己的底層服務 <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code>。</p><p translation-origin=\"off\">In AngularJS, the <a href=\"https://docs.angularjs.org/api/ng/service/$location\" title=\"$location | API | AngularJS\">$location service</a> handles all routing configuration and navigation, encoding and decoding of URLS, redirects, and interactions with browser APIs.\nAngular uses its own underlying <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code> service for all of these tasks.</p>\n\n<p translation-result=\"on\">當你從 AngularJS 遷移到 Angular 時，你會希望把儘可能多的責任移交給 Angular，以便利用新的 API。為了幫你完成這種轉換，Angular 提供了 <code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>。該模組支援<em>統一</em>位置服務，可以把 AngularJS 中 <code>$location</code> 服務的職責轉給 Angular 的 <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code> 服務。</p><p translation-origin=\"off\">When you migrate from AngularJS to Angular you will want to move as much responsibility as possible to Angular, so that you can take advantage of new APIs.\nTo help with the transition, Angular provides the <code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>.\nThis module enables a <em>unified</em> location service that shifts responsibilities from the AngularJS <code>$location</code> service to the Angular <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code> service.</p>\n\n<p translation-result=\"on\">要使用 <code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>，就會從 <code>@angular/common/upgrade</code> 中匯入此符號，並使用靜態方法 <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 把它新增到你的 <code>AppModule</code> 匯入表（<code>imports</code>）中。</p><p translation-origin=\"off\">To use the <code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>, import the symbol from <code>@angular/common/upgrade</code> and add it to your <code>AppModule</code> imports using the static <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> method.</p>\n\n<code-example language=\"typescript\">\n\n// Other imports …\nimport { <a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a> } from '@angular/common/upgrade';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    // Other <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> imports…\n    LocationUpgradeModule.config()\n  ]\n})\nexport class AppModule {}\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 方法接受一個配置物件，該物件的 <code>useHash</code> 為 <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code>，<code>hashPrefix</code> 為 URL 字首。</p><p translation-origin=\"off\">The <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> method accepts a configuration object that allows you to configure options including the <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> with the <code>useHash</code> property, and the URL prefix with the <code>hashPrefix</code> property.</p>\n\n<p translation-result=\"on\"><code>useHash</code> 屬性預設為 <code>false</code>，而 <code>hashPrefix</code> 預設為空 <code>string</code>。傳遞配置物件可以覆蓋預設值。</p><p translation-origin=\"off\">The <code>useHash</code> property defaults to <code>false</code>, and the <code>hashPrefix</code> defaults to an empty <code>string</code>.\nPass the configuration object to override the defaults.</p>\n\n<code-example language=\"typescript\">\n\nLocationUpgradeModule.config({\n  useHash: true,\n  hashPrefix: '!'\n})\n\n</code-example>\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><strong>注意：</strong>關於 <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 方法的更多可用配置項，請參閱 <code><a href=\"api/common/upgrade/LocationUpgradeConfig\" class=\"code-anchor\">LocationUpgradeConfig</a></code>。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nSee the <code><a href=\"api/common/upgrade/LocationUpgradeConfig\" class=\"code-anchor\">LocationUpgradeConfig</a></code> for more configuration options available to the <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> method.</p>\n\n</div>\n<p translation-result=\"on\">這會為 AngularJS 中的 <code>$location</code> 提供者註冊一個替代品。一旦註冊成功，導航過程中所有由 AngularJS 觸發的導航、路由廣播訊息以及任何必需的變更檢測週期都會改由 Angular 進行處理。這樣，你就可以透過這個唯一的途徑在此混合應用的兩個框架間進行導航了。</p><p translation-origin=\"off\">This registers a drop-in replacement for the <code>$location</code> provider in AngularJS.\nOnce registered, all navigation, routing broadcast messages, and any necessary digest cycles in AngularJS triggered during navigation are handled by Angular.\nThis gives you a single way to navigate within both sides of your hybrid application consistently.</p>\n\n<p translation-result=\"on\">要想在 AngularJS 中使用 <code>$location</code> 服務作為提供者，你需要使用一個工廠提供者來降級 <code><a href=\"api/common/upgrade/$locationShim\" class=\"code-anchor\">$locationShim</a></code>。</p><p translation-origin=\"off\">For usage of the <code>$location</code> service as a provider in AngularJS, you need to downgrade the <code><a href=\"api/common/upgrade/$locationShim\" class=\"code-anchor\">$locationShim</a></code> using a factory provider.</p>\n\n<code-example language=\"typescript\">\n\n// Other imports …\nimport { $locationShim } from '@angular/common/upgrade';\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('myHybridApp', […])\n  .factory('$location', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>($locationShim));\n\n</code-example>\n<p translation-result=\"on\">一旦引入了 Angular 路由器，你只要使用 Angular 路由器就可以透過統一位置服務來觸發導航了，同時，你仍然可以透過 AngularJS 和 Angular 進行導航。</p><p translation-origin=\"off\">Once you introduce the Angular Router, using the Angular Router triggers navigations through the unified location service, still providing a single source for navigating with AngularJS and Angular.</p>\n\n<!--TODO:\n\nCorrectly document how to use AOT with SystemJS-based `ngUpgrade` apps (or better yet update the `ngUpgrade` examples/guides to use `@angular/cli`).\nSee [https://github.com/angular/angular/issues/35989][GithubAngularAngularIssues35989].\n\n## Using Ahead-of-time compilation with hybrid apps\n\n## 使用混合式應用進行預先編譯\n\nYou can take advantage of Ahead-of-time (AOT) compilation on hybrid apps just like on any other Angular application.\nThe setup for a hybrid app is mostly the same as described in the [Ahead-of-time Compilation chapter][AioGuideAotCompiler] save for differences in `index.html` and `main-aot.ts`\n\n你可以像在任何其他 Angular 應用程式上一樣在混合應用程式上利用 Ahead-of-time (AOT) 編譯。混合應用程式的設定與[提前編譯章節][AioGuideAotCompiler]中描述的基本相同，只是 `index.html` 和 `main-aot.ts` 有所不同\n\nThe `index.html` will likely have script tags loading AngularJS files, so the `index.html` for AOT must also load those files.\nAn easy way to copy them is by adding each to the `copy-dist-files.js` file.\n\n`index.html` 可能會有載入 AngularJS 檔案的 script 標籤，因此 AOT 的 `index.html` 也必須載入這些檔案。複製它們的一種簡單方法是將每個都新增到 `copy-dist-files.js` 檔案中。\n\nYou'll need to use the generated `AppModuleFactory`, instead of the original `AppModule` to bootstrap the hybrid app:\n\n你需要使用產生的 `AppModuleFactory`，而不是原始的 `AppModule` 來引導混合應用程式：\n\n<code-example header=\"app/main-aot.ts\" path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\">\nimport { platformBrowser } from &#39;@angular/platform-browser&#39;;\n\nimport { AppModule } from &#39;./app.module&#39;;\n\nplatformBrowser().bootstrapModule(AppModule);\n\n\n</code-example>\n\nAnd that s all you need do to get the full benefit of AOT for Angular apps!\n\n這就是你要充分利用 AOT for Angular 應用程式的全部優勢！\n\n-->\n<h2 id=\"phonecat-upgrade-tutorial\" translation-result=\"on\">PhoneCat 升級課程<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#phonecat-upgrade-tutorial\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">PhoneCat Upgrade Tutorial<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#phonecat-upgrade-tutorial\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在本節和下節中，你將看一個完整的例子，它使用 <code>upgrade</code> 模組準備和升級了一個應用程式。\n該應用就是來自<a href=\"https://docs.angularjs.org/tutorial\" title=\"PhoneCat Tutorial App | Tutorial | AngularJS\">原 AngularJS 課程</a>中的<a href=\"https://github.com/angular/angular-phonecat\" title=\"angular/angular-phonecat | GitHub\">Angular PhoneCat</a>。\n那是我們很多人當初開始 Angular 探險之旅的地方。\n現在，你會看到如何把該應用帶入 Angular 的美麗新世界。</p><p translation-origin=\"off\">In this section, you'll learn to prepare and upgrade an application with <code>ngUpgrade</code>.\nThe example application is <a href=\"https://github.com/angular/angular-phonecat\" title=\"angular/angular-phonecat | GitHub\">Angular PhoneCat</a> from <a href=\"https://docs.angularjs.org/tutorial\" title=\"PhoneCat Tutorial App | Tutorial | AngularJS\">the original AngularJS tutorial</a>, which is where many of us began our Angular adventures.\nNow you'll see how to bring that application to the brave new world of Angular.</p>\n\n<p translation-result=\"on\">這期間，你將學到如何在實踐中應用<a href=\"guide/upgrade#preparation\" title=\"Preparation - Upgrading from AngularJS to Angular | Angular\">準備指南</a>中列出的那些重點步驟。\n你要先讓該應用向 Angular 看齊，並開始寫 TypeScript。</p><p translation-origin=\"off\">During the process you'll learn how to apply the steps outlined in the <a href=\"guide/upgrade#preparation\" title=\"Preparation - Upgrading from AngularJS to Angular | Angular\">preparation guide</a>.\nYou'll align the application with Angular and also start writing in TypeScript.</p>\n\n<p translation-result=\"on\">本課程基於 <code>angular-phonecat</code> 課程的 1.5.x 版本，該課程儲存在程式碼儲存庫的 <a href=\"https://github.com/angular/angular-phonecat/commits/1.5-snapshot\" title=\"angular/angular-phonecat v1.5 | GitHub\">1.5-snapshot</a> 分支中。接下來，複製 <a href=\"https://github.com/angular/angular-phonecat\" title=\"angular/angular-phonecat | GitHub\">angular-phonecat</a> 程式碼儲存庫，check out <code>1.5-snapshot</code> 分支並應用這些步驟。</p><p translation-origin=\"off\">This tutorial is based on the 1.5.x version of the <code>angular-phonecat</code> tutorial, which is preserved in the <a href=\"https://github.com/angular/angular-phonecat/commits/1.5-snapshot\" title=\"angular/angular-phonecat v1.5 | GitHub\">1.5-snapshot</a> branch of the repository.\nTo follow along, clone the <a href=\"https://github.com/angular/angular-phonecat\" title=\"angular/angular-phonecat | GitHub\">angular-phonecat</a> repository, check out the <code>1.5-snapshot</code> branch and apply the steps as you go.</p>\n\n<p translation-result=\"on\">在專案結構方面，工作的起點是這樣的：</p><p translation-origin=\"off\">In terms of project structure, this is where the work begins:</p>\n\n<div class=\"filetree\">\n  <div class=\"file\">\n    angular-phonecat\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      bower.json\n    </div>\n    <div class=\"file\">\n      karma.conf.js\n    </div>\n    <div class=\"file\">\n      package.json\n    </div>\n    <div class=\"file\">\n      app\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        core\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          checkmark\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            checkmark.filter.js\n          </div>\n          <div class=\"file\">\n            checkmark.filter.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          phone\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            phone.module.js\n          </div>\n          <div class=\"file\">\n            phone.service.js\n          </div>\n          <div class=\"file\">\n            phone.service.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          core.module.js\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-detail\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-detail.component.js\n        </div>\n        <div class=\"file\">\n          phone-detail.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-detail.module.js\n        </div>\n        <div class=\"file\">\n          phone-detail.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-list\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-list.component.js\n        </div>\n        <div class=\"file\">\n          phone-list.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-list.module.js\n        </div>\n        <div class=\"file\">\n          phone-list.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        img\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           …\n        </div>\n      </div>\n      <div class=\"file\">\n        phones\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           …\n        </div>\n      </div>\n      <div class=\"file\">\n        app.animations.js\n      </div>\n      <div class=\"file\">\n        app.config.js\n      </div>\n      <div class=\"file\">\n        app.css\n      </div>\n      <div class=\"file\">\n        app.module.js\n      </div>\n      <div class=\"file\">\n        index.html\n      </div>\n    </div>\n    <div class=\"file\">\n      e2e-tests\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        protractor-conf.js\n      </div>\n      <div class=\"file\">\n        scenarios.js\n      </div>\n    </div>\n  </div>\n</div>\n<p translation-result=\"on\">這確實是一個很好地起點。這些程式碼使用了 AngularJS 1.5 的元件 API，並遵循了 <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\" title=\"Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">AngularJS 風格指南</a>進行組織，\n在成功升級之前，這是一個很重要的<a href=\"guide/upgrade#follow-the-angularjs-style-guide\" title=\"Follow the AngularJS Style Guide - Upgrading from AngularJS to Angular | Angular\">準備步驟</a>。</p><p translation-origin=\"off\">This is actually a pretty good starting point.\nThe code uses the AngularJS 1.5 component API and the organization follows the <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\" title=\"Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">AngularJS Style Guide</a>, which is an important <a href=\"guide/upgrade#follow-the-angularjs-style-guide\" title=\"Follow the AngularJS Style Guide - Upgrading from AngularJS to Angular | Angular\">preparation step</a> before a successful upgrade.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">每個元件、服務和過濾器都在它自己的原始檔中 —— 就像<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\" title=\"Single Responsibility - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">單一規則</a>所要求的。</p><p translation-origin=\"off\">Each component, service, and filter is in its own source file, as per the <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\" title=\"Single Responsibility - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Rule of 1</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>core</code>、<code>phone-detail</code> 和 <code>phone-list</code> 模組都在它們自己的子目錄中。那些子目錄除了包含 HTML 範本之外，還包含 JavaScript 程式碼，它們共同完成一個特性。\n這是<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\" title=\"Folders-by-Feature Structure - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">按特性分目錄的結構</a>\n和<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\" title=\"Modularity - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">模組化</a>規則所要求的。</p><p translation-origin=\"off\">The <code>core</code>, <code>phone-detail</code>, and <code>phone-list</code> modules are each in their own subdirectory.\nThose subdirectories contain the JavaScript code as well as the HTML templates that go with each particular feature.\nThis is in line with the <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\" title=\"Folders-by-Feature Structure - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Folders-by-Feature Structure</a> and <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\" title=\"Modularity - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Modularity</a> rules.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">單元測試都和應用程式碼在一起，它們很容易找到。就像規則\n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\" title=\"Organizing Tests - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">組織測試檔案</a>中要求的那樣。</p><p translation-origin=\"off\">Unit tests are located side-by-side with application code where they are easily found, as described in the rules for <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\" title=\"Organizing Tests - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Organizing Tests</a>.</p>\n\n</li>\n</ul>\n<h3 id=\"switching-to-typescript\" translation-result=\"on\">切換到 TypeScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#switching-to-typescript\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Switching to TypeScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#switching-to-typescript\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">因為你將使用 TypeScript 編寫 Angular 的程式碼，所以在開始升級之前，先要把 TypeScript 的編譯器設定好。</p><p translation-origin=\"off\">Since you're going to be writing Angular code in TypeScript, it makes sense to bring in the TypeScript compiler even before you begin upgrading.</p>\n\n<p translation-result=\"on\">你還將開始逐步淘汰 Bower 包管理器，換成 NPM。後面你將使用 NPM 來安裝新的相依套件，並最終從專案中移除 Bower。</p><p translation-origin=\"off\">You'll also start to gradually phase out the Bower package manager in favor of NPM, installing all new dependencies using NPM, and eventually removing Bower from the project.</p>\n\n<p translation-result=\"on\">先把 TypeScript 套件安裝到專案中。</p><p translation-origin=\"off\">Begin by installing TypeScript to the project.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm i typescript --save-dev\n\n</code-example>\n<p translation-result=\"on\">還要為那些沒有自帶型別資訊的函式庫（比如 AngularJS、AngularJS Material 和 Jasmine）安裝型別定義檔案。</p><p translation-origin=\"off\">Install type definitions for the existing libraries that you're using but that don't come with prepackaged types:\nAngularJS, AngularJS Material, and the Jasmine unit test framework.</p>\n\n<p translation-result=\"on\">對於 PhoneCat 應用，我們可以執行下列命令來安裝必要的型別定義檔案：</p><p translation-origin=\"off\">For the PhoneCat app, we can install the necessary type definitions by running the following command:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @types/jasmine @types/angular @types/angular-animate @types/angular-aria @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n\n</code-example>\n<p translation-result=\"on\">如果你正在使用 AngularJS Material，你可以透過下列命令安裝其型別定義：</p><p translation-origin=\"off\">If you are using AngularJS Material, you can install the type definitions via:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @types/angular-material --save-dev\n\n</code-example>\n<p translation-result=\"on\">你還應該要往專案目錄下新增一個 <code>tsconfig.json</code> 檔案，\n就像在 <a href=\"guide/typescript-configuration\" title=\"TypeScript configuration | Angular\">TypeScript 配置</a>中講過的那樣。\n<code>tsconfig.json</code> 檔案會告訴 TypeScript 編譯器如何把 TypeScript 檔案轉成 ES5 程式碼，並打包進 CommonJS 模組中。</p><p translation-origin=\"off\">You should also configure the TypeScript compiler with a <code>tsconfig.json</code> in the project directory as described in the <a href=\"guide/typescript-configuration\" title=\"TypeScript configuration | Angular\">TypeScript Configuration</a> guide.\nThe <code>tsconfig.json</code> file tells the TypeScript compiler how to turn your TypeScript files into ES5 code bundled into CommonJS modules.</p>\n\n<p translation-result=\"on\">最後，你應該把下列 npm 指令碼新增到 <code>package.json</code> 中，用於把 TypeScript 檔案編譯成 JavaScript（根據 <code>tsconfig.json</code> 的配置）：</p><p translation-origin=\"off\">Finally, you should add some npm scripts in <code>package.json</code> to compile the TypeScript files to JavaScript (based on the <code>tsconfig.json</code> configuration file):</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\n\"scripts\": {\n  \"tsc\": \"tsc\",\n  \"tsc:w\": \"tsc -w\",\n  …\n\n</code-example>\n<p translation-result=\"on\">現在，從命令列中用監視模式啟動 TypeScript 編譯器：</p><p translation-origin=\"off\">Now launch the TypeScript compiler from the command line in watch mode:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm run tsc:w\n\n</code-example>\n<p translation-result=\"on\">讓這個處理序一直在後台執行，監聽任何變化並自動重新編譯。</p><p translation-origin=\"off\">Keep this process running in the background, watching and recompiling as you make changes.</p>\n\n<p translation-result=\"on\">接下來，把 JavaScript 檔案轉換成 TypeScript 檔案。由於 TypeScript 是 ECMAScript 2015 的一個超集，而 ES2015 又是 ECMAScript 5 的超集，所以你可以簡單的把檔案的副檔名從 <code>.js</code> 換成 <code>.ts</code>，它們還是會像以前一樣工作。由於 TypeScript 編譯器仍在執行，它會為每一個 <code>.ts</code> 檔案產生對應的 <code>.js</code> 檔案，而真正執行的是編譯後的 <code>.js</code> 檔案。如果你用 <code>npm start</code> 開啟了本專案的 HTTP 伺服器，你會在瀏覽器中看到一個功能完好的應用。</p><p translation-origin=\"off\">Next, convert your current JavaScript files into TypeScript.\nSince TypeScript is a super-set of ECMAScript 2015, which in turn is a super-set of ECMAScript 5, you can switch the file extensions from <code>.js</code> to <code>.ts</code> and everything will work just like it did before.\nAs the TypeScript compiler runs, it emits the corresponding <code>.js</code> file for every <code>.ts</code> file and the compiled JavaScript is what actually gets executed.\nIf you start the project HTTP server with <code>npm start</code>, you should see the fully functional application in your browser.</p>\n\n<p translation-result=\"on\">有了 TypeScript，你就可以從它的一些特性中獲益了。此語言可以為 AngularJS 應用提供很多價值。</p><p translation-origin=\"off\">Now that you have TypeScript though, you can start benefiting from some of its features.\nThere is a lot of value the language can provide to AngularJS applications.</p>\n\n<p translation-result=\"on\">首先，TypeScript 是一個 ES2015 的超集。任何以前用 ES5 寫的程式（就像 PhoneCat 範例）都可以開始透過 TypeScript 納入那些新增到 ES2015 中的新特性。這包括 <code>let</code>、<code>const</code>、箭頭函式、函式預設引數以及解構（destructure）賦值。</p><p translation-origin=\"off\">For one thing, TypeScript is a superset of ES2015.\nAny application that has previously been written in ES5 —like the PhoneCat example has— can with TypeScript start incorporating all of the JavaScript features that are new to ES2015.\nThese include things like <code>let</code>s and <code>const</code>s, arrow functions, default function parameters, and destructuring assignments.</p>\n\n<p translation-result=\"on\">你能做的另一件事就是把<em>型別安全</em>新增到程式碼中。這實際上已經部分完成了，因為你已經安裝了 AngularJS 的型別定義。TypeScript 會幫你檢查是否正確呼叫了 AngularJS 的 API，—— 比如往 Angular 模組中註冊元件。</p><p translation-origin=\"off\">Another thing you can do is start adding <em>type safety</em> to your code.\nThis has actually partially already happened because of the AngularJS typings you installed.\nTypeScript are checking that you are calling AngularJS APIs correctly when you do things like register components to Angular modules.</p>\n\n<p translation-result=\"on\">你還能開始把<em>型別註解</em>新增到自己的程式碼中，來從 TypeScript 的型別系統中獲得更多幫助。比如，你可以給 <code>checkmark</code> 過濾器加上註解，表明它期待一個 <code>boolean</code> 型別的引數。這可以更清楚的表明此過濾器打算做什麼。</p><p translation-origin=\"off\">But you can also start adding <em>type annotations</em> to get even more out of type system of TypeScript.\nFor instance, you can annotate the checkmark filter so that it explicitly expects booleans as arguments.\nThis makes it clearer what the filter is supposed to do.</p>\n\n<code-example header=\"app/core/checkmark/checkmark.filter.ts\" path=\"upgrade-phonecat-1-typescript/app/core/checkmark/checkmark.filter.ts\">\nangular.\n  module('core').\n  filter('checkmark', () =&gt; (input: boolean) =&gt; input ? '\\u2713' : '\\u2718');\n\n\n</code-example>\n<p translation-result=\"on\">在 <code>Phone</code> 服務中，你可以明確的把 <code>$resource</code> 服務宣告為 <code>angular.resource.IResourceService</code>，一個 AngularJS 型別定義提供的型別。</p><p translation-origin=\"off\">In the <code>Phone</code> service, you can explicitly annotate the <code>$resource</code> service dependency as an <code>angular.resource.IResourceService</code> - a type defined by the AngularJS typings.</p>\n\n<code-example header=\"app/core/phone/phone.service.ts\" path=\"upgrade-phonecat-1-typescript/app/core/phone/phone.service.ts\">\nangular.\n  module('core.phone').\n  factory('Phone', ['$resource',\n    ($resource: angular.resource.IResourceService) =&gt;\n      $resource('phones/:phoneId.json', {}, {\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: {\n          method: 'GET',\n          params: {phoneId: 'phones'},\n          isArray: true\n        }\n      })\n  ]);\n\n\n</code-example>\n<p translation-result=\"on\">你可以在應用的路由配置中使用同樣的技巧，那裡你用到了 location 和 route 服務。一旦為它們提供了型別資訊，TypeScript 就能檢查你是否在用型別的正確引數來呼叫它們了。</p><p translation-origin=\"off\">You can apply the same trick to the route configuration file of the application in <code>app.config.ts</code>, where you are using the location and route services.\nBy annotating them accordingly TypeScript can verify you're calling their APIs with the correct kinds of arguments.</p>\n\n<code-example header=\"app/app.config.ts\" path=\"upgrade-phonecat-1-typescript/app/app.config.ts\">\nangular.\n  module('phonecatApp').\n  config(['$locationProvider', '$routeProvider',\n    function config($locationProvider: angular.ILocationProvider,\n                    $routeProvider: angular.route.IRouteProvider) {\n      $locationProvider.hashPrefix('!');\n\n      $routeProvider.\n        when('/phones', {\n          template: '&lt;phone-list&gt;&lt;/phone-list&gt;'\n        }).\n        when('/phones/:phoneId', {\n          template: '&lt;phone-detail&gt;&lt;/phone-detail&gt;'\n        }).\n        otherwise('/phones');\n    }\n  ]);\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你用安裝的這個<a href=\"https://www.npmjs.com/package/@types/angular\" title=\"@types/angular | npm\">AngularJS.x 型別定義檔案</a>\n並不是由 Angular 開發組維護的，但它也已經足夠全面了。藉助這些型別定義的幫助，它可以為 AngularJS.x 程式加上全面的型別註解。</p><p translation-origin=\"off\">The <a href=\"https://www.npmjs.com/package/@types/angular\" title=\"@types/angular | npm\">AngularJS 1.x type definitions</a> you installed are not officially maintained by the Angular team, but are quite comprehensive.\nIt is possible to make an AngularJS 1.x application fully type-annotated with the help of these definitions.</p>\n\n<p translation-result=\"on\">如果你想這麼做，就在 <code>tsconfig.json</code> 中啟用 <code>noImplicitAny</code> 配置項。這樣，如果遇到什麼還沒有型別註解的程式碼，TypeScript 編譯器就會顯示一個警告。你可以用它作為指南，告訴你現在與一個完全型別化的專案距離還有多遠。</p><p translation-origin=\"off\">If this is something you wanted to do, it would be a good idea to enable the <code>noImplicitAny</code> configuration option in <code>tsconfig.json</code>.\nThis would cause the TypeScript compiler to display a warning when there is any code that does not yet have type annotations.\nYou could use it as a guide to inform us about how close you are to having a fully annotated project.</p>\n\n</div>\n<p translation-result=\"on\">你能用的另一個 TypeScript 特性是<em>類</em>。具體來講，你可以把控制器轉換成類別。這種方式下，你離成為 Angular 元件類就又近了一步，它會令你的升級之路變得更簡單。</p><p translation-origin=\"off\">Another TypeScript feature you can make use of is <em>classes</em>.\nIn particular, you can turn component controllers into classes.\nThat way they'll be a step closer to becoming Angular component classes, which will make life easier once you upgrade.</p>\n\n<p translation-result=\"on\">AngularJS 期望控制器是一個建構函式。這實際上就是 ES2015/TypeScript 中的類，這也就意味著只要你把一個類別註冊為元件控制器，AngularJS 就會愉快的使用它。</p><p translation-origin=\"off\">AngularJS expects controllers to be constructor functions.\nThat is exactly what ES2015/TypeScript classes are under the hood, so that means you can just plug in a class as a component controller and AngularJS will happily use it.</p>\n\n<p translation-result=\"on\">新的“電話列表（phone list）”元件控制器類是這樣的：</p><p translation-origin=\"off\">Here is what the new class for the phone list component controller looks like:</p>\n\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-1-typescript/app/phone-list/phone-list.component.ts\">\nclass PhoneListController {\n  phones: any[];\n  orderProp: string;\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['Phone'];\n  constructor(Phone: any) {\n    this.phones = Phone.query();\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<p translation-result=\"on\">以前在控制器函式中實現的一切，現在都改由類別的建構函式來實現了。型別注入註解透過靜態屬性 <code>$inject</code> 被附加到了類上。在執行時，它們變成了 <code>PhoneListController.$inject</code>。</p><p translation-origin=\"off\">What was previously done in the controller function is now done in the class constructor function.\nThe dependency injection annotations are attached to the class using a static property <code>$inject</code>.\nAt runtime this becomes the <code>PhoneListController.$inject</code> property.</p>\n\n<p translation-result=\"on\">該類還聲明瞭另外三個成員：電話列表、當前排序鍵的名字和搜尋條件。這些東西你以前就加到了控制器上，只是從來沒有在任何地方顯式定義過它們。最後一個成員從未真正在 TypeScript 程式碼中用過，因為它只是在範本中被參考過。但為了清晰起見，你還是應該定義出此控制器應有的所有成員。</p><p translation-origin=\"off\">The class additionally declares three members:\nThe array of phones, the name of the current sort key, and the search query.\nThese are all things you have already been attaching to the controller but that weren't explicitly declared anywhere.\nThe last one of these isn't actually used in the TypeScript code since it is only referred to in the template, but for the sake of clarity you should define all of the controller members.</p>\n\n<p translation-result=\"on\">在電話詳情控制器中，你有兩個成員：一個是使用者正在檢視的電話，另一個是正在顯示的圖像：</p><p translation-origin=\"off\">In the Phone detail controller, you'll have two members:\nOne for the phone that the user is looking at and another for the URL of the currently displayed image:</p>\n\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.ts\">\nclass PhoneDetailController {\n  phone: any;\n  mainImageUrl: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['$routeParams', 'Phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, Phone: any) {\n    const phoneId = $routeParams.phoneId;\n    this.phone = Phone.get({phoneId}, (phone: any) =&gt; {\n      this.setImage(phone.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p translation-result=\"on\">這已經讓你的控制器程式碼看起來更像 Angular 了。你的準備工作做好了，可以引進 Angular 到專案中了。</p><p translation-origin=\"off\">This makes the controller code look a lot more like Angular already.\nYou're all set to actually introduce Angular into the project.</p>\n\n<p translation-result=\"on\">如果專案中有任何 AngularJS 的服務，它們也是轉換成類別的優秀候選人，像控制器一樣，它們也是建構函式。但是在本專案中，你只有一個 <code>Phone</code> 工廠，這有點特別，因為它是一個 <code>ngResource</code> 工廠。所以你不會在準備階段中處理它，而是在下一節中直接把它轉換成 Angular 服務。</p><p translation-origin=\"off\">If you had any AngularJS services in the project, those would also be a good candidate for converting to classes, since like controllers, they're also constructor functions.\nBut you only have the <code>Phone</code> factory in this project, and that is a bit special since it is an <code>ngResource</code> factory.\nSo you won't be doing anything to it in the preparation stage.\nYou'll instead turn it directly into an Angular service.</p>\n\n<h3 id=\"installing-angular\" translation-result=\"on\">安裝 Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#installing-angular\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Installing Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#installing-angular\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">準備工作做完了，接下來就開始把 PhoneCat 升級到 Angular。\n你將在 Angular<a href=\"guide/upgrade#upgrading-with-ngupgrade\" title=\"Upgrading with ngUpgrade - Upgrading from AngularJS to Angular | Angular\">升級模組</a>的幫助下增量式的完成此項工作。\n做完這些之後，就能把 AngularJS 從專案中完全移除了，但其中的關鍵是在不破壞此程式的前提下一小塊一小塊的完成它。</p><p translation-origin=\"off\">Having completed the preparation work, get going with the Angular upgrade of PhoneCat.\nYou'll do this incrementally with the help of <a href=\"guide/upgrade#upgrading-with-ngupgrade\" title=\"Upgrading with ngUpgrade - Upgrading from AngularJS to Angular | Angular\">ngUpgrade</a> that comes with Angular.\nBy the time you're done, you'll be able to remove AngularJS from the project completely, but the key is to do this piece by piece without breaking the application.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">該專案還包含一些動畫，在此指南的當前版本你先不升級它，請到 <a href=\"guide/animations\" title=\"Introduction to Angular animations | Angular\">Angular 動畫</a>中進一步學習。</p><p translation-origin=\"off\">The project also contains some animations.\nYou won't upgrade them in this version of the guide.\nTurn to the <a href=\"guide/animations\" title=\"Introduction to Angular animations | Angular\">Angular animations</a> guide to learn about that.</p>\n\n</div>\n<p translation-result=\"on\">用 SystemJS 模組載入器把 Angular 安裝到專案中。\n看看<a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">升級的準備工作</a>中的指南，並從那裡獲得如下配置：</p><p translation-origin=\"off\">Install Angular into the project, along with the SystemJS module loader.\nTake a look at the results of the <a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">upgrade setup instructions</a> and get the following configurations from there:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">把 Angular 和其它新依賴新增到 <code>package.json</code> 中</p><p translation-origin=\"off\">Add Angular and the other new dependencies to <code>package.json</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">把 SystemJS 的配置檔案 <code>systemjs.config.js</code> 新增到專案的根目錄。</p><p translation-origin=\"off\">The SystemJS configuration file <code>systemjs.config.js</code> to the project root directory.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">這些完成之後，就執行：</p><p translation-origin=\"off\">Once these are done, run:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install\n\n</code-example>\n<p translation-result=\"on\">很快你就可以透過 <code>index.html</code> 來把 Angular 的依賴快速載入到應用中，但首先，你得做一些目錄結構調整。這是因為你正準備從 <code>node_modules</code> 中載入檔案，然而目前專案中的每一個檔案都是從 <code>/app</code> 目錄下載入的。</p><p translation-origin=\"off\">Soon you can load Angular dependencies into the application inside <code>index.html</code>, but first you need to do some directory path adjustments.\nYou'll need to load files from <code>node_modules</code> and the project root instead of from the <code>/app</code> directory as you've been doing to this point.</p>\n\n<p translation-result=\"on\">把 <code>app/index.html</code> 移入專案的根目錄，然後把 <code>package.json</code> 中的開發伺服器根目錄也指向專案的根目錄，而不再是 <code>app</code> 目錄：</p><p translation-origin=\"off\">Move the <code>app/index.html</code> file to the project root directory.\nThen change the development server root path in <code>package.json</code> to also point to the project root instead of <code>app</code>:</p>\n\n<code-example language=\"json\">\n\n\"start\": \"http-server ./ -a localhost -p 8000 -c-1\",\n\n</code-example>\n<p translation-result=\"on\">現在，你就能把專案根目錄下的每一樣東西發給瀏覽器了。但你<em>不想</em>為了適應開發環境中的設定，被迫修改應用程式碼中用到的所有圖片和資料的路徑。因此，你要往 <code>index.html</code> 中新增一個 <code>&lt;base&gt;</code> 標籤，它將導致各種相對路徑被解析回 <code>/app</code> 目錄：</p><p translation-origin=\"off\">Now you're able to serve everything from the project root to the web browser.\nBut you do <em>not</em> want to have to change all the image and data paths used in the application code to match the development setup.\nFor that reason, you'll add a <code>&lt;base&gt;</code> tag to <code>index.html</code>, which will cause relative URLs to be resolved back to the <code>/app</code> directory:</p>\n\n<code-example header=\"index.html\" path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"base\">\n&lt;base href=\"/app/\"&gt;\n\n</code-example>\n<p translation-result=\"on\">現在你可以透過 SystemJS 載入 Angular 了。你還要把 Angular 的Polyfill指令碼（polyfills） 和 SystemJS 的配置加到 <code>&lt;head&gt;</code> 區的末尾，然後，你能就用 <code>System.import</code> 來載入實際的應用了：</p><p translation-origin=\"off\">Now you can load Angular using SystemJS.\nYou'll add the Angular polyfills and the SystemJS configuration to the end of the <code>&lt;head&gt;</code> section, and then you'll use <code>System.import</code> to load the actual application:</p>\n\n<code-example header=\"index.html\" path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"angular\">\n&lt;script src=\"/node_modules/core-js/client/shim.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/node_modules/zone.js/bundles/zone.umd.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/node_modules/systemjs/dist/system.src.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/systemjs.config.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  System.import('/app');\n&lt;/script&gt;\n\n</code-example>\n<p translation-result=\"on\">你還需要對<a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">升級的準備工作</a>期間安裝的 <code>systemjs.config.js</code> 檔案做一些調整。</p><p translation-origin=\"off\">You also need to make a couple of adjustments to the <code>systemjs.config.js</code> file installed during <a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">upgrade setup</a>.</p>\n\n<p translation-result=\"on\">在 SystemJS 載入期間為瀏覽器指出專案的根在哪裡，而不再使用 <code>&lt;base&gt;</code> URL。</p><p translation-origin=\"off\">Point the browser to the project root when loading things through SystemJS, instead of using the <code>&lt;base&gt;</code> URL.</p>\n\n<p translation-result=\"on\">再透過 <code>npm install @angular/upgrade --save</code> 安裝 <code>upgrade</code> 套件，併為 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 包新增一個對映。</p><p translation-origin=\"off\">Install the <code>upgrade</code> package using <code>npm install @angular/upgrade --save</code> and add a mapping for the <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> package.</p>\n\n<code-example header=\"systemjs.config.js\" path=\"upgrade-phonecat-2-hybrid/systemjs.config.1.js\" region=\"paths\">\nSystem.config({\n  paths: {\n    // paths serve as alias\n    'npm:': '/node_modules/'\n  },\n  map: {\n    'ng-loader': '../src/systemjs-angular-loader.js',\n    app: '/app',\n    /* . . . */\n    '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/fesm2022/static.mjs',\n    /* . . . */\n  },\n\n</code-example>\n<h3 id=\"creating-the-appmodule\" translation-result=\"on\">建立 <code>AppModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#creating-the-appmodule\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Creating the <code>AppModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#creating-the-appmodule\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">現在，建立一個名叫 <code>AppModule</code> 的根 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 類別。這裡已經有了一個名叫 <code>app.module.ts</code> 的檔案，其中存放著 AngularJS 的模組。把它改名為 <code>app.module.ajs.ts</code>，同時也要在 <code>index.html</code> 中修改對應的指令碼名。檔案的內容保留：</p><p translation-origin=\"off\">Now create the root <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> class called <code>AppModule</code>.\nThere is already a file named <code>app.module.ts</code> that holds the AngularJS module.\nRename it to <code>app.module.ajs.ts</code> and update the corresponding script name in the <code>index.html</code> as well.\nThe file contents remain:</p>\n\n<code-example header=\"app.module.ajs.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ajs.ts\">\n// Define the `phonecatApp` AngularJS module\nangular.module('phonecatApp', [\n  'ngAnimate',\n  'ngRoute',\n  'core',\n  'phoneDetail',\n  'phoneList',\n]);\n\n\n</code-example>\n<p translation-result=\"on\">然後建立一個新的 <code>app.module.ts</code> 檔案，其中是一個最小化的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 類：</p><p translation-origin=\"off\">Now create a new <code>app.module.ts</code> with the minimum <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> class:</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"bare\">\nimport { <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n}\n\n</code-example>\n<h3 id=\"bootstrapping-a-hybrid-phonecat\" translation-result=\"on\">引導 PhoneCat 的混合式應用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-a-hybrid-phonecat\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Bootstrapping a hybrid PhoneCat<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-a-hybrid-phonecat\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">接下來，你把該應用程式引導改裝為一個同時支援 AngularJS 和 Angular 的<em>混合式應用</em>。然後，就能開始把這些不可分割的小塊轉換到 Angular 了。</p><p translation-origin=\"off\">Next, you'll bootstrap the application as a <em>hybrid application</em> that supports both AngularJS and Angular components.\nAfter that, you can start converting the individual pieces to Angular.</p>\n\n<p translation-result=\"on\">本應用現在是使用宿主頁面中附加到 <code>&lt;html&gt;</code> 元素上的 AngularJS 指令 <code>ng-app</code> 引導的。\n但在混合式應用中，不能再這麼用了。你得用<a href=\"guide/upgrade#bootstrapping-hybrid-applications\" title=\"Bootstrapping hybrid applications - Upgrading from AngularJS to Angular | Angular\">ngUpgrade bootstrap</a>方法代替。</p><p translation-origin=\"off\">The application is currently bootstrapped using the AngularJS <code>ng-app</code> directive attached to the <code>&lt;html&gt;</code> element of the host page.\nThis will no longer work in the hybrid application.\nSwitch to the <a href=\"guide/upgrade#bootstrapping-hybrid-applications\" title=\"Bootstrapping hybrid applications - Upgrading from AngularJS to Angular | Angular\">ngUpgrade bootstrap</a> method instead.</p>\n\n<p translation-result=\"on\">首先，從 <code>index.html</code> 中移除 <code>ng-app</code>。然後在 <code>AppModule</code> 中匯入 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，並改寫它的 <code>ngDoBootstrap</code> 方法：</p><p translation-origin=\"off\">First, remove the <code>ng-app</code> attribute from <code>index.html</code>.\nThen import <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> in the <code>AppModule</code>, and override its <code>ngDoBootstrap</code> method:</p>\n\n<code-example header=\"app/app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"upgrademodule\">\nimport { <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">注意，你正在從內部的 <code>ngDoBootstrap</code> 中引導 AngularJS 模組。它的引數和你在手動引導 AngularJS 時傳給 <code>angular.bootstrap</code> 的是一樣的：應用的根元素，和所要載入的 AngularJS 1.x 模組的陣列。</p><p translation-origin=\"off\">You are bootstrapping the AngularJS module from inside <code>ngDoBootstrap</code>.\nThe arguments are the same as you would pass to <code>angular.bootstrap</code> if you were manually bootstrapping AngularJS:\nthe root element of the application; and an array of the AngularJS 1.x modules that you want to load.</p>\n\n<p translation-result=\"on\">最後，在 <code>app/main.ts</code> 中引導這個 <code>AppModule</code>。該檔案在 <code>systemjs.config.js</code> 中被配置為了應用的入口，所以它已經被載入進了瀏覽器中。</p><p translation-origin=\"off\">Finally, bootstrap the <code>AppModule</code> in <code>app/main.ts</code>.\nThis file has been configured as the application entrypoint in <code>systemjs.config.js</code>, so it is already being loaded by the browser.</p>\n\n<code-example header=\"app/main.ts\" path=\"upgrade-phonecat-2-hybrid/app/main.ts\" region=\"bootstrap\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n</code-example>\n<p translation-result=\"on\">現在，你同時執行著 AngularJS 和 Angular。漂亮！不過你還沒有執行什麼實際的 Angular 元件，這就是接下來要做的。</p><p translation-origin=\"off\">Now you're running both AngularJS and Angular at the same time.\nThat is pretty exciting!\nYou're not running any actual Angular components yet.\nThat is next.</p>\n\n<div class=\"callout is-helpful\">\n<header ng-should-translate=\"\" translation-result=\"on\">為何要宣告 *angular* 為*angular.IAngularStatic*？</header><header ng-should-translate=\"\" translation-origin=\"off\">Why declare *angular* as *angular.IAngularStatic*?</header>\n\n<p translation-result=\"on\"><code>@types/angular</code> 宣告為 UMD 模組，根據 <a href=\"https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#support-for-umd-module-definitions\" title=\"Support for UMD module definitions - What's new in TypeScript | microsoft/TypeScript | GitHub\">UMD 型別</a>的工作方式，一旦你在檔案中有一條 ES6 的 <code>import</code> 陳述式，所有的 UMD 型別化的模型必須都透過 <code>import</code> 陳述式匯入，\n而是不是全域可用。</p><p translation-origin=\"off\"><code>@types/angular</code> is declared as a UMD module, and due to the way <a href=\"https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#support-for-umd-module-definitions\" title=\"Support for UMD module definitions - What's new in TypeScript | microsoft/TypeScript | GitHub\">UMD typings</a> work, once you have an ES6 <code>import</code> statement in a file all UMD typed modules must also be imported using <code>import</code> statements instead of being globally available.</p>\n\n<p translation-result=\"on\">AngularJS 是日前是透過 <code>index.html</code> 中的 script 標籤載入，這意味著整個應用是作為一個全域變數進行存取的，使用同一個 <code>angular</code> 變數的例項。但如果你使用 <code>import * as angular from 'angular'</code>，我還需要徹底修改 AngularJS 應用中載入每個檔案的方式，確保 AngularJS 應用被正確載入。</p><p translation-origin=\"off\">AngularJS is currently loaded by a script tag in <code>index.html</code>, which means that the whole app has access to it as a global and uses the same instance of the <code>angular</code> variable.\nIf you used <code>import * as angular from 'angular'</code> instead, you'd also have to load every file in the AngularJS application to use ES2015 modules in order to ensure AngularJS was being loaded correctly.</p>\n\n<p translation-result=\"on\">這需要相當多的努力，通常也不值得去做，特別是當你正在朝著 Angular 前進時。但如果你把 <code>angular</code> 宣告為 <code>angular.IAngularStatic</code>，指明它是一個全域變數，仍然可以獲得全面的型別支援。</p><p translation-origin=\"off\">This is a considerable effort and it often isn't worth it, especially since you are in the process of moving your code to Angular.\nInstead, declare <code>angular</code> as <code>angular.IAngularStatic</code> to indicate it is a global variable and still have full typing support.</p>\n\n<div class=\"callout is-important\">\n<header ng-should-translate=\"\" translation-result=\"on\">為 Angular 應用手動建立 UMD 套件</header><header ng-should-translate=\"\" translation-origin=\"off\">Manually create a UMD bundle for your Angular application</header>\n\n<p translation-result=\"on\">從 Angular 版本 13 開始，<a href=\"https://github.com/angular/angular/issues/38366\" title=\" Issue 38366: RFC: Ivy Library Distribution| angular/angular | GitHub\">分發格式</a> 中不再包含 UMD 套件。</p><p translation-origin=\"off\">Starting with Angular version 13, the <a href=\"https://github.com/angular/angular/issues/38366\" title=\" Issue 38366: RFC: Ivy Library Distribution| angular/angular | GitHub\">distribution format</a> no longer includes UMD bundles.</p>\n\n<p translation-result=\"on\">如果你的使用案例需要 UMD 格式，請使用 <a href=\"https://rollupjs.org\" title=\"rollup.js\"><code>rollup</code></a> 從平面 ES 模組檔案手動產生套件。</p><p translation-origin=\"off\">If your use case requires the UMD format, use <a href=\"https://rollupjs.org\" title=\"rollup.js\"><code>rollup</code></a> to manually produce a bundle from the flat ES module files.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">使用 <code>npm</code> 全域安裝 <code>rollup</code></p><p translation-origin=\"off\">Use <code>npm</code> to globally install <code>rollup</code></p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm i -g rollup\n\nnpm i -g 彙總\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">輸出 <code>rollup</code> 的版本並驗證安裝是否成功</p><p translation-origin=\"off\">Output the version of <code>rollup</code> and verify the installation was successful</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nrollup -v\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">為 <code>rollup</code> 建立 <code>rollup.config.js</code> 配置檔案，以使用全域 <code>ng</code> 命令來參考所有 Angular 框架的匯出。</p><p translation-origin=\"off\">Create the <code>rollup.config.js</code> configuration file for <code>rollup</code> to use the global <code>ng</code> command to reference all of the Angular framework exports.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">建立一個名為 <code>rollup.config.js</code> 的檔案</p><p translation-origin=\"off\">Create a file named <code>rollup.config.js</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">將以下內容複製到 <code>rollup.config.js</code></p><p translation-origin=\"off\">Copy the following content into <code>rollup.config.js</code></p>\n\n<code-example language=\"javascript\">\n\nexport default {\n  input: 'node_modules/@angular/core/fesm2022/core.js',\n  output: {\n    file: 'bundle.js',\n    format: 'umd',\n    name: 'ng'\n  }\n}\n\n</code-example>\n</li>\n</ol>\n</li>\n<li>\n<p translation-result=\"on\">使用 <code>rollup</code> 根據 <code>rollup.config.js</code> 中的設定建立 <code>bundle.js</code> UMD 套件</p><p translation-origin=\"off\">Use <code>rollup</code> to create the <code>bundle.js</code> UMD bundle using settings in <code>rollup.config.js</code></p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nrollup -c rollup.config.js\n\n</code-example>\n</li>\n</ol>\n<p translation-result=\"on\"><code>bundle.js</code> 檔案包含你的 UMD 套件。有關 GitHub 上的範例，請參閱 <a href=\"https://github.com/mgechev/angular-umd-bundle\" title=\"UMD Angular bundle | mgechev/angular-umd-bundle | GitHub\">UMD Angular 套件</a>。</p><p translation-origin=\"off\">The <code>bundle.js</code> file contains your UMD bundle.\nFor an example on GitHub, see <a href=\"https://github.com/mgechev/angular-umd-bundle\" title=\"UMD Angular bundle | mgechev/angular-umd-bundle | GitHub\">UMD Angular bundle</a>.</p>\n\n</div>\n</div>\n<h3 id=\"upgrading-the-phone-service\" translation-result=\"on\">升級 <code>Phone</code> 服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-the-phone-service\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Upgrading the Phone service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-the-phone-service\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你要移植到 Angular 的第一個片段是 <code>Phone</code> 工廠（位於 <code>app/core/phone/phone.service.ts</code>），並且讓它能幫助控制器從伺服器上載入電話資訊。目前，它是用 <code>ngResource</code> 實現的，你用它做兩件事：</p><p translation-origin=\"off\">The first piece you'll port over to Angular is the <code>Phone</code> service, which resides in <code>app/core/phone/phone.service.ts</code> and makes it possible for components to load phone information from the server.\nRight now it is implemented with ngResource and you're using it for two things:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">把所有電話的列表載入到電話列表元件中。</p><p translation-origin=\"off\">For loading the list of all phones into the phone list component</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把一臺電話的詳情載入到電話詳情元件中。</p><p translation-origin=\"off\">For loading the details of a single phone into the phone detail component</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">你可以用 Angular 的服務類來替換這個實現，而把控制器繼續留在 AngularJS 的地盤上。</p><p translation-origin=\"off\">You can replace this implementation with an Angular service class, while keeping the controllers in AngularJS land.</p>\n\n<p translation-result=\"on\">在這個新版本中，你匯入了 Angular 的 HTTP 模組，並且用它的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務替換掉 <code>ngResource</code>。</p><p translation-origin=\"off\">In the new version, you import the Angular HTTP module and call its <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service instead of <code>ngResource</code>.</p>\n\n<p translation-result=\"on\">再次開啟 <code>app.module.ts</code> 檔案，匯入並把 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> 新增到 <code>AppModule</code> 的 <code>imports</code> 陣列中：</p><p translation-origin=\"off\">Re-open the <code>app.module.ts</code> file, import and add <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> to the <code>imports</code> array of the <code>AppModule</code>:</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"httpclientmodule\">\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">現在，你已經準備好了升級 <code>Phone</code> 服務本身。你將為 <code>phone.service.ts</code> 檔案中基於 ngResource 的服務加上 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 裝飾器：</p><p translation-origin=\"off\">Now you're ready to upgrade the Phone service itself.\nReplace the ngResource-based service in <code>phone.service.ts</code> with a TypeScript class decorated as <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code>:</p>\n\n<code-example header=\"app/core/phone/phone.service.ts (skeleton)\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"classdef\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n/* . . . */\n}\n\n</code-example>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 裝飾器將把一些依賴注入相關的元資料附加到該類上，讓 Angular 知道它的依賴資訊。\n就像在<a href=\"guide/dependency-injection\" title=\"Dependency injection in Angular | Angular\">依賴注入指南</a>中描述過的那樣，\n這是一個令牌裝飾器，你要把它用在那些沒有其它 Angular 裝飾器，並且自己有依賴注入的類上。</p><p translation-origin=\"off\">The <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> decorator will attach some dependency injection metadata to the class, letting Angular know about its dependencies.\nAs described by the <a href=\"guide/dependency-injection\" title=\"Dependency injection in Angular | Angular\">Dependency Injection Guide</a>, this is a marker decorator you need to use for classes that have no other Angular decorators but still need to have their dependencies injected.</p>\n\n<p translation-result=\"on\">在它的建構函式中，該類期待一個 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務。<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務將被注入進來並存入一個私有欄位。然後該服務在兩個例項方法中被使用到，一個載入所有電話的列表，另一個載入一臺指定電話的詳情：</p><p translation-origin=\"off\">In its constructor the class expects to get the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service.\nIt will be injected to it and it is stored as a private field.\nThe service is then used in the two instance methods, one of which loads the list of all phones, and the other loads the details of a specified phone:</p>\n\n<code-example header=\"app/core/phone/phone.service.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"fullclass\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&lt;PhoneData[]&gt; {\n    return this.http.get&lt;PhoneData[]&gt;(`phones/phones.json`);\n  }\n  get(id: string): Observable&lt;PhoneData&gt; {\n    return this.http.get&lt;PhoneData&gt;(`phones/${id}.json`);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">該方法現在返回一個 <code>Phone</code> 型別或 <code>Phone[]</code> 型別的可觀察物件（Observable）。這是一個你從未用過的型別，因此你得為它新增一個簡單的介面：</p><p translation-origin=\"off\">The methods now return observables of type <code>PhoneData</code> and <code>PhoneData[]</code>.\nThis is a type you don't have yet.\nAdd a simple interface for it:</p>\n\n<code-example header=\"app/core/phone/phone.service.ts (interface)\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"phonedata-interface\">\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n</code-example>\n<p translation-result=\"on\"><code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 有一個 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a></code> 方法，可以使 Angular 服務在 AngularJS 的程式碼中可用。使用它來插入 <code>Phone</code> 服務：</p><p translation-origin=\"off\"><code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> has a <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a></code> method for the purpose of making Angular services available to AngularJS code.\nUse it to plug in the <code>Phone</code> service:</p>\n\n<code-example header=\"app/core/phone/phone.service.ts (downgrade)\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"downgrade-injectable\">\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n/* . . . */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n/* . . . */\n}\n\nangular.module('core.phone')\n  .factory('phone', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Phone));\n\n</code-example>\n<p translation-result=\"on\">最終，該類別的全部程式碼如下：</p><p translation-origin=\"off\">Here is the full, final code for the service:</p>\n\n<code-example header=\"app/core/phone/phone.service.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\nimport { Observable } from 'rxjs';\n\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&lt;PhoneData[]&gt; {\n    return this.http.get&lt;PhoneData[]&gt;(`phones/phones.json`);\n  }\n  get(id: string): Observable&lt;PhoneData&gt; {\n    return this.http.get&lt;PhoneData&gt;(`phones/${id}.json`);\n  }\n}\n\nangular.module('core.phone')\n  .factory('phone', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Phone));\n\n\n</code-example>\n<p translation-result=\"on\">注意，你要單獨匯入了 RxJS <code>Observable</code> 中的 <code>map</code> 運運算元。對每個 RxJS 運運算元都要這麼做。</p><p translation-origin=\"off\">Notice that you're importing the <code>map</code> operator of the RxJS <code>Observable</code> separately.\nDo this for every RxJS operator.</p>\n\n<p translation-result=\"on\">這個新的 <code>Phone</code> 服務具有和老的基於 <code>ngResource</code> 的服務相同的特性。因為它是 Angular 服務，你透過 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>providers</code> 陣列來註冊它：</p><p translation-origin=\"off\">The new <code>Phone</code> service has the same features as the original, <code>ngResource</code>-based service.\nBecause it is an Angular service, you register it with the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> providers:</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phone\">\nimport { Phone } from './core/phone/phone.service';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n  providers: [\n    Phone,\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">現在，你正在用 SystemJS 載入 <code>phone.service.ts</code>，你應該從 <code>index.html</code> 中<strong>移除該服務的 <code>&lt;script&gt;</code> 標籤</strong>。這也是你在升級所有元件時將會做的事。在從 AngularJS 向 Angular 升級的同時，你也把程式碼從指令碼移植為模組。</p><p translation-origin=\"off\">Now that you are loading <code>phone.service.ts</code> through an import that is resolved by SystemJS, you should <strong>remove the &lt;script&gt; tag</strong> for the service from <code>index.html</code>.\nThis is something you'll do to all components as you upgrade them.\nSimultaneously with the AngularJS to Angular upgrade you're also migrating code from scripts to modules.</p>\n\n<p translation-result=\"on\">這時，你可以把兩個控制器從使用老的服務切換成使用新的。你像降級過的 <code>phone</code> 工廠一樣 <code>$inject</code> 它，但它實際上是一個 <code>Phone</code> 類別的例項，並且你可以據此註解它的型別：</p><p translation-origin=\"off\">At this point, you can switch the two components to use the new service instead of the old one.\nWhile you <code>$inject</code> it as the downgraded <code>phone</code> factory, it is really an instance of the <code>Phone</code> class and you annotate its type accordingly:</p>\n\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ajs.ts\">\ndeclare const angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneListController {\n  phones: PhoneData[];\n  orderProp: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['phone'];\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones =&gt; {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'app/phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ajs.ts\">\ndeclare const angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneDetailController {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['$routeParams', 'phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, phone: Phone) {\n    const phoneId = $routeParams.phoneId;\n    phone.get(phoneId).subscribe(data =&gt; {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p translation-result=\"on\">這裡的兩個 AngularJS 控制器在使用 Angular 的服務！控制器不需要關心這一點，儘管實際上該服務返回的是可觀察物件（Observable），而不是承諾（Promise）。無論如何，你達到的效果都是把服務移植到 Angular，而不用被迫移植元件來使用它。</p><p translation-origin=\"off\">Now there are two AngularJS components using an Angular service!\nThe components don't need to be aware of this, though the fact that the service returns observables and not promises is a bit of a giveaway.\nIn any case, what you've achieved is a migration of a service to Angular without having to yet migrate the components that use it.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你也能使用 <code>Observable</code> 的 <code>toPromise</code> 方法來在服務中把這些可觀察物件轉變成 Promise，以進一步減小元件控制器中需要修改的程式碼量。</p><p translation-origin=\"off\">You could use the <code>toPromise</code> method of <code>Observable</code> to turn those observables into promises in the service.\nIn many cases that reduce the number of changes to the component controllers.</p>\n\n</div>\n<h3 id=\"upgrading-components\" translation-result=\"on\">升級元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-components\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Upgrading Components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-components\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">接下來，把 AngularJS 的控制器升級成 Angular 的元件。每次升級一個，同時仍然保持應用執行在混合模式下。在做轉換的同時，你還將自訂首個 Angular<em>管道</em>。</p><p translation-origin=\"off\">Upgrade the AngularJS components to Angular components next.\nDo it one component at a time while still keeping the application in hybrid mode.\nAs you make these conversions, you'll also define your first Angular <em>pipes</em>.</p>\n\n<p translation-result=\"on\">先看看電話列表元件。它目前包含一個 TypeScript 控制器類和一個元件定義物件。重新命名控制器類，並把 AngularJS 的元件定義物件更換為 Angular <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 裝飾器，這樣你就把它變形為 Angular 的元件了。然後，你還要從類中移除靜態 <code>$inject</code> 屬性。</p><p translation-origin=\"off\">Look at the phone list component first.\nRight now it contains a TypeScript controller class and a component definition object.\nYou can morph this into an Angular component by just renaming the controller class and turning the AngularJS component definition object into an Angular <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> decorator.\nYou can then also remove the static <code>$inject</code> property from the class:</p>\n\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"initialclass\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n  phones: PhoneData[];\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: string;\n  orderProp: string;\n\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones =&gt; {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n  /* . . . */\n}\n\n</code-example>\n<p translation-result=\"on\"><code>selector</code> 屬性是一個 CSS 選擇器，用來定義元件應該被放在頁面的哪。在 AngularJS 中，你會基於元件名字來匹配，但是在 Angular 中，你要顯式指定這些選擇器。本元件將會對應元素名字 <code>phone-list</code>，和 AngularJS 版本一樣。</p><p translation-origin=\"off\">The <code>selector</code> attribute is a CSS selector that defines where on the page the component should go.\nIn AngularJS you do matching based on component names, but in Angular you have these explicit selectors.\nThis one will match elements with the name <code>phone-list</code>, just like the AngularJS version did.</p>\n\n<p translation-result=\"on\">現在，將元件的模版也轉換為 Angular 語法。在搜尋控制項中，把 AngularJS 的 <code>$ctrl</code> 表示式替換成 Angular 的雙向繫結語法 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code>：</p><p translation-origin=\"off\">Now convert the template of this component into Angular syntax.\nThe search controls replace the AngularJS <code>$ctrl</code> expressions with the two-way <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> binding syntax of Angular:</p>\n\n<code-example header=\"app/phone-list/phone-list.template.html (search controls)\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"controls\">\n&lt;p&gt;\n  Search:\n  &lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"<a href=\"api/animations/query\" class=\"code-anchor\">query</a>\" /&gt;\n&lt;/p&gt;\n\n&lt;p&gt;\n  Sort by:\n  &lt;select [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"orderProp\"&gt;\n    &lt;option value=\"name\"&gt;Alphabetical&lt;/option&gt;\n    &lt;option value=\"age\"&gt;Newest&lt;/option&gt;\n  &lt;/select&gt;\n&lt;/p&gt;\n\n</code-example>\n<p translation-result=\"on\">把列表中的 <code>ng-repeat</code> 替換為 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>，\n就像<a href=\"guide/built-in-directives\" title=\"Built-in directives | Angular\">範本語法指南</a>中所講的那樣。\n再把 <code><a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a></code> 標籤的 <code>ng-src</code> 替換為一個標準的 <code>src</code> 屬性（property）繫結。</p><p translation-origin=\"off\">Replace the <code>ng-repeat</code> of the list with an <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> as <a href=\"guide/built-in-directives\" title=\"Built-in directives | Angular\">described in the Template Syntax page</a>.\nReplace the <code>ng-src</code> of the image tag with a binding to the native <code>src</code> property.</p>\n\n<code-example header=\"app/phone-list/phone-list.template.html (phones)\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"list\">\n&lt;ul class=\"phones\"&gt;\n  &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\"&gt;\n    &lt;a href=\"/#!/phones/{{phone.id}}\" class=\"thumb\"&gt;\n      &lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"phone.imageUrl\" [alt]=\"phone.name\" /&gt;\n    &lt;/a&gt;\n    &lt;a href=\"/#!/phones/{{phone.id}}\" class=\"name\"&gt;{{phone.name}}&lt;/a&gt;\n    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n<h4 id=\"no-angular-filter-or-orderby-filters\" translation-result=\"on\">沒有 Angular <code>filter</code> 或 <code>orderBy</code> 過濾器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#no-angular-filter-or-orderby-filters\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">No Angular <code>filter</code> or <code>orderBy</code> filters<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#no-angular-filter-or-orderby-filters\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">Angular 中並不存在 AngularJS 中內建的 <code>filter</code> 和 <code>orderBy</code> 過濾器。所以你得自己實現進行過濾和排序。</p><p translation-origin=\"off\">The built-in AngularJS <code>filter</code> and <code>orderBy</code> filters do not exist in Angular, so you need to do the filtering and sorting yourself.</p>\n\n<p translation-result=\"on\">你把 <code>filter</code> 和 <code>orderBy</code> 過濾器改成繫結到控制器中的 <code>getPhones()</code> 方法，透過該方法，元件本身實現了過濾和排序邏輯。</p><p translation-origin=\"off\">You replaced the <code>filter</code> and <code>orderBy</code> filters with bindings to the <code>getPhones()</code> controller method, which implements the filtering and ordering logic inside the component itself.</p>\n\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"getphones\">\ngetPhones(): PhoneData[] {\n  return this.sortPhones(this.filterPhones(this.phones));\n}\n\nprivate filterPhones(phones: PhoneData[]) {\n  if (phones &amp;&amp; this.query) {\n    return phones.filter(phone =&gt; {\n      const name = phone.name.toLowerCase();\n      const snippet = phone.snippet.toLowerCase();\n      return name.indexOf(this.query) &gt;= 0 || snippet.indexOf(this.query) &gt;= 0;\n    });\n  }\n  return phones;\n}\n\nprivate sortPhones(phones: PhoneData[]) {\n  if (phones &amp;&amp; this.orderProp) {\n    return phones\n      .slice(0) // Make a copy\n      .sort((a, b) =&gt; {\n        if (a[this.orderProp] &lt; b[this.orderProp]) {\n          return -1;\n        } else if ([b[this.orderProp] &lt; a[this.orderProp]]) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n  }\n  return phones;\n}\n\n</code-example>\n<p translation-result=\"on\">現在你需要降級你的 Angular 元件，這樣你就可以在 AngularJS 中使用它了。你要註冊一個 <code>phoneList</code><em>指令</em>，而不是註冊一個元件，它是一個降級版的 Angular 元件。</p><p translation-origin=\"off\">Now you need to downgrade the Angular component so you can use it in AngularJS.\nInstead of registering a component, you register a <code>phoneList</code> <em>directive</em>, a downgraded version of the Angular component.</p>\n\n<p translation-result=\"on\">強制型別轉換 <code>as angular.IDirectiveFactory</code> 告訴 TypeScript 編譯器 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a></code> 方法 的返回值是一個指令工廠。</p><p translation-origin=\"off\">The <code>as angular.IDirectiveFactory</code> cast tells the TypeScript compiler that the return value of the <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a></code> method is a directive factory.</p>\n\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"downgrade-component\">\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n/* . . . */\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n  /* . . . */\n}\n\nangular.module('phoneList')\n  .directive(\n    'phoneList',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({component: PhoneListComponent}) as angular.IDirectiveFactory\n  );\n\n</code-example>\n<p translation-result=\"on\">新的 <code>PhoneListComponent</code> 使用 Angular 的 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 指令，它位於 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 中。把 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 新增到 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>imports</code> 中，並宣告新的 <code>PhoneListComponent</code> 元件，因為你降級了它：</p><p translation-origin=\"off\">The new <code>PhoneListComponent</code> uses the Angular <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> directive, located in the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>.\nAdd the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> to <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> imports and declare the new <code>PhoneListComponent</code> since you downgraded it:</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonelist\">\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">從 <code>index.html</code> 中移除電話列表元件的&lt;script&gt;標籤。</p><p translation-origin=\"off\">Remove the &lt;script&gt; tag for the phone list component from <code>index.html</code>.</p>\n\n<p translation-result=\"on\">現在，剩下的 <code>phone-detail.component.ts</code> 檔案變成了這樣：</p><p translation-origin=\"off\">Now set the remaining <code>phone-detail.component.ts</code> as follows:</p>\n\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ts\">\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { RouteParams } from '../ajs-upgraded-providers';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html',\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(routeParams: RouteParams, phone: Phone) {\n    phone.get(routeParams.phoneId).subscribe(data =&gt; {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.module('phoneDetail')\n  .directive(\n    'phoneDetail',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({component: PhoneDetailComponent}) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<p translation-result=\"on\">這和電話列表元件很相似。這裡的竅門在於 <code>RouteParams</code> 型別裝飾器，它標記出了 <code>routeParams</code> 依賴項。</p><p translation-origin=\"off\">This is similar to the phone list component.\nThe new wrinkle is the <code>RouteParams</code> type annotation that identifies the <code>routeParams</code> dependency.</p>\n\n<p translation-result=\"on\">AngularJS 注入器具有 AngularJS 路由器的依賴，叫做 <code>$routeParams</code>。它被注入到了 <code>PhoneDetails</code> 中，但 <code>PhoneDetails</code> 現在還是一個 AngularJS 控制器。你要把它注入到新的 <code>PhoneDetailsComponent</code> 中。</p><p translation-origin=\"off\">The AngularJS injector has an AngularJS router dependency called <code>$routeParams</code>, which was injected into <code>PhoneDetails</code> when it was still an AngularJS controller.\nYou intend to inject it into the new <code>PhoneDetailsComponent</code>.</p>\n\n<p translation-result=\"on\">不幸的是，AngularJS 的依賴不會自動在 Angular 的元件中可用。\n你必須使用<a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\" title=\"Making AngularJS Dependencies Injectable to Angular - Upgrading from AngularJS to Angular | Angular\">工廠提供者（factory provider）</a>\n來把 <code>$routeParams</code> 包裝成 Angular 的服務提供者。\n新建一個名叫 <code>ajs-upgraded-providers.ts</code> 的檔案，並且在 <code>app.module.ts</code> 中匯入它：</p><p translation-origin=\"off\">Unfortunately, AngularJS dependencies are not automatically available to Angular components.\nYou must upgrade this service using a <a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\" title=\"Making AngularJS Dependencies Injectable to Angular - Upgrading from AngularJS to Angular | Angular\">factory provider</a> to make <code>$routeParams</code> an Angular injectable.\nDo that in a new file called <code>ajs-upgraded-providers.ts</code> and import it in <code>app.module.ts</code>:</p>\n\n<code-example header=\"app/ajs-upgraded-providers.ts\" path=\"upgrade-phonecat-2-hybrid/app/ajs-upgraded-providers.ts\">\nexport abstract class RouteParams {\n  [key: string]: string;\n}\n\nexport function routeParamsFactory(i: any) {\n  return i.get('$routeParams');\n}\n\nexport const routeParamsProvider = {\n  provide: RouteParams,\n  useFactory: routeParamsFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<code-example header=\"app/app.module.ts ($routeParams)\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"routeparams\">\nimport { routeParamsProvider } from './ajs-upgraded-providers';\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n\n</code-example>\n<p translation-result=\"on\">把該元件的範本轉變成 Angular 的語法，程式碼如下：</p><p translation-origin=\"off\">Convert the phone detail component template into Angular syntax as follows:</p>\n\n<code-example header=\"app/phone-detail/phone-detail.template.html\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.template.html\">\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"phone\"&gt;\n  &lt;div class=\"phone-images\"&gt;\n    &lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>\" class=\"phone\" alt=\"Phone {{ phone.name }} - thumbnail {{ index }}\"\n        [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{'selected': <a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> === mainImageUrl}\"\n        *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> of phone.images; let index = index;\" /&gt;\n  &lt;/div&gt;\n\n  &lt;h1&gt;{{phone.name}}&lt;/h1&gt;\n\n  &lt;p&gt;{{phone.description}}&lt;/p&gt;\n\n  &lt;ul class=\"phone-thumbs\"&gt;\n    &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> of phone.images; let index = index\"&gt;\n      &lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>\" (click)=\"setImage(<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>)\" alt=\"Phone {{ phone.name }} - thumbnail {{ index }}\"/&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n\n  &lt;ul class=\"specs\"&gt;\n    &lt;li&gt;\n      &lt;span&gt;Availability and Networks&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Availability&lt;/dt&gt;\n        &lt;dd *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let availability of phone.availability\"&gt;{{availability}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Battery&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;<a href=\"api/core/Type\" class=\"code-anchor\">Type</a>&lt;/dt&gt;\n        &lt;dd&gt;{{phone.battery?.type}}&lt;/dd&gt;\n        &lt;dt&gt;Talk <a href=\"api/common/Time\" class=\"code-anchor\">Time</a>&lt;/dt&gt;\n        &lt;dd&gt;{{phone.battery?.talkTime}}&lt;/dd&gt;\n        &lt;dt&gt;Standby time (<a href=\"api/forms/MaxValidator\" class=\"code-anchor\">max</a>)&lt;/dt&gt;\n        &lt;dd&gt;{{phone.battery?.standbyTime}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Storage and Memory&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;RAM&lt;/dt&gt;\n        &lt;dd&gt;{{phone.storage?.ram}}&lt;/dd&gt;\n        &lt;dt&gt;Internal Storage&lt;/dt&gt;\n        &lt;dd&gt;{{phone.storage?.flash}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Connectivity&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Network Support&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.cell}}&lt;/dd&gt;\n        &lt;dt&gt;WiFi&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.wifi}}&lt;/dd&gt;\n        &lt;dt&gt;Bluetooth&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.bluetooth}}&lt;/dd&gt;\n        &lt;dt&gt;Infrared&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.infrared | checkmark}}&lt;/dd&gt;\n        &lt;dt&gt;GPS&lt;/dt&gt;\n        &lt;dd&gt;{{phone.connectivity?.gps | checkmark}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Android&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;OS <a href=\"api/core/Version\" class=\"code-anchor\">Version</a>&lt;/dt&gt;\n        &lt;dd&gt;{{phone.android?.os}}&lt;/dd&gt;\n        &lt;dt&gt;UI&lt;/dt&gt;\n        &lt;dd&gt;{{phone.android?.ui}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Size and Weight&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Dimensions&lt;/dt&gt;\n        &lt;dd *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let dim of phone.sizeAndWeight?.dimensions\"&gt;{{dim}}&lt;/dd&gt;\n        &lt;dt&gt;Weight&lt;/dt&gt;\n        &lt;dd&gt;{{phone.sizeAndWeight?.weight}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Display&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Screen size&lt;/dt&gt;\n        &lt;dd&gt;{{phone.display?.screenSize}}&lt;/dd&gt;\n        &lt;dt&gt;Screen resolution&lt;/dt&gt;\n        &lt;dd&gt;{{phone.display?.screenResolution}}&lt;/dd&gt;\n        &lt;dt&gt;Touch screen&lt;/dt&gt;\n        &lt;dd&gt;{{phone.display?.touchScreen | checkmark}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Hardware&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;CPU&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.cpu}}&lt;/dd&gt;\n        &lt;dt&gt;USB&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.usb}}&lt;/dd&gt;\n        &lt;dt&gt;Audio / headphone jack&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.audioJack}}&lt;/dd&gt;\n        &lt;dt&gt;FM Radio&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.fmRadio | checkmark}}&lt;/dd&gt;\n        &lt;dt&gt;Accelerometer&lt;/dt&gt;\n        &lt;dd&gt;{{phone.hardware?.accelerometer | checkmark}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Camera&lt;/span&gt;\n      &lt;dl&gt;\n        &lt;dt&gt;Primary&lt;/dt&gt;\n        &lt;dd&gt;{{phone.camera?.primary}}&lt;/dd&gt;\n        &lt;dt&gt;Features&lt;/dt&gt;\n        &lt;dd&gt;{{phone.camera?.features?.join(', ')}}&lt;/dd&gt;\n      &lt;/dl&gt;\n    &lt;/li&gt;\n    &lt;li&gt;\n      &lt;span&gt;Additional Features&lt;/span&gt;\n      &lt;dd&gt;{{phone.additionalFeatures}}&lt;/dd&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n\n\n</code-example>\n<p translation-result=\"on\">這裡有幾個值得注意的改動：</p><p translation-origin=\"off\">There are several notable changes here:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">你從所有表示式中移除了 <code>$ctrl.</code> 字首。</p><p translation-origin=\"off\">You've removed the <code>$ctrl.</code> prefix from all expressions</p>\n\n</li>\n<li>\n<p translation-result=\"on\">正如你在電話列表中做過的那樣，你把 <code>ng-src</code> 替換成了標準的 <code>src</code> 屬性繫結。</p><p translation-origin=\"off\">You've replaced <code>ng-src</code> with property bindings for the standard <code>src</code> property</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你在 <code>ng-class</code> 周圍使用了屬性繫結語法。雖然 Angular 中有一個\n和 AngularJS 中<a href=\"guide/built-in-directives\" title=\"Built-in directives | Angular\">非常相似的 <code>ngClass</code></a>指令，\n但是它的值不會神奇的作為表示式進行計算。在 Angular 中，範本中的屬性（Attribute）值總是被作為\n屬性（Property）表示式計算，而不是作為字串字面量。</p><p translation-origin=\"off\">You're using the property binding syntax around <code>ng-class</code>.\nThough Angular does have a <a href=\"guide/built-in-directives\" title=\"Built-in directives | Angular\">very similar <code>ngClass</code></a> as AngularJS does, its value is not magically evaluated as an expression.\nIn Angular, you always specify in the template when the value of an attribute is a property expression, as opposed to a literal string.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你把 <code>ng-repeat</code> 替換成了 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code></p><p translation-origin=\"off\">You've replaced <code>ng-repeat</code>s with <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>s</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你把 <code>ng-click</code> 替換成了一個到標準 <code>click</code> 事件的繫結</p><p translation-origin=\"off\">You've replaced <code>ng-click</code> with an event binding for the standard <code>click</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">你把整個範本都包裹進了一個 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 中，這導致只有當存在一個電話時它才會渲染。你必須這麼做，是因為元件首次載入時你還沒有 <code>phone</code> 變數，這些表示式就會參考到一個不存在的值。和 AngularJS 不同，當你嘗試參考未定義物件上的屬性時，Angular 中的表示式不會默默失敗。你必須明確指出這種情況是你所期望的。</p><p translation-origin=\"off\">You've wrapped the whole template in an <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> that causes it only to be rendered when there is a phone present.\nYou need this because when the component first loads, you don't have <code>phone</code> yet and the expressions will refer to a non-existing value.\nUnlike in AngularJS, Angular expressions do not fail silently when you try to refer to properties on undefined objects.\nYou need to be explicit about cases where this is expected.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">把 <code>PhoneDetailComponent</code> 元件新增到 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <em>declarations</em> 中：</p><p translation-origin=\"off\">Add <code>PhoneDetailComponent</code> component to the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> <em>declarations</em>:</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonedetail\">\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">你現在應該從 <code>index.html</code> 中移除電話詳情元件的&lt;script&gt;。</p><p translation-origin=\"off\">You should now also remove the phone detail component &lt;script&gt; tag from <code>index.html</code>.</p>\n\n<h4 id=\"add-the-checkmarkpipe\" translation-result=\"on\">新增 <em>CheckmarkPipe</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-checkmarkpipe\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Add the <em>CheckmarkPipe</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-checkmarkpipe\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">AngularJS 指令中有一個 <code>checkmark</code><em>過濾器</em>，把它轉換成 Angular 的<strong>管道</strong>。</p><p translation-origin=\"off\">The AngularJS directive had a <code>checkmark</code> <em>filter</em>.\nTurn that into an Angular <strong>pipe</strong>.</p>\n\n<p translation-result=\"on\">沒有什麼升級方法能把過濾器轉換成管道。但你也並不需要它。把過濾器函式轉換成等價的 Pipe 類非常簡單。實現方式和以前一樣，但把它們包裝進 <code>transform</code> 方法中就可以了。把該檔案改名成 <code>checkmark.pipe.ts</code>，以符合 Angular 中的命名約定：</p><p translation-origin=\"off\">There is no upgrade method to convert filters into pipes.\nYou won't miss it.\nIt is easy to turn the filter function into an equivalent Pipe class.\nThe implementation is the same as before, repackaged in the <code>transform</code> method.\nRename the file to <code>checkmark.pipe.ts</code> to conform with Angular conventions:</p>\n\n<code-example header=\"app/core/checkmark/checkmark.pipe.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.ts\">\nimport { <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>, <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> } from '@angular/core';\n\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({name: 'checkmark'})\nexport class CheckmarkPipe implements <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> {\n  transform(input: boolean) {\n    return input ? '\\u2713' : '\\u2718';\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">現在，匯入並宣告這個新建立的管道，同時從 <code>index.html</code> 檔案中移除該過濾器的 <code>&lt;script&gt;</code> 標籤：</p><p translation-origin=\"off\">Now import and declare the newly created pipe and remove the filter &lt;script&gt; tag from <code>index.html</code>:</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"checkmarkpipe\">\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n    CheckmarkPipe\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<h3 id=\"aot-compile-the-hybrid-app\" translation-result=\"on\">對混合式應用做 AOT 編譯<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#aot-compile-the-hybrid-app\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">AOT compile the hybrid app<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#aot-compile-the-hybrid-app\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要在混合式應用中使用 AOT 編譯，你首先要像其它 Angular 應用一樣設定它，就像<a href=\"guide/aot-compiler\" title=\"Ahead-of-time (AOT) compilation | Angular\">AOT 編譯一章</a>所講的那樣。</p><p translation-origin=\"off\">To use AOT with a hybrid app, you have to first set it up like any other Angular application, as shown in the <a href=\"guide/aot-compiler\" title=\"Ahead-of-time (AOT) compilation | Angular\">Ahead-of-time Compilation chapter</a>.</p>\n\n<p translation-result=\"on\">然後修改 <code>main-aot.ts</code> 的引導程式碼，來引導 AOT 編譯器所產生的 <code>AppComponentFactory</code>：</p><p translation-origin=\"off\">Then change <code>main-aot.ts</code> to bootstrap the <code>AppComponentFactory</code> that was generated by the AOT compiler:</p>\n\n<code-example header=\"app/main-aot.ts\" path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\">\nimport { <a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a> } from '@angular/platform-browser';\n\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>().bootstrapModule(AppModule);\n\n\n</code-example>\n<p translation-result=\"on\">你還要把在 <code>index.html</code> 中已經用到的所有 AngularJS 檔案載入到 <code>aot/index.html</code> 中：</p><p translation-origin=\"off\">You need to load all the AngularJS files you already use in <code>index.html</code> in <code>aot/index.html</code> as well:</p>\n\n<code-example header=\"aot/index.html\" path=\"upgrade-phonecat-2-hybrid/aot/index.html\">\n&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n\n    &lt;base href=\"/app/\"&gt;\n\n    &lt;title&gt;Google Phone Gallery&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" /&gt;\n    &lt;link rel=\"stylesheet\" href=\"app.css\" /&gt;\n    &lt;link rel=\"stylesheet\" href=\"app.animations.css\" /&gt;\n\n    &lt;script src=\"https://code.jquery.com/jquery-2.2.4.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://code.angularjs.org/1.5.5/angular.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://code.angularjs.org/1.5.5/angular-animate.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://code.angularjs.org/1.5.5/angular-resource.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://code.angularjs.org/1.5.5/angular-route.js\"&gt;&lt;/script&gt;\n\n    &lt;script src=\"app.module.ajs.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"app.config.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"app.animations.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"core/core.module.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"core/phone/phone.module.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"phone-list/phone-list.module.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"phone-detail/phone-detail.module.js\"&gt;&lt;/script&gt;\n\n    &lt;script src=\"/node_modules/core-js/client/shim.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/node_modules/zone.js/bundles/zone.umd.min.js\"&gt;&lt;/script&gt;\n\n    &lt;script&gt;window.module = 'aot';&lt;/script&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;div class=\"view-container\"&gt;\n      &lt;div ng-view class=\"view-frame\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n  &lt;script src=\"/dist/build.js\"&gt;&lt;/script&gt;\n&lt;/html&gt;\n\n\n</code-example>\n<p translation-result=\"on\">這些檔案要帶著相應的Polyfill指令碼複製到一起。應用執行時需要的檔案，比如電話列表 <code>.json</code> 和圖片，也需要複製過去。</p><p translation-origin=\"off\">These files need to be copied together with the polyfills.\nThe files the application needs at runtime, like the <code>.json</code> phone lists and images, also need to be copied.</p>\n\n<p translation-result=\"on\">透過 <code>npm install fs-extra --save-dev</code> 安裝 <code>fs-extra</code> 可以更好的複製檔案，並且把 <code>copy-dist-files.js</code> 檔案改成這樣：</p><p translation-origin=\"off\">Install <code>fs-extra</code> using <code>npm install fs-extra --save-dev</code> for better file copying, and change <code>copy-dist-files.js</code> to the following:</p>\n\n<code-example header=\"copy-dist-files.js\" path=\"upgrade-phonecat-2-hybrid/copy-dist-files.js\">\nvar fsExtra = require('fs-extra');\nvar resources = [\n  // polyfills\n  'node_modules/core-js/client/shim.min.js',\n  'node_modules/zone.js/bundles/zone.umd.min.js',\n  // css\n  'app/app.css',\n  'app/app.animations.css',\n  // images and json files\n  'app/<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>/',\n  'app/phones/',\n  // app files\n  'app/app.module.ajs.js',\n  'app/app.config.js',\n  'app/app.animations.js',\n  'app/core/core.module.js',\n  'app/core/phone/phone.module.js',\n  'app/phone-list/phone-list.module.js',\n  'app/phone-detail/phone-detail.module.js'\n];\nresources.map(function(sourcePath) {\n  // Need to rename zone.umd.min.js to zone.min.js\n  var destPath = `aot/${sourcePath}`.replace('.umd.min.js', '.min.js');\n  fsExtra.copySync(sourcePath, destPath);\n});\n\n\n</code-example>\n<p translation-result=\"on\">這就是想要在升級應用期間 AOT 編譯所需的一切！</p><p translation-origin=\"off\">And that is all you need to use AOT while upgrading your app!</p>\n\n<h3 id=\"adding-the-angular-router-and-bootstrap\" translation-result=\"on\">新增 Angular 路由器和載入程式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#adding-the-angular-router-and-bootstrap\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Adding The Angular Router And Bootstrap<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#adding-the-angular-router-and-bootstrap\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">此刻，你已經把所有 AngularJS 的元件替換成了它們在 Angular 中的等價物，不過你仍然在 AngularJS 路由器中使用它們。</p><p translation-origin=\"off\">At this point, you've replaced all AngularJS application components with their Angular counterparts, even though you're still serving them from the AngularJS router.</p>\n\n<h4 id=\"add-the-angular-router\" translation-result=\"on\">新增 Angular 路由器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-angular-router\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Add the Angular router<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-angular-router\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">Angular 有一個<a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">全新的路由器</a>。</p><p translation-origin=\"off\">Angular has an <a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">all-new router</a>.</p>\n\n<p translation-result=\"on\">像所有的路由器一樣，它需要在 UI 中指定一個位置來顯示路由的檢視。在 Angular 中，它是 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>，並位於應用元件樹頂部的<em>根元件</em>中。</p><p translation-origin=\"off\">Like all routers, it needs a place in the UI to display routed views.\nFor Angular that is the <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> and it belongs in a <em>root component</em> at the top of the applications component tree.</p>\n\n<p translation-result=\"on\">你還沒有這樣一個根元件，因為該應用仍然是像一個 AngularJS 應用那樣被管理的。建立新的 <code>app.component.ts</code> 檔案，放入像這樣的 <code>AppComponent</code> 類：</p><p translation-origin=\"off\">You don't yet have such a root component, because the application is still managed as an AngularJS app.\nCreate a new <code>app.component.ts</code> file with the following <code>AppComponent</code> class:</p>\n\n<code-example header=\"app/app.component.ts\" path=\"upgrade-phonecat-3-final/app/app.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phonecat-app',\n  template: '&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;'\n})\nexport class AppComponent { }\n\n\n</code-example>\n<p translation-result=\"on\">它有一個很簡單的範本，只包含 <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>。該元件只負責渲染活動路由的內容，此外啥也不幹。</p><p translation-origin=\"off\">It has a template that only includes the <code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>.\nThis component just renders the contents of the active route and nothing else.</p>\n\n<p translation-result=\"on\">該選擇器告訴 Angular：當應用啟動時就把這個根元件插入到宿主頁面的 <code>&lt;phonecat-app&gt;</code> 元素中。</p><p translation-origin=\"off\">The selector tells Angular to plug this root component into the <code>&lt;phonecat-app&gt;</code> element on the host web page when the application launches.</p>\n\n<p translation-result=\"on\">把這個 <code>&lt;phonecat-app&gt;</code> 元素插入到 <code>index.html</code> 中。用它來代替 AngularJS 中的 <code>ng-view</code> 指令：</p><p translation-origin=\"off\">Add this <code>&lt;phonecat-app&gt;</code> element to the <code>index.html</code>.\nIt replaces the old AngularJS <code>ng-view</code> directive:</p>\n\n<code-example header=\"index.html (body)\" path=\"upgrade-phonecat-3-final/index.html\" region=\"appcomponent\">\n&lt;body&gt;\n  &lt;phonecat-app&gt;&lt;/phonecat-app&gt;\n&lt;/body&gt;\n\n</code-example>\n<h4 id=\"create-the-routing-module\" translation-result=\"on\">建立<em>路由模組</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-the-routing-module\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Create the <em>Routing Module</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-the-routing-module\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">無論在 AngularJS 還是 Angular 或其它框架中，路由器都需要進行配置。</p><p translation-origin=\"off\">A router needs configuration whether it is the AngularJS or Angular or any other router.</p>\n\n<p translation-result=\"on\">Angular 路由器配置的詳情最好去查閱下<a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">路由與導航</a>文件。\n它建議你建立一個專們用於路由器配置的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>（名叫<em>路由模組</em>）。</p><p translation-origin=\"off\">The details of Angular router configuration are best left to the <a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">Routing documentation</a> which recommends that you create a <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> dedicated to router configuration (called a <em>Routing Module</em>).</p>\n\n<code-example header=\"app/app-routing.module.ts\" path=\"upgrade-phonecat-3-final/app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router';\nimport { <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a>, <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a> } from '@angular/common';\n\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: '', redirectTo: 'phones', pathMatch: 'full' },\n  { path: 'phones',          component: PhoneListComponent },\n  { path: 'phones/:phoneId', component: PhoneDetailComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ RouterModule.forRoot(routes) ],\n  exports: [ <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> ],\n  providers: [\n    { provide: <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, useValue: '!' },\n    { provide: <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a>, useClass: <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a> },\n  ]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p translation-result=\"on\">該模組定義了一個 <code>routes</code> 物件，它帶有兩個路由，分別指向兩個電話元件，以及為空路徑指定的預設路由。它把 <code>routes</code> 傳給 <code>RouterModule.forRoot</code> 方法，該方法會完成剩下的事。</p><p translation-origin=\"off\">This module defines a <code>routes</code> object with two routes to the two phone components and a default route for the empty path.\nIt passes the <code>routes</code> to the <code>RouterModule.forRoot</code> method which does the rest.</p>\n\n<p translation-result=\"on\">一些額外的提供者讓路由器使用“hash”策略解析 URL，比如 <code>#!/phones</code>，而不是預設的“Push State”策略。</p><p translation-origin=\"off\">A couple of extra providers enable routing with \"hash\" URLs such as <code>#!/phones</code> instead of the default \"push state\" strategy.</p>\n\n<p translation-result=\"on\">現在，修改 <code>AppModule</code>，讓它匯入這個 <code>AppRoutingModule</code>，並同時宣告根元件 <code>AppComponent</code>。這會告訴 Angular，它應該使用根元件 <code>AppComponent</code> 引導應用，並把它的檢視插入到宿主頁面中。</p><p translation-origin=\"off\">Now update the <code>AppModule</code> to import this <code>AppRoutingModule</code> and also the declare the root <code>AppComponent</code> as the bootstrap component.\nThat tells Angular that it should bootstrap the application with the <em>root</em> <code>AppComponent</code> and insert its view into the host web page.</p>\n\n<p translation-result=\"on\">你還要從 <code>app.module.ts</code> 中移除呼叫 <code>ngDoBootstrap()</code> 來引導 AngularJS 模組的程式碼，以及對 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 的匯入程式碼。</p><p translation-origin=\"off\">You must also remove the bootstrap of the AngularJS module from <code>ngDoBootstrap()</code> in <code>app.module.ts</code> and the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> import.</p>\n\n<code-example header=\"app/app.module.ts\" path=\"upgrade-phonecat-3-final/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\nimport { Phone } from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p translation-result=\"on\">而且，由於你現在直接路由到 <code>PhoneListComponent</code> 和 <code>PhoneDetailComponent</code>，而不再使用帶 <code>&lt;phone-list&gt;</code> 或 <code>&lt;phone-detail&gt;</code> 標籤的路由範本，因此你同樣不再需要它們的 Angular 選擇器。</p><p translation-origin=\"off\">And since you are routing to <code>PhoneListComponent</code> and <code>PhoneDetailComponent</code> directly rather than using a route template with a <code>&lt;phone-list&gt;</code> or <code>&lt;phone-detail&gt;</code> tag, you can do away with their Angular selectors as well.</p>\n\n<h4 id=\"generate-links-for-each-phone\" translation-result=\"on\">為每個電話產生連結<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#generate-links-for-each-phone\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Generate links for each phone<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#generate-links-for-each-phone\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在電話列表中，你不用再被迫硬編碼電話詳情的連結了。你可以透過把每個電話的 <code>id</code> 繫結到 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 指令來產生它們了，該指令的建構函式會為 <code>PhoneDetailComponent</code> 產生正確的 URL：</p><p translation-origin=\"off\">You no longer have to hardcode the links to phone details in the phone list.\nYou can generate data bindings for the <code>id</code> of each phone to the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> directive and let that directive construct the appropriate URL to the <code>PhoneDetailComponent</code>:</p>\n\n<code-example header=\"app/phone-list/phone-list.template.html (list with links)\" path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.template.html\" region=\"list\">\n&lt;ul class=\"phones\"&gt;\n  &lt;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\"&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/phones', phone.id]\" class=\"thumb\"&gt;\n      &lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"phone.imageUrl\" [alt]=\"phone.name\" /&gt;\n    &lt;/a&gt;\n    &lt;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/phones', phone.id]\" class=\"name\"&gt;{{phone.name}}&lt;/a&gt;\n    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">要了解詳情，請檢視<a href=\"guide/router\">路由與導航</a>頁。</p><p translation-origin=\"off\">See the <a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">Routing</a> page for details.</p>\n\n</div>\n<h4 id=\"use-route-parameters\" translation-result=\"on\">使用路由引數<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#use-route-parameters\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Use route parameters<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#use-route-parameters\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">Angular 路由器會傳入不同的路由引數。改正 <code>PhoneDetail</code> 元件的建構函式，讓它改用注入進來的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 物件。從 <code>ActivatedRoute.snapshot.params</code> 中提取出 <code>phoneId</code>，並像以前一樣獲取手機的資料：</p><p translation-origin=\"off\">The Angular router passes route parameters differently.\nCorrect the <code>PhoneDetail</code> component constructor to expect an injected <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> object.\nExtract the <code>phoneId</code> from the <code>ActivatedRoute.snapshot.params</code> and fetch the phone data as before:</p>\n\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html'\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(activatedRoute: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, phone: Phone) {\n    phone.get(activatedRoute.snapshot.paramMap.get('phoneId'))\n      .subscribe((p: PhoneData) =&gt; {\n        this.phone = p;\n        this.setImage(p.images[0]);\n      });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">你現在執行的就是純正的 Angular 應用了！</p><p translation-origin=\"off\">You are now running a pure Angular application!</p>\n\n<h3 id=\"say-goodbye-to-angularjs\" translation-result=\"on\">再見，AngularJS！<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#say-goodbye-to-angularjs\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Say Goodbye to AngularJS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#say-goodbye-to-angularjs\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">終於可以把輔助訓練的輪子摘下來了！讓你的應用作為一個純粹、閃亮的 Angular 程式開始它的新生命吧。剩下的所有任務就是移除程式碼 —— 這當然是每個程式設計師最喜歡的任務！</p><p translation-origin=\"off\">It is time to take off the training wheels and let the application begin its new life as a pure, shiny Angular app.\nThe remaining tasks all have to do with removing code - which of course is every programmer's favorite task!</p>\n\n<p translation-result=\"on\">應用仍然以混合式應用的方式啟動，然而這再也沒有必要了。</p><p translation-origin=\"off\">The application is still bootstrapped as a hybrid app.\nThere is no need for that anymore.</p>\n\n<p translation-result=\"on\">把應用的引導（<code>bootstrap</code>）方式從 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 的改為 Angular 的。</p><p translation-origin=\"off\">Switch the bootstrap method of the application from the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> to the Angular way.</p>\n\n<code-example header=\"main.ts\" path=\"upgrade-phonecat-3-final/app/main.ts\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n\n</code-example>\n<p translation-result=\"on\">如果你還沒有這麼做，請從 <code>app.module.ts 刪除所有 </code>UpgradeModule 的參考，\n以及所有用於 AngularJS 服務的<a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">工廠提供者（factory provider）</a>和 <code>app/ajs-upgraded-providers.ts</code> 檔案。</p><p translation-origin=\"off\">If you haven't already, remove all references to the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> from <code>app.module.ts</code>, as well as any <a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\" title=\"Making AngularJS Dependencies Injectable to Angular - Upgrading from AngularJS to Angular | Angular\">factory provider</a> for AngularJS services, and the <code>app/ajs-upgraded-providers.ts</code> file.</p>\n\n<p translation-result=\"on\">還要刪除所有的 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> 或 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 以及與 AngularJS 相關的工廠或指令宣告。</p><p translation-origin=\"off\">Also remove any <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> or <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> you find, together with the associated AngularJS factory or directive declarations.</p>\n\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-3-final/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\nimport { Phone } from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p translation-result=\"on\">你還要完全移除了下列檔案。它們是 AngularJS 的模組配置檔案和型別定義檔案，在 Angular 中不需要了：</p><p translation-origin=\"off\">You may also completely remove the following files.\nThey are AngularJS module configuration files and not needed in Angular:</p>\n\n<ul>\n<li>\n<p><code>app/app.module.ajs.ts</code></p>\n</li>\n<li>\n<p><code>app/app.config.ts</code></p>\n</li>\n<li>\n<p><code>app/core/core.module.ts</code></p>\n</li>\n<li>\n<p><code>app/core/phone/phone.module.ts</code></p>\n</li>\n<li>\n<p><code>app/phone-detail/phone-detail.module.ts</code></p>\n</li>\n<li>\n<p><code>app/phone-list/phone-list.module.ts</code></p>\n</li>\n</ul>\n<p translation-result=\"on\">還需要解除安裝 AngularJS 的外部型別定義檔案。你現在只需要留下 Jasmine 和 Angular 所需的Polyfill指令碼。<code>systemjs.config.js</code> 中的 <code>@angular/upgrade</code> 套件及其對映也可以移除了。</p><p translation-origin=\"off\">The external typings for AngularJS may be uninstalled as well.\nThe only ones you still need are for Jasmine and Angular polyfills.\nThe <code>@angular/upgrade</code> package and its mapping in <code>systemjs.config.js</code> can also go.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm uninstall @angular/upgrade --save\nnpm uninstall @types/angular @types/angular-animate @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n\n</code-example>\n<p translation-result=\"on\">最後，從 <code>index.html</code> 中，移除所有對 AngularJS 和 jQuery 指令碼的參考。當這些全部做完時，<code>index.html</code> 應該是這樣的：</p><p translation-origin=\"off\">Finally, from <code>index.html</code>, remove all references to AngularJS scripts and jQuery.\nWhen you're done, this is what it should look like:</p>\n\n<code-example header=\"index.html\" path=\"upgrade-phonecat-3-final/index.html\" region=\"full\">\n&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;base href=\"/app/\"&gt;\n    &lt;title&gt;Google Phone Gallery&lt;/title&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" /&gt;\n    &lt;link rel=\"stylesheet\" href=\"app.css\" /&gt;\n\n    &lt;script src=\"/node_modules/core-js/client/shim.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/node_modules/zone.js/bundles/zone.umd.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/node_modules/systemjs/dist/system.src.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/systemjs.config.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n      System.import('/app');\n    &lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;phonecat-app&gt;&lt;/phonecat-app&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code-example>\n<p translation-result=\"on\">這是你最後一次看到 AngularJS 了！它曾經帶給你很多幫助，不過現在，該說再見了。</p><p translation-origin=\"off\">That is the last you'll see of AngularJS!\nIt has served us well but now it is time to say goodbye.</p>\n\n<h2 id=\"appendix-upgrading-phonecat-tests\" translation-result=\"on\">附錄：升級 PhoneCat 的測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#appendix-upgrading-phonecat-tests\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Appendix: Upgrading PhoneCat Tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#appendix-upgrading-phonecat-tests\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">測試不僅要在升級過程中被保留，它還是確保應用在升級過程中不會被破壞的一個安全指示器。要達到這個目的，E2E 測試尤其有用。</p><p translation-origin=\"off\">Tests can not only be retained through an upgrade process, but they can also be used as a valuable safety measure when ensuring that the application does not break during the upgrade.\nE2E tests are especially useful for this purpose.</p>\n\n<h3 id=\"e2e-tests\" translation-result=\"on\">E2E 測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#e2e-tests\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">E2E Tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#e2e-tests\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">PhoneCat 專案中同時有基於 Protractor 的 E2E 測試和一些基於 Karma 的單元測試。對這兩者來說，E2E 測試的轉換要容易得多：根據定義，E2E 測試透過與應用中顯示的這些 UI 元素互動，從<em>外部</em>存取你的應用來進行測試。E2E 測試實際上並不關心這些應用中各部件的內部結構。這也意味著，雖然你已經修改了此應用程式，但是 E2E 測試套件仍然應該能像以前一樣全部透過。因為從使用者的角度來說，你並沒有改變應用的行為。</p><p translation-origin=\"off\">The PhoneCat project has both E2E Protractor tests and some Karma unit tests in it.\nOf these two, E2E tests can be dealt with much more easily:\nBy definition, E2E tests access the application from the <em>outside</em> by interacting with the various UI elements the application puts on the screen.\nE2E tests aren't really that concerned with the internal structure of the application components.\nThat also means that, although you modify the project quite a bit during the upgrade, the E2E test suite should keep passing with just minor modifications.\nYou didn't change how the application behaves from the user's point of view.</p>\n\n<p translation-result=\"on\">在轉成 TypeScript 期間，你不用做什麼就能讓 E2E 測試正常工作。但是當你想改成按照混合式應用進行引導時，必須做一些修改。</p><p translation-origin=\"off\">During TypeScript conversion, there is nothing to do to keep E2E tests working.\nBut when you change the bootstrap to that of a Hybrid app, you must make a few changes.</p>\n\n<p translation-result=\"on\">再對 <code>protractor-conf.js</code> 做下列修改，與混合應用同步：</p><p translation-origin=\"off\">Update the <code>protractor-conf.js</code> to sync with hybrid applications:</p>\n\n<code-example language=\"javascript\">\n\nng12Hybrid: true\n\n</code-example>\n<p translation-result=\"on\">當你開始元件和模組升級到 Angular 時，還需要一系列後續的修改。這是因為 E2E 測試有一些匹配器是 AngularJS 中特有的。對於 PhoneCat 來說，為了讓它能在 Angular 下工作，你得做下列修改：</p><p translation-origin=\"off\">When you start to upgrade components and their templates to Angular, you'll make more changes because the E2E tests have matchers that are specific to AngularJS.\nFor PhoneCat you need to make the following changes in order to make things work with Angular:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">老程式碼</nt-wrapper><nt-wrapper translation-origin=\"off\">Previous code</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">新程式碼</nt-wrapper><nt-wrapper translation-origin=\"off\">New code</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>by.repeater('phone in $ctrl.phones').column('phone.name')</code></td>\n<td align=\"left\"><code>by.css('.phones .name')</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">repeater 匹配器依賴於 AngularJS 中的 <code>ng-repeat</code></nt-wrapper><nt-wrapper translation-origin=\"off\">The repeater matcher relies on AngularJS <code>ng-repeat</code></nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>by.repeater('phone in $ctrl.phones')</code></td>\n<td align=\"left\"><code>by.css('.phones li')</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">repeater 匹配器依賴於 AngularJS 中的 <code>ng-repeat</code></nt-wrapper><nt-wrapper translation-origin=\"off\">The repeater matcher relies on AngularJS <code>ng-repeat</code></nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>by.model('$ctrl.query')</code></td>\n<td align=\"left\"><code>by.css('input')</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">模型匹配器依賴於 AngularJS <code>ng-model</code></nt-wrapper><nt-wrapper translation-origin=\"off\">The model matcher relies on AngularJS <code>ng-model</code></nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>by.model('$ctrl.orderProp')</code></td>\n<td align=\"left\"><code>by.css('select')</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">模型匹配器依賴於 AngularJS <code>ng-model</code></nt-wrapper><nt-wrapper translation-origin=\"off\">The model matcher relies on AngularJS <code>ng-model</code></nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>by.binding('$ctrl.phone.name')</code></td>\n<td align=\"left\"><code>by.css('h1')</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">binding 匹配器依賴於 AngularJS 的資料繫結</nt-wrapper><nt-wrapper translation-origin=\"off\">The binding matcher relies on AngularJS data binding</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">當引導方式從 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 切換到純 Angular 的時，AngularJS 就從頁面中完全消失了。此時，你需要告訴 Protractor，它不用再找 AngularJS 應用了，而是從頁面中查詢 <em>Angular</em> 應用。</p><p translation-origin=\"off\">When the bootstrap method is switched from that of <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> to pure Angular, AngularJS ceases to exist on the page completely.\nAt this point, you need to tell Protractor that it should not be looking for an AngularJS application anymore, but instead it should find <em>Angular apps</em> from the page.</p>\n\n<p translation-result=\"on\">替換之前在 <code>protractor-conf.js</code> 中加入 <code>ng12Hybrid</code>，象這樣：</p><p translation-origin=\"off\">Replace the <code>ng12Hybrid</code> previously added with the following in <code>protractor-conf.js</code>:</p>\n\n<code-example language=\"javascript\">\n\nuseAllAngular2AppRoots: true,\n\n</code-example>\n<p translation-result=\"on\">同樣，<code>PhoneCat</code> 的測試程式碼中有兩個 Protractor API 呼叫內部使用了 AngularJS 的 <code>$location</code>。該服務沒有了，你就得把這些呼叫用一個 WebDriver 的通用 URL API 代替。第一個 API 是“重新導向（redirect）”規約：</p><p translation-origin=\"off\">Also, there are a couple of Protractor API calls in the PhoneCat test code that are using the AngularJS <code>$location</code> service under the hood.\nAs that service is no longer present after the upgrade, replace those calls with ones that use the generic URL APIs of WebDriver instead.\nThe first of these is the redirection spec:</p>\n\n<code-example header=\"e2e-tests/scenarios.ts\" path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"redirect\">\nit('should redirect `index.html` to `index.html#!/phones', async () =&gt; {\n  await browser.get('index.html');\n  await browser.waitForAngular();\n  const url = await browser.getCurrentUrl();\n  expect(url.endsWith('/phones')).toBe(true);\n});\n\n</code-example>\n<p translation-result=\"on\">然後是“電話連結（phone links）”規約：</p><p translation-origin=\"off\">And the second is the phone links spec:</p>\n\n<code-example header=\"e2e-tests/scenarios.ts\" path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"links\">\nit('should render phone specific links', async () =&gt; {\n  const <a href=\"api/animations/query\" class=\"code-anchor\">query</a> = element(by.css('input'));\n  await query.sendKeys('nexus');\n  await element.all(by.css('.phones li a')).first().click();\n  const url = await browser.getCurrentUrl();\n  expect(url.endsWith('/phones/nexus-s')).toBe(true);\n});\n\n</code-example>\n<h3 id=\"unit-tests\" translation-result=\"on\">單元測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#unit-tests\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Unit Tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#unit-tests\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">另一方面，對於單元測試來說，需要更多的轉化工作。實際上，它們需要隨著產品程式碼一起升級。</p><p translation-origin=\"off\">For unit tests, on the other hand, more conversion work is needed.\nEffectively they need to be <em>upgraded</em> along with the production code.</p>\n\n<p translation-result=\"on\">在轉成 TypeScript 期間，嚴格來講沒有什麼改動是必須的。但把單元測試程式碼轉成 TypeScript 仍然是個好主意，。</p><p translation-origin=\"off\">During TypeScript conversion no changes are strictly necessary.\nBut it may bea good idea to convert the unit test code into TypeScript as well.</p>\n\n<p translation-result=\"on\">比如，在這個電話詳情元件的規約中，你不僅用到了 ES2015 中的箭頭函式和塊作用域變數這些特性，還為所用的一些 AngularJS 服務提供了型別定義。</p><p translation-origin=\"off\">For instance, in the phone detail component spec, you can use ES2015 features like arrow functions and block-scoped variables and benefit from the type definitions of the AngularJS services you're consuming:</p>\n\n<code-example header=\"app/phone-detail/phone-detail.component.spec.ts\" path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.spec.ts\">\ndescribe('phoneDetail', () =&gt; {\n\n  // Load the module that contains the `phoneDetail` component before each test\n  beforeEach(angular.mock.module('phoneDetail'));\n\n  // Test the controller\n  describe('PhoneDetailController', () =&gt; {\n    let $httpBackend: angular.IHttpBackendService;\n    let ctrl: any;\n    const xyzPhoneData = {\n      name: 'phone xyz',\n      images: ['image/url1.png', 'image/url2.png']\n    };\n\n    beforeEach(inject(($componentController: any,\n                       _$httpBackend_: angular.IHttpBackendService,\n                       $routeParams: angular.route.IRouteParamsService) =&gt; {\n      $httpBackend = _$httpBackend_;\n      $httpBackend.expectGET('phones/xyz.json').respond(xyzPhoneData);\n\n      $routeParams.phoneId = 'xyz';\n\n      ctrl = $componentController('phoneDetail');\n    }));\n\n    it('should fetch the phone details', () =&gt; {\n      jasmine.addCustomEqualityTester(angular.equals);\n\n      expect(ctrl.phone).toEqual({});\n\n      $httpBackend.flush();\n      expect(ctrl.phone).toEqual(xyzPhoneData);\n    });\n\n  });\n\n});\n\n\n</code-example>\n<p translation-result=\"on\">一旦你開始了升級過程並引入了 SystemJS，還需要對 Karma 進行配置修改。你需要讓 SystemJS 載入所有的 Angular 新程式碼，</p><p translation-origin=\"off\">Once you start the upgrade process and bring in SystemJS, configuration changes are needed for Karma.\nYou need to let SystemJS load all the new Angular code, which can be done with the following kind of shim file:</p>\n\n<code-example header=\"karma-test-shim.js\" path=\"upgrade-phonecat-2-hybrid/karma-test-shim.1.js\">\n// /*<a href=\"api/core/global\" class=\"code-anchor\">global</a> jasmine, __karma__, window*/\nError.stackTraceLimit = 0; // \"No stacktrace\"\" is usually best for app testing.\n\n// Uncomment to get full stacktrace output. Sometimes helpful, usually not.\n// Error.stackTraceLimit = Infinity; //\n\njasmine.DEFAULT_TIMEOUT_INTERVAL = 1000;\n\nvar builtPath = '/base/app/';\n\n__karma__.loaded = function () { };\n\nfunction isJsFile(path) {\n  return path.slice(-3) == '.js';\n}\n\nfunction isSpecFile(path) {\n  return /\\.spec\\.(.*\\.)?js$/.test(path);\n}\n\nfunction isBuiltFile(path) {\n  return isJsFile(path) &amp;&amp; (path.slice(0, builtPath.length) == builtPath);\n}\n\nvar allSpecFiles = Object.keys(window.__karma__.files)\n  .filter(isSpecFile)\n  .filter(isBuiltFile);\n\nSystem.config({\n  baseURL: '/base',\n  // Extend usual application package list with test folder\n  packages: { 'testing': { main: 'index.js', defaultExtension: 'js' } },\n\n  // Assume npm: is set in `paths` in systemjs.config\n  // Map the angular testing bundles\n  map: {\n    '@angular/core/testing': 'npm:@angular/core/fesm2022/testing.mjs',\n    '@angular/common/testing': 'npm:@angular/common/fesm2022/testing.mjs',\n    '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing': 'npm:@angular/common/fesm2022/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing.mjs',\n    '@angular/compiler/testing': 'npm:@angular/compiler/fesm2022/testing.mjs',\n    '@angular/platform-browser/testing': 'npm:@angular/platform-browser/fesm2022/testing.mjs',\n    '@angular/platform-browser-dynamic/testing': 'npm:@angular/platform-browser-dynamic/fesm2022/testing.mjs',\n    '@angular/router/testing': 'npm:@angular/router/fesm2022/testing.mjs',\n    '@angular/forms/testing': 'npm:@angular/forms/fesm2022/testing.mjs',\n  },\n});\n\nSystem.import('systemjs.config.js')\n  .then(importSystemJsExtras)\n  .then(initTestBed)\n  .then(initTesting);\n\n/** <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a> SystemJS configuration extras. Keep going w/o it */\nfunction importSystemJsExtras(){\n  return System.import('systemjs.config.extras.js')\n  .catch(function(reason) {\n    console.log(\n      'Warning: System.import could not load the optional \"systemjs.config.extras.js\". Did you omit it by accident? Continuing without it.'\n    );\n    console.log(reason);\n  });\n}\n\nfunction initTestBed() {\n  return Promise.all([\n    System.import('@angular/core/testing'),\n    System.import('@angular/platform-browser-dynamic/testing')\n  ])\n\n  .then(function (providers) {\n    var coreTesting    = providers[0];\n    var browserTesting = providers[1];\n\n    coreTesting.TestBed.initTestEnvironment(\n      browserTesting.BrowserDynamicTestingModule,\n      browserTesting.platformBrowserDynamicTesting());\n  })\n}\n\n// Import all spec files and start karma\nfunction initTesting() {\n  return Promise.all(\n    allSpecFiles.map(function (moduleName) {\n      return System.import(moduleName);\n    })\n  )\n  .then(__karma__.start, __karma__.error);\n}\n\n\n</code-example>\n<p translation-result=\"on\">這個 shim 檔案首先載入了 SystemJS 的配置，然後是 Angular 的測試支援庫，然後是應用本身的規約檔案。</p><p translation-origin=\"off\">The shim first loads the SystemJS configuration, then the test the support libraries of Angular, and then the spec files of the application themselves.</p>\n\n<p translation-result=\"on\">然後需要修改 Karma 配置，來讓它使用本應用的根目錄作為基礎目錄（base directory），而不是 <code>app</code>。</p><p translation-origin=\"off\">Karma configuration should then be changed so that it uses the application root dir as the base directory, instead of <code>app</code>.</p>\n\n<code-example header=\"karma.conf.js\" path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"basepath\">\nbasePath: './',\n\n</code-example>\n<p translation-result=\"on\">一旦這些完成了，你就能載入 SystemJS 和其它依賴，並切換配置檔案來載入那些應用檔案，而<em>不用</em>在 Karma 頁面中包含它們。你要讓這個 shim 檔案和 SystemJS 去載入它們。</p><p translation-origin=\"off\">Once done, you can load SystemJS and other dependencies, and also switch the configuration for loading application files so that they are <em>not</em> included to the page by Karma.\nYou'll let the shim and SystemJS load them.</p>\n\n<code-example header=\"karma.conf.js\" path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"files\">\n// System.js for module loading\n'node_modules/systemjs/dist/system.src.js',\n\n// Polyfills\n'node_modules/core-js/client/shim.js',\n\n// zone.js\n'node_modules/zone.js/bundles/zone.umd.js',\n'node_modules/zone.js/bundles/zone-testing.umd.js',\n\n// RxJs.\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/rxjs/**/*.js', included: false, watched: false },\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/rxjs/**/*.js.map', included: false, watched: false },\n\n// Angular itself and the testing library\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/@angular/**/*.mjs', included: false, watched: false },\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/@angular/**/*.mjs.map', included: false, watched: false },\n\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/tslib/tslib.js', included: false, watched: false },\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/systemjs-plugin-babel/**/*.js', included: false, watched: false },\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'systemjs.config.js', included: false, watched: false},\n'karma-test-shim.js',\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/**/*.module.js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/*!(.module|.spec).js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/!(bower_components)/**/*!(.module|.spec).js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/**/*.spec.js', included: false, watched: true},\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: '**/*.html', included: false, watched: true},\n\n</code-example>\n<p translation-result=\"on\">由於 Angular 元件中的 HTML 範本也同樣要被載入，所以你得幫 Karma 一把，幫它在正確的路徑下找到這些範本：</p><p translation-origin=\"off\">Since the HTML templates of Angular components will be loaded as well, you must help Karma out a bit so that it can route them to the right paths:</p>\n\n<code-example header=\"karma.conf.js\" path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"html\">\n// proxied base paths for loading assets\nproxies: {\n  // required for component assets fetched by Angular's compiler\n  '/phone-detail': '/base/app/phone-detail',\n  '/phone-list': '/base/app/phone-list'\n},\n\n</code-example>\n<p translation-result=\"on\">如果產品程式碼被切換到了 Angular，單元測試檔案本身也需要切換過來。對勾（checkmark）管道的規約可能是最直觀的，因為它沒有任何依賴：</p><p translation-origin=\"off\">The unit test files themselves also need to be switched to Angular when their production counterparts are switched.\nThe specs for the checkmark pipe are probably the most straightforward, as the pipe has no dependencies:</p>\n\n<code-example header=\"app/core/checkmark/checkmark.pipe.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.spec.ts\">\nimport { CheckmarkPipe } from './checkmark.pipe';\n\ndescribe('CheckmarkPipe', () =&gt; {\n\n  it('should convert boolean values to unicode checkmark or cross', () =&gt; {\n    const checkmarkPipe = new CheckmarkPipe();\n    expect(checkmarkPipe.transform(true)).toBe('\\u2713');\n    expect(checkmarkPipe.transform(false)).toBe('\\u2718');\n  });\n});\n\n\n</code-example>\n<p translation-result=\"on\"><code>Phone</code> 服務的測試會牽扯到一點別的。你需要把模擬版的 AngularJS <code>$httpBackend</code> 服務切換到模擬板的 Angular Http 後端。</p><p translation-origin=\"off\">The unit test for the phone service is a bit more involved.\nYou need to switch from the mocked-out AngularJS <code>$httpBackend</code> to a mocked-out Angular Http backend.</p>\n\n<code-example header=\"app/core/phone/phone.service.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.spec.ts\">\nimport { inject, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>, <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing';\nimport { Phone, PhoneData } from './phone.service';\n\ndescribe('Phone', () =&gt; {\n  let phone: Phone;\n  const phonesData: PhoneData[] = [\n    {name: 'Phone X', snippet: '', images: []},\n    {name: 'Phone Y', snippet: '', images: []},\n    {name: 'Phone Z', snippet: '', images: []}\n  ];\n  let httpMock: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({\n      imports: [\n        <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>\n      ],\n      providers: [\n        Phone,\n      ]\n    });\n  });\n\n  beforeEach(inject([<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>, Phone], (_httpMock_: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>, _phone_: Phone) =&gt; {\n    httpMock = _httpMock_;\n    phone = _phone_;\n  }));\n\n  afterEach(() =&gt; {\n    httpMock.verify();\n  });\n\n  it('should fetch the phones data from `/phones/phones.json`', () =&gt; {\n    phone.query().subscribe(result =&gt; {\n      expect(result).toEqual(phonesData);\n    });\n    const req = httpMock.expectOne(`/phones/phones.json`);\n    req.flush(phonesData);\n  });\n\n});\n\n\n\n</code-example>\n<p translation-result=\"on\">對於元件的規約，你可以模擬出 <code>Phone</code> 服務本身，並且讓它提供電話的資料。你可以對這些元件使用 Angular 的元件單元測試 API。</p><p translation-origin=\"off\">For the component specs, you can mock out the <code>Phone</code> service itself, and have it provide canned phone data.\nYou use the component unit testing APIs of Angular for both components.</p>\n\n<code-example header=\"app/phone-detail/phone-detail.component.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.spec.ts\">\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\nimport { PhoneDetailComponent&nbsp;} from './phone-detail.component';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { CheckmarkPipe } from '../core/checkmark/checkmark.pipe';\n\nfunction xyzPhoneData(): PhoneData {\n  return {name: 'phone xyz', snippet: '', images: ['image/url1.png', 'image/url2.png']};\n}\n\nclass MockPhone {\n  get(id: string): Observable&lt;PhoneData&gt; {\n    return of(xyzPhoneData());\n  }\n}\n\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n\ndescribe('PhoneDetailComponent', () =&gt; {\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { phoneId: 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n  it('should fetch phone detail', () =&gt; {\n    const fixture = TestBed.createComponent(PhoneDetailComponent);\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('h1').textContent).toContain(xyzPhoneData().name);\n  });\n});\n\n\n</code-example>\n<code-example header=\"app/phone-list/phone-list.component.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.spec.ts\">\nimport {<a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>} from '@angular/common/testing';\nimport {<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>} from '@angular/core';\nimport {<a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>} from '@angular/core/testing';\nimport {<a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>} from '@angular/router';\nimport {Observable, of} from 'rxjs';\n\nimport {Phone, PhoneData} from '../core/phone/phone.service';\n\nimport {PhoneListComponent} from './phone-list.component';\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\nclass MockPhone {\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&lt;PhoneData[]&gt; {\n    return of([\n      {name: 'Nexus S', snippet: '', images: []}, {name: 'Motorola DROID', snippet: '', images: []}\n    ]);\n  }\n}\n\nlet fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;PhoneListComponent&gt;;\n\ndescribe('PhoneList', () =&gt; {\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          declarations: [PhoneListComponent],\n          providers: [\n            {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({params: {phoneId: 1}})},\n            {provide: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>, useClass: <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>},\n            {provide: Phone, useClass: MockPhone},\n          ],\n          schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n        })\n        .compileComponents();\n  }));\n\n  beforeEach(() =&gt; {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n  it('should create \"phones\" model with 2 phones fetched from xhr', () =&gt; {\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelectorAll('.phone-list-item').length).toBe(2);\n    expect(compiled.querySelector('.phone-list-item:nth-child(1)').textContent)\n        .toContain('Motorola DROID');\n    expect(compiled.querySelector('.phone-list-item:nth-child(2)').textContent)\n        .toContain('Nexus S');\n  });\n\n  xit('should set the default value of orderProp model', () =&gt; {\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('select option:last-child').selected).toBe(true);\n  });\n});\n\n\n</code-example>\n<p translation-result=\"on\">最後，當你切換到 Angular 路由時，需要重新過一遍這些元件測試。對詳情元件來說，你需要提供一個 Angular <code>RouteParams</code> 的 mock 物件，而不再用 AngularJS 中的 <code>$routeParams</code>。</p><p translation-origin=\"off\">Finally, revisit both of the component tests when you switch to the Angular router.\nFor the details component, provide a mock of Angular <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> object instead of using the AngularJS <code>$routeParams</code>.</p>\n\n<code-example header=\"app/phone-detail/phone-detail.component.spec.ts\" path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.spec.ts\" region=\"activatedroute\">\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n/* . . . */\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n  /* . . . */\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { phoneId: 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n</code-example>\n<p translation-result=\"on\">對於電話列表元件，還要再做少量的調整，以便路由器能讓 <code>RouteLink</code> 指令正常工作。</p><p translation-origin=\"off\">And for the phone list component, a few adjustments to the router make the <code>RouteLink</code> directives work.</p>\n\n<code-example header=\"app/phone-list/phone-list.component.spec.ts\" path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.component.spec.ts\" region=\"routestuff\">\nimport {<a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>} from '@angular/common/testing';\nimport {<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>} from '@angular/core';\nimport {<a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>} from '@angular/core/testing';\nimport {<a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>} from '@angular/router';\nimport {Observable, of} from 'rxjs';\n\nimport {Phone, PhoneData} from '../core/phone/phone.service';\n\nimport {PhoneListComponent} from './phone-list.component';\n\n  /* . . . */\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          declarations: [PhoneListComponent],\n          providers: [\n            {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({params: {phoneId: 1}})},\n            {provide: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>, useClass: <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>},\n            {provide: Phone, useClass: MockPhone},\n          ],\n          schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n        })\n        .compileComponents();\n  }));\n\n  beforeEach(() =&gt; {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/common\n - api/common/upgrade\n - api/common/upgrade/$locationShim\n - api/common/upgrade/LocationUpgradeModule\n - api/upgrade/static/downgradeComponent\n - guide/deprecations\n - guide/releases\n - guide/updating\n - guide/upgrade-performance\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/APP_BASE_HREF\n - api/common/HashLocationStrategy\n - api/common/Location\n - api/common/LocationStrategy\n - api/common/NgClass\n - api/common/NgFor\n - api/common/NgIf\n - api/common/NgOptimizedImage\n - api/common/Time\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpClientModule\n - api/common/http/testing/HttpClientTestingModule\n - api/common/http/testing/HttpTestingController\n - api/common/testing/SpyLocation\n - api/common/upgrade/$locationShim\n - api/common/upgrade/LocationUpgradeConfig\n - api/common/upgrade/LocationUpgradeModule\n - api/common/upgrade/LocationUpgradeModule#config\n - api/core/Component\n - api/core/Directive\n - api/core/DoBootstrap\n - api/core/ElementRef\n - api/core/EventEmitter\n - api/core/Injectable\n - api/core/Injector\n - api/core/Input\n - api/core/NO_ERRORS_SCHEMA\n - api/core/NgModule\n - api/core/NgZone\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/Optional\n - api/core/Output\n - api/core/Pipe\n - api/core/PipeTransform\n - api/core/SimpleChanges\n - api/core/Type\n - api/core/Version\n - api/core/global\n - api/core/ng-content\n - api/core/testing/ComponentFixture\n - api/core/testing/TestBed\n - api/core/testing/waitForAsync\n - api/forms/FormsModule\n - api/forms/MaxValidator\n - api/forms/NgModel\n - api/forms/PatternValidator\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/BrowserModule\n - api/platform-browser/platformBrowser\n - api/router/ActivatedRoute\n - api/router/Router\n - api/router/RouterLink\n - api/router/RouterModule\n - api/router/RouterOutlet\n - api/router/Routes\n - api/router/UrlSegment\n - api/upgrade/static\n - api/upgrade/static/UpgradeComponent\n - api/upgrade/static/UpgradeModule\n - api/upgrade/static/downgradeComponent\n - api/upgrade/static/downgradeInjectable\n - guide/animations\n - guide/aot-compiler\n - guide/built-in-directives\n - guide/dependency-injection\n - guide/glossary#lazy-loading\n - guide/hierarchical-dependency-injection\n - guide/lifecycle-hooks\n - guide/ngmodules\n - guide/router\n - guide/typescript-configuration\n - guide/upgrade#add-the-angular-router\n - guide/upgrade#add-the-checkmarkpipe\n - guide/upgrade#adding-the-angular-router-and-bootstrap\n - guide/upgrade#aot-compile-the-hybrid-app\n - guide/upgrade#appendix-upgrading-phonecat-tests\n - guide/upgrade#bootstrapping-a-hybrid-phonecat\n - guide/upgrade#bootstrapping-hybrid-applications\n - guide/upgrade#change-detection\n - guide/upgrade#components-and-the-dom\n - guide/upgrade#configure-a-custom-route-matcher-for-angularjs-routes\n - guide/upgrade#create-a-component-to-render-angularjs-content\n - guide/upgrade#create-a-service-to-lazy-load-angularjs\n - guide/upgrade#create-the-routing-module\n - guide/upgrade#creating-the-appmodule\n - guide/upgrade#dependency-injection\n - guide/upgrade#e2e-tests\n - guide/upgrade#e2e-測試\n - guide/upgrade#follow-the-angularjs-style-guide\n - guide/upgrade#generate-links-for-each-phone\n - guide/upgrade#how-ngupgrade-works\n - guide/upgrade#installing-angular\n - guide/upgrade#lazy-loading-angularjs\n - guide/upgrade#making-angular-dependencies-injectable-to-angularjs\n - guide/upgrade#making-angularjs-dependencies-injectable-to-angular\n - guide/upgrade#migrating-to-typescript\n - guide/upgrade#ngupgrade-的工作原理\n - guide/upgrade#no-angular-filter-or-orderby-filters\n - guide/upgrade#phonecat-upgrade-tutorial\n - guide/upgrade#phonecat-升級課程\n - guide/upgrade#preparation\n - guide/upgrade#projecting-angularjs-content-into-angular-components\n - guide/upgrade#say-goodbye-to-angularjs\n - guide/upgrade#switching-to-typescript\n - guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\n - guide/upgrade#unit-tests\n - guide/upgrade#upgrading-components\n - guide/upgrade#upgrading-from-angularjs-to-angular\n - guide/upgrade#upgrading-the-phone-service\n - guide/upgrade#upgrading-with-ngupgrade\n - guide/upgrade#use-route-parameters\n - guide/upgrade#using-a-module-loader\n - guide/upgrade#using-angular-components-from-angularjs-code\n - guide/upgrade#using-angularjs-component-directives-from-angular-code\n - guide/upgrade#using-component-directives\n - guide/upgrade#using-the-unified-angular-location-service\n - guide/upgrade#using-upgrademodule-with-angular-ngmodules\n - guide/upgrade#為延遲載入-angularjs-建立一個服務\n - guide/upgrade#為每個電話產生連結\n - guide/upgrade#為那些-angularjs-路由配置自訂路由匹配器\n - guide/upgrade#從-angular-程式碼使用-angularjs-元件指令\n - guide/upgrade#從-angularjs-程式碼中使用-angular-元件\n - guide/upgrade#從-angularjs-升級到-angular\n - guide/upgrade#使用-ngupgrade-升級\n - guide/upgrade#使用模組載入器\n - guide/upgrade#使用元件型指令\n - guide/upgrade#使用統一的-angular-位置服務location\n - guide/upgrade#使用路由引數\n - guide/upgrade#依賴注入\n - guide/upgrade#再見angularjs\n - guide/upgrade#準備工作\n - guide/upgrade#切換到-typescript\n - guide/upgrade#建立-appmodule\n - guide/upgrade#建立一個用來渲染-angularjs-內容的元件\n - guide/upgrade#建立路由模組\n - guide/upgrade#升級-phone-服務\n - guide/upgrade#升級元件\n - guide/upgrade#單元測試\n - guide/upgrade#變更檢測\n - guide/upgrade#安裝-angular\n - guide/upgrade#對混合式應用做-aot-編譯\n - guide/upgrade#引導-phonecat-的混合式應用\n - guide/upgrade#引導混合應用程式\n - guide/upgrade#延遲載入-angularjs\n - guide/upgrade#把-angular-的內容透傳進-angularjs-的元件型指令\n - guide/upgrade#把-angularjs-的內容投影到-angular-元件中\n - guide/upgrade#沒有-angular-filter-或-orderby-過濾器\n - guide/upgrade#新增-angular-路由器\n - guide/upgrade#新增-angular-路由器和載入程式\n - guide/upgrade#新增-checkmarkpipe\n - guide/upgrade#元件與-dom\n - guide/upgrade#讓-angular-的依賴能被注入到-angularjs-中\n - guide/upgrade#讓-angularjs-中的依賴可被注入到-angular\n - guide/upgrade#遷移到-typescript\n - guide/upgrade#透過-angular-的-ngmodule-來使用-upgrademodule\n - guide/upgrade#遵循-angularjs-風格指南\n - guide/upgrade#附錄升級-phonecat-的測試\n - guide/upgrade-setup\n - http://browserify.org\n - https://blog.angular.io/finding-a-path-forward-with-angularjs-7e186fdd4429\n - https://docs.angularjs.org/api/ng/function/angular.bootstrap\n - https://docs.angularjs.org/api/ng/service/$location\n - https://docs.angularjs.org/api/ng/type/angular.Module\n - https://docs.angularjs.org/api/ng/type/angular.Module#component\n - https://docs.angularjs.org/api/ngRoute/directive/ngView\n - https://docs.angularjs.org/api/ngRoute/provider/$routeProvider\n - https://docs.angularjs.org/tutorial\n - https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#support-for-umd-module-definitions\n - https://github.com/angular/angular-phonecat\n - https://github.com/angular/angular-phonecat/commits/1.5-snapshot\n - https://github.com/angular/angular/issues/38366\n - https://github.com/angular/quickstart\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\n - https://github.com/mgechev/angular-umd-bundle\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/upgrade.md?message=docs%3A%20請簡述你的修改...\n - https://github.com/systemjs/systemjs\n - https://rollupjs.org\n - https://webpack.github.io\n - https://www.npmjs.com/package/@types/angular\n-->"}