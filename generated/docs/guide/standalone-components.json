{"id":"guide/standalone-components","title":"Getting started with standalone components","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/standalone-components.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"getting-started-with-standalone-components\" translation-result=\"on\">獨立元件入門<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#getting-started-with-standalone-components\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Getting started with standalone components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#getting-started-with-standalone-components\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\"><strong>獨立元件</strong>提供了一種簡化的方式來建構 Angular 應用程式。獨立元件、指令和管道旨在透過減少對 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的需求來簡化創作體驗。現有應用程式可以選擇性地以增量方式採用新的獨立風格，而無需任何重大更改。</p><p translation-origin=\"off\"><strong>Standalone components</strong> provide a simplified way to build Angular applications. Standalone components, directives, and pipes aim to streamline the authoring experience by reducing the need for <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s. Existing applications can optionally and incrementally adopt the new standalone style without any breaking changes.</p>\n\n<h2 id=\"creating-standalone-components\" translation-result=\"on\">建立獨立元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#creating-standalone-components\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Creating standalone components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#creating-standalone-components\"><i class=\"material-icons\">link</i></a></h2>\n\n<video controls=\"\">\n  <source src=\"assets/videos/Getting Started with Standalone Components in Angular-x5PZwb4XurU.webm\" type=\"video/webm\">\n  <source src=\"assets/videos/Getting Started with Standalone Components in Angular-x5PZwb4XurU.mp4\" type=\"video/mp4\">\n  <track src=\"assets/videos/Getting Started with Standalone Components in Angular-x5PZwb4XurU.en.vtt\" label=\"English\" kind=\"subtitles\" srclang=\"en\">\n  <track src=\"assets/videos/Getting Started with Standalone Components in Angular-x5PZwb4XurU.cn.vtt\" label=\"簡體中文\" kind=\"subtitles\" srclang=\"zh-CN\" default=\"\">\n  <track src=\"assets/videos/Getting Started with Standalone Components in Angular-x5PZwb4XurU.tw.vtt\" label=\"正體中文\" kind=\"subtitles\" srclang=\"zh-TW\">\n  <p>注意：本影片不支援 IE 瀏覽器</p>\n</video>\n<h3 id=\"the-standalone-flag-and-component-imports\" translation-result=\"on\"><code>standalone</code> 標誌和元件 <code>imports</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#the-standalone-flag-and-component-imports\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">The <code>standalone</code> flag and component <code>imports</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#the-standalone-flag-and-component-imports\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">元件、指令和管道現在可以標記為 <code>standalone: true</code>。標記為獨立的 Angular 類不需要在 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中宣告（如果你嘗試，Angular 編譯器會報告錯誤）。</p><p translation-origin=\"off\">Components, directives, and pipes can now be marked as <code>standalone: true</code>. Angular classes marked as standalone do not need to be declared in an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> (the Angular compiler will report an error if you try).</p>\n\n<p translation-result=\"on\">獨立元件直接指定它們的依賴項，而不是透過 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 獲取它們。例如，如果 <code>PhotoGalleryComponent</code> 是獨立元件，它可以直接匯入另一個獨立元件 <code>ImageGridComponent</code>：</p><p translation-origin=\"off\">Standalone components specify their dependencies directly instead of getting them through <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s. For example, if <code>PhotoGalleryComponent</code> is a standalone component, it can directly import another standalone component <code>ImageGridComponent</code>:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'photo-gallery',\n  imports: [ImageGridComponent],\n  template: `\n    ... &lt;image-grid [images]=\"imageList\"&gt;&lt;/image-grid&gt;\n  `,\n})\nexport class PhotoGalleryComponent {\n  // component logic\n}\n</code-example>\n<p translation-result=\"on\"><code>imports</code> 也可用於參考獨立指令和管道。透過這種方式，可以編寫獨立元件，而無需建立 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 來管理範本依賴項。</p><p translation-origin=\"off\"><code>imports</code> can also be used to reference standalone directives and pipes. In this way, standalone components can be written without the need to create an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> to manage template dependencies.</p>\n\n<h3 id=\"using-existing-ngmodules-in-a-standalone-component\" translation-result=\"on\">在獨立元件中使用現有的 NgModules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-existing-ngmodules-in-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Using existing NgModules in a standalone component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-existing-ngmodules-in-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">編寫獨立元件時，你可能希望在元件的範本中使用其他元件、指令或管道。其中某些依賴項可能不會標記為獨立，而是由現有的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 宣告和匯出。在這種情況下，你可以將 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 直接匯入到獨立元件中：</p><p translation-origin=\"off\">When writing a standalone component, you may want to use other components, directives, or pipes in the component's template. Some of those dependencies might not be marked as standalone, but instead declared and exported by an existing <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>. In this case, you can import the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> directly into the standalone component:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  selector: 'photo-gallery',\n  // an existing module is imported directly into a standalone component\n  imports: [MatButtonModule],\n  template: `\n    ...\n    &lt;button mat-button&gt;Next Page&lt;/button&gt;\n  `,\n})\nexport class PhotoGalleryComponent {\n  // logic\n}\n</code-example>\n<p translation-result=\"on\">你可以在範本中將獨立元件與現有的基於 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的函式庫或依賴項一起使用。獨立元件可以充分利用現有的 Angular 庫生態系統。</p><p translation-origin=\"off\">You can use standalone components with existing <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>-based libraries or dependencies in your template. Standalone components can take full advantage of the existing ecosystem of Angular libraries.</p>\n\n<h2 id=\"using-standalone-components-in-ngmodule-based-applications\" translation-result=\"on\">在基於 NgModule 的應用程式中使用獨立元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-standalone-components-in-ngmodule-based-applications\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Using standalone components in NgModule-based applications<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#using-standalone-components-in-ngmodule-based-applications\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">獨立元件也可以匯入到現有的基於 NgModules 的上下文中。這允許現有應用程式（今天使用 NgModules）逐步採用新的獨立風格的元件。</p><p translation-origin=\"off\">Standalone components can also be imported into existing NgModules-based contexts. This allows existing applications (which are using NgModules today) to incrementally adopt the new, standalone style of component.</p>\n\n<p translation-result=\"on\">你可以像匯入 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 一樣匯入獨立元件（或指令或管道）- 使用 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code>：</p><p translation-origin=\"off\">You can import a standalone component (or directive, or pipe) just like you would an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> - using <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code>:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [AlbumComponent],\n  exports: [AlbumComponent], \n  imports: [PhotoGalleryComponent],\n})\nexport class AlbumModule {}\n</code-example>\n<h2 id=\"bootstrapping-an-application-using-a-standalone-component\" translation-result=\"on\">使用獨立元件引導應用程式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#bootstrapping-an-application-using-a-standalone-component\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Bootstrapping an application using a standalone component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#bootstrapping-an-application-using-a-standalone-component\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">透過使用獨立元件作為應用程式的根元件，可以在沒有任何 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的情況下引導 Angular 應用程式。這是使用 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> API 來完成的：</p><p translation-origin=\"off\">An Angular application can be bootstrapped without any <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> by using a standalone component as the application's root component. This is done using the <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> API:</p>\n\n<code-example language=\"ts\">\n// in the main.ts file\nimport {<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>} from '@angular/platform-browser';\nimport {PhotoAppComponent} from './app/photo.app.component';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent);\n</code-example>\n<h3 id=\"configuring-dependency-injection\" translation-result=\"on\">配置依賴注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#configuring-dependency-injection\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Configuring dependency injection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#configuring-dependency-injection\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">引導應用程式時，你通常希望配置 Angular 的依賴注入並提供配置值或服務以在整個應用程式中使用。你可以將這些作為提供者傳遞給 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code>：</p><p translation-origin=\"off\">When bootstrapping an application, often you want to configure Angular’s dependency injection and provide configuration values or services for use throughout the application. You can pass these as providers to <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code>:</p>\n\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    // ...\n  ]\n});\n</code-example>\n<p translation-result=\"on\">獨立的引導操作基於顯式配置 <code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code> 列表以進行依賴注入。在 Angular 中，帶有 <code>provide</code> 字首的函式可用於配置不同的系統，而不必匯入 NgModules。比如 <code><a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a></code> 可用於 <code>RouterModule.forRoot</code> 中以配置路由器：</p><p translation-origin=\"off\">The standalone bootstrap operation is based on explicitly configuring a list of <code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code>s for dependency injection. In Angular, <code>provide</code>-prefixed functions can be used to configure different systems without needing to import NgModules. For example, <code><a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a></code> is used in place of <code>RouterModule.forRoot</code> to configure the router:</p>\n\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    <a href=\"api/router/provideRouter\" class=\"code-anchor\">provideRouter</a>([/* app routes */]),\n    // ...\n  ]\n});\n</code-example>\n<p translation-result=\"on\">許多第三方庫也已更新以支援這種 <code>provide</code> 配置模式。如果某個庫僅為其 DI 配置提供 NgModule API，你可以用 <code><a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a></code> 實用函式，來將它與 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> 和其他獨立上下文一起使用：</p><p translation-origin=\"off\">Many third party libraries have also been updated to support this <code>provide</code>-function configuration pattern. If a library only offers an NgModule API for its DI configuration, you can use the <code><a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a></code> utility to still use it with <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> and other standalone contexts:</p>\n\n<code-example language=\"ts\">\nimport {LibraryModule} from 'ngmodule-based-library';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    <a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a>(\n      LibraryModule.forRoot()\n    ),\n  ]\n});\n</code-example>\n<h2 id=\"routing-and-lazy-loading\" translation-result=\"on\">路由和延遲載入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#routing-and-lazy-loading\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Routing and lazy-loading<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#routing-and-lazy-loading\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">路由器 API 進行了更新和簡化，以利用獨立元件的優勢：在許多常見的延遲載入場景中不再需要 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>。</p><p translation-origin=\"off\">The router APIs were updated and simplified to take advantage of the standalone components: an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> is no longer required in many common, lazy-loading scenarios.</p>\n\n<h3 id=\"lazy-loading-a-standalone-component\" translation-result=\"on\">延遲載入獨立元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Lazy loading a standalone component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-a-standalone-component\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">任何路由都可以用 <code>loadComponent</code> 延遲載入其路由到的獨立元件：</p><p translation-origin=\"off\">Any route can lazily load its routed, standalone component by using <code>loadComponent</code>:</p>\n\n<code-example language=\"ts\">\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadComponent: () =&gt; import('./admin/panel.component').then(mod =&gt; mod.AdminPanelComponent)},\n  // ...\n];\n</code-example>\n<p translation-result=\"on\">只要載入的元件是獨立的，就可以用。</p><p translation-origin=\"off\">This works as long as the loaded component is standalone.</p>\n\n<h3 id=\"lazy-loading-many-routes-at-once\" translation-result=\"on\">一次延遲載入多個路由<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-many-routes-at-once\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Lazy loading many routes at once<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-many-routes-at-once\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>loadChildren</code> 操作現在支援載入一組新的子 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>，而無需編寫延遲載入的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 來匯入 <code>RouterModule.forChild</code> 來宣告路由。當以這種方式載入的每個路由都使用獨立元件時，這會起作用。</p><p translation-origin=\"off\">The <code>loadChildren</code> operation now supports loading a new set of child <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>s without needing to write a lazy loaded <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> that imports <code>RouterModule.forChild</code> to declare the routes. This works when every route loaded this way is using a standalone component.</p>\n\n<code-example language=\"ts\">\n// In the main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadChildren: () =&gt; import('./admin/routes').then(mod =&gt; mod.ADMIN_ROUTES)},\n  // ...\n];\n\n// In admin/routes.ts:\nexport const ADMIN_ROUTES: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'home', component: AdminHomeComponent},\n  {path: 'users', component: AdminUsersComponent},\n  // ...\n];\n</code-example>\n<h3 id=\"lazy-loading-and-default-exports\" translation-result=\"on\">延遲載入和預設匯出<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-and-default-exports\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Lazy loading and default exports<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#lazy-loading-and-default-exports\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">使用 <code>loadChildren</code> 和 <code>loadComponent</code> 時，路由器會理解並使用 <code>default</code> 匯出來自動解開封裝動態 <code>import()</code> 呼叫。你可以利用這一點跳過 <code>.then()</code> 進行此類延遲載入操作。</p><p translation-origin=\"off\">When using <code>loadChildren</code> and <code>loadComponent</code>, the router understands and automatically unwraps dynamic <code>import()</code> calls with <code>default</code> exports. You can take advantage of this to skip the <code>.then()</code> for such lazy loading operations.</p>\n\n<code-example language=\"ts\">\n// In the main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {path: 'admin', loadChildren: () =&gt; import('./admin/routes')},\n  // ...\n];\n\n// In admin/routes.ts:\nexport default [\n  {path: 'home', component: AdminHomeComponent},\n  {path: 'users', component: AdminUsersComponent},\n  // ...\n] as <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[];\n</code-example>\n<h3 id=\"providing-services-to-a-subset-of-routes\" translation-result=\"on\">為路由的子集提供服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#providing-services-to-a-subset-of-routes\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Providing services to a subset of routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#providing-services-to-a-subset-of-routes\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的延遲載入 API （ <code>loadChildren</code>）在載入路由的延遲載入的子項時會建立一個新的“模組”注入器。此特性通常可用於僅嚮應用程式中的一部分路由提供服務。例如，如果 <code>/admin</code> 下的所有路由都使用 <code>loadChildren</code> 邊界來限定範圍，則可以僅向這些路由提供僅限管理的服務。執行此操作需要使用 <code>loadChildren</code> API，即使延遲載入有問題的路由不是必要的。</p><p translation-origin=\"off\">The lazy loading API for <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s (<code>loadChildren</code>) creates a new \"module\" injector when it loads the lazily loaded children of a route. This feature was often useful to provide services only to a subset of routes in the application. For example, if all routes under <code>/admin</code> were scoped using a <code>loadChildren</code> boundary, then admin-only services could be provided only to those routes. Doing this required using the <code>loadChildren</code> API, even if lazy loading of the routes in question was unnecessary.</p>\n\n<p translation-result=\"on\">路由器現在支援在 <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> 上顯式指定其他 <code>providers</code>，這允許相同的範圍限定，而無需延遲載入或 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>。例如，<code>/admin</code> 路由結構中的範圍服務將類似於：</p><p translation-origin=\"off\">The Router now supports explicitly specifying additional <code>providers</code> on a <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code>, which allows this same scoping without the need for either lazy loading or <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s. For example, scoped services within an <code>/admin</code> route structure would look like:</p>\n\n<code-example language=\"ts\">\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [\n  {\n    path: 'admin',\n    providers: [\n      AdminService,\n      {provide: ADMIN_API_KEY, useValue: '12345'},\n    ],\n    children: [\n      {path: 'users', component: AdminUsersComponent},\n      {path: 'teams', component: AdminTeamsComponent},\n    ],\n  },\n  // ... other application routes that don't\n  //     have access to ADMIN_API_KEY or AdminService.\n];\n</code-example>\n<p translation-result=\"on\">也可以將 <code>providers</code> 與額外路由配置的 <code>loadChildren</code> 結合使用，以實現與延遲載入帶有額外路由和路由級服務提供者的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 相同的效果。此範例配置與上面相同的提供者/子路由，但在延遲載入邊界之後：</p><p translation-origin=\"off\">It's also possible to combine <code>providers</code> with <code>loadChildren</code> of additional routing configuration, to achieve the same effect of lazy loading an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> with additional routes and route-level providers. This example configures the same providers/child routes as above, but behind a lazy loaded boundary:</p>\n\n<code-example language=\"ts\">\n// Main application:\nexport const <a href=\"api/router/ROUTES\" class=\"code-anchor\">ROUTES</a>: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = {\n  // Lazy-load the admin routes.\n  {path: 'admin', loadChildren: () =&gt; import('./admin/routes').then(mod =&gt; mod.ADMIN_ROUTES)},\n  // ... rest of the routes\n}\n\n// In admin/routes.ts:\nexport const ADMIN_ROUTES: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a>[] = [{\n  path: '',\n  pathMatch: 'prefix',\n  providers: [\n    AdminService,\n    {provide: ADMIN_API_KEY, useValue: 12345},\n  ],\n  children: [\n    {path: 'users', component: AdminUsersCmp},\n    {path: 'teams', component: AdminTeamsCmp},\n  ],\n}];\n</code-example>\n<p translation-result=\"on\">請注意這裡使用了空路徑路由來定義供所有子路由共享的宿主 <code>providers</code>。</p><p translation-origin=\"off\">Note the use of an empty-path route to host <code>providers</code> that are shared among all the child routes.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a></code> 也可用於將現有的基於 NgModule 的 DI 配置匯入到路由 <code>providers</code> 中。</p><p translation-origin=\"off\"><code><a href=\"api/core/importProvidersFrom\" class=\"code-anchor\">importProvidersFrom</a></code> can be used to import existing NgModule-based DI configuration into route <code>providers</code> as well.</p>\n\n<h2 id=\"advanced-topics\" translation-result=\"on\">高階主題<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#advanced-topics\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Advanced topics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#advanced-topics\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本節會更詳細地介紹僅與更進階的使用模式相關的。第一次瞭解獨立元件、指令和管道時，你可以安全地跳過本節。</p><p translation-origin=\"off\">This section goes into more details that are relevant only to more advanced usage patterns. You can safely skip this section when learning about standalone components, directives, and pipes for the first time. </p>\n\n<h3 id=\"standalone-components-for-library-authors\" translation-result=\"on\">針對庫作者的獨立元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-components-for-library-authors\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Standalone components for library authors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-components-for-library-authors\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">獨立的元件、指令和管道可以從匯入它們的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中匯出：</p><p translation-origin=\"off\">Standalone components, directives, and pipes can be exported from <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s that import them:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ImageCarouselComponent, ImageSlideComponent],\n  exports: [ImageCarouselComponent, ImageSlideComponent],\n})\nexport class CarouselModule {}\n</code-example>\n<p translation-result=\"on\">此模式對於釋出一組合作指令的 Angular 庫很有用。在上面的範例中，<code>ImageCarouselComponent</code> 和 <code>ImageSlideComponent</code> 需要出現在範本中，以建構一個邏輯上的“輪播小部件”。</p><p translation-origin=\"off\">This pattern is useful for Angular libraries that publish a set of cooperating directives. In the above example, both the <code>ImageCarouselComponent</code> and <code>ImageSlideComponent</code> need to be present in a template to build up one logical \"carousel widget\". </p>\n\n<p translation-result=\"on\">作為釋出 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的替代方案，庫作者可能希望匯出一個合作指令陣列：</p><p translation-origin=\"off\">As an alternative to publishing a <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>, library authors might want to export an array of cooperating directives:</p>\n\n<code-example language=\"ts\">\nexport const CAROUSEL_DIRECTIVES = [ImageCarouselComponent, ImageSlideComponent] as const;\n</code-example>\n<p translation-result=\"on\">這樣的陣列可以由使用 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的應用程式匯入並新增到 <code>@<a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code>。請注意 TypeScript 的 <code>as const</code> 構造的存在：它為 Angular 編譯器提供了正確編譯所需的額外資訊，並且是一種推薦的實踐（因為它使匯出的陣列從 TypeScript 的角度來看是不可變的）。</p><p translation-origin=\"off\">Such an array could be imported by applications using <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s and added to the <code>@<a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code>. Please note the presence of the TypeScript’s <code>as const</code> construct: it gives Angular compiler additional information required for proper compilation and is a recommended practice (as it makes the exported array immutable from the TypeScript point of view).</p>\n\n<h3 id=\"dependency-injection-and-injectors-hierarchy\" translation-result=\"on\">依賴注入和注入器層次結構<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#dependency-injection-and-injectors-hierarchy\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Dependency injection and injectors hierarchy<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#dependency-injection-and-injectors-hierarchy\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 應用程式可以透過指定一組可用的提供者來配置依賴注入。在典型應用中，有兩種不同的注入器型別：</p><p translation-origin=\"off\">Angular applications can configure dependency injection by specifying a set of available providers. In a typical application, there are two different injector types:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">具有在 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 或 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({providedIn: \"...\"})</code> 中配置的服務提供者的<strong>模組注入器</strong>。這些應用程式範圍的提供者對模組注入器中配置的所有元件以及其他服務可見。</p><p translation-origin=\"off\"><strong>module injector</strong> with providers configured in <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> or <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({providedIn: \"...\"})</code>. Those application-wide providers are visible to all components in as well as to other services configured in a module injector.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在 <code>@<a href=\"api/core/Directive#providers\" class=\"code-anchor\">Directive.providers</a></code> / <code>@Component.providers</code> 或 <code>@<a href=\"api/core/Component#viewProviders\" class=\"code-anchor\">Component.viewProviders</a></code> 中配置的<strong>節點注入器</strong>。這些提供者僅對給定元件及其所有子項可見。</p><p translation-origin=\"off\"><strong>node injectors</strong> configured in <code>@<a href=\"api/core/Directive#providers\" class=\"code-anchor\">Directive.providers</a></code> / <code>@Component.providers</code> or <code>@<a href=\"api/core/Component#viewProviders\" class=\"code-anchor\">Component.viewProviders</a></code>. Those providers are visible to a given component and all its children only.</p>\n\n</li>\n</ul>\n<h4 id=\"environment-injectors\" translation-result=\"on\">環境注入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#environment-injectors\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Environment injectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#environment-injectors\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">使 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 變成可選的將需要一種新方法來用應用程式範圍的提供者（例如<a href=\"/api/common/http/HttpClient\">HttpClient</a>）配置“模組”注入器。在獨立應用程式（使用 <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> 建立的）中，可以在引導過程中在 <code>providers</code> 選項中配置“模組”提供者：</p><p translation-origin=\"off\">Making <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s optional will require new ways of configuring \"module\" injectors with application-wide providers (for example, <a href=\"/api/common/http/HttpClient\">HttpClient</a>). In the standalone application (one created with <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code>), “module” providers can be configured during the bootstrap process, in the <code>providers</code> option: </p>\n\n<code-example language=\"ts\">\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(PhotoAppComponent, {\n  providers: [\n    {provide: BACKEND_URL, useValue: 'https://photoapp.looknongmodules.com/api'},\n    {provide: PhotosService, useClass: PhotosService},\n    // ...\n  ]\n});\n</code-example>\n<p translation-result=\"on\">新的引導 API 為我們提供了在不使用 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的情況下配置“模組注入器”的方法。從這個意義上說，名稱的“模組”部分不再相關，我們決定引入一個新術語：“環境注入器”。</p><p translation-origin=\"off\">The new bootstrap API gives us back the means of configuring “module injectors” without using <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>s. In this sense, the “module” part of the name is no longer relevant and we’ve decided to introduce a new term: “environment injectors”. </p>\n\n<p translation-result=\"on\">可以用以下方法之一配置環境注入器：</p><p translation-origin=\"off\">Environment injectors can be configured using one of the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>（在透過 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 引導的應用程式中）；</p><p translation-origin=\"off\"><code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> (in applications bootstrapping through an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>);</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({provideIn: \"...\"})</code>（在基於 NgModule 以及“獨立”應用程式中）；</p><p translation-origin=\"off\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({provideIn: \"...\"})</code>(in both the NgModule-based and the “standalone” applications);</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> 呼叫中的 <code>providers</code> 選項（在完全“獨立”的應用程式中）；</p><p translation-origin=\"off\"><code>providers</code> option in the <code><a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a></code> call (in fully “standalone” applications);</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> 配置中的 <code>providers</code> 欄位。</p><p translation-origin=\"off\"><code>providers</code> field in a <code><a href=\"api/router/Route\" class=\"code-anchor\">Route</a></code> configuration.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">Angular v14 引入了一種新的 TypeScript 型別 <code><a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a></code> 來表示這種新命名。附帶的 <code><a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a></code> API 使得以程式設計方式建立環境注入器成為可能：</p><p translation-origin=\"off\">Angular v14 introduces a new TypeScript type <code><a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a></code> to represent this new naming. The accompanying <code><a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a></code> API makes it possible to create environment injectors programmatically: </p>\n\n<code-example language=\"ts\">\nimport {<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>} from '@angular/core';\n\nconst parentInjector = … // existing environment injector\nconst childInjector = <a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>([{provide: PhotosService, useClass: CustomPhotosService}], parentInjector);\n</code-example>\n<p translation-result=\"on\">環境注入器還有一個額外的能力：它們可以在建立環境注入器時執行初始化邏輯（類似於建立模組注入器時執行的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 建構函式）：</p><p translation-origin=\"off\">Environment injectors have one additional capability: they can execute initialization logic when an environment injector gets created (similar to the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> constructors that get executed when a module injector is created):</p>\n\n<code-example language=\"ts\">\nimport {<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>, <a href=\"api/core/ENVIRONMENT_INITIALIZER\" class=\"code-anchor\">ENVIRONMENT_INITIALIZER</a>} from '@angular/core';\n\n<a href=\"api/core/createEnvironmentInjector\" class=\"code-anchor\">createEnvironmentInjector</a>([\n{provide: PhotosService, useClass: CustomPhotosService},\n{provide: <a href=\"api/core/ENVIRONMENT_INITIALIZER\" class=\"code-anchor\">ENVIRONMENT_INITIALIZER</a>, useValue: () =&gt; {\n        console.log(\"This function runs when this <a href=\"api/core/EnvironmentInjector\" class=\"code-anchor\">EnvironmentInjector</a> gets created\");\n}}\n]);\n</code-example>\n<h4 id=\"standalone-injectors\" translation-result=\"on\">獨立注入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-injectors\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Standalone injectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#standalone-injectors\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">實際上，依賴注入器層次結構在使用獨立元件的應用程式中稍微複雜一些。讓我們考慮以下範例：</p><p translation-origin=\"off\">In reality, the dependency injectors hierarchy is slightly more elaborate in applications using standalone components. Let’s consider the following example:</p>\n\n<code-example language=\"ts\">\n// an existing \"datepicker\" component with an <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'datepicker',\n  template: '...',\n})\nclass DatePickerComponent {\n  constructor(private calendar: CalendarService) {\n  }\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [DatePickerComponent],\n  exports: [DatePickerComponent]\n  providers: [CalendarService],\n})\nclass DatePickerModule {\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'date-modal',\n  template: '&lt;datepicker&gt;&lt;/datepicker&gt;',\n  standalone: true,\n  imports: [DatePickerModule]\n})\nclass DateModalComponent {\n}\n</code-example>\n<p translation-result=\"on\">在上面的範例中，元件 <code>DateModalComponent</code> 是獨立的 - 它可以直接使用，並且沒有需要匯入才能使用它的 NgModule。但是，<code>DateModalComponent</code> 有一個依賴項 <code>DatePickerComponent</code>，它是透過其 NgModule（<code>DatePickerModule</code>）匯入的。此 NgModule 可以宣告 <code>DatePickerComponent</code> 正常執行所需的提供者（在本例中為：<code>CalendarService</code>）。</p><p translation-origin=\"off\">In the above example, the component <code>DateModalComponent</code> is standalone - it can be consumed directly and has no NgModule which needs to be imported in order to use it. However, <code>DateModalComponent</code> has a dependency, the <code>DatePickerComponent,</code> which is imported via its NgModule (the <code>DatePickerModule</code>). This NgModule may declare providers (in this case: <code>CalendarService</code>) which are required for the <code>DatePickerComponent</code> to function correctly.</p>\n\n<p translation-result=\"on\">當 Angular 建立獨立元件時，它需要知道當前注入器具有獨立元件依賴項的所有必要服務，包括基於 NgModules 的服務。為了保證這一點，在某些情況下，Angular 會建立一個新的“獨立注入器”作為當前環境注入器的子項。今天，這種情況發生在所有引導的獨立元件上：它將是根環境注入器的子項。相同的規則適用於動態建立的（例如，由路由器或 <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> API）獨立元件。</p><p translation-origin=\"off\">When Angular creates a standalone component, it needs to know that the current injector has all of the necessary services for the standalone component's dependencies, including those based on NgModules. To guarantee that, in some cases Angular will create a new \"standalone injector\" as a child of the current environment injector. Today, this happens for all bootstrapped standalone components: it will be a child of the root environment injector. The same rule applies to the dynamically created (for example, by the router or the <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> API) standalone components. </p>\n\n<p translation-result=\"on\">建立了一個單獨的獨立注入器，以確保獨立元件匯入的提供者與應用程式的其餘部分“隔離”。這讓我們將獨立元件視為真正獨立的部分，不能將它們的實現細節“洩漏”給應用程式的其餘部分。</p><p translation-origin=\"off\">A separate standalone injector is created to ensure that providers imported by a standalone component are “isolated” from the rest of the application. This lets us think of standalone components as truly self-contained pieces that can’t “leak” their implementation details to the rest of the application.</p>\n\n<h4 id=\"resolve-circular-dependencies-with-a-forward-class-reference\" translation-result=\"on\">使用前向類參考解決迴圈依賴<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#resolve-circular-dependencies-with-a-forward-class-reference\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Resolve circular dependencies with a forward class reference<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/standalone-components#resolve-circular-dependencies-with-a-forward-class-reference\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在 TypeScript 裡面，類宣告的順序是很重要的。如果一個類別尚未定義，就不能參考它。</p><p translation-origin=\"off\">The order of class declaration matters in TypeScript. You can't refer directly to a class until it's been defined.</p>\n\n<p translation-result=\"on\">這通常不是問題，但有時迴圈參考是不可避免的。例如，當類“A”參考類“B”而“B”也參考“A”時。其中之一必須首先定義。</p><p translation-origin=\"off\">This isn't usually a problem but sometimes circular references are unavoidable. For example, when class 'A' refers to class 'B' and 'B' refers to 'A'. One of them has to be defined first.</p>\n\n<p translation-result=\"on\">Angular 的 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> 函式建立了一個 Angular 稍後可以解析的間接參考。</p><p translation-origin=\"off\">The Angular <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> function creates an indirect reference that Angular can resolve later. </p>\n\n<p translation-result=\"on\">例如，當獨立父元件匯入獨立子元件時會發生這種情況，反之亦然。你可以使用 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a></code> 函式解決此迴圈依賴問題。</p><p translation-origin=\"off\">For example, this situation happens when a standalone parent component imports a standalone child component and vice-versa. You can resolve this circular dependency issue by using the <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a></code> function.</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true, \n  imports: [ChildComponent],\n  selector: 'app-parent',\n  template: `&lt;app-child [hideParent]=\"hideParent\"&gt;&lt;/app-child&gt;`,\n})\nexport class ParentComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hideParent: boolean;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  standalone: true,\n  imports: [<a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; ParentComponent)],\n  selector: 'app-child',\n  template: `&lt;app-parent *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"!hideParent\"&gt;&lt;/app-parent&gt;`,\n})\nexport class ChildComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hideParent: boolean;\n}\n</code-example>\n<div class=\"alert is-important\">\n<p translation-result=\"on\">這種型別的匯入可能會導致元件例項化期間出現無限遞迴。請確保這種遞迴具有停止條件，會在某種時刻停止。</p><p translation-origin=\"off\">This kind of imports may result in an infinite recursion during component instantiation. Make sure that this recursion has an exit condition that stops it at some point.</p>\n\n</div>\n\n  \n</div>\n\n\n<!-- links to this doc:\n - api/common/NgOptimizedImage\n - api/core/Component\n - api/core/Directive\n - api/core/Pipe\n - api/core/createEnvironmentInjector\n - api/core/importProvidersFrom\n - api/platform-browser\n - api/platform-browser/bootstrapApplication\n - guide/glossary\n - guide/standalone-migration\n - guide/update-to-version-15\n-->\n<!-- links from this doc:\n - /api/common/http/HttpClient\n - api/common/CommonModule\n - api/common/NgIf\n - api/core/Component\n - api/core/Component#viewProviders\n - api/core/Directive#providers\n - api/core/ENVIRONMENT_INITIALIZER\n - api/core/EnvironmentInjector\n - api/core/Injectable\n - api/core/Input\n - api/core/NgModule\n - api/core/NgModule#imports\n - api/core/NgModule#providers\n - api/core/Provider\n - api/core/ViewContainerRef\n - api/core/createEnvironmentInjector\n - api/core/forwardRef\n - api/core/importProvidersFrom\n - api/platform-browser/bootstrapApplication\n - api/router/ROUTES\n - api/router/Route\n - api/router/provideRouter\n - guide/standalone-components#advanced-topics\n - guide/standalone-components#bootstrapping-an-application-using-a-standalone-component\n - guide/standalone-components#configuring-dependency-injection\n - guide/standalone-components#creating-standalone-components\n - guide/standalone-components#dependency-injection-and-injectors-hierarchy\n - guide/standalone-components#environment-injectors\n - guide/standalone-components#getting-started-with-standalone-components\n - guide/standalone-components#lazy-loading-a-standalone-component\n - guide/standalone-components#lazy-loading-and-default-exports\n - guide/standalone-components#lazy-loading-many-routes-at-once\n - guide/standalone-components#providing-services-to-a-subset-of-routes\n - guide/standalone-components#resolve-circular-dependencies-with-a-forward-class-reference\n - guide/standalone-components#routing-and-lazy-loading\n - guide/standalone-components#standalone-components-for-library-authors\n - guide/standalone-components#standalone-injectors\n - guide/standalone-components#standalone-標誌和元件-imports\n - guide/standalone-components#the-standalone-flag-and-component-imports\n - guide/standalone-components#using-existing-ngmodules-in-a-standalone-component\n - guide/standalone-components#using-standalone-components-in-ngmodule-based-applications\n - guide/standalone-components#一次延遲載入多個路由\n - guide/standalone-components#為路由的子集提供服務\n - guide/standalone-components#使用前向類參考解決迴圈依賴\n - guide/standalone-components#使用獨立元件引導應用程式\n - guide/standalone-components#依賴注入和注入器層次結構\n - guide/standalone-components#建立獨立元件\n - guide/standalone-components#在基於-ngmodule-的應用程式中使用獨立元件\n - guide/standalone-components#在獨立元件中使用現有的-ngmodules\n - guide/standalone-components#延遲載入和預設匯出\n - guide/standalone-components#延遲載入獨立元件\n - guide/standalone-components#獨立注入器\n - guide/standalone-components#獨立元件入門\n - guide/standalone-components#環境注入器\n - guide/standalone-components#路由和延遲載入\n - guide/standalone-components#配置依賴注入\n - guide/standalone-components#針對庫作者的獨立元件\n - guide/standalone-components#高階主題\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/standalone-components.md?message=docs%3A%20請簡述你的修改...\n-->"}