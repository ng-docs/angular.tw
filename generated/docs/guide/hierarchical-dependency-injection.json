{"id":"guide/hierarchical-dependency-injection","title":"Hierarchical injectors","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/hierarchical-dependency-injection.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"hierarchical-injectors\" translation-result=\"on\">多級注入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#hierarchical-injectors\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Hierarchical injectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#hierarchical-injectors\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">Angular 中的注入器有一些規則，你可以利用這些規則來在應用程式中獲得所需的可注入物件可見性。通過了解這些規則，可以確定應在哪個 NgModule、元件或指令中宣告服務提供者。</p><p translation-origin=\"off\">Injectors in Angular have rules that you can leverage to achieve the desired visibility of injectables in your applications.\nBy understanding these rules, you can determine in which NgModule, Component, or Directive you should declare a provider.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n本主題使用以下象形圖。</p><p translation-origin=\"off\"><strong>NOTE</strong>:<br>\nThis topic uses the following pictographs.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">html 實體</nt-wrapper><nt-wrapper translation-origin=\"off\">html entities</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">象形文字</nt-wrapper><nt-wrapper translation-origin=\"off\">pictographs</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>🌺</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">紅芙蓉（<code>🌺</code>）</nt-wrapper><nt-wrapper translation-origin=\"off\">red hibiscus (<code>🌺</code>)</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>🌻</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">向日葵（<code>🌻</code>）</nt-wrapper><nt-wrapper translation-origin=\"off\">sunflower (<code>🌻</code>)</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>🌷</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">鬱金香 (<code>🌷</code>)</nt-wrapper><nt-wrapper translation-origin=\"off\">tulip (<code>🌷</code>)</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>🌿</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">蕨類 ( <code>🌿</code> )</nt-wrapper><nt-wrapper translation-origin=\"off\">fern (<code>🌿</code>)</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>🍁</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">楓葉（<code>🍁</code>）</nt-wrapper><nt-wrapper translation-origin=\"off\">maple leaf (<code>🍁</code>)</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>🐳</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">鯨魚 ( <code>🐳</code> )</nt-wrapper><nt-wrapper translation-origin=\"off\">whale (<code>🐳</code>)</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>🐶</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">狗 ( <code>🐶</code> )</nt-wrapper><nt-wrapper translation-origin=\"off\">dog (<code>🐶</code>)</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>🦔</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">刺蝟 ( <code>🦔</code> )</nt-wrapper><nt-wrapper translation-origin=\"off\">hedgehog (<code>🦔</code>)</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n</div>\n<p translation-result=\"on\">你使用 Angular 建構的應用程式可能會變得非常大，管理這種複雜性的方法之一是將應用程式拆分為許多封裝良好的小模組，這些模組本身也會拆分為定義明確的元件樹。</p><p translation-origin=\"off\">The applications you build with Angular can become quite large, and one way to manage this complexity is to split up the application into many small well-encapsulated modules, that are by themselves split up into a well-defined tree of components.</p>\n\n<p translation-result=\"on\">你的頁面中可能會有某些部分會與應用程式的其餘部分完全獨立地工作，它具有自己的服務本地副本和所需的其它依賴項。在應用程式中，這些部分使用的某些服務可能會與其它部分共享，或者與元件樹中更深層的父元件共享，而其它依賴項則應該是私有的。</p><p translation-origin=\"off\">There can be sections of your page that works in a completely independent way than the rest of the application, with its own local copies of the services and other dependencies that it needs. Some of the services that these sections of the application use might be shared with other parts of the application, or with parent components that are further up in the component tree, while other dependencies are meant to be private.</p>\n\n<p translation-result=\"on\">使用多級依賴注入，你可以隔離應用程式的各個部分，並允許它們保有自己的私有依賴項，不與應用程式的其餘部分共享，或者讓父元件僅與其子元件共享某些依賴項，而不與元件樹的其餘部分共享等。多級依賴注入能讓你僅在需要時才在應用程式的不同部分之間共享依賴項。</p><p translation-origin=\"off\">With hierarchical dependency injection, you can isolate sections of the application and give them their own private dependencies not shared with the rest of the application, or have parent components share certain dependencies with its child components only but not with the rest of the component tree, and so on. Hierarchical dependency injection enables you to share dependencies between different parts of the application only when and if you need to.</p>\n\n<h2 id=\"types-of-injector-hierarchies\" translation-result=\"on\">注入器層次結構的型別<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#types-of-injector-hierarchies\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Types of injector hierarchies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#types-of-injector-hierarchies\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 中的注入器有一些規則，你可以利用這些規則來在應用程式中獲得所需的可注入物件的可見性。通過了解這些規則，可以確定應在哪個 NgModule、元件或指令中宣告服務提供者。</p><p translation-origin=\"off\">Injectors in Angular have rules that you can leverage to\nachieve the desired visibility of injectables in your applications.\nBy understanding these rules, you can determine in which\nNgModule, Component, or Directive you should declare a provider.</p>\n\n<p translation-result=\"on\">Angular 中有兩個注入器層次結構：</p><p translation-origin=\"off\">Angular has two injector hierarchies:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">注入器層次結構</nt-wrapper><nt-wrapper translation-origin=\"off\">Injector hierarchies</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><code>ModuleInjector</code> 層次結構</nt-wrapper><nt-wrapper translation-origin=\"off\"><code>ModuleInjector</code> hierarchy</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">使用 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 或 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 註解在此層次結構中配置 <code>ModuleInjector</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Configure a <code>ModuleInjector</code> in this hierarchy using an <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> or <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> annotation.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><code>ElementInjector</code> 層次結構</nt-wrapper><nt-wrapper translation-origin=\"off\"><code>ElementInjector</code> hierarchy</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在每個 DOM 元素上隱含建立。預設情況下，<code>ElementInjector</code> 是空的，除非你在 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 或 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 的 <code>providers</code> 屬性中配置它。</nt-wrapper><nt-wrapper translation-origin=\"off\">Created implicitly at each DOM element. An <code>ElementInjector</code> is empty by default unless you configure it in the <code>providers</code> property on <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code>.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p><a id=\"register-providers-injectable\"></a></p>\n<h3 id=\"moduleinjector\"><code>ModuleInjector</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#moduleinjector\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">可以透過以下兩種方式之一配置 <code>ModuleInjector</code>：</p><p translation-origin=\"off\">The <code>ModuleInjector</code> can be configured in one of two ways by using:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 的 <code>providedIn</code> 屬性參考 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 或 <code>root</code></p><p translation-origin=\"off\">The <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> <code>providedIn</code> property to refer to <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code>, or <code>root</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 的 <code>providers</code> 陣列</p><p translation-origin=\"off\">The <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> <code>providers</code> array</p>\n\n</li>\n</ul>\n<div class=\"callout is-helpful\">\n<header ng-should-translate=\"\">Tree-shaking and @Injectable()</header>\n<h4 id=\"搖樹最佳化與-injectable\">搖樹最佳化與 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#搖樹最佳化與-injectable\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 的 <code>providedIn</code> 屬性優於 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 的 <code>providers</code> 陣列。使用 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 的 <code>providedIn</code> 時，最佳化工具可以進行搖樹最佳化，從而刪除你的應用程式中未使用的服務，以減小捆綁套件尺寸。</p><p translation-origin=\"off\">Using the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> <code>providedIn</code> property is preferable to using the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> <code>providers</code> array. With <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> <code>providedIn</code>, optimization tools can perform tree-shaking, which removes services that your application isn't using. This results in smaller bundle sizes.</p>\n\n<p translation-result=\"on\">搖樹最佳化對於庫特別有用，因為使用該函式庫的應用程式不需要注入它。在 <a href=\"guide/architecture-services\">服務與依賴注入簡介</a>瞭解關於<a href=\"guide/architecture-services#providing-services\">可搖樹最佳化的提供者</a>的更多資訊。</p><p translation-origin=\"off\">Tree-shaking is especially useful for a library because the application which uses the library may not have a need to inject it.\nRead more about <a href=\"guide/architecture-services#providing-services\">tree-shakable providers</a> in <a href=\"guide/architecture-services\">Introduction to services and dependency injection</a>.</p>\n\n</div>\n<p translation-result=\"on\"><code>ModuleInjector</code> 由 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 和 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code> 屬性配置。<code>ModuleInjector</code> 是可以透過 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code> 遞迴找到的所有 providers 陣列的扁平化。</p><p translation-origin=\"off\"><code>ModuleInjector</code> is configured by the <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> and <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code> property.\n<code>ModuleInjector</code> is a flattening of all the providers arrays that can be reached by following the <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code> recursively.</p>\n\n<p translation-result=\"on\">子 <code>ModuleInjector</code> 是在延遲載入其它 <code>@NgModules</code> 時建立的。</p><p translation-origin=\"off\">Child <code>ModuleInjector</code> hierarchies are created when lazy loading other <code>@NgModules</code>.</p>\n\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 的 <code>providedIn</code> 屬性提供服務的方式如下：</p><p translation-origin=\"off\">Provide services with the <code>providedIn</code> property of <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> as follows:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'  // &lt;--provides this service in the root ModuleInjector\n})\nexport class ItemService {\n  name = 'telephone';\n}\n\n</code-example>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 裝飾器標識服務類別。該 <code>providedIn</code> 屬性配置指定的 <code>ModuleInjector</code>，這裡的 <code>root</code> 會把讓該服務在 <code>root</code> <code>ModuleInjector</code> 上可用。</p><p translation-origin=\"off\">The <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator identifies a service class.\nThe <code>providedIn</code> property configures a specific <code>ModuleInjector</code>, here <code>root</code>, which makes the service available in the <code>root</code> <code>ModuleInjector</code>.</p>\n\n<h4 id=\"platform-injector\" translation-result=\"on\">平台注入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#platform-injector\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Platform injector<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#platform-injector\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在 <code>root</code> 之上還有兩個注入器，一個是額外的 <code>ModuleInjector</code>，一個是 <code>NullInjector()</code>。</p><p translation-origin=\"off\">There are two more injectors above <code>root</code>, an additional <code>ModuleInjector</code> and <code>NullInjector()</code>.</p>\n\n<p translation-result=\"on\">思考下 Angular 要如何透過 <code>main.ts</code> 中的如下程式碼引導應用程式：</p><p translation-origin=\"off\">Consider how Angular bootstraps the application with the following in <code>main.ts</code>:</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule).then(ref =&gt; {…})\n\n</code-example>\n<p translation-result=\"on\"><code>bootstrapModule()</code> 方法會建立一個由 <code>AppModule</code> 配置的注入器作為平台注入器的子注入器。也就是 <code>root</code> <code>ModuleInjector</code>。</p><p translation-origin=\"off\">The <code>bootstrapModule()</code> method creates a child injector of the platform injector which is configured by the <code>AppModule</code>.\nThis is the <code>root</code> <code>ModuleInjector</code>.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>()</code> 方法建立一個由 <code>PlatformModule</code> 配置的注入器，該注入器包含特定平台的依賴項。這允許多個應用共享同一套平台配置。比如，無論你執行多少個應用程式，瀏覽器都只有一個 URL 欄。你可以使用 <code><a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>()</code> 函式提供 <code>extraProviders</code>，從而在平台級別配置特定平台的額外提供者。</p><p translation-origin=\"off\">The <code><a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>()</code> method creates an injector configured by a <code>PlatformModule</code>, which contains platform-specific dependencies.\nThis allows multiple applications to share a platform configuration.\nFor example, a browser has only one URL bar, no matter how many applications you have running.\nYou can configure additional platform-specific providers at the platform level by supplying <code>extraProviders</code> using the <code><a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>()</code> function.</p>\n\n<p translation-result=\"on\">層次結構中的下一個父注入器是 <code>NullInjector()</code>，它是樹的頂部。如果你在樹中向上走了很遠，以至於要在 <code>NullInjector()</code> 中尋找服務，那麼除非使用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>，否則將收到錯誤訊息，因為最終所有東西都將以 <code>NullInjector()</code> 結束並返回錯誤，或者對於 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>，返回 <code>null</code>。關於 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 的更多資訊，請參閱本指南的 <a href=\"guide/hierarchical-dependency-injection#optional\"><code>@Optional()</code> 部分</a>。</p><p translation-origin=\"off\">The next parent injector in the hierarchy is the <code>NullInjector()</code>, which is the top of the tree.\nIf you've gone so far up the tree that you are looking for a service in the <code>NullInjector()</code>, you'll get an error unless you've used <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> because ultimately, everything ends at the <code>NullInjector()</code> and it returns an error or, in the case of <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>, <code>null</code>.\nFor more information on <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>, see the <a href=\"guide/hierarchical-dependency-injection#optional\"><code>@Optional()</code> section</a> of this guide.</p>\n\n<p translation-result=\"on\">下圖展示了前面各段落描述的 <code>root</code> <code>ModuleInjector</code> 及其父注入器之間的關係。</p><p translation-origin=\"off\">The following diagram represents the relationship between the <code>root</code> <code>ModuleInjector</code> and its parent injectors as the previous paragraphs describe.</p>\n\n<div class=\"lightbox\">\n<img alt=\"NullInjector, ModuleInjector, root injector\" src=\"generated/images/guide/dependency-injection/injectors.svg\" width=\"600\" height=\"445\">\n</div>\n<p translation-result=\"on\">雖然 <code>root</code> 是一個特殊的別名，但其它 <code>ModuleInjector</code> 都沒有別名。每當建立動態載入元件時，你還會建立 <code>ModuleInjector</code>，比如路由器，它還會建立子 <code>ModuleInjector</code>。</p><p translation-origin=\"off\">While the name <code>root</code> is a special alias, other <code>ModuleInjector</code> hierarchies don't have aliases.\nYou have the option to create <code>ModuleInjector</code> hierarchies whenever a dynamically loaded component is created, such as with the Router, which will create child <code>ModuleInjector</code> hierarchies.</p>\n\n<p translation-result=\"on\">無論是使用 <code>bootstrapModule()</code> 的方法配置它，還是將所有提供者都用 <code>root</code> 註冊到其自己的服務中，所有請求最終都會轉發到 <code>root</code> 注入器。</p><p translation-origin=\"off\">All requests forward up to the root injector, whether you configured it with the <code>bootstrapModule()</code> method, or registered all providers with <code>root</code> in their own services.</p>\n\n<div class=\"callout is-helpful\">\n<header ng-should-translate=\"\">@Injectable() vs. @NgModule()</header>\n<p translation-result=\"on\">如果你在 <code>AppModule</code> 的 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 中配置應用級提供者，它就會覆蓋一個在 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 的 <code>root</code> 元資料中配置的提供者。你可以用這種方式，來配置供多個應用共享的服務的非預設提供者。</p><p translation-origin=\"off\">If you configure an app-wide provider in the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> of <code>AppModule</code>, it overrides one configured for <code>root</code> in the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> metadata.\nYou can do this to configure a non-default provider of a service that is shared with multiple applications.</p>\n\n<p translation-result=\"on\">下面的例子中，透過把 <a href=\"guide/router#location-strategy\">location 策略</a> 的提供者新增到 <code>AppModule</code> 的 <code>providers</code> 列表中，為路由器配置了非預設的 <a href=\"guide/router#location-strategy\">location 策略</a>。</p><p translation-origin=\"off\">Here is an example of the case where the component router configuration includes a non-default <a href=\"guide/router#location-strategy\">location strategy</a> by listing its provider in the <code>providers</code> list of the <code>AppModule</code>.</p>\n\n<code-example header=\"src/app/app.module.ts (providers)\" path=\"dependency-injection-in-action/src/app/app.module.ts\" region=\"providers\">\nproviders: [\n  { provide: <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a>, useClass: <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a> }\n]\n\n</code-example>\n</div>\n<h3 id=\"elementinjector\"><code>ElementInjector</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#elementinjector\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">Angular 會為每個 DOM 元素隱含建立 <code>ElementInjector</code>。</p><p translation-origin=\"off\">Angular creates <code>ElementInjector</code> hierarchies implicitly for each DOM element.</p>\n\n<p translation-result=\"on\">可以用 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 裝飾器中的 <code>providers</code> 或 <code>viewProviders</code> 屬性來配置 <code>ElementInjector</code> 以提供服務。比如，下面的 <code>TestComponent</code> 透過提供此服務來配置 <code>ElementInjector</code>：</p><p translation-origin=\"off\">Providing a service in the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator using its <code>providers</code> or <code>viewProviders</code> property configures an <code>ElementInjector</code>.\nFor example, the following <code>TestComponent</code> configures the <code>ElementInjector</code> by providing the service as follows:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  …\n  providers: [{ provide: ItemService, useValue: { name: 'lamp' } }]\n})\nexport class TestComponent\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n參閱<a href=\"guide/hierarchical-dependency-injection#resolution-rules\">解析規則</a>部分以瞭解 <code>ModuleInjector</code> 樹和 <code>ElementInjector</code> 樹之間的關係。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nSee the <a href=\"guide/hierarchical-dependency-injection#resolution-rules\">resolution rules</a> section to understand the relationship between the <code>ModuleInjector</code> tree and the <code>ElementInjector</code> tree.</p>\n\n</div>\n<p translation-result=\"on\">在元件中提供服務時，可以透過 <code>ElementInjector</code> 在該元件例項處使用該服務。根據<a href=\"guide/hierarchical-dependency-injection#resolution-rules\">解析規則</a>部分描述的可見性規則，它也同樣在子元件/指令處可見。</p><p translation-origin=\"off\">When you provide services in a component, that service is available by way of the <code>ElementInjector</code> at that component instance.\nIt may also be visible at child component/directives based on visibility rules described in the <a href=\"guide/hierarchical-dependency-injection#resolution-rules\">resolution rules</a> section.</p>\n\n<p translation-result=\"on\">當元件例項被銷燬時，該服務例項也將被銷燬。</p><p translation-origin=\"off\">When the component instance is destroyed, so is that service instance.</p>\n\n<h4 id=\"directive-and-component\" translation-result=\"on\"><code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 和 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#directive-和-component\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\"><code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> and <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#directive-and-component\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">元件是一種特殊型別的指令，這意味著 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 具有 <code>providers</code> 屬性，<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 也同樣如此。這意味著指令和元件都可以使用 <code>providers</code> 屬性來配置提供者。當使用 <code>providers</code> 屬性為元件或指令配置提供者時，該提供程商就屬於該元件或指令的 <code>ElementInjector</code>。同一元素上的元件和指令共享同一個注入器。</p><p translation-origin=\"off\">A component is a special type of directive, which means that just as <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> has a <code>providers</code> property, <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> does too.\nThis means that directives as well as components can configure providers, using the <code>providers</code> property.\nWhen you configure a provider for a component or directive using the <code>providers</code> property, that provider belongs to the <code>ElementInjector</code> of that component or directive.\nComponents and directives on the same element share an injector.</p>\n\n<p><a id=\"resolution-rules\"></a></p>\n<h2 id=\"resolution-rules\" translation-result=\"on\">解析規則<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#resolution-rules\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Resolution rules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#resolution-rules\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">當為元件/指令解析令牌時，Angular 分為兩個階段來解析它：</p><p translation-origin=\"off\">When resolving a token for a component/directive, Angular resolves it in two phases:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">針對 <code>ElementInjector</code> 層次結構中它的父級。</p><p translation-origin=\"off\">Against its parents in the <code>ElementInjector</code> hierarchy.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">針對 <code>ModuleInjector</code> 層次結構中它的父級。</p><p translation-origin=\"off\">Against its parents in the <code>ModuleInjector</code> hierarchy.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">當元件宣告依賴項時，Angular 會嘗試使用它自己的 <code>ElementInjector</code> 來滿足該依賴。如果元件的注入器缺少提供者，它將把請求傳給其父元件的 <code>ElementInjector</code>。</p><p translation-origin=\"off\">When a component declares a dependency, Angular tries to satisfy that dependency with its own <code>ElementInjector</code>.\nIf the component's injector lacks the provider, it passes the request up to its parent component's <code>ElementInjector</code>.</p>\n\n<p translation-result=\"on\">這些請求將繼續轉發，直到 Angular 找到可以處理該請求的注入器或用完祖先 <code>ElementInjector</code>。</p><p translation-origin=\"off\">The requests keep forwarding up until Angular finds an injector that can handle the request or runs out of ancestor <code>ElementInjector</code> hierarchies.</p>\n\n<p translation-result=\"on\">如果 Angular 在任何 <code>ElementInjector</code> 中都找不到提供者，它將返回到發起請求的元素，並在 <code>ModuleInjector</code> 層次結構中進行查詢。如果 Angular 仍然找不到提供者，它將引發錯誤。</p><p translation-origin=\"off\">If Angular doesn't find the provider in any <code>ElementInjector</code> hierarchies, it goes back to the element where the request originated and looks in the <code>ModuleInjector</code> hierarchy.\nIf Angular still doesn't find the provider, it throws an error.</p>\n\n<p translation-result=\"on\">如果你已在不同級別註冊了相同 DI 令牌的提供者，則 Angular 會用遇到的第一個來解析該依賴。比如，如果提供者已經在需要此服務的元件中本地註冊了，則 Angular 不會再尋找同一服務的其它提供者。</p><p translation-origin=\"off\">If you have registered a provider for the same DI token at different levels, the first one Angular encounters is the one it uses to resolve the dependency.\nIf, for example, a provider is registered locally in the component that needs a service,\nAngular doesn't look for another provider of the same service.</p>\n\n<h2 id=\"resolution-modifiers\" translation-result=\"on\">解析修飾符<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#resolution-modifiers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Resolution modifiers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#resolution-modifiers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">可以使用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>，<code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code>，<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 和 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 來修飾 Angular 的解析行為。從 <code>@angular/core</code> 匯入它們，並在注入服務時在元件類建構函式中使用它們。</p><p translation-origin=\"off\">Angular's resolution behavior can be modified with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>, <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code>, <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> and <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>.\nImport each of them from <code>@angular/core</code> and use each in the component class constructor when you inject your service.</p>\n\n<p translation-result=\"on\">關於展示本節介紹的解析修飾符的可執行應用，請參閱<live-example name=\"resolution-modifiers\">解析修飾符範例</live-example>。</p><p translation-origin=\"off\">For a working application showcasing the resolution modifiers that this section covers, see the <live-example name=\"resolution-modifiers\">resolution modifiers example</live-example>.</p>\n\n<h3 id=\"types-of-modifiers\" translation-result=\"on\">修飾符的型別<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#types-of-modifiers\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Types of modifiers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#types-of-modifiers\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">解析修飾符分為三類：</p><p translation-origin=\"off\">Resolution modifiers fall into three categories:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">如果 Angular 找不到你要的東西該怎麼辦，用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code></p><p translation-origin=\"off\">What to do if Angular doesn't find what you're looking for, that is <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">從哪裡開始尋找，用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code></p><p translation-origin=\"off\">Where to start looking, that is <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">到哪裡停止尋找，用 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 和 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code></p><p translation-origin=\"off\">Where to stop looking, <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> and <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code></p>\n\n</li>\n</ul>\n<p translation-result=\"on\">預設情況下，Angular 始終從當前的 <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> 開始，並一直向上搜尋。修飾符使你可以更改開始（預設是自己）或結束位置。</p><p translation-origin=\"off\">By default, Angular always starts at the current <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> and keeps searching all the way up.\nModifiers allow you to change the starting, or <em>self</em>, location and the ending location.</p>\n\n<p translation-result=\"on\">另外，你可以組合除 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 和 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 之外的所有修飾符，當然還有 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 和 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code>。</p><p translation-origin=\"off\">Additionally, you can combine all of the modifiers except <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> and <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> and of course <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> and <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code>.</p>\n\n<p><a id=\"optional\"></a></p>\n<h3 id=\"optional\"><code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#optional\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 允許 Angular 將你注入的服務視為可選服務。這樣，如果無法在執行時解析它，Angular 只會將服務解析為 <code>null</code>，而不會丟擲錯誤。在下面的範例中，服務 <code>OptionalService</code> 沒有在 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 或元件類中提供，所以它沒有在應用中的任何地方。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> allows Angular to consider a service you inject to be optional.\nThis way, if it can't be resolved at runtime, Angular resolves the service as <code>null</code>, rather than throwing an error.\nIn the following example, the service, <code>OptionalService</code>, isn't provided in the service, <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code>, or component class, so it isn't available anywhere in the app.</p>\n\n<code-example header=\"src/app/optional/optional.component.ts\" path=\"resolution-modifiers/src/app/optional/optional.component.ts\" region=\"optional-component\">\nexport class OptionalComponent {\n  constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public optional?: OptionalService) {}\n}\n\n</code-example>\n<h3 id=\"self\"><code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#self\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 讓 Angular 僅檢視當前元件或指令的 <code>ElementInjector</code>。</p><p translation-origin=\"off\">Use <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> so that Angular will only look at the <code>ElementInjector</code> for the current component or directive.</p>\n\n<p translation-result=\"on\"><code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 的一個好例子是要注入某個服務，但只有當該服務在當前宿主元素上可用時才行。為了避免這種情況下出錯，請將 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 與 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 結合使用。</p><p translation-origin=\"off\">A good use case for <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> is to inject a service but only if it is available on the current host element.\nTo avoid errors in this situation, combine <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>.</p>\n\n<p translation-result=\"on\">比如，在下面的 <code>SelfComponent</code> 中。請注意在建構函式中注入的 <code>LeafService</code>。</p><p translation-origin=\"off\">For example, in the following <code>SelfComponent</code>, notice the injected <code>LeafService</code> in the constructor.</p>\n\n<code-example header=\"src/app/self-no-data/self-no-data.component.ts\" path=\"resolution-modifiers/src/app/self-no-data/self-no-data.component.ts\" region=\"self-no-data-component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-self-no-data',\n  templateUrl: './self-no-data.component.html',\n  styleUrls: ['./self-no-data.component.css']\n})\nexport class SelfNoDataComponent {\n  constructor(@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public leaf?: LeafService) { }\n}\n\n\n</code-example>\n<p translation-result=\"on\">在這個例子中，有一個父提供者，注入服務將返回該值，但是，使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 和 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 注入的服務將返回 <code>null</code> 因為 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 告訴注入器在當前宿主元素上就要停止搜尋。</p><p translation-origin=\"off\">In this example, there is a parent provider and injecting the service will return the value, however, injecting the service with <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> and <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> will return <code>null</code> because <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> tells the injector to stop searching in the current host element.</p>\n\n<p translation-result=\"on\">另一個範例顯示了具有 <code>FlowerService</code> 提供者的元件類別。在這個例子中，注入器沒有超出當前 <code>ElementInjector</code> 就停止了，因為它已經找到了 <code>FlowerService</code> 並返回了鬱金香<code>🌷</code>。</p><p translation-origin=\"off\">Another example shows the component class with a provider for <code>FlowerService</code>.\nIn this case, the injector looks no further than the current <code>ElementInjector</code> because it finds the <code>FlowerService</code> and returns the tulip <code>🌷</code>.</p>\n\n<code-example header=\"src/app/self/self.component.ts\" path=\"resolution-modifiers/src/app/self/self.component.ts\" region=\"self-component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-self',\n  templateUrl: './self.component.html',\n  styleUrls: ['./self.component.css'],\n  providers: [{ provide: FlowerService, useValue: { emoji: '🌷' } }]\n\n})\nexport class SelfComponent {\n  constructor(@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>() public flower: FlowerService) {}\n}\n\n</code-example>\n<h3 id=\"skipself\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#skipself\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 與 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 相反。使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>，Angular 在父 <code>ElementInjector</code> 中而不是當前 <code>ElementInjector</code> 中開始搜尋服務。因此，如果父 <code>ElementInjector</code> 對 <code>emoji</code> 使用了值 <code>🌿</code>（蕨類），但元件的 <code>providers</code> 陣列中有 <code>🍁</code>（楓葉），則 Angular 將忽略 <code>🍁</code>（楓葉），而使用 <code>🌿</code>（蕨類）。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> is the opposite of <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code>.\nWith <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>, Angular starts its search for a service in the parent <code>ElementInjector</code>, rather than in the current one.\nSo if the parent <code>ElementInjector</code> were using the fern <code>🌿</code> value for <code>emoji</code>, but you had maple leaf <code>🍁</code> in the component's <code>providers</code> array, Angular would ignore maple leaf <code>🍁</code> and use fern <code>🌿</code>.</p>\n\n<p translation-result=\"on\">要在程式碼中看到這一點，請先假定 <code>emoji</code> 的以下值就是父元件正在使用的值，如本服務所示：</p><p translation-origin=\"off\">To see this in code, assume that the following value for <code>emoji</code> is what the parent component were using, as in this service:</p>\n\n<code-example header=\"src/app/leaf.service.ts\" path=\"resolution-modifiers/src/app/leaf.service.ts\" region=\"leafservice\">\nexport class LeafService {\n  emoji = '🌿';\n}\n\n</code-example>\n<p translation-result=\"on\">想象一下，在子元件中，你有一個不同的值 <code>🍁</code>（楓葉），但你想使用父項的值。你就要使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>：</p><p translation-origin=\"off\">Imagine that in the child component, you had a different value, maple leaf <code>🍁</code> but you wanted to use the parent's value instead.\nThis is when you'd use <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>:</p>\n\n<code-example header=\"src/app/skipself/skipself.component.ts\" path=\"resolution-modifiers/src/app/skipself/skipself.component.ts\" region=\"skipself-component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-skipself',\n  templateUrl: './skipself.component.html',\n  styleUrls: ['./skipself.component.css'],\n  // Angular would ignore this LeafService instance\n  providers: [{ provide: LeafService, useValue: { emoji: '🍁' } }]\n})\nexport class SkipselfComponent {\n  // Use @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() in the constructor\n  constructor(@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() public leaf: LeafService) { }\n}\n\n</code-example>\n<p translation-result=\"on\">在這個例子中，你獲得的 <code>emoji</code> 值將為 <code>🌿</code>（蕨類），而不是 <code>🍁</code>（楓葉）。</p><p translation-origin=\"off\">In this case, the value you'd get for <code>emoji</code> would be fern <code>🌿</code>, not maple leaf <code>🍁</code>.</p>\n\n<h4 id=\"skipself-with-optional\" translation-result=\"on\">合用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 和 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#合用-skipself-和-optional\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#skipself-with-optional\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">如果值為 <code>null</code> 請同時使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 和 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 來防止錯誤。在下面的範例中，將 <code>Person</code> 服務注入到建構函式中。<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 告訴 Angular 跳過當前的注入器，如果 <code>Person</code> 服務為 <code>null</code>，則 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 將防止報錯。</p><p translation-origin=\"off\">Use <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> to prevent an error if the value is <code>null</code>.\nIn the following example, the <code>Person</code> service is injected in the constructor.\n<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> tells Angular to skip the current injector and <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> will prevent an error should the <code>Person</code> service be <code>null</code>.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass Person {\n  constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parent?: Person) {}\n}\n\n</code-example>\n<h3 id=\"host\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#host\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 使你可以在搜尋提供者時將當前元件指定為注入器樹的最後一站。即使樹的更上級有一個服務例項，Angular 也不會繼續尋找。使用 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 的例子如下：</p><p translation-origin=\"off\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> lets you designate a component as the last stop in the injector tree when searching for providers.\nEven if there is a service instance further up the tree, Angular won't continue looking\nUse <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> as follows:</p>\n\n<code-example header=\"src/app/host/host.component.ts\" path=\"resolution-modifiers/src/app/host/host.component.ts\" region=\"host-component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-host',\n  templateUrl: './host.component.html',\n  styleUrls: ['./host.component.css'],\n  //  provide the service\n  providers: [{ provide: FlowerService, useValue: { emoji: '🌷' } }]\n})\nexport class HostComponent {\n  // use @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() in the constructor when injecting the service\n  constructor(@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public flower?: FlowerService) { }\n\n}\n\n</code-example>\n<p translation-result=\"on\">由於 <code>HostComponent</code> 在其建構函式中具有 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>，因此，無論 <code>HostComponent</code> 的父級是否可能有 <code>flower.emoji</code> 值，該 <code>HostComponent</code> 都將使用 <code>🌷</code>（鬱金香）。</p><p translation-origin=\"off\">Since <code>HostComponent</code> has <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> in its constructor, no matter what the parent of <code>HostComponent</code> might have as a <code>flower.emoji</code> value, the <code>HostComponent</code> will use tulip <code>🌷</code>.</p>\n\n<h2 id=\"logical-structure-of-the-template\" translation-result=\"on\">範本的邏輯結構<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#logical-structure-of-the-template\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Logical structure of the template<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#logical-structure-of-the-template\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在元件類中提供服務時，服務在 <code>ElementInjector</code> 樹中的可見性是取決於你在何處以及如何提供這些服務。</p><p translation-origin=\"off\">When you provide services in the component class, services are visible within the <code>ElementInjector</code> tree relative to where and how you provide those services.</p>\n\n<p translation-result=\"on\">瞭解 Angular 範本的基礎邏輯結構將為你配置服務並進而控制其可見性奠定基礎。</p><p translation-origin=\"off\">Understanding the underlying logical structure of the Angular template will give you a foundation for configuring services and in turn control their visibility.</p>\n\n<p translation-result=\"on\">元件在範本中使用，如以下範例所示：</p><p translation-origin=\"off\">Components are used in your templates, as in the following example:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;app-root&gt;\n  &lt;app-child&gt;&lt;/app-child&gt;\n&lt;/app-root&gt;\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n通常，你要在單獨的檔案中宣告元件及其範本。為了理解注入系統的工作原理，從組合邏輯樹的視角來看它們是很有幫助的。使用術語<em>“邏輯”</em>將其與渲染樹（你的應用程式 DOM 樹）區分開。為了標記元件範本的位置，本指南使用 <code>&lt;#VIEW&gt;</code> 偽元素，該元素實際上不存在於渲染樹中，僅用於心智模型中。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nUsually, you declare the components and their templates in separate files.\nFor the purposes of understanding how the injection system works, it is useful to look at them from the point of view of a combined logical tree.\nThe term <em>logical</em> distinguishes it from the render tree, which is your application's DOM tree.\nTo mark the locations of where the component templates are located, this guide uses the <code>&lt;#VIEW&gt;</code> pseudo-element, which doesn't actually exist in the render tree and is present for mental model purposes only.</p>\n\n</div>\n<p translation-result=\"on\">下面是如何將 <code>&lt;app-root&gt;</code> 和 <code>&lt;app-child&gt;</code> 檢視樹組合為單個邏輯樹的範例：</p><p translation-origin=\"off\">The following is an example of how the <code>&lt;app-root&gt;</code> and <code>&lt;app-child&gt;</code> view trees are combined into a single logical tree:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;app-root&gt;\n  &lt;#VIEW&gt;\n    &lt;app-child&gt;\n     &lt;#VIEW&gt;\n       …content goes here…\n     &lt;/#VIEW&gt;\n    &lt;/app-child&gt;\n  &lt;/#VIEW&gt;\n&lt;/app-root&gt;\n\n</code-example>\n<p translation-result=\"on\">當你在元件類中配置服務時，瞭解這種 <code>&lt;#VIEW&gt;</code> 劃界的思想尤其重要。</p><p translation-origin=\"off\">Understanding the idea of the <code>&lt;#VIEW&gt;</code> demarcation is especially significant when you configure services in the component class.</p>\n\n<h2 id=\"providing-services-in-component\" translation-result=\"on\">在 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 中提供服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#在-component-中提供服務\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Providing services in <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#providing-services-in-component\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你如何透過 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code>（或 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code>）裝飾器提供服務決定了它們的可見性。以下各節示範了 <code>providers</code> 和 <code>viewProviders</code> 以及使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 和 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 修改服務可見性的方法。</p><p translation-origin=\"off\">How you provide services using a <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> (or <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code>) decorator determines their visibility.\nThe following sections demonstrate <code>providers</code> and <code>viewProviders</code> along with ways to modify service visibility with <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> and <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>.</p>\n\n<p translation-result=\"on\">元件類可以透過兩種方式提供服務：</p><p translation-origin=\"off\">A component class can provide services in two ways:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">陣列</nt-wrapper><nt-wrapper translation-origin=\"off\">Arrays</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">使用 <code>providers</code> 陣列</nt-wrapper><nt-wrapper translation-origin=\"off\">With a <code>providers</code> array</nt-wrapper></td>\n<td align=\"left\"><code-example format=\"typescript\" language=\"typescript\"> @<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ \n&nbsp; … \n&nbsp; providers: [ \n&nbsp;&nbsp;&nbsp; {provide: FlowerService, useValue: {emoji: '🌺'}} \n&nbsp; ] \n}) </code-example></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">使用 <code>viewProviders</code> 陣列</nt-wrapper><nt-wrapper translation-origin=\"off\">With a <code>viewProviders</code> array</nt-wrapper></td>\n<td align=\"left\"><code-example format=\"typescript\" language=\"typescript\"> @<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ \n&nbsp; … \n&nbsp;viewProviders: [ \n&nbsp;&nbsp;&nbsp; {provide: AnimalService, useValue: {emoji: '🐶'}} \n&nbsp; ] \n}) </code-example></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">為了解 <code>providers</code> 和 <code>viewProviders</code> 對服務可見性的影響有何差異，以下各節將逐步建構一個 <live-example name=\"providers-viewproviders\"></live-example> 並在程式碼和邏輯樹中比較 <code>providers</code> 和 <code>viewProviders</code> 的作用。</p><p translation-origin=\"off\">To understand how the <code>providers</code> and <code>viewProviders</code> influence service visibility differently, the following sections build a <live-example name=\"providers-viewproviders\"></live-example> step-by-step and compare the use of <code>providers</code> and <code>viewProviders</code> in code and a logical tree.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n在邏輯樹中，你會看到 <code>@Provide</code>，<code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 和 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>，這些不是真正的 HTML 屬性，只是為了在這裡證明其幕後的原理。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nIn the logical tree, you'll see <code>@Provide</code>, <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code>, and <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>, which are not real HTML attributes but are here to demonstrate what is going on under the hood.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">Angular 服務屬性</nt-wrapper><nt-wrapper translation-origin=\"off\">Angular service attribute</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳細資訊</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(Token)=&gt;Value </code-example></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">示範如果 <code>Token</code> 在邏輯樹中的此位置注入，其值將是 <code>Value</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Demonstrates that if <code>Token</code> is injected at this location in the logical tree its value would be <code>Value</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> @Provide(Token=Value) </code-example></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">示範在邏輯樹中的此位置有一個值為 <code>Value</code> 的 <code>Token</code> provider 宣告。</nt-wrapper><nt-wrapper translation-origin=\"off\">Demonstrates that there is a declaration of <code>Token</code> provider with value <code>Value</code> at this location in the logical tree.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code-example format=\"typescript\" hidecopy=\"\" language=\"typescript\"> @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(Token) </code-example></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">示範應該在此位置使用後備 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 注入器。</nt-wrapper><nt-wrapper translation-origin=\"off\">Demonstrates that a fallback <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> injector should be used at this location.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n</div>\n<h3 id=\"example-app-structure\" translation-result=\"on\">應用程式結構範例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#example-app-structure\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Example app structure<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#example-app-structure\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">範例應用程式的 <code>root</code> 提供了 <code>FlowerService</code>，其 <code>emoji</code> 值為 <code>🌺</code>（紅色芙蓉）。</p><p translation-origin=\"off\">The example application has a <code>FlowerService</code> provided in <code>root</code> with an <code>emoji</code> value of red hibiscus <code>🌺</code>.</p>\n\n<code-example header=\"src/app/flower.service.ts\" path=\"providers-viewproviders/src/app/flower.service.ts\" region=\"flowerservice\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class FlowerService {\n  emoji = '🌺';\n}\n\n</code-example>\n<p translation-result=\"on\">考慮一個只有 <code>AppComponent</code> 和 <code>ChildComponent</code> 的簡單應用程式。最基本的渲染檢視看起來就像巢狀(Nesting)的 HTML 元素，比如：</p><p translation-origin=\"off\">Consider an application with only an <code>AppComponent</code> and a <code>ChildComponent</code>.\nThe most basic rendered view would look like nested HTML elements such as the following:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;app-root&gt; &lt;!-- AppComponent selector --&gt;\n    &lt;app-child&gt; &lt;!-- ChildComponent selector --&gt;\n    &lt;/app-child&gt;\n&lt;/app-root&gt;\n\n</code-example>\n<p translation-result=\"on\">但是，在幕後，Angular 在解析注入請求時使用如下邏輯視圖表示形式：</p><p translation-origin=\"off\">However, behind the scenes, Angular uses a logical view representation as follows when resolving injection requests:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;app-root&gt; &lt;!-- AppComponent selector --&gt;\n    &lt;#VIEW&gt;\n        &lt;app-child&gt; &lt;!-- ChildComponent selector --&gt;\n            &lt;#VIEW&gt;\n            &lt;/#VIEW&gt;\n        &lt;/app-child&gt;\n    &lt;/#VIEW&gt;\n&lt;/app-root&gt;\n\n</code-example>\n<p translation-result=\"on\">此處的 <code>&lt;#VIEW&gt;</code> 表示範本的例項。請注意，每個元件都有自己的 <code>&lt;#VIEW&gt;</code>。</p><p translation-origin=\"off\">The <code>&lt;#VIEW&gt;</code> here represents an instance of a template.\nNotice that each component has its own <code>&lt;#VIEW&gt;</code>.</p>\n\n<p translation-result=\"on\">瞭解此結構可以告知你如何提供和注入服務，並完全控制服務的可見性。</p><p translation-origin=\"off\">Knowledge of this structure can inform how you provide and inject your services, and give you complete control of service visibility.</p>\n\n<p translation-result=\"on\">現在，考慮 <code>&lt;app-root&gt;</code> 只注入了 <code>FlowerService</code>：</p><p translation-origin=\"off\">Now, consider that <code>&lt;app-root&gt;</code> injects the <code>FlowerService</code>:</p>\n\n<code-example header=\"src/app/app.component.ts\" path=\"providers-viewproviders/src/app/app.component.1.ts\" region=\"injection\">\nexport class AppComponent  {\n  constructor(public flower: FlowerService) {}\n}\n\n</code-example>\n<p translation-result=\"on\">將繫結新增到 <code>&lt;app-root&gt;</code> 範本來將結果視覺化：</p><p translation-origin=\"off\">Add a binding to the <code>&lt;app-root&gt;</code> template to visualize the result:</p>\n\n<code-example header=\"src/app/app.component.html\" path=\"providers-viewproviders/src/app/app.component.html\" region=\"binding-flower\">\n&lt;p&gt;Emoji from FlowerService: {{flower.emoji}}&lt;/p&gt;\n\n</code-example>\n<p translation-result=\"on\">該檢視中的輸出為：</p><p translation-origin=\"off\">The output in the view would be:</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nEmoji from FlowerService: 🌺\n\n</code-example>\n<p translation-result=\"on\">在邏輯樹中，可以把它表示成這樣：</p><p translation-origin=\"off\">In the logical tree, this would be represented as follows:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n        @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService) flower=&gt;\"🌺\"&gt;\n  &lt;#VIEW&gt;\n    &lt;p&gt;Emoji from FlowerService: {{flower.emoji}} (🌺)&lt;/p&gt;\n    &lt;app-child&gt;\n      &lt;#VIEW&gt;\n      &lt;/#VIEW&gt;\n    &lt;/app-child&gt;\n  &lt;/#VIEW&gt;\n&lt;/app-root&gt;\n\n</code-example>\n<p translation-result=\"on\">當 <code>&lt;app-root&gt;</code> 請求 <code>FlowerService</code> 時，注入器的工作就是解析 <code>FlowerService</code> 令牌。令牌的解析分為兩個階段：</p><p translation-origin=\"off\">When <code>&lt;app-root&gt;</code> requests the <code>FlowerService</code>, it is the injector's job to resolve the <code>FlowerService</code> token.\nThe resolution of the token happens in two phases:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">注入器確定邏輯樹中搜索的開始位置和結束位置。注入程式從起始位置開始，並在邏輯樹的每個級別上查詢令牌。如果找到令牌，則將其返回。</p><p translation-origin=\"off\">The injector determines the starting location in the logical tree and an ending location of the search.\nThe injector begins with the starting location and looks for the token at each level in the logical tree.\nIf the token is found it is returned.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果未找到令牌，則注入程式將尋找最接近的父 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 委派該請求。</p><p translation-origin=\"off\">If the token is not found, the injector looks for the closest parent <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> to delegate the request to.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">在這個例子中，約束為：</p><p translation-origin=\"off\">In the example case, the constraints are:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">從屬於 <code>&lt;app-root&gt;</code> 的 <code>&lt;#VIEW&gt;</code> 開始，並結束於 <code>&lt;app-root&gt;</code>。</p><p translation-origin=\"off\">Start with <code>&lt;#VIEW&gt;</code> belonging to <code>&lt;app-root&gt;</code> and end with <code>&lt;app-root&gt;</code>.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">通常，搜尋的起點就是注入點。但是，在這個例子中，<code>&lt;app-root&gt;</code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 的特殊之處在於它們還包括自己的 <code>viewProviders</code>，這就是為什麼搜尋從 <code>&lt;app-root&gt;</code> 的 <code>&lt;#VIEW&gt;</code> 開始的原因。對於匹配同一位置的指令，情況卻並非如此。</p><p translation-origin=\"off\">Normally the starting point for search is at the point of injection.\nHowever, in this case <code>&lt;app-root&gt;</code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>s are special in that they also include their own <code>viewProviders</code>, which is why the search starts at <code>&lt;#VIEW&gt;</code> belonging to <code>&lt;app-root&gt;</code>.\nThis would not be the case for a directive matched at the same location.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">結束位置恰好與元件本身相同，因為它就是此應用程式中最最上層的元件。</p><p translation-origin=\"off\">The ending location happens to be the same as the component itself, because it is the topmost component in this application.</p>\n\n</li>\n</ul>\n</li>\n<li>\n<p translation-result=\"on\">當在 <code>ElementInjector</code> 中找不到注入令牌時，就用 <code>AppModule</code> 充當後備注入器。</p><p translation-origin=\"off\">The <code>AppModule</code> acts as the fallback injector when the injection token can't be found in the <code>ElementInjector</code> hierarchies.</p>\n\n</li>\n</ol>\n<h3 id=\"using-the-providers-array\" translation-result=\"on\">使用 <code>providers</code> 陣列<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#using-the-providers-array\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Using the <code>providers</code> array<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#using-the-providers-array\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">現在，在 <code>ChildComponent</code> 類中，為 <code>FlowerService</code> 新增一個提供者，以便在接下來的小節中示範更復雜的解析規則：</p><p translation-origin=\"off\">Now, in the <code>ChildComponent</code> class, add a provider for <code>FlowerService</code> to demonstrate more complex resolution rules in the upcoming sections:</p>\n\n<code-example header=\"src/app/child.component.ts\" path=\"providers-viewproviders/src/app/child/child.component.1.ts\" region=\"flowerservice\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child',\n  templateUrl: './child.component.html',\n  styleUrls: ['./child.component.css'],\n  // use the providers array to provide a service\n  providers: [{ provide: FlowerService, useValue: { emoji: '🌻' } }]\n})\n\nexport class ChildComponent {\n  // inject the service\n  constructor( public flower: FlowerService) { }\n}\n\n\n</code-example>\n<p translation-result=\"on\">現在，在 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 裝飾器中提供了 <code>FlowerService</code>，當 <code>&lt;app-child&gt;</code> 請求該服務時，注入器僅需要查詢 <code>&lt;app-child&gt;</code> 中的 <code>ElementInjector</code>。不必再透過注入器樹繼續搜尋。</p><p translation-origin=\"off\">Now that the <code>FlowerService</code> is provided in the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator, when the <code>&lt;app-child&gt;</code> requests the service, the injector has only to look as far as the <code>ElementInjector</code> in the <code>&lt;app-child&gt;</code>.\nIt won't have to continue the search any further through the injector tree.</p>\n\n<p translation-result=\"on\">下一步是將繫結新增到 <code>ChildComponent</code> 範本。</p><p translation-origin=\"off\">The next step is to add a binding to the <code>ChildComponent</code> template.</p>\n\n<code-example header=\"src/app/child.component.html\" path=\"providers-viewproviders/src/app/child/child.component.html\" region=\"flower-binding\">\n&lt;p&gt;Emoji from FlowerService: {{flower.emoji}}&lt;/p&gt;\n\n</code-example>\n<p translation-result=\"on\">要渲染新的值，請在 <code>AppComponent</code> 範本的底部新增 <code>&lt;app-child&gt;</code>，以便其檢視也顯示向日葵：</p><p translation-origin=\"off\">To render the new values, add <code>&lt;app-child&gt;</code> to the bottom of the <code>AppComponent</code> template so the view also displays the sunflower:</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nChild Component\nEmoji from FlowerService: 🌻\n\n</code-example>\n<p translation-result=\"on\">在邏輯樹中，可以把它表示成這樣：</p><p translation-origin=\"off\">In the logical tree, this is represented as follows:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n        @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService) flower=&gt;\"🌺\"&gt;\n  &lt;#VIEW&gt;\n    &lt;p&gt;Emoji from FlowerService: {{flower.emoji}} (🌺)&lt;/p&gt;\n    &lt;app-child @Provide(FlowerService=\"🌻\")\n               @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService)=&gt;\"🌻\"&gt; &lt;!-- search ends here --&gt;\n      &lt;#VIEW&gt; &lt;!-- search starts here --&gt;\n        &lt;h2&gt;Parent <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&lt;/h2&gt;\n        &lt;p&gt;Emoji from FlowerService: {{flower.emoji}} (🌻)&lt;/p&gt;\n      &lt;/#VIEW&gt;\n    &lt;/app-child&gt;\n  &lt;/#VIEW&gt;\n&lt;/app-root&gt;\n\n</code-example>\n<p translation-result=\"on\">當 <code>&lt;app-child&gt;</code> 請求 <code>FlowerService</code> 時，注入器從 <code>&lt;app-child&gt;</code> 的 <code>&lt;#VIEW&gt;</code> 開始搜尋（包括 <code>&lt;#VIEW&gt;</code>，因為它是從 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 注入的），併到 <code>&lt;app-child&gt;</code> 結束。在這個例子中，<code>FlowerService</code> 在 <code>&lt;app-child&gt;</code> 的 <code>providers</code> 陣列中解析為向日葵🌻。注入器不必在注入器樹中進一步查詢。一旦找到 <code>FlowerService</code>，它便停止執行，再也看不到🌺（紅芙蓉）。</p><p translation-origin=\"off\">When <code>&lt;app-child&gt;</code> requests the <code>FlowerService</code>, the injector begins its search at the <code>&lt;#VIEW&gt;</code> belonging to <code>&lt;app-child&gt;</code> (<code>&lt;#VIEW&gt;</code> is included because it is injected from <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code>) and ends with <code>&lt;app-child&gt;</code>.\nIn this case, the <code>FlowerService</code> is resolved in the <code>providers</code> array with sunflower <code>🌻</code> of the <code>&lt;app-child&gt;</code>.\nThe injector doesn't have to look any further in the injector tree.\nIt stops as soon as it finds the <code>FlowerService</code> and never sees the red hibiscus <code>🌺</code>.</p>\n\n<p><a id=\"use-view-providers\"></a></p>\n<h3 id=\"using-the-viewproviders-array\" translation-result=\"on\">使用 <code>viewProviders</code> 陣列<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#using-the-viewproviders-array\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Using the <code>viewProviders</code> array<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#using-the-viewproviders-array\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">使用 <code>viewProviders</code> 陣列是在 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 裝飾器中提供服務的另一種方法。使用 <code>viewProviders</code> 使服務在 <code>&lt;#VIEW&gt;</code> 中可見。</p><p translation-origin=\"off\">Use the <code>viewProviders</code> array as another way to provide services in the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator.\nUsing <code>viewProviders</code> makes services visible in the <code>&lt;#VIEW&gt;</code>.</p>\n\n<div class=\"is-helpful alert\">\n<p translation-result=\"on\">除了使用 <code>viewProviders</code> 陣列外，其它步驟與使用 <code>providers</code> 陣列相同。</p><p translation-origin=\"off\">The steps are the same as using the <code>providers</code> array, with the exception of using the <code>viewProviders</code> array instead.</p>\n\n<p translation-result=\"on\">關於這些步驟的說明，請繼續本節。如果你可以自行設定，請跳至<a href=\"guide/hierarchical-dependency-injection#modify-visibility\">修改服務可用性</a> 一節。</p><p translation-origin=\"off\">For step-by-step instructions, continue with this section.\nIf you can set it up on your own, skip ahead to <a href=\"guide/hierarchical-dependency-injection#modify-visibility\">Modifying service availability</a>.</p>\n\n</div>\n<p translation-result=\"on\">該範例應用程式具有第二個服務 <code>AnimalService</code> 來示範 <code>viewProviders</code>。</p><p translation-origin=\"off\">The example application features a second service, the <code>AnimalService</code> to demonstrate <code>viewProviders</code>.</p>\n\n<p translation-result=\"on\">首先，建立一個 <code>AnimalService</code> 與 <code>emoji</code> 的🐳（鯨魚）屬性：</p><p translation-origin=\"off\">First, create an <code>AnimalService</code> with an <code>emoji</code> property of whale <code>🐳</code>:</p>\n\n<code-example header=\"src/app/animal.service.ts\" path=\"providers-viewproviders/src/app/animal.service.ts\" region=\"animal-service\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class AnimalService {\n  emoji = '🐳';\n}\n\n</code-example>\n<p translation-result=\"on\">遵循與 <code>FlowerService</code> 相同的模式，將 <code>AnimalService</code> 注入 <code>AppComponent</code> 類：</p><p translation-origin=\"off\">Following the same pattern as with the <code>FlowerService</code>, inject the <code>AnimalService</code> in the <code>AppComponent</code> class:</p>\n\n<code-example header=\"src/app/app.component.ts\" path=\"providers-viewproviders/src/app/app.component.ts\" region=\"inject-animal-service\">\nexport class AppComponent  {\n  constructor(public flower: FlowerService, public animal: AnimalService) {}\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n你可以保留所有與 <code>FlowerService</code> 相關的程式碼，因為它可以與 <code>AnimalService</code> 進行比較。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nYou can leave all the <code>FlowerService</code> related code in place as it will allow a comparison with the <code>AnimalService</code>.</p>\n\n</div>\n<p translation-result=\"on\">新增一個 <code>viewProviders</code> 陣列，並將 <code>AnimalService</code> 也注入到 <code>&lt;app-child&gt;</code> 類中，但是給 <code>emoji</code> 一個不同的值。在這裡，它的值為🐶（小狗）。</p><p translation-origin=\"off\">Add a <code>viewProviders</code> array and inject the <code>AnimalService</code> in the <code>&lt;app-child&gt;</code> class, too, but give <code>emoji</code> a different value.\nHere, it has a value of dog <code>🐶</code>.</p>\n\n<code-example header=\"src/app/child.component.ts\" path=\"providers-viewproviders/src/app/child/child.component.ts\" region=\"provide-animal-service\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child',\n  templateUrl: './child.component.html',\n  styleUrls: ['./child.component.css'],\n  // provide services\n  providers: [{ provide: FlowerService, useValue: { emoji: '🌻' } }],\n  viewProviders: [{ provide: AnimalService, useValue: { emoji: '🐶' } }]\n})\n\nexport class ChildComponent {\n  // inject service\n  constructor( public flower: FlowerService, public animal: AnimalService) { }\n}\n\n</code-example>\n<p translation-result=\"on\">將繫結新增到 <code>ChildComponent</code> 和 <code>AppComponent</code> 範本。在 <code>ChildComponent</code> 範本中，新增以下繫結：</p><p translation-origin=\"off\">Add bindings to the <code>ChildComponent</code> and the <code>AppComponent</code> templates.\nIn the <code>ChildComponent</code> template, add the following binding:</p>\n\n<code-example header=\"src/app/child.component.html\" path=\"providers-viewproviders/src/app/child/child.component.html\" region=\"animal-binding\">\n&lt;p&gt;Emoji from AnimalService: {{animal.emoji}}&lt;/p&gt;\n\n</code-example>\n<p translation-result=\"on\">此外，將其新增到 <code>AppComponent</code> 範本：</p><p translation-origin=\"off\">Additionally, add the same to the <code>AppComponent</code> template:</p>\n\n<code-example header=\"src/app/app.component.html\" path=\"providers-viewproviders/src/app/app.component.html\" region=\"binding-animal\">\n&lt;p&gt;Emoji from AnimalService: {{animal.emoji}}&lt;/p&gt;\n\n</code-example>\n<p translation-result=\"on\">現在，你應該在瀏覽器中看到兩個值：</p><p translation-origin=\"off\">Now you should see both values in the browser:</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nAppComponent\nEmoji from AnimalService: 🐳\n\nChild Component\nEmoji from AnimalService: 🐶\n\n</code-example>\n<p translation-result=\"on\">此 <code>viewProviders</code> 範例的邏輯樹如下：</p><p translation-origin=\"off\">The logic tree for this example of <code>viewProviders</code> is as follows:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n         @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService) animal=&gt;\"🐳\"&gt;\n  &lt;#VIEW&gt;\n    &lt;app-child&gt;\n      &lt;#VIEW @Provide(AnimalService=\"🐶\")\n            @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService=&gt;\"🐶\")&gt;\n       &lt;!-- ^^using viewProviders means AnimalService is available in &lt;#VIEW&gt;--&gt;\n       &lt;p&gt;Emoji from AnimalService: {{animal.emoji}} (🐶)&lt;/p&gt;\n      &lt;/#VIEW&gt;\n    &lt;/app-child&gt;\n  &lt;/#VIEW&gt;\n&lt;/app-root&gt;\n\n</code-example>\n<p translation-result=\"on\">與 <code>FlowerService</code> 範例一樣，<code>&lt;app-child&gt;</code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 裝飾器中提供了 <code>AnimalService</code>。這意味著，由於注入器首先在元件的 <code>ElementInjector</code> 中查詢，因此它將找到 <code>AnimalService</code> 的值 🐶（小狗）。它不需要繼續搜尋 <code>ElementInjector</code> 樹，也不需要搜尋 <code>ModuleInjector</code>。</p><p translation-origin=\"off\">Just as with the <code>FlowerService</code> example, the <code>AnimalService</code> is provided in the <code>&lt;app-child&gt;</code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator.\nThis means that since the injector first looks in the <code>ElementInjector</code> of the component, it finds the <code>AnimalService</code> value of dog <code>🐶</code>.\nIt doesn't need to continue searching the <code>ElementInjector</code> tree, nor does it need to search the <code>ModuleInjector</code>.</p>\n\n<h3 id=\"providers-vs-viewproviders\" translation-result=\"on\"><code>providers</code> 與 <code>viewProviders</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#providers-vs-viewproviders\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\"><code>providers</code> vs. <code>viewProviders</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#providers-vs-viewproviders\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">為了看清 <code>providers</code> 和 <code>viewProviders</code> 的差異，請在範例中新增另一個元件，並將其命名為 <code>InspectorComponent</code>。<code>InspectorComponent</code> 將是 <code>ChildComponent</code> 的子 <code>ChildComponent</code>。在 <code>inspector.component.ts</code> 中，將 <code>FlowerService</code> 和 <code>AnimalService</code> 注入建構函式中：</p><p translation-origin=\"off\">To see the difference between using <code>providers</code> and <code>viewProviders</code>, add another component to the example and call it <code>InspectorComponent</code>.\n<code>InspectorComponent</code> will be a child of the <code>ChildComponent</code>.\nIn <code>inspector.component.ts</code>, inject the <code>FlowerService</code> and <code>AnimalService</code> in the constructor:</p>\n\n<code-example header=\"src/app/inspector/inspector.component.ts\" path=\"providers-viewproviders/src/app/inspector/inspector.component.ts\" region=\"injection\">\nexport class InspectorComponent {\n  constructor(public flower: FlowerService, public animal: AnimalService) { }\n}\n\n</code-example>\n<p translation-result=\"on\">你不需要 <code>providers</code> 或 <code>viewProviders</code> 陣列。接下來，在 <code>inspector.component.html</code> 中，從以前的元件中新增相同的 html：</p><p translation-origin=\"off\">You do not need a <code>providers</code> or <code>viewProviders</code> array.\nNext, in <code>inspector.component.html</code>, add the same markup from previous components:</p>\n\n<code-example header=\"src/app/inspector/inspector.component.html\" path=\"providers-viewproviders/src/app/inspector/inspector.component.html\" region=\"binding\">\n&lt;p&gt;Emoji from FlowerService: {{flower.emoji}}&lt;/p&gt;\n&lt;p&gt;Emoji from AnimalService: {{animal.emoji}}&lt;/p&gt;\n\n</code-example>\n<p translation-result=\"on\">別忘了將 <code>InspectorComponent</code> 新增到 <code>AppModule</code> <code>declarations</code> 陣列。</p><p translation-origin=\"off\">Remember to add the <code>InspectorComponent</code> to the <code>AppModule</code> <code>declarations</code> array.</p>\n\n<code-example header=\"src/app/app.module.ts\" path=\"providers-viewproviders/src/app/app.module.ts\" region=\"appmodule\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>, <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> ],\n  declarations: [ AppComponent, ChildComponent, InspectorComponent ],\n  bootstrap:    [ AppComponent ],\n  providers: []\n})\nexport class AppModule { }\n\n</code-example>\n<p translation-result=\"on\">接下來，確保你的 <code>child.component.html</code> 包含以下內容：</p><p translation-origin=\"off\">Next, make sure your <code>child.component.html</code> contains the following:</p>\n\n<code-example header=\"src/app/child/child.component.html\" path=\"providers-viewproviders/src/app/child/child.component.html\" region=\"child-component\">\n&lt;p&gt;Emoji from FlowerService: {{flower.emoji}}&lt;/p&gt;\n&lt;p&gt;Emoji from AnimalService: {{animal.emoji}}&lt;/p&gt;\n\n&lt;div class=\"container\"&gt;\n  &lt;h3&gt;Content projection&lt;/h3&gt;\n\t&lt;ng-content&gt;&lt;/ng-content&gt;\n&lt;/div&gt;\n\n&lt;h3&gt;Inside the view&lt;/h3&gt;\n&lt;app-inspector&gt;&lt;/app-inspector&gt;\n\n</code-example>\n<p translation-result=\"on\">前兩行帶有繫結，來自之前的步驟。新的部分是 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 和 <code>&lt;app-inspector&gt;</code>。<code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 允許你投影內容，<code>ChildComponent</code> 範本中的 <code>&lt;app-inspector&gt;</code> 使 <code>InspectorComponent</code> 成為 <code>ChildComponent</code> 的子元件。</p><p translation-origin=\"off\">The first two lines, with the bindings, are there from previous steps.\nThe new parts are  <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> and <code>&lt;app-inspector&gt;</code>.\n<code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> allows you to project content, and <code>&lt;app-inspector&gt;</code> inside the <code>ChildComponent</code> template makes the <code>InspectorComponent</code> a child component of <code>ChildComponent</code>.</p>\n\n<p translation-result=\"on\">接下來，將以下內容新增到 <code>app.component.html</code> 中以利用內容投影的優勢。</p><p translation-origin=\"off\">Next, add the following to <code>app.component.html</code> to take advantage of content projection.</p>\n\n<code-example header=\"src/app/app.component.html\" path=\"providers-viewproviders/src/app/app.component.html\" region=\"content-projection\">\n&lt;app-child&gt;&lt;app-inspector&gt;&lt;/app-inspector&gt;&lt;/app-child&gt;\n\n</code-example>\n<p translation-result=\"on\">現在，瀏覽器將渲染以下內容，為簡潔起見，省略了前面的範例：</p><p translation-origin=\"off\">The browser now renders the following, omitting the previous examples for brevity:</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\n//…Omitting previous examples. The following applies to this section.\n\nContent projection: this is coming from content. Doesn't get to see\npuppy because the puppy is declared inside the view only.\n\nEmoji from FlowerService: 🌻\nEmoji from AnimalService: 🐳\n\nEmoji from FlowerService: 🌻\nEmoji from AnimalService: 🐶\n\n</code-example>\n<p translation-result=\"on\">這四個繫結說明了 <code>providers</code> 和 <code>viewProviders</code> 之間的區別。由於🐶（小狗）在 <code>&lt;#VIEW&gt;</code> 中宣告，因此投影內容不可見。投影的內容中會看到🐳（鯨魚）。</p><p translation-origin=\"off\">These four bindings demonstrate the difference between <code>providers</code> and <code>viewProviders</code>.\nSince the dog <code>🐶</code> is declared inside the <code>&lt;#VIEW&gt;</code>, it isn't visible to the projected content.\nInstead, the projected content sees the whale <code>🐳</code>.</p>\n\n<p translation-result=\"on\">但是下一部分，<code>InspectorComponent</code> 是 <code>ChildComponent</code> 的子元件，<code>InspectorComponent</code> 在 <code>&lt;#VIEW&gt;</code> 內部，因此當它請求 <code>AnimalService</code> 時，它會看到🐶（小狗）。</p><p translation-origin=\"off\">The next section though, where <code>InspectorComponent</code> is a child component of <code>ChildComponent</code>, <code>InspectorComponent</code> is inside the <code>&lt;#VIEW&gt;</code>, so when it asks for the <code>AnimalService</code>, it sees the dog <code>🐶</code>.</p>\n\n<p translation-result=\"on\">邏輯樹中的 <code>AnimalService</code> 如下所示：</p><p translation-origin=\"off\">The <code>AnimalService</code> in the logical tree would look like this:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n         @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService) animal=&gt;\"🐳\"&gt;\n  &lt;#VIEW&gt;\n    &lt;app-child&gt;\n      &lt;#VIEW @Provide(AnimalService=\"🐶\")\n            @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService=&gt;\"🐶\")&gt;\n        &lt;!-- ^^using viewProviders means AnimalService is available in &lt;#VIEW&gt;--&gt;\n        &lt;p&gt;Emoji from AnimalService: {{animal.emoji}} (🐶)&lt;/p&gt;\n  \n        &lt;div class=\"container\"&gt;\n          &lt;h3&gt;Content projection&lt;/h3&gt;\n          &lt;app-inspector @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService) animal=&gt;\"🐳\"&gt;\n            &lt;p&gt;Emoji from AnimalService: {{animal.emoji}} (🐳)&lt;/p&gt;\n          &lt;/app-inspector&gt;\n        &lt;/div&gt;\n  \n      &lt;/#VIEW&gt;\n      &lt;app-inspector&gt;\n        &lt;#VIEW&gt;\n          &lt;p&gt;Emoji from AnimalService: {{animal.emoji}} (🐶)&lt;/p&gt;\n        &lt;/#VIEW&gt;\n      &lt;/app-inspector&gt;\n    &lt;/app-child&gt;\n  &lt;/#VIEW&gt;\n&lt;/app-root&gt;\n\n</code-example>\n<p translation-result=\"on\"><code>&lt;app-inspector&gt;</code> 的投影內容中看到了🐳（鯨魚），而不是🐶（小狗），因為🐶（小狗）在 <code>&lt;app-child&gt;</code> 的 <code>&lt;#VIEW&gt;</code> 中。如果 <code>&lt;app-inspector&gt;</code> 也位於 <code>&lt;#VIEW&gt;</code> 則只能看到🐶（小狗）。</p><p translation-origin=\"off\">The projected content of <code>&lt;app-inspector&gt;</code> sees the whale <code>🐳</code>, not the dog <code>🐶</code>, because the dog <code>🐶</code> is inside the <code>&lt;app-child&gt;</code> <code>&lt;#VIEW&gt;</code>.\nThe <code>&lt;app-inspector&gt;</code> can only see the dog <code>🐶</code> if it is also within the <code>&lt;#VIEW&gt;</code>.</p>\n\n<p><a id=\"modify-visibility\"></a></p>\n<h2 id=\"modifying-service-visibility\" translation-result=\"on\">修改服務可見性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#modifying-service-visibility\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Modifying service visibility<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#modifying-service-visibility\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本節講的是如何使用可見性修飾符 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>，<code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 和 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 來限制 <code>ElementInjector</code> 的開始和結束範圍。</p><p translation-origin=\"off\">This section describes how to limit the scope of the beginning and ending <code>ElementInjector</code> using the visibility decorators <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>, <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code>, and <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>.</p>\n\n<h3 id=\"visibility-of-provided-tokens\" translation-result=\"on\">提供者令牌的可見性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#visibility-of-provided-tokens\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Visibility of provided tokens<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#visibility-of-provided-tokens\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">可見性裝飾器影響搜尋注入令牌時在邏輯樹中開始和結束的位置。為此，要將可見性裝飾器放置在注入點，即 <code>constructor()</code>，而不是在宣告點。</p><p translation-origin=\"off\">Visibility decorators influence where the search for the injection token begins and ends in the logic tree.\nTo do this, place visibility decorators at the point of injection, that is, the <code>constructor()</code>, rather than at a point of declaration.</p>\n\n<p translation-result=\"on\">為了修改該注入器從哪裡開始尋找 <code>FlowerService</code>，把 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 加到 <code>&lt;app-child&gt;</code> 的 <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 宣告 <code>FlowerService</code> 中。該宣告在 <code>&lt;app-child&gt;</code> 建構函式中，如 <code>child.component.ts</code> 所示：</p><p translation-origin=\"off\">To alter where the injector starts looking for <code>FlowerService</code>, add <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> to the <code>&lt;app-child&gt;</code> <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> declaration for the <code>FlowerService</code>.\nThis declaration is in the <code>&lt;app-child&gt;</code> constructor as shown in <code>child.component.ts</code>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nconstructor(@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() public flower : FlowerService) { }\n\n</code-example>\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>，<code>&lt;app-child&gt;</code> 注入器不會尋找自身來獲取 <code>FlowerService</code>。相反，注入器開始在 <code>&lt;app-root&gt;</code> 的 <code>ElementInjector</code> 中尋找 <code>FlowerService</code>，在那裡它什麼也沒找到。\n然後，它返回到 <code>&lt;app-child&gt;</code> 的 <code>ModuleInjector</code> 並找到🌺（紅芙蓉）值，這是可用的，因為 <code>&lt;app-child&gt;</code> <code>ModuleInjector</code> 和 <code>&lt;app-root&gt;</code> <code>ModuleInjector</code> 被展開成了一個 <code>ModuleInjector</code>。因此，UI 將渲染以下內容：</p><p translation-origin=\"off\">With <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>, the <code>&lt;app-child&gt;</code> injector doesn't look to itself for the <code>FlowerService</code>.\nInstead, the injector starts looking for the <code>FlowerService</code> at the <code>ElementInjector</code> or the <code>&lt;app-root&gt;</code>, where it finds nothing.\nThen, it goes back to the <code>&lt;app-child&gt;</code> <code>ModuleInjector</code> and finds the red hibiscus <code>🌺</code> value, which is available because the <code>&lt;app-child&gt;</code> <code>ModuleInjector</code> and the <code>&lt;app-root&gt;</code> <code>ModuleInjector</code> are flattened into one <code>ModuleInjector</code>.\nThus, the UI renders the following:</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nEmoji from FlowerService: 🌺\n\n</code-example>\n<p translation-result=\"on\">在邏輯樹中，這種情況可能如下所示：</p><p translation-origin=\"off\">In a logical tree, this same idea might look like this:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n        @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService) flower=&gt;\"🌺\"&gt;\n  &lt;#VIEW&gt;\n    &lt;app-child @Provide(FlowerService=\"🌻\")&gt;\n      &lt;#VIEW @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>)=&gt;\"🌺\"&gt;\n        &lt;!-- With <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>, the injector looks to the next injector up the tree --&gt;\n      &lt;/#VIEW&gt;\n    &lt;/app-child&gt;\n  &lt;/#VIEW&gt;\n&lt;/app-root&gt;\n\n</code-example>\n<p translation-result=\"on\">儘管 <code>&lt;app-child&gt;</code> 提供了🌻（向日葵），但該應用程式渲染了🌺（紅色芙蓉），因為 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 導致當前的注入器跳過了自身並尋找其父級。</p><p translation-origin=\"off\">Though <code>&lt;app-child&gt;</code> provides the sunflower <code>🌻</code>, the application renders the red hibiscus <code>🌺</code> because <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>  causes the current injector to skip itself and look to its parent.</p>\n\n<p translation-result=\"on\">如果現在將 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>（以及 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>）新增到了 <code>FlowerService</code> 的 <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code>，其結果將為 <code>null</code>。這是因為 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 將搜尋的上限限制為 <code>&lt;#VIEW&gt;</code>。這是在邏輯樹中的情況：</p><p translation-origin=\"off\">If you now add <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> (in addition to the <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>) to the <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> of the <code>FlowerService</code>, the result will be <code>null</code>.\nThis is because <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> limits the upper bound of the search to the <code>&lt;#VIEW&gt;</code>.\nHere's the idea in the logical tree:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n        @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService) flower=&gt;\"🌺\"&gt;\n  &lt;#VIEW&gt; &lt;!-- end search here with null--&gt;\n    &lt;app-child @Provide(FlowerService=\"🌻\")&gt; &lt;!-- start search here --&gt;\n      &lt;#VIEW @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService, @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>, @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>, @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>)=&gt;null&gt;\n      &lt;/#VIEW&gt;\n      &lt;/app-parent&gt;\n  &lt;/#VIEW&gt;\n&lt;/app-root&gt;\n\n</code-example>\n<p translation-result=\"on\">在這裡，服務及其值是相同的，但是 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 阻止了注入器對 <code>FlowerService</code> 進行任何高於 <code>&lt;#VIEW&gt;</code> 的查詢，因此找不到它並返回 <code>null</code>。</p><p translation-origin=\"off\">Here, the services and their values are the same, but <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> stops the injector from looking any further than the <code>&lt;#VIEW&gt;</code> for <code>FlowerService</code>, so it doesn't find it and returns <code>null</code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n範例應用程式使用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 因此該應用程式不會引發錯誤，但是其原理是一樣的。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThe example application uses <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> so the application does not throw an error, but the principles are the same.</p>\n\n</div>\n<h3 id=\"skipself-and-viewproviders\" translation-result=\"on\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 和 <code>viewProviders</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#skipself-和-viewproviders\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> and <code>viewProviders</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#skipself-and-viewproviders\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">該 <code>&lt;app-child&gt;</code> 目前提供在 <code>viewProviders</code> 陣列中提供了值為 🐶（小狗）的 <code>AnimalService</code>。由於注入器只需要檢視 <code>&lt;app-child&gt;</code> 的 <code>ElementInjector</code> 中的 <code>AnimalService</code>，它就不會看到🐳（鯨魚）。</p><p translation-origin=\"off\">The <code>&lt;app-child&gt;</code> currently provides the <code>AnimalService</code> in the <code>viewProviders</code> array with the value of dog <code>🐶</code>.\nBecause the injector has only to look at the <code>ElementInjector</code> of the <code>&lt;app-child&gt;</code> for the <code>AnimalService</code>, it never sees the whale <code>🐳</code>.</p>\n\n<p translation-result=\"on\">在 <code>FlowerService</code> 這個例子中，如果將 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 新增到 <code>AnimalService</code> 的建構函式中，則注入器將不在 <code>AnimalService</code> 的當前 <code>&lt;app-child&gt;</code> 的 <code>ElementInjector</code> 中查詢 <code>AnimalService</code>。</p><p translation-origin=\"off\">As in the <code>FlowerService</code> example, if you add <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> to the constructor for the <code>AnimalService</code>, the injector won't look in the  <code>ElementInjector</code> of the current <code>&lt;app-child&gt;</code> for the <code>AnimalService</code>.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport class ChildComponent {\n\n  // add @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()\n  constructor(@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() public animal : AnimalService) { }\n\n}\n\n</code-example>\n<p translation-result=\"on\">相反，注入器將從 <code>&lt;app-root&gt;</code> <code>ElementInjector</code> 開始找。請記住，<code>&lt;app-child&gt;</code> 類在 <code>viewProviders</code> 陣列中 <code>AnimalService</code> 中提供了🐶（小狗）的值：</p><p translation-origin=\"off\">Instead, the injector will begin at the <code>&lt;app-root&gt;</code> <code>ElementInjector</code>.\nRemember that the <code>&lt;app-child&gt;</code> class provides the <code>AnimalService</code> in the <code>viewProviders</code> array with a value of dog <code>🐶</code>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child',\n  …\n  viewProviders:\n  [{ provide: AnimalService, useValue: { emoji: '🐶' } }]\n})\n\n</code-example>\n<p translation-result=\"on\">在 <code>&lt;app-child&gt;</code> 中使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 的邏輯樹是這樣的：</p><p translation-origin=\"off\">The logical tree looks like this with <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> in <code>&lt;app-child&gt;</code>:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n          @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService=&gt;\"🐳\")&gt;\n  &lt;#VIEW&gt;&lt;!-- search begins here --&gt;\n    &lt;app-child&gt;\n      &lt;#VIEW @Provide(AnimalService=\"🐶\")\n             @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>=&gt;\"🐳\")&gt;\n        &lt;!--Add @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> --&gt;\n      &lt;/#VIEW&gt;\n    &lt;/app-child&gt;\n  &lt;/#VIEW&gt;\n&lt;/app-root&gt;\n\n</code-example>\n<p translation-result=\"on\">在 <code>&lt;app-child&gt;</code> 中使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>，注入器就會在 <code>&lt;app-root&gt;</code> 的 <code>ElementInjector</code> 中找到 🐳（鯨）。</p><p translation-origin=\"off\">With <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> in the <code>&lt;app-child&gt;</code>, the injector begins its search for the <code>AnimalService</code> in the <code>&lt;app-root&gt;</code> <code>ElementInjector</code> and finds whale <code>🐳</code>.</p>\n\n<h3 id=\"host-and-viewproviders\" translation-result=\"on\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 和 <code>viewProviders</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#host-和-viewproviders\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> and <code>viewProviders</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#host-and-viewproviders\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果把 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 新增到 <code>AnimalService</code> 的建構函式上，結果就是🐶（小狗），因為注入器會在 <code>&lt;app-child&gt;</code> 的 <code>&lt;#VIEW&gt;</code> 中查詢 <code>AnimalService</code> 服務。這裡是 <code>&lt;app-child&gt;</code> 類中的 <code>viewProviders</code> 陣列和建構函式中的 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>：</p><p translation-origin=\"off\">If you add <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> to the constructor for <code>AnimalService</code>, the result is dog <code>🐶</code> because the injector finds the <code>AnimalService</code> in the <code>&lt;app-child&gt;</code> <code>&lt;#VIEW&gt;</code>.\nHere is the <code>viewProviders</code> array in the <code>&lt;app-child&gt;</code> class and <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> in the constructor:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child',\n  …\n  viewProviders:\n  [{ provide: AnimalService, useValue: { emoji: '🐶' } }]\n\n})\nexport class ChildComponent {\n  constructor(@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() public animal : AnimalService) { }\n}\n\n</code-example>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 導致注入器開始查詢，直到遇到 <code>&lt;#VIEW&gt;</code> 的邊緣。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> causes the injector to look until it encounters the edge of the <code>&lt;#VIEW&gt;</code>.</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n          @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService=&gt;\"🐳\")&gt;\n  &lt;#VIEW&gt;\n    &lt;app-child&gt;\n      &lt;#VIEW @Provide(AnimalService=\"🐶\")\n             @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService, @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>=&gt;\"🐶\")&gt; &lt;!-- @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a> stops search here --&gt;\n      &lt;/#VIEW&gt;\n    &lt;/app-child&gt;\n  &lt;/#VIEW&gt;\n&lt;/app-root&gt;\n\n</code-example>\n<p translation-result=\"on\">將帶有第三個動物🦔（刺蝟）的 <code>viewProviders</code> 陣列新增到 <code>app.component.ts</code> 的 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 元資料中：</p><p translation-origin=\"off\">Add a <code>viewProviders</code> array with a third animal, hedgehog <code>🦔</code>, to the <code>app.component.ts</code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> metadata:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: [ './app.component.css' ],\n  viewProviders: [{ provide: AnimalService, useValue: { emoji: '🦔' } }]\n})\n\n</code-example>\n<p translation-result=\"on\">接下來，同時把 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 和 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 加在 <code>child.component.ts</code> 中 <code>AnimalService</code> 的建構函式中。這是 <code>&lt;app-child&gt;</code> 建構函式中的 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 和 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>：</p><p translation-origin=\"off\">Next, add <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> along with <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> to the constructor for the <code>Animal Service</code> in <code>child.component.ts</code>.\nHere are <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> and <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> in the <code>&lt;app-child&gt;</code> constructor:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport class ChildComponent {\n\n  constructor(\n  @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() public animal : AnimalService) { }\n\n}\n\n</code-example>\n<p translation-result=\"on\">將 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 和 <code><a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 應用於 <code>providers</code> 陣列中的 <code>FlowerService</code>，結果為 <code>null</code>，因為 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 會在 <code>&lt;app-child&gt;</code> 的注入器中開始搜尋，但是 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 要求它在 <code>&lt;#VIEW&gt;</code> 停止搜尋 —— 沒有 <code>FlowerService</code>。在邏輯樹中，你可以看到 <code>FlowerService</code> 在 <code>&lt;app-child&gt;</code> 中可見，而在 <code>&lt;#VIEW&gt;</code> 中不可見。</p><p translation-origin=\"off\">When <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> and <code><a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> were applied to the <code>FlowerService</code>, which is in the <code>providers</code> array, the result was <code>null</code> because <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> starts its search in the <code>&lt;app-child&gt;</code> injector, but <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> stops searching at <code>&lt;#VIEW&gt;</code> —where there is no <code>FlowerService</code>\nIn the logical tree, you can see that the <code>FlowerService</code> is visible in <code>&lt;app-child&gt;</code>, not its <code>&lt;#VIEW&gt;</code>.</p>\n\n<p translation-result=\"on\">不過，提供在 <code>AppComponent</code> 的 <code>viewProviders</code> 陣列中的 <code>AnimalService</code>，是可見的。</p><p translation-origin=\"off\">However, the <code>AnimalService</code>, which is provided in the <code>AppComponent</code> <code>viewProviders</code> array, is visible.</p>\n\n<p translation-result=\"on\">邏輯樹表示法說明了為何如此：</p><p translation-origin=\"off\">The logical tree representation shows why this is:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n        @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService=&gt;\"🐳\")&gt;\n  &lt;#VIEW @Provide(AnimalService=\"🦔\")\n         @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService, @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>)=&gt;\"🦔\"&gt;\n    &lt;!-- ^^@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() starts here,  @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() stops here^^ --&gt;\n    &lt;app-child&gt;\n      &lt;#VIEW @Provide(AnimalService=\"🐶\")\n             @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService, @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>, @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>, @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>)=&gt;\"🦔\"&gt;\n               &lt;!-- Add @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> ^^--&gt;\n      &lt;/#VIEW&gt;\n      &lt;/app-child&gt;\n  &lt;/#VIEW&gt;\n&lt;/app-root&gt;\n\n</code-example>\n<p translation-result=\"on\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 導致注入器從 <code>&lt;app-root&gt;</code> 而不是 <code>&lt;app-child&gt;</code> 處開始對 <code>AnimalService</code> 進行搜尋，而 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 會在 <code>&lt;app-root&gt;</code> 的 <code>&lt;#VIEW&gt;</code> 處停止搜尋。\n由於 <code>AnimalService</code> 是透過 <code>viewProviders</code> 陣列提供的，因此注入程式會在 <code>&lt;#VIEW&gt;</code> 找到🦔（刺蝟）。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>, causes the injector to start its search for the <code>AnimalService</code> at the <code>&lt;app-root&gt;</code>, not the <code>&lt;app-child&gt;</code>, where the request originates, and <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> stops the search at the <code>&lt;app-root&gt;</code> <code>&lt;#VIEW&gt;</code>.\nSince <code>AnimalService</code> is provided by way of the <code>viewProviders</code> array, the injector finds hedgehog <code>🦔</code> in the <code>&lt;#VIEW&gt;</code>.</p>\n\n<p><a id=\"component-injectors\"></a></p>\n<h2 id=\"elementinjector-use-case-examples\" translation-result=\"on\"><code>ElementInjector</code> 使用案例範例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#elementinjector-use-case-examples\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\"><code>ElementInjector</code> use case examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#elementinjector-use-case-examples\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在不同級別配置一個或多個提供者的能力開闢了很有用的可能性。要檢視正在執行的應用中的以下情況，請參閱<live-example>英雄範例</live-example>。</p><p translation-origin=\"off\">The ability to configure one or more providers at different levels opens up useful possibilities.\nFor a look at the following scenarios in a working app, see the <live-example>heroes use case examples</live-example>.</p>\n\n<h3 id=\"scenario-service-isolation\" translation-result=\"on\">場景：服務隔離<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-service-isolation\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Scenario: service isolation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-service-isolation\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">出於架構方面的考慮，可能會讓你決定把一個服務限制到只能在它所屬的那個應用域中存取。比如，這個例子中包括一個用於顯示反派列表的 <code>VillainsListComponent</code>，它會從 <code>VillainsService</code> 中獲得反派列表資料。</p><p translation-origin=\"off\">Architectural reasons may lead you to restrict access to a service to the application domain where it belongs.\nFor example, the guide sample includes a <code>VillainsListComponent</code> that displays a list of villains.\nIt gets those villains from a <code>VillainsService</code>.</p>\n\n<p translation-result=\"on\">如果你在根模組 <code>AppModule</code> 中（也就是你註冊 <code>HeroesService</code> 的地方）提供 <code>VillainsService</code>，就會讓應用中的任何地方都能存取到 <code>VillainsService</code>，包括針對英雄的工作流。如果你稍後修改了 <code>VillainsService</code>，就可能破壞了英雄元件中的某些地方。在根模組 <code>AppModule</code> 中提供該服務將會引入此風險。</p><p translation-origin=\"off\">If you provided <code>VillainsService</code> in the root <code>AppModule</code> (where you registered the <code>HeroesService</code>), that would make the <code>VillainsService</code> visible everywhere in the application, including the <em>Hero</em> workflows.\nIf you later modified the <code>VillainsService</code>, you could break something in a hero component somewhere.</p>\n\n<p translation-result=\"on\">該怎麼做呢？你可以在 <code>VillainsListComponent</code> 的 <code>providers</code> 元資料中提供 <code>VillainsService</code>，就像這樣：</p><p translation-origin=\"off\">Instead, you can provide the <code>VillainsService</code> in the <code>providers</code> metadata of the <code>VillainsListComponent</code> like this:</p>\n\n<code-example header=\"src/app/villains-list.component.ts (metadata)\" path=\"hierarchical-dependency-injection/src/app/villains-list.component.ts\" region=\"metadata\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-villains-list',\n  templateUrl: './villains-list.component.html',\n  providers: [ VillainsService ]\n})\n\n</code-example>\n<p translation-result=\"on\">在 <code>VillainsListComponent</code> 的元資料中而不是其它地方提供 <code>VillainsService</code> 服務，該服務就會只在 <code>VillainsListComponent</code> 及其子元件樹中可用。</p><p translation-origin=\"off\">By providing <code>VillainsService</code> in the <code>VillainsListComponent</code> metadata and nowhere else, the service becomes available only in the <code>VillainsListComponent</code> and its subcomponent tree.</p>\n\n<p translation-result=\"on\"><code>VillainService</code> 對於 <code>VillainsListComponent</code> 來說是單例的，因為它就是在這裡宣告的。只要 <code>VillainsListComponent</code> 沒有銷燬，它就始終是 <code>VillainService</code> 的同一個例項。但是對於 <code>VillainsListComponent</code> 的多個例項，每個 <code>VillainsListComponent</code> 的例項都會有自己的 <code>VillainService</code> 例項。</p><p translation-origin=\"off\"><code>VillainService</code> is a singleton with respect to <code>VillainsListComponent</code> because that is where it is declared.\nAs long as <code>VillainsListComponent</code> does not get destroyed it will be the same instance of <code>VillainService</code> but if there are multiple instances of <code>VillainsListComponent</code>, then each instance of <code>VillainsListComponent</code> will have its own instance of <code>VillainService</code>.</p>\n\n<h3 id=\"scenario-multiple-edit-sessions\" translation-result=\"on\">場景：多重編輯會話<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-multiple-edit-sessions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Scenario: multiple edit sessions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-multiple-edit-sessions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">很多應用允許使用者同時進行多個任務。比如，在納稅申報應用中，申報人可以開啟多個報稅單，隨時可能從一個切換到另一個。</p><p translation-origin=\"off\">Many applications allow users to work on several open tasks at the same time.\nFor example, in a tax preparation application, the preparer could be working on several tax returns, switching from one to the other throughout the day.</p>\n\n<p translation-result=\"on\">為了示範這種場景，假設有一個顯示超級英雄列表的外部 <code>HeroListComponent</code>。</p><p translation-origin=\"off\">To demonstrate that scenario, imagine an outer <code>HeroListComponent</code> that displays a list of super heroes.</p>\n\n<p translation-result=\"on\">要開啟一個英雄的報稅單，申報者點選英雄名，它就會開啟一個元件來編輯那個申報單。每個選中的申報單都會在自己的元件中開啟，並且可以同時開啟多個申報單。</p><p translation-origin=\"off\">To open a hero's tax return, the preparer clicks on a hero name, which opens a component for editing that return.\nEach selected hero tax return opens in its own component and multiple returns can be open at the same time.</p>\n\n<p translation-result=\"on\">每個報稅單元件都有下列特徵：</p><p translation-origin=\"off\">Each tax return component has the following characteristics:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">屬於它自己的報稅單會話</p><p translation-origin=\"off\">Is its own tax return editing session</p>\n\n</li>\n<li>\n<p translation-result=\"on\">可以修改一個報稅單，而不會影響另一個元件中的申報單</p><p translation-origin=\"off\">Can change a tax return without affecting a return in another component</p>\n\n</li>\n<li>\n<p translation-result=\"on\">能把所做的修改儲存到它的報稅單中，或者放棄它們</p><p translation-origin=\"off\">Has the ability to save the changes to its tax return or cancel them</p>\n\n</li>\n</ul>\n<div class=\"lightbox\">\n<img alt=\"Heroes in action\" src=\"generated/images/guide/dependency-injection/hid-heroes-anim.gif\" width=\"500\" height=\"384\">\n</div>\n<p translation-result=\"on\">假設 <code>HeroTaxReturnComponent</code> 還有一些管理並還原這些更改的邏輯。這對於簡單的報稅單來說是很容易的。不過，在現實世界中，報稅單的資料模型非常複雜，對這些修改的管理可能不得不投機取巧。你可以把這種管理任務委託給一個輔助服務，就像這個例子中所做的。</p><p translation-origin=\"off\">Suppose that the <code>HeroTaxReturnComponent</code> had logic to manage and restore changes.\nThat would be a straightforward task for a hero tax return.\nIn the real world, with a rich tax return data model, the change management would be tricky.\nYou could delegate that management to a helper service, as this example does.</p>\n\n<p translation-result=\"on\">報稅單服務 HeroTaxReturnService 快取了單條 HeroTaxReturn，用於追蹤那個申報單的變更，並且可以儲存或還原它。它把後兩項職責委託給了全應用級的單例服務 HeroService，HeroService 是透過依賴注入機制取得的。</p><p translation-origin=\"off\">The <code>HeroTaxReturnService</code> caches a single <code>HeroTaxReturn</code>, tracks changes to that return, and can save or restore it.\nIt also delegates to the application-wide singleton <code>HeroService</code>, which it gets by injection.</p>\n\n<code-example header=\"src/app/hero-tax-return.service.ts\" path=\"hierarchical-dependency-injection/src/app/hero-tax-return.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HeroTaxReturn } from './hero';\nimport { HeroesService } from './heroes.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroTaxReturnService {\n  private currentTaxReturn!: HeroTaxReturn;\n  private originalTaxReturn!: HeroTaxReturn;\n\n  constructor(private heroService: HeroesService) { }\n\n  set taxReturn(htr: HeroTaxReturn) {\n    this.originalTaxReturn = htr;\n    this.currentTaxReturn  = htr.clone();\n  }\n\n  get taxReturn(): HeroTaxReturn {\n    return this.currentTaxReturn;\n  }\n\n  restoreTaxReturn() {\n    this.taxReturn = this.originalTaxReturn;\n  }\n\n  saveTaxReturn() {\n    this.taxReturn = this.currentTaxReturn;\n    this.heroService.saveTaxReturn(this.currentTaxReturn).subscribe();\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">下面是正在使用 <code>HeroTaxReturnService</code> 的 <code>HeroTaxReturnComponent</code> 元件。</p><p translation-origin=\"off\">Here is the <code>HeroTaxReturnComponent</code> that makes use of <code>HeroTaxReturnService</code>.</p>\n\n<code-example header=\"src/app/hero-tax-return.component.ts\" path=\"hierarchical-dependency-injection/src/app/hero-tax-return.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\nimport { HeroTaxReturn } from './hero';\nimport { HeroTaxReturnService } from './hero-tax-return.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-tax-return',\n  templateUrl: './hero-tax-return.component.html',\n  styleUrls: [ './hero-tax-return.component.css' ],\n  providers: [ HeroTaxReturnService ]\n})\nexport class HeroTaxReturnComponent {\n  message = '';\n\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() close = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;void&gt;();\n\n  get taxReturn(): HeroTaxReturn {\n    return this.heroTaxReturnService.taxReturn;\n  }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  set taxReturn(htr: HeroTaxReturn) {\n    this.heroTaxReturnService.taxReturn = htr;\n  }\n\n  constructor(private heroTaxReturnService: HeroTaxReturnService) { }\n\n  onCanceled()  {\n    this.flashMessage('Canceled');\n    this.heroTaxReturnService.restoreTaxReturn();\n  }\n\n  onClose() { this.close.emit(); }\n\n  onSaved() {\n    this.flashMessage('Saved');\n    this.heroTaxReturnService.saveTaxReturn();\n  }\n\n  flashMessage(msg: string) {\n    this.message = msg;\n    setTimeout(() =&gt; this.message = '', 500);\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">透過 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 屬性可以得到<em>要編輯的報稅單</em>，這個屬性被實現成了讀取器（getter）和設定器（setter）。設定器根據傳進來的報稅單初始化了元件自己的 <code>HeroTaxReturnService</code> 例項。讀取器總是返回該服務所存英雄的當前狀態。元件也會請求該服務來儲存或還原這個報稅單。</p><p translation-origin=\"off\">The <em>tax-return-to-edit</em> arrives by way of the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> property, which is implemented with getters and setters.\nThe setter initializes the component's own instance of the <code>HeroTaxReturnService</code> with the incoming return.\nThe getter always returns what that service says is the current state of the hero.\nThe component also asks the service to save and restore this tax return.</p>\n\n<p translation-result=\"on\">但如果該服務是一個全應用範圍的單例就不行了。每個元件就都會共享同一個服務例項，每個元件也都會覆蓋屬於其它英雄的報稅單。</p><p translation-origin=\"off\">This won't work if the service is an application-wide singleton.\nEvery component would share the same service instance, and each component would overwrite the tax return that belonged to another hero.</p>\n\n<p translation-result=\"on\">要防止這一點，就要在 <code>HeroTaxReturnComponent</code> 元資料的 <code>providers</code> 屬性中配置元件級的注入器，來提供該服務。</p><p translation-origin=\"off\">To prevent this, configure the component-level injector of <code>HeroTaxReturnComponent</code> to provide the service, using the  <code>providers</code> property in the component metadata.</p>\n\n<code-example header=\"src/app/hero-tax-return.component.ts (providers)\" path=\"hierarchical-dependency-injection/src/app/hero-tax-return.component.ts\" region=\"providers\">\nproviders: [ HeroTaxReturnService ]\n\n</code-example>\n<p translation-result=\"on\"><code>HeroTaxReturnComponent</code> 有它自己的 <code>HeroTaxReturnService</code> 提供者。\n回憶一下，每個元件的<em>例項</em>都有它自己的注入器。\n在元件級提供服務可以確保元件的<em>每個</em>例項都得到一個自己的、私有的服務例項。這可以確保報稅單不會被意外覆蓋。</p><p translation-origin=\"off\">The <code>HeroTaxReturnComponent</code> has its own provider of the <code>HeroTaxReturnService</code>.\nRecall that every component <em>instance</em> has its own injector.\nProviding the service at the component level ensures that <em>every</em> instance of the component gets a private instance of the service. This makes sure that no tax return gets overwritten.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">該場景程式碼中的其它部分依賴另一些 Angular 的特性和技術，你將會在本文件的其它章節學到。\n你可以到<live-example></live-example>檢視程式碼和下載它。</p><p translation-origin=\"off\">The rest of the scenario code relies on other Angular features and techniques that you can learn about elsewhere in the documentation.\nYou can review it and download it from the <live-example></live-example>.</p>\n\n</div>\n<h3 id=\"scenario-specialized-providers\" translation-result=\"on\">場景：專門的提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-specialized-providers\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Scenario: specialized providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-specialized-providers\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在其它層級重新提供服務的另一個理由，是在元件樹的深層中把該服務替換為一個<em>更專門化的</em>實現。</p><p translation-origin=\"off\">Another reason to provide a service again at another level is to substitute a <em>more specialized</em> implementation of that service, deeper in the component tree.</p>\n\n<p translation-result=\"on\">例如，考慮一個包含輪胎服務資訊並依賴其它服務來提供有關汽車的更多詳細資訊的 <code>Car</code> 元件。</p><p translation-origin=\"off\">For example, consider a <code>Car</code> component that includes tire service information and depends on other services to provide more details about the car.</p>\n\n<p translation-result=\"on\">標記為 （A） 的根注入器使用<em>通用</em>提供者來獲取有關 <code>CarService</code> 和 <code>EngineService</code> 的詳細資訊。</p><p translation-origin=\"off\">The root injector, marked as (A), uses <em>generic</em> providers for details about <code>CarService</code> and <code>EngineService</code>.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\"><code>Car</code> 元件（A）。元件 （A） 顯示有關汽車的輪胎服務資料，並指定通用服務以提供有關汽車的更多資訊。</p><p translation-origin=\"off\"><code>Car</code> component (A).  Component (A) displays tire service data about a car and specifies generic services to provide more information about the car.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">子元件（B）。元件（B）為 <code>CarService</code> 和 <code>EngineService</code> 定義了自己的<em>特化的</em>提供者，它們具有適合元件 （B） 中發生的事情的特殊能力。</p><p translation-origin=\"off\">Child component (B). Component (B) defines its own, <em>specialized</em> providers for <code>CarService</code> and <code>EngineService</code> that have special capabilities suitable for what's going on in component (B).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">子元件（C）作為元件（B）的子元件。元件 （C） 為 <code>CarService</code> 定義了自己的、<em>更加特化</em>的提供者。</p><p translation-origin=\"off\">Child component (C) as a child of Component (B). Component (C) defines its own, even <em>more specialized</em> provider for <code>CarService</code>.</p>\n\n</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"car components\" src=\"generated/images/guide/dependency-injection/car-components.png\" width=\"338\" height=\"201\">\n</div>\n<p translation-result=\"on\">在幕後，每個元件都有自己的注入器，這個注入器帶有為元件本身準備的 0 個、1 個或多個提供者。</p><p translation-origin=\"off\">Behind the scenes, each component sets up its own injector with zero, one, or more providers defined for that component itself.</p>\n\n<p translation-result=\"on\">當你在最深的元件 （C） 處解析 <code>Car</code> 例項時，其注入器會產生：</p><p translation-origin=\"off\">When you resolve an instance of <code>Car</code> at the deepest component (C), its injector produces: </p>\n\n<ul>\n<li>\n<p translation-result=\"on\">由注入器 （C） 解析的 <code>Car</code> 例項</p><p translation-origin=\"off\">An instance of <code>Car</code> resolved by injector (C)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">由注入器 （B） 解析的 <code>Engine</code></p><p translation-origin=\"off\">An <code>Engine</code> resolved by injector (B)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它的 <code>Tires</code> 由根注入器 （A） 解析。</p><p translation-origin=\"off\">Its <code>Tires</code> resolved by the root injector (A).</p>\n\n</li>\n</ul>\n<div class=\"lightbox\">\n<img alt=\"car injector tree\" src=\"generated/images/guide/dependency-injection/injector-tree.png\" width=\"600\" height=\"248\">\n</div>\n<h2 id=\"more-on-dependency-injection\" translation-result=\"on\">關於依賴注入的更多知識<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#more-on-dependency-injection\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">More on dependency injection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#more-on-dependency-injection\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要了解關於 Angular 依賴注入的更多資訊，參閱 <a href=\"guide/dependency-injection-providers\">DI 提供者</a>和 <a href=\"guide/dependency-injection-in-action\">DI 實戰</a> 兩章。</p><p translation-origin=\"off\">For more information on Angular dependency injection, see the <a href=\"guide/dependency-injection-providers\">DI Providers</a> and <a href=\"guide/dependency-injection-in-action\">DI in Action</a> guides.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - errors/NG0200\n - guide/dependency-injection\n - guide/dependency-injection-navtree\n - guide/dependency-injection-overview\n - guide/example-apps-list\n - guide/glossary\n - guide/ngmodule-faq\n - guide/providers\n - guide/template-expression-operators\n - guide/upgrade\n-->\n<!-- links from this doc:\n - api/common/HashLocationStrategy\n - api/common/LocationStrategy\n - api/core/Component\n - api/core/Directive\n - api/core/EventEmitter\n - api/core/Host\n - api/core/Inject\n - api/core/Injectable\n - api/core/Injector\n - api/core/Input\n - api/core/NgModule\n - api/core/NgModule#imports\n - api/core/NgModule#providers\n - api/core/Optional\n - api/core/Output\n - api/core/Self\n - api/core/SkipSelf\n - api/core/ng-content\n - api/forms/FormsModule\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/BrowserModule\n - api/platform-browser/platformBrowser\n - guide/architecture-services\n - guide/architecture-services#providing-services\n - guide/dependency-injection-in-action\n - guide/dependency-injection-providers\n - guide/hierarchical-dependency-injection#directive-and-component\n - guide/hierarchical-dependency-injection#directive-和-component\n - guide/hierarchical-dependency-injection#elementinjector\n - guide/hierarchical-dependency-injection#elementinjector-use-case-examples\n - guide/hierarchical-dependency-injection#elementinjector-使用案例範例\n - guide/hierarchical-dependency-injection#example-app-structure\n - guide/hierarchical-dependency-injection#hierarchical-injectors\n - guide/hierarchical-dependency-injection#host\n - guide/hierarchical-dependency-injection#host-and-viewproviders\n - guide/hierarchical-dependency-injection#host-和-viewproviders\n - guide/hierarchical-dependency-injection#logical-structure-of-the-template\n - guide/hierarchical-dependency-injection#modify-visibility\n - guide/hierarchical-dependency-injection#modifying-service-visibility\n - guide/hierarchical-dependency-injection#moduleinjector\n - guide/hierarchical-dependency-injection#more-on-dependency-injection\n - guide/hierarchical-dependency-injection#optional\n - guide/hierarchical-dependency-injection#platform-injector\n - guide/hierarchical-dependency-injection#providers-vs-viewproviders\n - guide/hierarchical-dependency-injection#providers-與-viewproviders\n - guide/hierarchical-dependency-injection#providing-services-in-component\n - guide/hierarchical-dependency-injection#resolution-modifiers\n - guide/hierarchical-dependency-injection#resolution-rules\n - guide/hierarchical-dependency-injection#scenario-multiple-edit-sessions\n - guide/hierarchical-dependency-injection#scenario-service-isolation\n - guide/hierarchical-dependency-injection#scenario-specialized-providers\n - guide/hierarchical-dependency-injection#self\n - guide/hierarchical-dependency-injection#skipself\n - guide/hierarchical-dependency-injection#skipself-and-viewproviders\n - guide/hierarchical-dependency-injection#skipself-with-optional\n - guide/hierarchical-dependency-injection#skipself-和-viewproviders\n - guide/hierarchical-dependency-injection#types-of-injector-hierarchies\n - guide/hierarchical-dependency-injection#types-of-modifiers\n - guide/hierarchical-dependency-injection#using-the-providers-array\n - guide/hierarchical-dependency-injection#using-the-viewproviders-array\n - guide/hierarchical-dependency-injection#visibility-of-provided-tokens\n - guide/hierarchical-dependency-injection#使用-providers-陣列\n - guide/hierarchical-dependency-injection#使用-viewproviders-陣列\n - guide/hierarchical-dependency-injection#修改服務可見性\n - guide/hierarchical-dependency-injection#修飾符的型別\n - guide/hierarchical-dependency-injection#關於依賴注入的更多知識\n - guide/hierarchical-dependency-injection#合用-skipself-和-optional\n - guide/hierarchical-dependency-injection#在-component-中提供服務\n - guide/hierarchical-dependency-injection#場景專門的提供者\n - guide/hierarchical-dependency-injection#場景多重編輯會話\n - guide/hierarchical-dependency-injection#場景服務隔離\n - guide/hierarchical-dependency-injection#多級注入器\n - guide/hierarchical-dependency-injection#平台注入器\n - guide/hierarchical-dependency-injection#應用程式結構範例\n - guide/hierarchical-dependency-injection#提供者令牌的可見性\n - guide/hierarchical-dependency-injection#搖樹最佳化與-injectable\n - guide/hierarchical-dependency-injection#範本的邏輯結構\n - guide/hierarchical-dependency-injection#注入器層次結構的型別\n - guide/hierarchical-dependency-injection#解析修飾符\n - guide/hierarchical-dependency-injection#解析規則\n - guide/router#location-strategy\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/hierarchical-dependency-injection.md?message=docs%3A%20請簡述你的修改...\n-->"}