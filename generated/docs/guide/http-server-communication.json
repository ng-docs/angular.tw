{"id":"guide/http-server-communication","title":"HTTP Server communication","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-server-communication.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"http-server-communication\" translation-result=\"on\">HTTP 伺服器通訊<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#http-server-communication\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">HTTP Server communication<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#http-server-communication\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">大多數前端應用程式都要透過 HTTP 協議與伺服器通訊，以下載或上傳資料以及存取其他後端服務。</p><p translation-origin=\"off\">Most front-end applications need to communicate with a server over the HTTP protocol, to download or upload data and access other back-end services.</p>\n\n<h2 id=\"setup-for-server-communication\" translation-result=\"on\">伺服器通訊的準備工作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#setup-for-server-communication\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Setup for server communication<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#setup-for-server-communication\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要想使用 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>，就要先匯入 Angular 的 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>。大多數應用都會在根模組 <code>AppModule</code> 中匯入它。</p><p translation-origin=\"off\">Before you can use <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>, you need to import the Angular <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>.\nMost apps do so in the root <code>AppModule</code>.</p>\n\n<code-example header=\"app/app.module.ts (excerpt)\" path=\"http/src/app/app.module.ts\" region=\"sketch\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    // import <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> after BrowserModule.\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n  declarations: [\n    AppComponent,\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n</code-example>\n<p translation-result=\"on\">然後，你可以把 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務注入成一個應用類別的依賴項，如下面的 <code>ConfigService</code> 例子所示。</p><p translation-origin=\"off\">You can then inject the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service as a dependency of an application class, as shown in the following <code>ConfigService</code> example.</p>\n\n<code-example header=\"app/config/config.service.ts (excerpt)\" path=\"http/src/app/config/config.service.ts\" region=\"proto\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class ConfigService {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n}\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服務為所有工作都使用了<a href=\"guide/glossary#observable\" title=\"可觀察的定義\">可觀察物件</a>。你必須匯入範例程式碼片段中出現的 RxJS 可觀察物件和運運算元。比如 <code>ConfigService</code> 中的這些匯入就很典型。</p><p translation-origin=\"off\">The <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service makes use of <a href=\"guide/glossary#observable\" title=\"Observable definition\">observables</a> for all transactions.\nYou must import the RxJS observable and operator symbols that appear in the example snippets.\nThese <code>ConfigService</code> imports are typical.</p>\n\n<code-example header=\"app/config/config.service.ts (RxJS imports)\" path=\"http/src/app/config/config.service.ts\" region=\"rxjs-imports\">\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, retry } from 'rxjs/operators';\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你可以執行本指南隨附的<live-example></live-example>。</p><p translation-origin=\"off\">You can run the <live-example></live-example> that accompanies this guide.</p>\n\n<p translation-result=\"on\">範例應用不需要資料伺服器。它依賴於 <a href=\"https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\">Angular 的 <em>in-memory-web-api</em></a>，該模組替換了 <em>HttpClient</em> 模組的 <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>。這個替代服務模擬了 REST 後端的行為。</p><p translation-origin=\"off\">The sample app does not require a data server.\nIt relies on the <a href=\"https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\">Angular <em>in-memory-web-api</em></a>, which replaces the <em>HttpClient</em> module's <code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>.\nThe replacement service simulates the behavior of a REST-like backend.</p>\n\n<p translation-result=\"on\">檢視 <code>AppModule</code> 中的 <em>imports</em>，就能瞭解它是如何配置的。</p><p translation-origin=\"off\">Look at the <code>AppModule</code> <em>imports</em> to see how it is configured.</p>\n\n</div>\n<h2 id=\"requesting-data-from-a-server\" translation-result=\"on\">從伺服器請求資料<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-data-from-a-server\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Requesting data from a server<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-data-from-a-server\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用 <a href=\"api/common/http/HttpClient#get\"><code>HttpClient.get()</code></a> 方法從伺服器獲取資料。該非同步方法會發送一個 HTTP 請求，並返回一個 Observable，它會在收到響應時發出所請求到的資料。返回的型別取決於你呼叫時傳入的 <code>observe</code> 和 <code>responseType</code> 引數。</p><p translation-origin=\"off\">Use the <a href=\"api/common/http/HttpClient#get\"><code>HttpClient.get()</code></a> method to fetch data from a server.\nThe asynchronous method sends an HTTP request, and returns an Observable that emits the requested data when the response is received.\nThe return type varies based on the <code>observe</code> and <code>responseType</code> values that you pass to the call.</p>\n\n<p translation-result=\"on\"><code>get()</code> 方法有兩個引數。要獲取的端點 URL，以及一個可以用來配置請求的<em>選項</em>物件。</p><p translation-origin=\"off\">The <code>get()</code> method takes two arguments; the endpoint URL from which to fetch, and an <em>options</em> object that is used to configure the request.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  headers?: <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> | {[header: string]: string | string[]},\n  observe?: 'body' | 'events' | 'response',\n  params?: <a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a>|{[param: string]: string | number | boolean | ReadonlyArray&lt;string | number | boolean&gt;},\n  reportProgress?: boolean,\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  withCredentials?: boolean,\n}\n\n</code-example>\n<p translation-result=\"on\">這些重要的選項包括 <em>observe</em> 和 <em>responseType</em> 屬性。</p><p translation-origin=\"off\">Important options include the <em>observe</em> and <em>responseType</em> properties.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><em>observe</em> 選項用於指定要返回的響應內容。</p><p translation-origin=\"off\">The <em>observe</em> option specifies how much of the response to return</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><em>responseType</em> 選項指定返回資料的格式。</p><p translation-origin=\"off\">The <em>responseType</em> option specifies the format in which to return data</p>\n\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">使用 <code>options</code> 物件來配置外發請求的其他方面。例如，在新增標頭資訊時，此服務會使用 <code>headers</code> 選項的屬性來設定預設頭資訊。</p><p translation-origin=\"off\">Use the <code>options</code> object to configure various other aspects of an outgoing request.\nIn adding headers, for example, the service set the default headers using the <code>headers</code> option property.</p>\n\n<p translation-result=\"on\">使用 <code>params</code> 屬性來配置帶有 HTTP URL 引數的請求，使用 <code>reportProgress</code> 選項來監聽傳輸大量資料時的進度事件。</p><p translation-origin=\"off\">Use the <code>params</code> property to configure a request with HTTP URL parameters, and the <code>reportProgress</code> option to listen for progress events when transferring large amounts of data.</p>\n\n</div>\n<p translation-result=\"on\">應用經常會從伺服器請求 JSON 資料。在 <code>ConfigService</code> 例子中，該應用需要伺服器 <code>config.json</code> 上的一個配置檔案來指定資源的 URL。</p><p translation-origin=\"off\">Applications often request JSON data from a server.\nIn the <code>ConfigService</code> example, the app needs a configuration file on the server, <code>config.json</code>, that specifies resource URLs.</p>\n\n<code-example header=\"assets/config.json\" path=\"http/src/assets/config.json\">\n{\n  \"heroesUrl\": \"api/heroes\",\n  \"textfile\": \"assets/textfile.txt\",\n  \"date\": \"2020-01-29\"\n}\n\n\n</code-example>\n<p translation-result=\"on\">要獲取這類資料，<code>get()</code> 呼叫需要以下幾個選項：<code>{observe: 'body', responseType: 'json'}</code>。這些是這些選項的預設值，所以下面的例子不會傳遞 options 物件。後面幾節展示了一些額外的選項。</p><p translation-origin=\"off\">To fetch this kind of data, the <code>get()</code> call needs the following options: <code>{observe: 'body', responseType: 'json'}</code>.\nThese are the default values for those options, so the following examples do not pass the options object.\nLater sections show some of the additional option possibilities.</p>\n\n<p><a id=\"config-service\"></a></p>\n<p translation-result=\"on\">這個例子符合透過定義一個可複用的可<a href=\"guide/glossary#service\" title=\"服務定義\">注入服務</a>來執行資料處理功能來建立可伸縮解決方案的最佳實踐。除了提取資料外，該服務還可以對資料進行後處理，新增錯誤處理，並新增重試邏輯。</p><p translation-origin=\"off\">The example conforms to the best practices for creating scalable solutions by defining a re-usable <a href=\"guide/glossary#service\" title=\"service definition\">injectable service</a> to perform the data-handling functionality.\nIn addition to fetching data, the service can post-process the data, add error handling, and add retry logic.</p>\n\n<p translation-result=\"on\"><code>ConfigService</code> 使用 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法獲取這個檔案。</p><p translation-origin=\"off\">The <code>ConfigService</code> fetches this file using the <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> method.</p>\n\n<code-example header=\"app/config/config.service.ts (getConfig v.1)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_1\">\nconfigUrl = 'assets/config.json';\n\ngetConfig() {\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<p translation-result=\"on\"><code>ConfigComponent</code> 注入了 <code>ConfigService</code> 並呼叫了 <code>getConfig</code> 服務方法。</p><p translation-origin=\"off\">The <code>ConfigComponent</code> injects the <code>ConfigService</code> and calls the <code>getConfig</code> service method.</p>\n\n<p translation-result=\"on\">由於該服務方法返回了一個 <code>Observable</code> 配置資料，該元件會<em>訂閱</em>該方法的返回值。訂閱回呼(Callback)只會對後處理進行最少量的處理。它會把資料欄位複製到元件的 <code>config</code> 物件中，該物件在元件範本中是資料繫結的，用於顯示。</p><p translation-origin=\"off\">Because the service method returns an <code>Observable</code> of configuration data, the component <em>subscribes</em> to the method's return value.\nThe subscription callback performs minimal post-processing.\nIt copies the data fields into the component's <code>config</code> object, which is data-bound in the component template for display.</p>\n\n<code-example header=\"app/config/config.component.ts (showConfig v.1)\" path=\"http/src/app/config/config.component.ts\" region=\"v1\">\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe((data: Config) =&gt; this.config = {\n        heroesUrl: data.heroesUrl,\n        textfile:  data.textfile,\n        date: data.date,\n    });\n}\n\n</code-example>\n<p><a id=\"always-subscribe\"></a></p>\n<h3 id=\"starting-the-request\" translation-result=\"on\">啟動請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#starting-the-request\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Starting the request<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#starting-the-request\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">對於所有 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法，在你在方法返回的 Observable 上呼叫 <code>subscribe()</code> 之前，該方法都不會開始其 HTTP 請求。</p><p translation-origin=\"off\">For all <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> methods, the method doesn't begin its HTTP request until you call <code>subscribe()</code> on the observable the method returns.</p>\n\n<p translation-result=\"on\">這適用於 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的<em>所有方法</em>。</p><p translation-origin=\"off\">This is true for <em>all</em> <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> <em>methods</em>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">當元件被銷燬時，你應該總是取消訂閱 Observable。</p><p translation-origin=\"off\">You should always unsubscribe from an observable when a component is destroyed.</p>\n\n</div>\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的所有方法返回的可觀察物件都設計為<em>冷的</em>。HTTP 請求的執行都是<em>延期執行的</em>，讓你可以用 <code>tap</code> 和 <code>catchError</code> 這樣的運運算元來在實際執行 HTTP 請求之前，先對這個可觀察物件進行擴充。</p><p translation-origin=\"off\">All observables returned from <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> methods are <em>cold</em> by design.\nExecution of the HTTP request is <em>deferred</em>, letting you extend the observable with additional operations such as  <code>tap</code> and <code>catchError</code> before anything actually happens.</p>\n\n<p translation-result=\"on\">呼叫 <code>subscribe()</code> 會觸發此 Observable 的執行，並導致 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 合成 HTTP 請求並將其傳送到伺服器。</p><p translation-origin=\"off\">Calling <code>subscribe()</code> triggers execution of the observable and causes <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> to compose and send the HTTP request to the server.</p>\n\n<p translation-result=\"on\">可以把這些 Observable 看做實際 HTTP 請求的<em>藍圖</em>。</p><p translation-origin=\"off\">Think of these observables as <em>blueprints</em> for actual HTTP requests.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">事實上，每個 <code>subscribe()</code> 都會啟動 observable 的一次單獨的、獨立的執行。訂閱兩次就會導致兩次 HTTP 請求。</p><p translation-origin=\"off\">In fact, each <code>subscribe()</code> initiates a separate, independent execution of the observable.\nSubscribing twice results in two HTTP requests.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst req = http.get&lt;Heroes&gt;('/api/heroes');\n// 0 requests made - .subscribe() not called.\nreq.subscribe();\n// 1 request made.\nreq.subscribe();\n// 2 requests made.\n\n</code-example>\n</div>\n<p><a id=\"typed-response\"></a></p>\n<h3 id=\"requesting-a-typed-response\" translation-result=\"on\">請求輸入一個類別型的響應<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-a-typed-response\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Requesting a typed response<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#requesting-a-typed-response\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">可以構造自己的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 請求來宣告響應物件的型別，以便讓輸出更容易、更明確。所指定的響應型別會在編譯時充當型別斷言。</p><p translation-origin=\"off\">Structure your <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> request to declare the type of the response object, to make consuming the output easier and more obvious.\nSpecifying the response type acts as a type assertion at compile time.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">指定響應型別是為了告訴 TypeScript 應該將響應視為給定型別的宣告。這是一個編譯期檢查，不能保證伺服器的響應一定是這種型別的物件。伺服器有責任確保返回伺服器 API 所指定的型別。</p><p translation-origin=\"off\">Specifying the response type is a declaration to TypeScript that it should treat your response as being of the given type.\nThis is a build-time check and doesn't guarantee that the server actually responds with an object of this type.\nIt is up to the server to ensure that the type specified by the server API is returned.</p>\n\n</div>\n<p translation-result=\"on\">要指定響應物件型別，首先要定義一個具有必需屬性的介面。這裡要使用介面而不是類，因為響應物件是普通物件，無法自動轉換成類別的例項。</p><p translation-origin=\"off\">To specify the response object type, first define an interface with the required properties.\nUse an interface rather than a class, because the response is a plain object that cannot be automatically converted to an instance of a class.</p>\n\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"config-interface\">\nexport interface Config {\n  heroesUrl: string;\n  textfile: string;\n  date: any;\n}\n\n</code-example>\n<p translation-result=\"on\">接下來，在伺服器中把該介面指定為 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 呼叫的型別引數。</p><p translation-origin=\"off\">Next, specify that interface as the <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> call's type parameter in the service.</p>\n\n<code-example header=\"app/config/config.service.ts (getConfig v.2)\" path=\"http/src/app/config/config.service.ts\" region=\"getConfig_2\">\ngetConfig() {\n  // now returns an Observable of Config\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">當你將一個介面作為型別引數傳給 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法時，要使用 <a href=\"guide/rx-library#operators\">RxJS 的 <code>map</code> 運運算元</a>來根據 UI 的需要變換響應資料。然後就可以將轉換後的資料傳給 <a href=\"api/common/AsyncPipe\">async 管道</a>了。</p><p translation-origin=\"off\">When you pass an interface as a type parameter to the <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> method, use the <a href=\"guide/rx-library#operators\">RxJS <code>map</code> operator</a> to transform the response data as needed by the UI.\nYou can then pass the transformed data to the <a href=\"api/common/AsyncPipe\">async pipe</a>.</p>\n\n</div>\n<p translation-result=\"on\">修改後的元件方法，其回呼(Callback)函式中獲取一個帶型別的物件，它易於使用，且消費起來更安全：</p><p translation-origin=\"off\">The callback in the updated component method receives a typed data object, which is easier and safer to consume:</p>\n\n<code-example header=\"app/config/config.component.ts (showConfig v.2)\" path=\"http/src/app/config/config.component.ts\" region=\"v2\">\nconfig: Config | undefined;\n\nshowConfig() {\n  this.configService.getConfig()\n    // clone the data object, using its known Config shape\n    .subscribe((data: Config) =&gt; this.config = { ...data });\n}\n\n</code-example>\n<p translation-result=\"on\">要存取介面中定義的屬性，必須將從 JSON 獲得的普通物件顯式轉換為所需的響應型別。比如，以下 <code>subscribe</code> 回呼(Callback)會將 <code>data</code> 作為物件接收，然後進行型別轉換以存取屬性。</p><p translation-origin=\"off\">To access properties that are defined in an interface, you must explicitly convert the plain object you get from the JSON to the required response type.\nFor example, the following <code>subscribe</code> callback receives <code>data</code> as an Object, and then type-casts it in order to access the properties.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n.subscribe(data =&gt; this.config = {\n  heroesUrl: (data as any).heroesUrl,\n  textfile:  (data as any).textfile,\n});\n\n</code-example>\n<p><a id=\"string-union-types\"></a></p>\n<div class=\"callout is-important\">\n<header ng-should-translate=\"\" translation-result=\"on\"><code>observe</code> 和 <code>response</code> 型別</header><header ng-should-translate=\"\" translation-origin=\"off\"><code>observe</code> and <code>response</code> types</header>\n\n<p translation-result=\"on\"><code>observe</code> 和 <code>response</code> 選項的型別是<em>字串聯合</em>型別，而不是普通字串。</p><p translation-origin=\"off\">The types of the <code>observe</code> and <code>response</code> options are <em>string unions</em>, rather than plain strings.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\noptions: {\n  …\n  observe?: 'body' | 'events' | 'response',\n  …\n  responseType?: 'arraybuffer'|'blob'|'json'|'text',\n  …\n}\n\n</code-example>\n<p translation-result=\"on\">這可能導致混淆。例如：</p><p translation-origin=\"off\">This can cause confusion.\nFor example:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n// this works\nclient.get('/foo', {responseType: 'text'})\n\n// but this does NOT work\nconst options = {\n  responseType: 'text',\n};\nclient.get('/foo', options)\n\n</code-example>\n<p>In the second case, TypeScript infers the type of <code>options</code> to be <code>{responseType: string}</code>.\nThe type is too wide to pass to <code>HttpClient.get</code> which is expecting the type of <code>responseType</code> to be one of the <em>specific</em> strings.\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> is typed explicitly this way so that the compiler can report the correct return type based on the options you provided.</p>\n<p>Use <code>as const</code> to let TypeScript know that you really do mean to use a constant string type:</p>\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst options = {\n  responseType: 'text' as const,\n};\nclient.get('/foo', options);\n\n</code-example>\n</div>\n<h3 id=\"reading-the-full-response\" translation-result=\"on\">讀取完整的回應內文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#reading-the-full-response\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Reading the full response<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-server-communication#reading-the-full-response\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在前面的例子中，對 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 的呼叫沒有指定任何選項。預設情況下，它返回了回應內文中包含的 JSON 資料。</p><p translation-origin=\"off\">In the previous example, the call to <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> did not specify any options.\nBy default, it returned the JSON data contained in the response body.</p>\n\n<p translation-result=\"on\">你可能還需要關於這次對話的更多資訊。比如，有時候伺服器會返回一個特殊的回應標頭或狀態碼，來指出某些在應用的工作流程中很重要的條件。</p><p translation-origin=\"off\">You might need more information about the transaction than is contained in the response body.\nSometimes servers return special headers or status codes to indicate certain conditions that are important to the application workflow.</p>\n\n<p translation-result=\"on\">可以用 <code>get()</code> 方法的 <code>observe</code> 選項來告訴 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>，你想要完整的響應物件：</p><p translation-origin=\"off\">Tell <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> that you want the full response with the <code>observe</code> option of the <code>get()</code> method:</p>\n\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"getConfigResponse\">\ngetConfigResponse(): Observable&lt;<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;&gt; {\n  return this.http.get&lt;Config&gt;(\n    this.configUrl, { observe: 'response' });\n}\n\n</code-example>\n<p translation-result=\"on\">現在，<code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 會返回一個 <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 型別的 <code>Observable</code>，而不只是 JSON 資料。</p><p translation-origin=\"off\">Now <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> returns an <code>Observable</code> of type <code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> rather than just the JSON data contained in the body.</p>\n\n<p translation-result=\"on\">該元件的 <code>showConfigResponse()</code> 方法會像顯示配置資料一樣顯示回應標頭：</p><p translation-origin=\"off\">The component's <code>showConfigResponse()</code> method displays the response headers as well as the configuration:</p>\n\n<code-example header=\"app/config/config.component.ts (showConfigResponse)\" path=\"http/src/app/config/config.component.ts\" region=\"showConfigResponse\">\nshowConfigResponse() {\n  this.configService.getConfigResponse()\n    // resp is of type `<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;`\n    .subscribe(resp =&gt; {\n      // display its headers\n      const keys = resp.headers.keys();\n      this.headers = keys.map(key =&gt;\n        `${key}: ${resp.headers.get(key)}`);\n\n      // access the body directly, which is typed as `Config`.\n      this.config = { ...resp.body! };\n    });\n}\n\n</code-example>\n<p translation-result=\"on\">如你所見，該響應物件具有一個帶有正確型別的 <code>body</code> 屬性。</p><p translation-origin=\"off\">As you can see, the response object has a <code>body</code> property of the correct type.</p>\n\n\n  <div class=\"reviewed\">最後複查時間：2/27/2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/common/AsyncPipe\n - api/common/http\n - api/common/http/HttpBackend\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpClientModule\n - api/common/http/HttpHeaders\n - api/common/http/HttpParams\n - api/common/http/HttpResponse\n - api/core/Injectable\n - api/core/NgModule\n - api/platform-browser/BrowserModule\n - guide/glossary#observable\n - guide/glossary#service\n - guide/http-server-communication#http-server-communication\n - guide/http-server-communication#http-伺服器通訊\n - guide/http-server-communication#reading-the-full-response\n - guide/http-server-communication#requesting-a-typed-response\n - guide/http-server-communication#requesting-data-from-a-server\n - guide/http-server-communication#setup-for-server-communication\n - guide/http-server-communication#starting-the-request\n - guide/http-server-communication#從伺服器請求資料\n - guide/http-server-communication#啟動請求\n - guide/http-server-communication#伺服器通訊的準備工作\n - guide/http-server-communication#請求輸入一個類別型的響應\n - guide/http-server-communication#讀取完整的回應內文\n - guide/rx-library#operators\n - https://github.com/angular/angular/tree/main/packages/misc/angular-in-memory-web-api\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-server-communication.md?message=docs%3A%20請簡述你的修改...\n-->"}