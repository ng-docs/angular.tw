{"id":"guide/template-typecheck","title":"Template type checking","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/template-typecheck.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"template-type-checking\" translation-result=\"on\">範本型別檢查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#template-type-checking\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Template type checking<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#template-type-checking\"><i class=\"material-icons\">link</i></a></h1>\n\n<h2 id=\"overview-of-template-type-checking\" translation-result=\"on\">範本型別檢查概述<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#overview-of-template-type-checking\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Overview of template type checking<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#overview-of-template-type-checking\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">正如 TypeScript 在程式碼中捕獲型別錯誤一樣，Angular 也會檢查應用程式範本中的表示式和繫結，並可以報告所發現的任何型別錯誤。Angular 當前有三種執行此操作的模式，具體取決於 <a href=\"guide/typescript-configuration\">TypeScript 配置檔案</a> 中的 <code>fullTemplateTypeCheck</code> 和 <code>strictTemplates</code> 標誌的值。</p><p translation-origin=\"off\">Just as TypeScript catches type errors in your code, Angular checks the expressions and bindings within the templates of your application and can report any type errors it finds.\nAngular currently has three modes of doing this, depending on the value of the <code>fullTemplateTypeCheck</code> and <code>strictTemplates</code> flags in the <a href=\"guide/typescript-configuration\">TypeScript configuration file</a>.</p>\n\n<h3 id=\"basic-mode\" translation-result=\"on\">基本模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#basic-mode\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Basic mode<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#basic-mode\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在最基本的型別檢查模式下，將 <code>fullTemplateTypeCheck</code> 標誌設定為 <code>false</code>，Angular 僅驗證範本中的最上層表示式。</p><p translation-origin=\"off\">In the most basic type-checking mode, with the <code>fullTemplateTypeCheck</code> flag set to <code>false</code>, Angular validates only top-level expressions in a template.</p>\n\n<p translation-result=\"on\">如果編寫 <code>&lt;map [city]=\"user.address.city\"&gt;</code>，則編譯器將驗證以下內容：</p><p translation-origin=\"off\">If you write <code>&lt;map [city]=\"user.address.city\"&gt;</code>, the compiler verifies the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>user</code> 是該元件類別的屬性</p><p translation-origin=\"off\"><code>user</code> is a property on the component class</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>user</code> 是具有 <code>address</code> 屬性的物件</p><p translation-origin=\"off\"><code>user</code> is an object with an address property</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>user.address</code> 是具有 <code>city</code> 屬性的物件</p><p translation-origin=\"off\"><code>user.address</code> is an object with a city property</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">編譯器不會驗證 <code>user.address.city</code> 的值是否可賦值給 <code>&lt;map&gt;</code> 元件的輸入屬性 <code>city</code>。</p><p translation-origin=\"off\">The compiler does not verify that the value of <code>user.address.city</code> is assignable to the city input of the <code>&lt;map&gt;</code> component.</p>\n\n<p translation-result=\"on\">編譯器在此模式下也有一些主要限制：</p><p translation-origin=\"off\">The compiler also has some major limitations in this mode:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">重要的是，它不會檢查嵌入式檢視，比如 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>，<code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 和其它 <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> 嵌入式檢視。</p><p translation-origin=\"off\">Importantly, it doesn't check embedded views, such as <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>, <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>, other <code><a href=\"api/core/ng-template\" class=\"code-anchor\">&lt;ng-template&gt;</a></code> embedded view.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它無法弄清 <code>#refs</code> 的型別、管道的結果、事件繫結中 <code>$event</code> 的型別等等。</p><p translation-origin=\"off\">It doesn't figure out the types of <code>#refs</code>, the results of pipes, or the type of <code>$event</code> in event bindings.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">在許多情況下，這些東西最終都以 <code>any</code> 型別結束，這可能導致表示式的後續部分不受檢查。</p><p translation-origin=\"off\">In many cases, these things end up as type <code>any</code>, which can cause subsequent parts of the expression to go unchecked.</p>\n\n<h3 id=\"full-mode\" translation-result=\"on\">完全模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#full-mode\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Full mode<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#full-mode\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果將 <code>fullTemplateTypeCheck</code> 標誌設定為 <code>true</code>，則 Angular 在範本中進行型別檢查時會更加主動。特別是：</p><p translation-origin=\"off\">If the <code>fullTemplateTypeCheck</code> flag is set to <code>true</code>, Angular is more aggressive in its type-checking within templates.\nIn particular:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">檢查嵌入式檢視（比如 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 內的 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>）</p><p translation-origin=\"off\">Embedded views (such as those within an <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>) are checked</p>\n\n</li>\n<li>\n<p translation-result=\"on\">管道具有正確的返回型別</p><p translation-origin=\"off\">Pipes have the correct return type</p>\n\n</li>\n<li>\n<p translation-result=\"on\">對指令和管道的本地參考具有正確的型別（any 泛型引數除外，該通用引數將是 <code>any</code>）</p><p translation-origin=\"off\">Local references to directives and pipes have the correct type (except for any generic parameters, which will be <code>any</code>)</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">以下仍然具有 <code>any</code> 型別。</p><p translation-origin=\"off\">The following still have type <code>any</code>.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">對 DOM 元素的本地參考。</p><p translation-origin=\"off\">Local references to DOM elements</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>$event</code> 物件</p><p translation-origin=\"off\">The <code>$event</code> object</p>\n\n</li>\n<li>\n<p translation-result=\"on\">安全導航表示式</p><p translation-origin=\"off\">Safe navigation expressions</p>\n\n</li>\n</ul>\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><code>fullTemplateTypeCheck</code> 標誌已經在 Angular 13 中棄用了。它被編譯器選項中的 <code>strictTemplates</code> 家族代替了。</p><p translation-origin=\"off\">The <code>fullTemplateTypeCheck</code> flag has been deprecated in Angular 13.\nThe <code>strictTemplates</code> family of compiler options should be used instead.</p>\n\n</div>\n<p><a id=\"strict-mode\"></a></p>\n<h3 id=\"strict-mode\" translation-result=\"on\">嚴格模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#strict-mode\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Strict mode<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#strict-mode\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Angular 延續了 <code>fullTemplateTypeCheck</code> 標誌的行為，並引入了第三個“嚴格模式”。嚴格模式是完全模式的超集，可以透過將 <code>strictTemplates</code> 標誌設定為 true 來存取。該標誌取代 <code>fullTemplateTypeCheck</code> 標誌。在嚴格模式下，Angular 添加了超出 8 版型別檢查器的檢查。</p><p translation-origin=\"off\">Angular maintains the behavior of the <code>fullTemplateTypeCheck</code> flag, and introduces a third \"strict mode\".\nStrict mode is a superset of full mode, and is accessed by setting the <code>strictTemplates</code> flag to true.\nThis flag supersedes the <code>fullTemplateTypeCheck</code> flag.\nIn strict mode, Angular uses checks that go beyond the version 8 type-checker.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n嚴格模式僅在使用 Ivy 時可用。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nStrict mode is only available if using Ivy.</p>\n\n</div>\n<p translation-result=\"on\">除了完全模式的行為之外，Angular 還會：</p><p translation-origin=\"off\">In addition to the full mode behavior, Angular does the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">驗證元件/指令繫結是否可賦值給它們的 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code></p><p translation-origin=\"off\">Verifies that component/directive bindings are assignable to their <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>s</p>\n\n</li>\n<li>\n<p translation-result=\"on\">驗證以上模式時，會遵守 TypeScript 的 <code>strictNullChecks</code> 標誌</p><p translation-origin=\"off\">Obeys TypeScript's <code>strictNullChecks</code> flag when validating the preceding mode</p>\n\n</li>\n<li>\n<p translation-result=\"on\">推斷元件/指令的正確型別，包括泛型</p><p translation-origin=\"off\">Infers the correct type of components/directives, including generics</p>\n\n</li>\n<li>\n<p translation-result=\"on\">推斷配置範本上下文的型別（比如，允許對 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code> 進行正確的型別檢查）</p><p translation-origin=\"off\">Infers template context types where configured (for example, allowing correct type-checking of <code><a href=\"api/common/NgFor\" class=\"code-anchor\">NgFor</a></code>)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在元件/指令、DOM 和動畫事件繫結中推斷 <code>$event</code> 的正確型別</p><p translation-origin=\"off\">Infers the correct type of <code>$event</code> in component/directive, DOM, and animation event bindings</p>\n\n</li>\n<li>\n<p translation-result=\"on\">根據標籤（tag）名稱（比如，<code>document.createElement</code> 將為該標籤返回正確的型別），推斷出對 DOM 元素的區域性參考的正確型別</p><p translation-origin=\"off\">Infers the correct type of local references to DOM elements, based on the tag name (for example, the type that <code>document.createElement</code> would return for that tag)</p>\n\n</li>\n</ul>\n<h2 id=\"checking-of-ngfor\" translation-result=\"on\"><code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 檢查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#ngfor-檢查\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Checking of <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#checking-of-ngfor\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">型別檢查的三種模式對嵌入式檢視的處理方式不同。考慮以下範例。</p><p translation-origin=\"off\">The three modes of type-checking treat embedded views differently.\nConsider the following example.</p>\n\n<code-example language=\"typescript\" header=\"User interface\">\n\ninterface User {\n  name: string;\n  address: {\n    city: string;\n    state: string;\n  }\n}\n\n</code-example>\n<code-example format=\"html\" language=\"html\">\n\n&lt;div *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let user of users\"&gt;\n  &lt;h2&gt;{{config.title}}&lt;/h2&gt;\n  &lt;span&gt;City: {{user.address.city}}&lt;/span&gt;\n&lt;/div&gt;\n\n</code-example>\n<p translation-result=\"on\"><code>&lt;h2&gt;</code> 和 <code>&lt;span&gt;</code> 在 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 嵌入式檢視中。在基本模式下，Angular 不會檢查它們中的任何一個。但是，在完全模式下，Angular 會檢查 <code>config</code> 和 <code>user</code> 是否存在，並假設為 <code>any</code> 的型別。在嚴格模式下，Angular 知道該 <code>user</code> 在 <code>&lt;span&gt;</code> 中是 <code>User</code> 型別，而 <code>address</code> 是與一個物件，它有一個 <code>string</code> 型別的屬性 <code>city</code>。</p><p translation-origin=\"off\">The <code>&lt;h2&gt;</code> and the <code>&lt;span&gt;</code> are in the <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> embedded view.\nIn basic mode, Angular doesn't check either of them.\nHowever, in full mode, Angular checks that <code>config</code> and <code>user</code> exist and assumes a type of <code>any</code>.\nIn strict mode, Angular knows that the <code>user</code> in the <code>&lt;span&gt;</code> has a type of <code>User</code>, and that <code>address</code> is an object with a <code>city</code> property of type <code>string</code>.</p>\n\n<p><a id=\"troubleshooting-template-errors\"></a></p>\n<h2 id=\"troubleshooting-template-errors\" translation-result=\"on\">排除範本錯誤<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#troubleshooting-template-errors\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Troubleshooting template errors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#troubleshooting-template-errors\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用嚴格模式，你可能會遇到在以前的兩種模式下都沒有出現過的範本錯誤。這些錯誤通常表示範本中的真正型別不匹配，而以前的工具並未捕獲這些錯誤。在這種情況下，該錯誤訊息會使該問題在範本中的位置清晰可見。</p><p translation-origin=\"off\">With strict mode, you might encounter template errors that didn't arise in either of the previous modes.\nThese errors often represent genuine type mismatches in the templates that were not caught by the previous tooling.\nIf this is the case, the error message should make it clear where in the template the problem occurs.</p>\n\n<p translation-result=\"on\">當 Angular 庫的型別不完整或不正確，或者在以下情況下型別與預期不完全一致時，也可能存在誤報。</p><p translation-origin=\"off\">There can also be false positives when the typings of an Angular library are either incomplete or incorrect, or when the typings don't quite line up with expectations as in the following cases.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">當庫的型別錯誤或不完整時（比如，如果編寫庫的時候沒有注意 <code>strictNullChecks</code>，則可能缺少 <code>null | undefined</code>）</p><p translation-origin=\"off\">When a library's typings are wrong or incomplete (for example, missing <code>null | undefined</code> if the library was not written with <code>strictNullChecks</code> in mind)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">當庫的輸入型別太窄並且庫沒有為 Angular 新增適當的元資料來解決這個問題時。這通常在禁用或使用其它通用布林輸入作為屬性時發生，比如 <code>&lt;input disabled&gt;</code>。</p><p translation-origin=\"off\">When a library's input types are too narrow and the library hasn't added appropriate metadata for Angular to figure this out.\nThis usually occurs with disabled or other common Boolean inputs used as attributes, for example, <code>&lt;input disabled&gt;</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在將 <code>$event.target</code> 用於 DOM 事件時（由於事件冒泡的可能性，DOM 型別中的 <code>$event.target</code> 不具有你可能期望的型別）</p><p translation-origin=\"off\">When using <code>$event.target</code> for DOM events (because of the possibility of event bubbling, <code>$event.target</code> in the DOM typings doesn't have the type you might expect)</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">如果發生此類誤報，則有以下幾種選擇：</p><p translation-origin=\"off\">In case of a false positive like these, there are a few options:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">在某些情況下，使用 <a href=\"guide/template-expression-operators#any-type-cast-function\"><code>$any()</code> 型別轉換函式</a>可以選擇不對部分表示式進行型別檢查</p><p translation-origin=\"off\">Use the <a href=\"guide/template-expression-operators#any-type-cast-function\"><code>$any()</code> type-cast function</a> in certain contexts to opt out of type-checking for a part of the expression</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你可以透過在應用程式的 TypeScript 配置檔案 <code>tsconfig.json</code> 中設定 <code>strictTemplates: false</code> 來完全禁用嚴格檢查</p><p translation-origin=\"off\">Disable strict checks entirely by setting <code>strictTemplates: false</code> in the application's TypeScript configuration file, <code>tsconfig.json</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">透過將<em>嚴格性標誌</em>設定為 <code>false</code>，可以在保持其它方面的嚴格性的同時，單獨禁用某些特定的型別檢查操作</p><p translation-origin=\"off\">Disable certain type-checking operations individually, while maintaining strictness in other aspects, by setting a <em>strictness flag</em> to <code>false</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果要一起使用 <code>strictTemplates</code> 和 <code>strictNullChecks</code>，則可以透過 <code>strictNullInputTypes</code> 來選擇性排除專門用於輸入繫結的嚴格空型別檢查</p><p translation-origin=\"off\">If you want to use <code>strictTemplates</code> and <code>strictNullChecks</code> together, opt out of strict null type checking specifically for input bindings using <code>strictNullInputTypes</code></p>\n\n</li>\n</ul>\n<p translation-result=\"on\">除非另行說明，下面的每個選項都會設定為 <code>strictTemplates</code> 的值（當 <code>strictTemplates</code> 為真時是 <code>true</code>，其他值也一樣）。</p><p translation-origin=\"off\">Unless otherwise commented, each following option is set to the value for <code>strictTemplates</code> (<code>true</code> when <code>strictTemplates</code> is <code>true</code> and conversely, the other way around).</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">嚴格標誌</nt-wrapper><nt-wrapper translation-origin=\"off\">Strictness flag</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">影響</nt-wrapper><nt-wrapper translation-origin=\"off\">Effect</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>strictInputTypes</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">是否檢查繫結表示式對 `@Input()` 欄位的可賦值性。也會影響指令泛型型別的推斷。</nt-wrapper><nt-wrapper translation-origin=\"off\">Whether the assignability of a binding expression to the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> field is checked. Also affects the inference of directive generic types.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>strictInputAccessModifiers</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在把繫結表示式賦值給 `@Input()` 時，是否檢查像 `private`/`protected`/`readonly` 這樣的存取修飾符。如果禁用，則 `@Input` 上的存取修飾符會被忽略，只進行型別檢查。本選項預設為 `false`，即使當 `strictTemplates` 為 `true` 時也一樣。</nt-wrapper><nt-wrapper translation-origin=\"off\">Whether access modifiers such as <code>private</code>/<code>protected</code>/<code>readonly</code> are honored when assigning a binding expression to an <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>. If disabled, the access modifiers of the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> are ignored; only the type is checked. This option is <code>false</code> by default, even with <code>strictTemplates</code> set to <code>true</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>strictNullInputTypes</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">檢查 `@Input()` 繫結時是否要 `strictNullChecks`（對於每個 `strictInputTypes`）。當使用的函式庫不是基於 `strictNullChecks` 建構的時，將其關閉會很有幫助。</nt-wrapper><nt-wrapper translation-origin=\"off\">Whether <code>strictNullChecks</code> is honored when checking <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> bindings (per <code>strictInputTypes</code>). Turning this off can be useful when using a library that was not built with <code>strictNullChecks</code> in mind.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>strictAttributeTypes</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">是否檢查使用文字屬性進行的 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 繫結。例如，<code-example format=\"html\" hidecopy=\"\" language=\"html\"> &lt;input matInput disabled=\"true\"&gt; </code-example>（將 <code>disabled</code> 屬性設定為字串 <code>'true'</code>）vs<code-example format=\"html\" hidecopy=\"\" language=\"html\"> &lt;input matInput [disabled]=\"true\"&gt; </code-example>（將 <code>disabled</code> 屬性設定為布林值 <code>true</code>）。</nt-wrapper><nt-wrapper translation-origin=\"off\">Whether to check <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> bindings that are made using text attributes. For example, <code-example format=\"html\" hidecopy=\"\" language=\"html\"> &lt;input matInput disabled=\"true\"&gt; </code-example> (setting the <code>disabled</code> property to the string <code>'true'</code>) vs <code-example format=\"html\" hidecopy=\"\" language=\"html\"> &lt;input matInput [disabled]=\"true\"&gt; </code-example> (setting the <code>disabled</code> property to the boolean <code>true</code>).</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>strictSafeNavigationTypes</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">是否根據 `user` 的型別正確推斷出安全導航操作的返回型別（比如 `user?.name`）。如果禁用，則 `user?.name` 的型別為 `any`。</nt-wrapper><nt-wrapper translation-origin=\"off\">Whether the return type of safe navigation operations (for example, <code>user?.name</code> will be correctly inferred based on the type of <code>user</code>). If disabled, <code>user?.name</code> will be of type <code>any</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>strictDomLocalRefTypes</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">對 DOM 元素的本地參考是否將具有正確的型別。如果禁用，對於 `` 來說 `ref` 會是 `any` 型別的。</nt-wrapper><nt-wrapper translation-origin=\"off\">Whether local references to DOM elements will have the correct type. If disabled <code>ref</code> will be of type <code>any</code> for <code>&lt;input #ref&gt;</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>strictOutputEventTypes</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">對於繫結到元件/指令 `@Output()` 或動畫事件的事件繫結，`$event` 是否具有正確的型別。如果禁用，它將為 `any`。</nt-wrapper><nt-wrapper translation-origin=\"off\">Whether <code>$event</code> will have the correct type for event bindings to component/directive an <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code>, or to animation events. If disabled, it will be <code>any</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>strictDomEventTypes</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">對於與 DOM 事件的事件繫結，`$event` 是否具有正確的型別。如果禁用，它將為 `any`。</nt-wrapper><nt-wrapper translation-origin=\"off\">Whether <code>$event</code> will have the correct type for event bindings to DOM events. If disabled, it will be <code>any</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>strictContextGenerics</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">泛型元件的型別引數是否應該被正確推斷（包括泛型上界和下界）. 如果禁用它，所有的型別引數都會被當做 `any`。</nt-wrapper><nt-wrapper translation-origin=\"off\">Whether the type parameters of generic components will be inferred correctly (including any generic bounds). If disabled, any type parameters will be <code>any</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>strictLiteralTypes</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">是否要推斷範本中宣告的物件和陣列字面量的型別。如果禁用，則此類文字的型別就是 `any`。當 `fullTemplateTypeCheck` 或 `strictTemplates` 為 `true` 時，此標誌為 `true`。</nt-wrapper><nt-wrapper translation-origin=\"off\">Whether object and array literals declared in the template will have their type inferred. If disabled, the type of such literals will be <code>any</code>. This flag is <code>true</code> when <em>either</em> <code>fullTemplateTypeCheck</code> or <code>strictTemplates</code> is set to <code>true</code>.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">如果使用這些標誌進行故障排除後仍然存在問題，可以透過禁用 <code>strictTemplates</code> 退回到完全模式。</p><p translation-origin=\"off\">If you still have issues after troubleshooting with these flags, fall back to full mode by disabling <code>strictTemplates</code>.</p>\n\n<p translation-result=\"on\">如果這不起作用，則最後一種選擇是完全關閉 full 模式，並使用 <code>fullTemplateTypeCheck: false</code>。</p><p translation-origin=\"off\">If that doesn't work, an option of last resort is to turn off full mode entirely with <code>fullTemplateTypeCheck: false</code>.</p>\n\n<p translation-result=\"on\">你無法使用任何推薦方式解決的型別檢查錯誤可能是因為範本型別檢查器本身存在錯誤。如果遇到需要退回到基本模式的錯誤，則很可能是這樣的錯誤。如果發生這種情況，請<a href=\"https://github.com/angular/angular/issues\">提出問題</a>，以便開發組解決。</p><p translation-origin=\"off\">A type-checking error that you cannot resolve with any of the recommended methods can be the result of a bug in the template type-checker itself.\nIf you get errors that require falling back to basic mode, it is likely to be such a bug.\nIf this happens, <a href=\"https://github.com/angular/angular/issues\">file an issue</a> so the team can address it.</p>\n\n<h2 id=\"inputs-and-type-checking\" translation-result=\"on\">輸入屬性與型別檢查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#inputs-and-type-checking\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Inputs and type-checking<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#inputs-and-type-checking\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">範本型別檢查器會檢查繫結表示式的型別是否與相應指令輸入的型別相容。比如，請考慮以下元件：</p><p translation-origin=\"off\">The template type checker checks whether a binding expression's type is compatible with that of the corresponding directive input.\nAs an example, consider the following component:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport interface User {\n  name: string;\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'user-detail',\n  template: '{{ user.name }}',\n})\nexport class UserDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() user: User;\n}\n\n</code-example>\n<p translation-result=\"on\"><code>AppComponent</code> 範本按以下方式使用此元件：</p><p translation-origin=\"off\">The <code>AppComponent</code> template uses this component as follows:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&lt;user-detail [user]=\"selectedUser\"&gt;&lt;/user-detail&gt;',\n})\nexport class AppComponent {\n  selectedUser: User | null = null;\n}\n\n</code-example>\n<p translation-result=\"on\">這裡，在檢查 <code>AppComponent</code> 的範本期間，<code>[user]=\"selectedUser\"</code> 繫結與 <code>UserDetailComponent.user</code> 輸入屬性相對應。因此，Angular 會將 <code>selectedUser</code> 屬性賦值給 <code>UserDetailComponent.user</code>，如果它們的型別不相容，則將導致錯誤。TypeScript 會根據其型別系統進行賦值檢查，並遵循在應用程式中配置的標誌（比如 <code>strictNullChecks</code>）。</p><p translation-origin=\"off\">Here, during type checking of the template for <code>AppComponent</code>, the <code>[user]=\"selectedUser\"</code> binding corresponds with the <code>UserDetailComponent.user</code> input.\nTherefore, Angular assigns the <code>selectedUser</code> property to <code>UserDetailComponent.user</code>, which would result in an error if their types were incompatible.\nTypeScript checks the assignment according to its type system, obeying flags such as <code>strictNullChecks</code> as they are configured in the application.</p>\n\n<p translation-result=\"on\">透過向範本型別檢查器提出更具體的範本內型別要求，可以避免一些執行時型別錯誤。透過在指令定義中提供各種“範本守衛”功能，可以讓自訂指令的輸入型別要求儘可能具體。參閱本指南中的<a href=\"guide/structural-directives#directive-type-checks\">強化自訂指令的範本型別檢查</a>。</p><p translation-origin=\"off\">Avoid run-time type errors by providing more specific in-template type requirements to the template type checker.\nMake the input type requirements for your own directives as specific as possible by providing template-guard functions in the directive definition.\nSee <a href=\"guide/structural-directives#directive-type-checks\">Improving template type checking for custom directives</a> in this guide.</p>\n\n<h3 id=\"strict-null-checks\" translation-result=\"on\">嚴格的空檢查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#strict-null-checks\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Strict null checks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#strict-null-checks\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當你啟用 <code>strictTemplates</code> 和 TypeScript 標誌 <code>strictNullChecks</code>，在某些情況下可能會發生型別檢查錯誤，這些情況很難避免。比如：</p><p translation-origin=\"off\">When you enable <code>strictTemplates</code> and the TypeScript flag <code>strictNullChecks</code>, typecheck errors might occur for certain situations that might not easily be avoided.\nFor example:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">一個可空值，該值繫結到未啟用 <code>strictNullChecks</code> 的函式庫中的指令。</p><p translation-origin=\"off\">A nullable value that is bound to a directive from a library which did not have <code>strictNullChecks</code> enabled.</p>\n\n<p translation-result=\"on\">對於沒有使用 <code>strictNullChecks</code> 編譯的函式庫，其宣告檔案將不會指示欄位是否可以為 <code>null</code>。對於庫正確處理 <code>null</code> 的情況，這是有問題的，因為編譯器將根據宣告檔案進行空值檢查，而它省略了 <code>null</code> 型別。這樣，編譯器會產生型別檢查錯誤，因為它要遵守 <code>strictNullChecks</code>。</p><p translation-origin=\"off\">For a library compiled without <code>strictNullChecks</code>, its declaration files will not indicate whether a field can be <code>null</code> or not.\nFor situations where the library handles <code>null</code> correctly, this is problematic, as the compiler will check a nullable value against the declaration files which omit the <code>null</code> type.\nAs such, the compiler produces a type-check error because it adheres to <code>strictNullChecks</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">將 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 管道與 Observable 一起使用會同步發出值。</p><p translation-origin=\"off\">Using the <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> pipe with an Observable which you know will emit synchronously.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 管道當前假定它預訂的 Observable 可以是非同步的，這意味著可能還沒有可用的值。在這種情況下，它仍然必須返回某些內容 —— <code>null</code>。換句話說，<code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 管道的返回型別包括 <code>null</code>，這在知道此 Observable 會同步發出非空值的情況下可能會導致錯誤。</p><p translation-origin=\"off\">The <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> pipe currently assumes that the Observable it subscribes to can be asynchronous, which means that it's possible that there is no value available yet.\nIn that case, it still has to return something —which is <code>null</code>.\nIn other words, the return type of the <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> pipe includes <code>null</code>, which might result in errors in situations where the Observable is known to emit a non-nullable value synchronously.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">對於上述問題，有兩種潛在的解決方法：</p><p translation-origin=\"off\">There are two potential workarounds to the preceding issues:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">在範本中，包括非空斷言運算子 <code>!</code> 用在可為空的表示式的末尾，比如</p><p translation-origin=\"off\">In the template, include the non-null assertion operator <code>!</code> at the end of a nullable expression, such as</p>\n\n<code-example format=\"html\" hidecopy=\"\" language=\"html\">\n\n&lt;user-detail [user]=\"user!\"&gt;&lt;/user-detail&gt;\n\n</code-example>\n<p translation-result=\"on\">在此範例中，編譯器在可空性方面會忽略型別不相容，就像在 TypeScript 程式碼中一樣。對於 <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> 管道，請注意，表示式需要用括號括起來，如</p><p translation-origin=\"off\">In this example, the compiler disregards type incompatibilities in nullability, just as in TypeScript code.\nIn the case of the <code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">async</a></code> pipe, notice that the expression needs to be wrapped in parentheses, as in</p>\n\n<code-example format=\"html\" hidecopy=\"\" language=\"html\">\n\n&lt;user-detail [user]=\"(user$ | async)!\"&gt;&lt;/user-detail&gt;\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">完全禁用 Angular 範本中的嚴格空檢查。</p><p translation-origin=\"off\">Disable strict null checks in Angular templates completely.</p>\n\n<p translation-result=\"on\">當啟用 <code>strictTemplates</code> 時，仍然可以禁用型別檢查的某些方面。將選項 <code>strictNullInputTypes</code> 設定為 <code>false</code> 將禁用 Angular 範本中的嚴格空檢查。此標誌會作用於應用程式中包含的所有元件。</p><p translation-origin=\"off\">When <code>strictTemplates</code> is enabled, it is still possible to disable certain aspects of type checking.\nSetting the option <code>strictNullInputTypes</code> to <code>false</code> disables strict null checks within Angular templates.\nThis flag applies for all components that are part of the application.</p>\n\n</li>\n</ul>\n<h3 id=\"advice-for-library-authors\" translation-result=\"on\">給庫作者的建議<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#advice-for-library-authors\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Advice for library authors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#advice-for-library-authors\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">作為庫作者，你可以採取多種措施為使用者提供最佳體驗。首先，啟用 <code>strictNullChecks</code> 並在輸入的型別中包括 <code>null</code>（如果適用），可以與消費者溝通，看他們是否可以提供可空的值。\n此外，可以提供特定範本型別檢查器的型別提示，請參閱本指南的<a href=\"guide/structural-directives#directive-type-checks\">為自訂指令改進範本型別檢查</a>和<a href=\"guide/template-typecheck#input-setter-coercion\">輸入設定器強制轉型</a>部分。</p><p translation-origin=\"off\">As a library author, you can take several measures to provide an optimal experience for your users.\nFirst, enabling <code>strictNullChecks</code> and including <code>null</code> in an input's type, as appropriate, communicates to your consumers whether they can provide a nullable value or not.\nAdditionally, it is possible to provide type hints that are specific to the template type checker.\nSee <a href=\"guide/structural-directives#directive-type-checks\">Improving template type checking for custom directives</a>, and <a href=\"guide/template-typecheck#input-setter-coercion\">Input setter coercion</a>.</p>\n\n<p><a id=\"input-setter-coercion\"></a></p>\n<h2 id=\"input-setter-coercion\" translation-result=\"on\">輸入 setter 強制型別轉換<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#input-setter-coercion\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Input setter coercion<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#input-setter-coercion\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">有時，指令或元件的 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 最好更改繫結到它的值，通常使用此輸入的 getter / setter 對。比如，考慮以下自訂按鈕元件：</p><p translation-origin=\"off\">Occasionally it is desirable for the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> of a directive or component to alter the value bound to it, typically using a getter/setter pair for the input.\nAs an example, consider this custom button component:</p>\n\n<p translation-result=\"on\">考慮以下指令：</p><p translation-origin=\"off\">Consider the following directive:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'submit-button',\n  template: `\n    &lt;div class=\"wrapper\"&gt;\n      &lt;button [disabled]=\"disabled\"&gt;Submit&lt;/button&gt;\n    &lt;/div&gt;\n  `,\n})\nclass SubmitButton {\n  private _disabled: boolean;\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n\n  set disabled(value: boolean) {\n    this._disabled = value;\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">在這裡，元件的輸入 <code>disabled</code> 將傳給範本中的 <code>&lt;button&gt;</code>。只要將 <code>boolean</code> 值繫結到輸入，所有這些工作都可以按預期進行。但是，假設使用者使用範本中的這個輸入作為屬性：</p><p translation-origin=\"off\">Here, the <code>disabled</code> input of the component is being passed on to the <code>&lt;button&gt;</code> in the template.\nAll of this works as expected, as long as a <code>boolean</code> value is bound to the input.\nBut, suppose a consumer uses this input in the template as an attribute:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;submit-button disabled&gt;&lt;/submit-button&gt;\n\n</code-example>\n<p translation-result=\"on\">這與繫結具有相同的效果：</p><p translation-origin=\"off\">This has the same effect as the binding:</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;submit-button [disabled]=\"''\"&gt;&lt;/submit-button&gt;\n\n</code-example>\n<p translation-result=\"on\">在執行時，輸入將設定為空字串，這不是 <code>boolean</code> 值。處理此問題的 Angular 元件庫通常將值“強制轉換”到 setter 中的正確型別中：</p><p translation-origin=\"off\">At runtime, the input will be set to the empty string, which is not a <code>boolean</code> value.\nAngular component libraries that deal with this problem often \"coerce\" the value into the right type in the setter:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nset disabled(value: boolean) {\n  this._disabled = (value === '') || value;\n}\n\n</code-example>\n<p translation-result=\"on\">最好在這裡將 <code>value</code> 的型別從 <code>boolean</code> 更改為 <code>boolean|''</code> 以匹配 setter 實際會接受的一組值。TypeScript 4.3 之前的版本要求 getter 和 setter 的型別相同，因此，如果 getter 要返回 <code>boolean</code> 則 setter 會卡在較窄的型別上。</p><p translation-origin=\"off\">It would be ideal to change the type of <code>value</code> here, from <code>boolean</code> to <code>boolean|''</code>, to match the set of values which are actually accepted by the setter.\nTypeScript prior to version 4.3 requires that both the getter and setter have the same type, so if the getter should return a <code>boolean</code> then the setter is stuck with the narrower type.</p>\n\n<p translation-result=\"on\">如果消費者對範本啟用了 Angular 的最嚴格的型別檢查功能，則會產生一個問題：空字串 <code>''</code> 實際上無法賦值給 <code>disabled</code> 欄位，使用屬性格式寫會產生型別錯誤。</p><p translation-origin=\"off\">If the consumer has Angular's strictest type checking for templates enabled, this creates a problem: the empty string (<code>''</code>) is not actually assignable to the <code>disabled</code> field, which creates a type error when the attribute form is used.</p>\n\n<p translation-result=\"on\">作為解決此問題的一種取巧方式，Angular 支援對 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 檢查比宣告的輸入欄位更寬鬆的型別。透過向元件類新增帶有 <code>ngAcceptInputType_</code> 字首的靜態屬性來啟用此功能：</p><p translation-origin=\"off\">As a workaround for this problem, Angular supports checking a wider, more permissive type for <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> than is declared for the input field itself.\nEnable this by adding a static property with the <code>ngAcceptInputType_</code> prefix to the component class:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass SubmitButton {\n  private _disabled: boolean;\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  get disabled(): boolean {\n    return this._disabled;\n  }\n\n  set disabled(value: boolean) {\n    this._disabled = (value === '') || value;\n  }\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngAcceptInputType_disabled: boolean|'';\n}\n\n</code-example>\n<div class=\"alert is-important\">\n<p translation-result=\"on\">從 TypeScript 4.3 開始，setter 能夠宣告為接受 <code>boolean|''</code> 型別，這就讓輸入屬性 setter 強制型別轉換欄位過時了。因此，輸入屬性 setter 強制型別轉換欄位也就棄用了。</p><p translation-origin=\"off\">Since TypeScript 4.3, the setter could have been declared to accept <code>boolean|''</code> as type, making the input setter coercion field obsolete.\nAs such, input setters coercion fields have been deprecated.</p>\n\n</div>\n<p translation-result=\"on\">該欄位不需要值。它只要存在就會通知 Angular 的型別檢查器，<code>disabled</code> 輸入應被視為接受與 <code>boolean|''</code> 型別匹配的繫結。字尾應為 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> <em>欄位</em>的名稱。</p><p translation-origin=\"off\">This field does not need to have a value.\nIts existence communicates to the Angular type checker that the <code>disabled</code> input should be considered as accepting bindings that match the type <code>boolean|''</code>.\nThe suffix should be the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> <em>field</em> name.</p>\n\n<p translation-result=\"on\">請注意，如果給定輸入存在 <code>ngAcceptInputType_</code> 覆蓋，則設定器應能夠處理任何覆蓋型別的值。</p><p translation-origin=\"off\">Care should be taken that if an <code>ngAcceptInputType_</code> override is present for a given input, then the setter should be able to handle any values of the overridden type.</p>\n\n<h2 id=\"disabling-type-checking-using-any\" translation-result=\"on\">使用 <code>$any()</code> 禁用型別檢查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#disabling-type-checking-using-any\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Disabling type checking using <code>$any()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/template-typecheck#disabling-type-checking-using-any\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">可以透過把繫結表示式包含在<a href=\"guide/template-expression-operators\">型別轉換偽函式 <code>$any()</code></a> 中來禁用型別檢查。編譯器會像在 TypeScript 中使用 <code>&lt;any&gt;</code> 或 <code>as any</code> 進行型別轉換一樣對待它。</p><p translation-origin=\"off\">Disable checking of a binding expression by surrounding the expression in a call to the <a href=\"guide/template-expression-operators\"><code>$any()</code> cast pseudo-function</a>.\nThe compiler treats it as a cast to the <code>any</code> type just like in TypeScript when a <code>&lt;any&gt;</code> or <code>as any</code> cast is used.</p>\n\n<p translation-result=\"on\">在以下範例中，將 <code>person</code> 強制轉換為 <code>any</code> 型別可以壓制錯誤 <code>Property address does not exist</code>。</p><p translation-origin=\"off\">In the following example, casting <code>person</code> to the <code>any</code> type suppresses the error <code>Property address does not exist</code>.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{$any(person).address.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - extended-diagnostics\n - extended-diagnostics/NG8101\n - extended-diagnostics/NG8102\n - guide/angular-compiler-options\n - guide/deprecations\n - guide/strict-mode\n - guide/structural-directives\n - guide/typescript-configuration\n-->\n<!-- links from this doc:\n - api/common/AsyncPipe\n - api/common/NgFor\n - api/common/NgIf\n - api/core/Component\n - api/core/Input\n - api/core/Output\n - api/core/ng-template\n - api/upgrade/static\n - guide/structural-directives#directive-type-checks\n - guide/template-expression-operators\n - guide/template-expression-operators#any-type-cast-function\n - guide/template-typecheck#advice-for-library-authors\n - guide/template-typecheck#basic-mode\n - guide/template-typecheck#checking-of-ngfor\n - guide/template-typecheck#disabling-type-checking-using-any\n - guide/template-typecheck#full-mode\n - guide/template-typecheck#input-setter-coercion\n - guide/template-typecheck#inputs-and-type-checking\n - guide/template-typecheck#ngfor-檢查\n - guide/template-typecheck#overview-of-template-type-checking\n - guide/template-typecheck#strict-mode\n - guide/template-typecheck#strict-null-checks\n - guide/template-typecheck#template-type-checking\n - guide/template-typecheck#troubleshooting-template-errors\n - guide/template-typecheck#嚴格模式\n - guide/template-typecheck#嚴格的空檢查\n - guide/template-typecheck#使用-any-禁用型別檢查\n - guide/template-typecheck#基本模式\n - guide/template-typecheck#完全模式\n - guide/template-typecheck#排除範本錯誤\n - guide/template-typecheck#範本型別檢查\n - guide/template-typecheck#範本型別檢查概述\n - guide/template-typecheck#給庫作者的建議\n - guide/template-typecheck#輸入-setter-強制型別轉換\n - guide/template-typecheck#輸入屬性與型別檢查\n - guide/typescript-configuration\n - https://github.com/angular/angular/issues\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/template-typecheck.md?message=docs%3A%20請簡述你的修改...\n-->"}