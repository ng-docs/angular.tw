{"id":"guide/signals","title":"Angular Signals","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/signals.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"angular-signals\" translation-result=\"on\">Angular 訊號（Signal）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#angular-signals\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Angular Signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#angular-signals\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\"><strong>Angular 訊號（Signal）</strong>是一個體系，可以精細地追蹤你的狀態在整個應用程式中的使用方式和位置，從而允許框架最佳化渲染更新。</p><p translation-origin=\"off\"><strong>Angular Signals</strong> is a system that granularly tracks how and where your state is used throughout an application, allowing the framework to optimize\nrendering updates.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">Angular訊號已經提供了<a href=\"/guide/releases#developer-preview\">開發者預覽版</a>。你已經可以嘗試使用它，但在穩定之前可能會發生變化。</p><p translation-origin=\"off\">Angular signals are available for <a href=\"/guide/releases#developer-preview\">developer preview</a>. They're ready for you to try, but may change before they are stable.</p>\n\n</div>\n<h2 id=\"what-are-signals\" translation-result=\"on\">什麼是訊號？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#what-are-signals\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What are signals?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#what-are-signals\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><strong>訊號</strong>是一個值的包裝器，可以在該值發生變化時通知感興趣的消費者。訊號可以包含任何值，從簡單的原語到複雜的資料結構。</p><p translation-origin=\"off\">A <strong>signal</strong> is a wrapper around a value that can notify interested consumers when that value changes. Signals can contain any value, from simple primitives to complex data structures.</p>\n\n<p translation-result=\"on\">訊號的值總會透過 getter 函式讀取，這使得 Angular 可以追蹤訊號的使用位置。</p><p translation-origin=\"off\">A signal's value is always read through a getter function, which allows Angular to track where the signal is used.</p>\n\n<p translation-result=\"on\">訊號可以是<strong>可寫的</strong>或<strong>唯讀的</strong>。</p><p translation-origin=\"off\">Signals may be either <em>writable</em> or <em>read-only</em>.</p>\n\n<h3 id=\"writable-signals\" translation-result=\"on\">可寫訊號<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#writable-signals\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Writable signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#writable-signals\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">可寫訊號提供了一個 API 來直接更新它們的值。你可以透過使用訊號的初始值呼叫 <code><a href=\"api/core/signal\" class=\"code-anchor\">signal</a></code> 函式來建立可寫訊號：</p><p translation-origin=\"off\">Writable signals provide an API for updating their values directly. You create writable signals by calling the <code><a href=\"api/core/signal\" class=\"code-anchor\">signal</a></code> function with the signal's initial value:</p>\n\n<code-example language=\"ts\">\nconst count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n\n// Signals are getter functions - calling them reads their value.\nconsole.log('The count is: ' + count());\n</code-example>\n<p translation-result=\"on\">要更改可寫訊號的值，你可以直接 <code>.set()</code>：</p><p translation-origin=\"off\">To change the value of a writable signal, you can either <code>.set()</code> it directly:</p>\n\n<code-example language=\"ts\">\ncount.set(3);\n</code-example>\n<p translation-result=\"on\">或者使用 <code>.update()</code> 操作從前一個值計算出一個新值：</p><p translation-origin=\"off\">or use the <code>.update()</code> operation to compute a new value from the previous one:</p>\n\n<code-example language=\"ts\">\n// Increment the count by 1.\ncount.update(value =&gt; value + 1);\n</code-example>\n<p translation-result=\"on\">在處理包含物件的訊號時，有時直接改變該物件很有用。例如，如果物件是一個數組，你可能希望在不完全替換陣列的情況下推送一個新值。要進行這樣的內部更改，請使用 <code>.mutate</code> 方法：</p><p translation-origin=\"off\">When working with signals that contain objects, it's sometimes useful to mutate that object directly. For example, if the object is an array, you may want to push a new value without replacing the array entirely. To make an internal change like this, use the <code>.mutate</code> method:</p>\n\n<code-example language=\"ts\">\nconst todos = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>([{title: 'Learn signals', done: false}]);\n\ntodos.mutate(value =&gt; {\n  // Change the first TODO in the array to 'done: true' without replacing it.\n  value[0].done = true;\n});\n</code-example>\n<p translation-result=\"on\">可寫訊號的型別為 <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>。</p><p translation-origin=\"off\">Writable signals have the type <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>.</p>\n\n<h3 id=\"computed-signals\" translation-result=\"on\">計算（computed）訊號<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Computed signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><strong>計算訊號</strong>是從其他訊號中派生出來的。可以使用 <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code> 並指定推導函式來定義一個：</p><p translation-origin=\"off\">A <strong>computed signal</strong> derives its value from other signals. Define one using <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code> and specifying a derivation function:</p>\n\n<code-example language=\"typescript\">\nconst count: <a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a>&lt;number&gt; = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\nconst doubleCount: <a href=\"api/core/Signal\" class=\"code-anchor\">Signal</a>&lt;number&gt; = <a href=\"api/core/computed\" class=\"code-anchor\">computed</a>(() =&gt; count() * 2);\n</code-example>\n<p translation-result=\"on\"><code>doubleCount</code> 訊號取決於 <code>count</code>。每當 <code>count</code> 更新時，Angular 知道任何依賴於 <code>count</code> 或 <code>doubleCount</code> 東西也需要更新。</p><p translation-origin=\"off\">The <code>doubleCount</code> signal depends on <code>count</code>. Whenever <code>count</code> updates, Angular knows that anything which depends on either <code>count</code> or <code>doubleCount</code> needs to update as well.</p>\n\n<h4 id=\"computeds-are-both-lazily-evaluated-and-memoized\" translation-result=\"on\">計算訊號都是惰性計算和記憶的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computeds-are-both-lazily-evaluated-and-memoized\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Computeds are both lazily evaluated and memoized<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computeds-are-both-lazily-evaluated-and-memoized\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在第一次讀取 <code>doubleCount</code> 之前，不會執行 <code>doubleCount</code> 的派生函式以計算其值。一旦計算出來，這個值就會被快取起來，以後讀取 <code>doubleCount</code> 將返回快取的值而不用重新計算。</p><p translation-origin=\"off\"><code>doubleCount</code>'s derivation function does not run to calculate its value until the first time <code>doubleCount</code> is read. Once calculated, this value is cached, and future reads of <code>doubleCount</code> will return the cached value without recalculating.</p>\n\n<p translation-result=\"on\">當 <code>count</code> 發生變化時，它會告訴 <code>doubleCount</code> 它的快取值不再有效，並且該值只會在下一次讀取 <code>doubleCount</code> 時重新計算。</p><p translation-origin=\"off\">When <code>count</code> changes, it tells <code>doubleCount</code> that its cached value is no longer valid, and the value is only recalculated on the next read of <code>doubleCount</code>.</p>\n\n<p translation-result=\"on\">因此，在計算訊號中執行計算量大的推導（例如過濾陣列）是相當安全的。</p><p translation-origin=\"off\">As a result, it's safe to perform computationally expensive derivations in computed signals, such as filtering arrays.</p>\n\n<h4 id=\"computed-signals-are-not-writable-signals\" translation-result=\"on\">計算訊號不是可寫訊號<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals-are-not-writable-signals\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Computed signals are not writable signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signals-are-not-writable-signals\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">你不能直接為計算訊號賦值。比如，</p><p translation-origin=\"off\">You cannot directly assign values to a computed signal. That is,</p>\n\n<code-example language=\"ts\">\ndoubleCount.set(3);\n</code-example>\n<p translation-result=\"on\">會產生編譯錯誤，因為 <code>doubleCount</code> 不是 <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>。</p><p translation-origin=\"off\">produces a compilation error, because <code>doubleCount</code> is not a <code><a href=\"api/core/WritableSignal\" class=\"code-anchor\">WritableSignal</a></code>.</p>\n\n<h4 id=\"computed-signal-dependencies-are-dynamic\" translation-result=\"on\">計算訊號的依賴性是動態的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signal-dependencies-are-dynamic\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Computed signal dependencies are dynamic<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#computed-signal-dependencies-are-dynamic\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">只能追蹤推導期間實際讀取過的訊號。例如，在此計算中，只會有條件地讀取 <code>count</code> 訊號：</p><p translation-origin=\"off\">Only the signals actually read during the derivation are tracked. For example, in this computed the <code>count</code> signal is only read conditionally:</p>\n\n<code-example language=\"ts\">\nconst showCount = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(false);\nconst count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\nconst conditionalCount = <a href=\"api/core/computed\" class=\"code-anchor\">computed</a>(() =&gt; {\n  if (showCount()) {\n    return `The count is ${count()}.`;\n  } else {\n    return 'Nothing to see here!';\n  }\n});\n</code-example>\n<p translation-result=\"on\">讀取 <code>conditionalCount</code> 時，如果 <code>showCount</code> 為 <code>false</code>，則<strong>沒有</strong>讀取 <code>count</code> 訊號就返回了訊息 “Nothing to see here!”。這意味著對 <code>count</code> 的更新不會導致重新計算。</p><p translation-origin=\"off\">When reading <code>conditionalCount</code>, if <code>showCount</code> is <code>false</code> the \"Nothing to see here!\" message is returned <em>without</em> reading the <code>count</code> signal. This means that updates to <code>count</code> will not result in a recomputation.</p>\n\n<p translation-result=\"on\">如果稍後將 <code>showCount</code> 設定為 <code>true</code> 並再次讀取 <code>conditionalCount</code>，則將重新執行派生並採用 <code>showCount</code> 為 <code>true</code> 的分支，返回顯示 <code>count</code> 值的訊息。對 <code>count</code> 的更改將使 <code>conditionalCount</code> 的快取值無效。</p><p translation-origin=\"off\">If <code>showCount</code> is later set to <code>true</code> and <code>conditionalCount</code> is read again, the derivation will re-execute and take the branch where <code>showCount</code> is <code>true</code>, returning the message which shows the value of <code>count</code>. Changes to <code>count</code> will then invalidate <code>conditionalCount</code>'s cached value.</p>\n\n<p translation-result=\"on\">請注意，可以刪除和新增依賴項。如果 <code>showCount</code> 稍後再次設定為 <code>false</code>，則 <code>count</code> 將不再被視為 <code>conditionalCount</code> 的依賴項。</p><p translation-origin=\"off\">Note that dependencies can be removed as well as added. If <code>showCount</code> is later set to <code>false</code> again, then <code>count</code> will no longer be considered a dependency of <code>conditionalCount</code>.</p>\n\n<h2 id=\"reading-signals-in-onpush-components\" translation-result=\"on\">在 <code>OnPush</code> 型元件中讀取訊號<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-signals-in-onpush-components\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Reading signals in <code>OnPush</code> components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-signals-in-onpush-components\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">當 <code>OnPush</code> 元件在其範本中使用訊號值時，Angular 會將訊號作為該元件的依賴項進行追蹤。當該訊號更新時，Angular 會自動<a href=\"/api/core/ChangeDetectorRef#markforcheck\">標記</a>元件以確保它在下次執行變更檢測時得到更新。有關 <code>OnPush</code> 元件的更多資訊，請參閱<a href=\"/guide/change-detection-skipping-subtrees\">跳過元件子樹</a>指南。</p><p translation-origin=\"off\">When an <code>OnPush</code> component uses a signal's value in its template, Angular will track the signal as a dependency of that component. When that signal is updated, Angular automatically <a href=\"/api/core/ChangeDetectorRef#markforcheck\">marks</a> the component to ensure it gets updated the next time change detection runs. Refer to the <a href=\"/guide/change-detection-skipping-subtrees\">Skipping component subtrees</a> guide for more information about <code>OnPush</code> components.</p>\n\n<h2 id=\"effects\" translation-result=\"on\">副作用（effect）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effects\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effects\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">訊號很有用，因為它們可以在變化時通知感興趣的消費者。<strong>副作用</strong>是一種操作，只要一個或多個訊號值發生變化就會執行。你可以使用 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 函式建立副作用：</p><p translation-origin=\"off\">Signals are useful because they can notify interested consumers when they change. An <strong>effect</strong> is an operation that runs whenever one or more signal values change. You can create an effect with the <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> function:</p>\n\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  console.log(`The current count is: ${count()}`);\n});\n</code-example>\n<p translation-result=\"on\">副作用<strong>至少會執行一次。</strong> 當副作用執行時，它會追蹤任何訊號值讀取。只要這些訊號值中的任何一個發生變化，副作用就會再次執行。與計算訊號類似，副作用會動態追蹤它們的依賴關係，並且僅追蹤在最近一次執行中讀取的訊號。</p><p translation-origin=\"off\">Effects always run <strong>at least once.</strong> When an effect runs, it tracks any signal value reads. Whenever any of these signal values change, the effect runs again. Similar to computed signals, effects keep track of their dependencies dynamically, and only track signals which were read in the most recent execution.</p>\n\n<p translation-result=\"on\">在變化檢測過程中，副作用始終<strong>非同步</strong>執行。</p><p translation-origin=\"off\">Effects always execute <strong>asynchronously</strong>, during the change detection process.</p>\n\n<h3 id=\"uses-for-effects\" translation-result=\"on\">何時使用副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#uses-for-effects\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Uses for effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#uses-for-effects\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在大多數應用程式程式碼中很少需要副作用，但在特定情況下可能會有用。下面是一些需要以 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 作為解決方案的例子：</p><p translation-origin=\"off\">Effects are rarely needed in most application code, but may be useful in specific circumstances. Here are some examples of situations where an <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> might be a good solution:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">記錄正在顯示的資料及其更改時間，用於分析或作為除錯工具</p><p translation-origin=\"off\">Logging data being displayed and when it changes, either for analytics or as a debugging tool</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在資料與 <code>window.localStorage</code> 之間保持同步</p><p translation-origin=\"off\">Keeping data in sync with <code>window.localStorage</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">新增無法用範本語法表達的自訂 DOM 行為</p><p translation-origin=\"off\">Adding custom DOM behavior that can't be expressed with template syntax</p>\n\n</li>\n<li>\n<p translation-result=\"on\">對 <code>&lt;canvas&gt;</code>、圖表庫或其他第三方 UI 庫執行自訂渲染</p><p translation-origin=\"off\">Performing custom rendering to a <code>&lt;canvas&gt;</code>, charting library, or other third party UI library</p>\n\n</li>\n</ul>\n<h4 id=\"when-not-to-use-effects\" translation-result=\"on\">何時不使用副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#when-not-to-use-effects\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">When not to use effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#when-not-to-use-effects\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">要避免使用副作用來傳播狀態變更。這可能會導致 <code>ExpressionChangedAfterItHasBeenChecked</code> 錯誤、導致無限迴圈更新或導致不必要的變更檢測週期。</p><p translation-origin=\"off\">Avoid using effects for propagation of state changes. This can result in <code>ExpressionChangedAfterItHasBeenChecked</code> errors, infinite circular updates, or unnecessary change detection cycles.</p>\n\n<p translation-result=\"on\">由於存在這些風險，在副作用中預設不允許設定訊號，但在絕對必要時也可以啟用。</p><p translation-origin=\"off\">Because of these risks, setting signals is disallowed by default in effects, but can be enabled if absolutely necessary.</p>\n\n<h3 id=\"injection-context\" translation-result=\"on\">注入上下文<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#injection-context\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Injection context<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#injection-context\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">預設情況下，使用 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a>()</code> 函式註冊新的副作用需要“注入上下文”（存取 <code>inject</code> 函式）。提供此功能的最簡單方法是在元件、指令或服務的 <code>constructor</code> 中呼叫 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>：</p><p translation-origin=\"off\">By default, registering a new effect with the <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a>()</code> function requires an \"injection context\" (access to the <code>inject</code> function). The easiest way to provide this is to call <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> within a component, directive, or service <code>constructor</code>:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  constructor() {\n    // Register a new effect.\n    <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n      console.log(`The count is: ${this.count()})`);\n    });\n  }\n}\n</code-example>\n<p translation-result=\"on\">或者，可以將副作用賦值給一個欄位（這也會為其提供一個描述性名稱）。</p><p translation-origin=\"off\">Alternatively, the effect can be assigned to a field (which also gives it a descriptive name).</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  \n  private loggingEffect = <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n    console.log(`The count is: ${this.count()})`);\n  });\n}\n</code-example>\n<p translation-result=\"on\">要在建構函式之外建立副作用，你可以透過 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> 的選項傳遞 <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> 以產生 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>：</p><p translation-origin=\"off\">To create an effect outside of the constructor, you can pass an <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> to <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> via its options:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})\nexport class EffectiveCounterCmp {\n  readonly count = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(0);\n  constructor(private injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {}\n\n  initializeLogging(): void {\n    <a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n      console.log(`The count is: ${this.count()})`);\n    }, {injector: this.injector});\n  }\n}\n</code-example>\n<h3 id=\"destroying-effects\" translation-result=\"on\">銷燬副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#destroying-effects\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Destroying effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#destroying-effects\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當你建立一個副作用時，它會在其閉包上下文被銷燬時自動銷燬。這意味著當元件被銷燬時，在元件內建立的副作用也會被銷燬。指令、服務等中的副作用也是如此。</p><p translation-origin=\"off\">When you create an effect, it is automatically destroyed when its enclosing context is destroyed. This means that effects created within components are destroyed when the component is destroyed. The same goes for effects within directives, services, etc.</p>\n\n<p translation-result=\"on\">副作用返回一個 <code><a href=\"api/core/EffectRef\" class=\"code-anchor\">EffectRef</a></code>，可用於透過 <code>.destroy()</code> 操作手動銷燬它們。這也可以與 <code>manualCleanup</code> 選項結合使用，以建立持續到手動銷燬為止的副作用。當不再需要這些副作用時，要小心地實際清理它們。</p><p translation-origin=\"off\">Effects return an <code><a href=\"api/core/EffectRef\" class=\"code-anchor\">EffectRef</a></code> that can be used to destroy them manually, via the <code>.destroy()</code> operation. This can also be combined with the <code>manualCleanup</code> option to create an effect that lasts until it is manually destroyed. Be careful to actually clean up such effects when they're no longer required.</p>\n\n<h2 id=\"advanced-topics\" translation-result=\"on\">高階主題<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#advanced-topics\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Advanced topics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#advanced-topics\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"signal-equality-functions\" translation-result=\"on\">訊號相等性判定函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#signal-equality-functions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Signal equality functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#signal-equality-functions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">建立訊號時，你可以選擇提供相等性判定函式，該函式將用於檢查新值是否真的與前一個值不同。</p><p translation-origin=\"off\">When creating a signal, you can optionally provide an equality function, which will be used to check whether the new value is actually different than the previous one.</p>\n\n<code-example language=\"ts\">\nimport _ from 'lodash';\n\nconst data = <a href=\"api/core/signal\" class=\"code-anchor\">signal</a>(['test'], {equal: _.isEqual});\n\n// Even though this is a different array instance, the deep equality\n// function will consider the values to be equal, and the <a href=\"api/core/signal\" class=\"code-anchor\">signal</a> won't\n// <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> any updates.\ndata.set(['test']);\n</code-example>\n<p translation-result=\"on\">可以為可寫訊號和計算訊號提供相等性判定函式。</p><p translation-origin=\"off\">Equality functions can be provided to both writable and computed signals.</p>\n\n<p translation-result=\"on\">對於可寫訊號，<code>.mutate()</code> 不會檢查相等性，因為它改變了當前值而不會產生新的參考。</p><p translation-origin=\"off\">For writable signals, <code>.mutate()</code> does not check for equality because it mutates the current value without producing a new reference.</p>\n\n<h3 id=\"reading-without-tracking-dependencies\" translation-result=\"on\">閱讀而不追蹤依賴關係<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-without-tracking-dependencies\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Reading without tracking dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#reading-without-tracking-dependencies\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在極少數情況下，你可能希望在響應式函式（如<code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code>或<code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>）中執行可能讀取訊號的程式碼，但<strong>不希望</strong>建立一個依賴項。</p><p translation-origin=\"off\">Rarely, you may want to execute code which may read signals in a reactive function such as <code><a href=\"api/core/computed\" class=\"code-anchor\">computed</a></code> or <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> <em>without</em> creating a dependency.</p>\n\n<p translation-result=\"on\">例如，假設當 <code>currentUser</code> 發生變化時，應該記錄 <code>counter</code> 的值。建立讀取這兩個訊號的 <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code>：</p><p translation-origin=\"off\">For example, suppose that when <code>currentUser</code> changes, the value of a <code>counter</code> should be logged. Creating an <code><a href=\"api/core/effect\" class=\"code-anchor\">effect</a></code> which reads both signals:</p>\n\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  console.log(`User set to `${currentUser()}` and the counter is ${counter()}`);\n});\n</code-example>\n<p translation-result=\"on\">此範例會在 <code>counter</code> 或 <code>currentUser</code> 發生變化時，記錄一條訊息。但是，如果副作用只應該在 <code>currentUser</code> 更改時才執行，則只會偶爾讀取 <code>counter</code>，因此對 <code>counter</code> 的更改不應記錄新訊息。</p><p translation-origin=\"off\">This example logs a message when <em>either</em> <code>currentUser</code> or <code>counter</code> changes. However, if the effect should only run when <code>currentUser</code> changes, then the read of <code>counter</code> is only incidental and changes to <code>counter</code> shouldn't log a new message.</p>\n\n<p translation-result=\"on\">你可以透過使用 <code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code> 呼叫其 getter 來防止對訊號的讀取被追蹤：</p><p translation-origin=\"off\">You can prevent a signal read from being tracked by calling its getter with <code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code>:</p>\n\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  console.log(`User set to `${currentUser()}` and the counter is ${<a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a>(counter)}`);\n});\n</code-example>\n<p translation-result=\"on\">當副作用需要呼叫一些不應被視為依賴項的外部程式碼時，<code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code> 也很有用：</p><p translation-origin=\"off\"><code><a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a></code> is also useful when an effect needs to invoke some external code which shouldn't be treated as a dependency:</p>\n\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>(() =&gt; {\n  const user = currentUser();\n  <a href=\"api/core/untracked\" class=\"code-anchor\">untracked</a>(() =&gt; {\n    // If the `loggingService` reads signals, they won't be counted as\n    // dependencies of this effect.\n    this.loggingService.log(`User set to ${user}`);\n  });\n});\n</code-example>\n<h3 id=\"effect-cleanup-functions\" translation-result=\"on\">副作用清理函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effect-cleanup-functions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Effect cleanup functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals#effect-cleanup-functions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">副作用可能會啟動長時間執行的操作，如果副作用在第一個操作完成之前就被銷燬或再次執行，則應取消該操作。建立副作用時，你的函式可以用 <code>onCleanup</code> 函式作為其第一個引數。這個 <code>onCleanup</code> 函式允許你註冊一個回呼(Callback)，該回調在副作用的下一次執行開始之前或副作用被銷燬時呼叫。</p><p translation-origin=\"off\">Effects might start long-running operations, which should be cancelled if the effect is destroyed or runs again before the first operation finished. When you create an effect, your function can optionally accept an <code>onCleanup</code> function as its first parameter. This <code>onCleanup</code> function lets you register a callback that is invoked before the next run of the effect begins, or when the effect is destroyed.</p>\n\n<code-example language=\"ts\">\n<a href=\"api/core/effect\" class=\"code-anchor\">effect</a>((onCleanup) =&gt; {\n  const user = currentUser();\n\n  const timer = setTimeout(() =&gt; {\n    console.log(`1 second ago, the user became ${user}`);\n  }, 1000);\n\n  onCleanup(() =&gt; {\n    clearTimeout(timer);\n  });\n});\n</code-example>\n\n  \n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/core/ChangeDetectorRef#markforcheck\n - /guide/change-detection-skipping-subtrees\n - /guide/releases#developer-preview\n - api/animations/trigger\n - api/core/Component\n - api/core/EffectRef\n - api/core/Injector\n - api/core/Signal\n - api/core/WritableSignal\n - api/core/computed\n - api/core/effect\n - api/core/signal\n - api/core/untracked\n - guide/signals#advanced-topics\n - guide/signals#angular-signals\n - guide/signals#angular-訊號signal\n - guide/signals#computed-signal-dependencies-are-dynamic\n - guide/signals#computed-signals\n - guide/signals#computed-signals-are-not-writable-signals\n - guide/signals#computeds-are-both-lazily-evaluated-and-memoized\n - guide/signals#destroying-effects\n - guide/signals#effect-cleanup-functions\n - guide/signals#effects\n - guide/signals#injection-context\n - guide/signals#reading-signals-in-onpush-components\n - guide/signals#reading-without-tracking-dependencies\n - guide/signals#signal-equality-functions\n - guide/signals#uses-for-effects\n - guide/signals#what-are-signals\n - guide/signals#when-not-to-use-effects\n - guide/signals#writable-signals\n - guide/signals#什麼是訊號\n - guide/signals#何時不使用副作用\n - guide/signals#何時使用副作用\n - guide/signals#訊號相等性判定函式\n - guide/signals#副作用effect\n - guide/signals#副作用清理函式\n - guide/signals#可寫訊號\n - guide/signals#在-onpush-型元件中讀取訊號\n - guide/signals#注入上下文\n - guide/signals#計算computed訊號\n - guide/signals#計算訊號不是可寫訊號\n - guide/signals#計算訊號的依賴性是動態的\n - guide/signals#計算訊號都是惰性計算和記憶的\n - guide/signals#銷燬副作用\n - guide/signals#閱讀而不追蹤依賴關係\n - guide/signals#高階主題\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/signals.md?message=docs%3A%20請簡述你的修改...\n-->"}