{"id":"guide/change-detection-slow-computations","title":"Slow computations","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/change-detection-slow-computations.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"slow-computations\" translation-result=\"on\">慢速計算<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-slow-computations#slow-computations\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Slow computations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-slow-computations#slow-computations\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">在每個變更檢測週期上，Angular 都會同步進行：</p><p translation-origin=\"off\">On every change detection cycle, Angular synchronously:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">除非另有指定，否則會根據每個元件的檢測策略估算所有元件中的所有範本表示式</p><p translation-origin=\"off\">Evaluates all template expressions in all components, unless specified otherwise, based on that each component's detection strategy</p>\n\n</li>\n<li>\n<p translation-result=\"on\">執行 <code>ngDoCheck</code> 、 <code>ngAfterContentChecked</code> 、 <code>ngAfterViewChecked</code> 和 <code>ngOnChanges</code> 生命週期鉤子。範本中的單個慢速計算或生命週期鉤子可能會減慢整個變更檢測過程，因為 Angular 會按順序執行計算。</p><p translation-origin=\"off\">Executes the <code>ngDoCheck</code>, <code>ngAfterContentChecked</code>, <code>ngAfterViewChecked</code>, and <code>ngOnChanges</code> lifecycle hooks.\nA single slow computation within a template or a lifecycle hook can slow down the entire change detection process because Angular runs the computations sequentially.</p>\n\n</li>\n</ul>\n<h2 id=\"identifying-slow-computations\" translation-result=\"on\">識別慢速計算<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-slow-computations#identifying-slow-computations\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Identifying slow computations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-slow-computations#identifying-slow-computations\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以用 Angular DevTools 的分析器來識別繁重的計算。在效能時間線中，單擊一個欄以預覽特定的變更檢測週期。這將顯示一個條形圖，該圖顯示了框架在每個元件的變更檢測上花了多長時間。當你點選一個元件時，你可以預覽 Angular 花了多長時間來評估其範本和生命週期鉤子。</p><p translation-origin=\"off\">You can identify heavy computations with Angular DevTools’ profiler. In the performance timeline, click a bar to preview a particular change detection cycle. This displays a bar chart, which shows how long the framework spent in change detection for each component. When you click a component, you can preview how long Angular spent  evaluating its template and lifecycle hooks.</p>\n\n<div class=\"lightbox\">\n  <img alt=\"Angular DevTools profiler preview showing slow computation\" src=\"generated/images/guide/change-detection/slow-computations.png\" width=\"1600\" height=\"887\">\n</div>\n<p translation-result=\"on\">比如，在上面的螢幕截圖中，選擇了所記錄的第二個變更檢測週期，其中 Angular 在這個週期花費了超過 573 毫秒，大部分時間都花在了 <code>EmployeeListComponent</code> 上。在詳細資訊面板中，你可以看到 Angular 花了超過 297 毫秒的時間來估算 <code>EmployeeListComponent</code> 的範本。</p><p translation-origin=\"off\">For example, in the preceding screenshot, the second recorded change detection cycle is selected. Angular spent over 573 ms on this cycle, with the most time spent in the <code>EmployeeListComponent</code>. In the details panel, you can see that Angular spent over 297 ms evaluating the template of the <code>EmployeeListComponent</code>.</p>\n\n<h2 id=\"optimizing-slow-computations\" translation-result=\"on\">最佳化慢速計算<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-slow-computations#optimizing-slow-computations\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Optimizing slow computations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/change-detection-slow-computations#optimizing-slow-computations\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">有幾種技術可以消除慢速計算：</p><p translation-origin=\"off\">Here are several techniques to remove slow computations:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>最佳化底層演算法</strong>。這是推薦的方法。如果你可以加快導致問題的演算法的速度，則可以加快整個變更檢測機制。</p><p translation-origin=\"off\"><strong>Optimizing the underlying algorithm</strong>. This is the recommended approach. If you can speed up the algorithm that is causing the problem, you can speed up the entire change detection mechanism.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>使用純管道進行快取</strong>。你可以將繁重的計算移動到純<a href=\"/guide/pipes\">管道</a>中。與 Angular 上一次呼叫它時相比，只有在檢測到其輸入發生更改時，Angular 才會重新估算純管道。</p><p translation-origin=\"off\"><strong>Caching using pure pipes</strong>. You can move the heavy computation to a pure <a href=\"/guide/pipes\">pipe</a>. Angular reevaluates a pure pipe only if it detects that its inputs have changed, compared to the previous time Angular called it.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>使用記憶化（memoization）</strong>。<a href=\"https://en.wikipedia.org/wiki/Memoization\">記憶化</a>是一種與純管道類似的技術，不同之處在於純管道僅保留計算中的最後一個結果，而記憶化可以儲存多個結果。</p><p translation-origin=\"off\"><strong>Using memoization</strong>. <a href=\"https://en.wikipedia.org/wiki/Memoization\">Memoization</a> is a similar technique to pure pipes, with the difference that pure pipes preserve only the last result from the computation where memoization could store multiple results.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>避免在生命週期鉤子中觸發重繪/迴流</strong>。某些<a href=\"https://web.dev/avoid-large-complex-layouts-and-layout-thrashing/\">操作</a>會導致瀏覽器同步重新計算頁面佈局或重新渲染它。由於迴流和重繪通常很慢，因此你要避免在每個變更檢測週期中都執行它們。</p><p translation-origin=\"off\"><strong>Avoid repaints/reflows in lifecycle hooks</strong>. Certain <a href=\"https://web.dev/avoid-large-complex-layouts-and-layout-thrashing/\">operations</a> cause the browser to either synchronously recalculate the layout of the page or re-render it. Since reflows and repaints are generally slow, you want to avoid performing them in every change detection cycle.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">純管道和記憶化有不同的權衡。與記憶化相比，純管道是 Angular 的內建概念，記憶化是一種用於快取函式結果的通用軟體工程實踐。如果你使用不同的引數頻繁呼叫繁重的計算，則記憶化的記憶體開銷可能會很大。</p><p translation-origin=\"off\">Pure pipes and memoization have different trade-offs. Pure pipes are an Angular built-in concept compared to memoization, which is a general software engineering practice for caching function results. The memory overhead of memoization could be significant if you invoke the heavy computation frequently with different arguments.</p>\n\n\n  <div class=\"reviewed\">最後複查時間：5/4/2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /guide/pipes\n - guide/change-detection-slow-computations#identifying-slow-computations\n - guide/change-detection-slow-computations#optimizing-slow-computations\n - guide/change-detection-slow-computations#slow-computations\n - guide/change-detection-slow-computations#最佳化慢速計算\n - guide/change-detection-slow-computations#慢速計算\n - guide/change-detection-slow-computations#識別慢速計算\n - https://en.wikipedia.org/wiki/Memoization\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/change-detection-slow-computations.md?message=docs%3A%20請簡述你的修改...\n - https://web.dev/avoid-large-complex-layouts-and-layout-thrashing/\n-->"}