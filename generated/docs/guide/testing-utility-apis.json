{"id":"guide/testing-utility-apis","title":"Testing Utility APIs","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/testing-utility-apis.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"testing-utility-apis\" translation-result=\"on\">測試實用工具 API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#testing-utility-apis\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Testing Utility APIs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#testing-utility-apis\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本頁面描述了一些最有用的 Angular 測試特性。</p><p translation-origin=\"off\">This page describes the most useful Angular testing features.</p>\n\n<p translation-result=\"on\">Angular 測試實用工具套件括 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>、<code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 以及一些控制測試環境的函式。<a href=\"guide/testing-utility-apis#testbed-api-summary\"><code>TestBed</code></a> 和 <a href=\"guide/testing-utility-apis#component-fixture-api-summary\"><code>ComponentFixture</code></a> 類是單獨介紹的。</p><p translation-origin=\"off\">The Angular testing utilities include the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>, the <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code>, and a handful of functions that control the test environment.\nThe <a href=\"guide/testing-utility-apis#testbed-api-summary\"><code>TestBed</code></a> and <a href=\"guide/testing-utility-apis#component-fixture-api-summary\"><code>ComponentFixture</code></a> classes are covered separately.</p>\n\n<p translation-result=\"on\">下面是一些獨立函式的摘要，以使用頻率排序：</p><p translation-origin=\"off\">Here's a summary of the stand-alone functions, in order of likely utility:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">函式</nt-wrapper><nt-wrapper translation-origin=\"off\">Function</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在一個特殊的<em>async 測試區域</em>中執行測試（<code>it</code>）的函式體或準備函式（<code>beforeEach</code>）。參閱 <a href=\"guide/testing-components-scenarios#waitForAsync\">waitForAsync</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Runs the body of a test (<code>it</code>) or setup (<code>beforeEach</code>) function within a special <em>async test zone</em>. See <a href=\"guide/testing-components-scenarios#waitForAsync\">waitForAsync</a>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在一個特殊的<em>fakeAsync 測試區域</em>中執行測試（<code>it</code>）的函式體，以便啟用線性風格的控制流。參閱 <a href=\"guide/testing-components-scenarios#fake-async\">fakeAsync</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Runs the body of a test (<code>it</code>) within a special <em>fakeAsync test zone</em>, enabling a linear control flow coding style. See <a href=\"guide/testing-components-scenarios#fake-async\">fakeAsync</a>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">透過在<em> fakeAsync 測試區域</em>中重新整理定時器和微任務（micro-task）佇列來模擬時間的流逝以及非同步活動的完成。<div class=\"alert is-helpful\"> 好奇和執著的讀者可能會喜歡這篇長部落格：<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules\">\"<em>任務、微任務、佇列和排程器</em>\"</a>. </div> 接受一個可選引數，它可以把虛擬時鐘往前推進特定的微秒數。清除排程到那個時間幀中的非同步活動。參閱 <a href=\"guide/testing-components-scenarios#tick\">tick</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Simulates the passage of time and the completion of pending asynchronous activities by flushing both <em>timer</em> and <em>micro-task</em> queues within the <em>fakeAsync test zone</em>. <div class=\"alert is-helpful\"> The curious, dedicated reader might enjoy this lengthy blog post, <a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules\">\"<em>Tasks, microtasks, queues and schedules</em>\"</a>. </div> Accepts an optional argument that moves the virtual clock forward by the specified number of milliseconds, clearing asynchronous activities scheduled within that timeframe. See <a href=\"guide/testing-components-scenarios#tick\">tick</a>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>inject</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">從當前的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 注入器中把一個或多個服務注入到一個測試函式中。它不能用於注入元件自身提供的服務。參閱 <a href=\"guide/testing-components-scenarios#get-injected-services\"><code>debugElement.injector</code></a> 部分的討論。</nt-wrapper><nt-wrapper translation-origin=\"off\">Injects one or more services from the current <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> injector into a test function. It cannot inject a service provided by the component itself. See discussion of the <a href=\"guide/testing-components-scenarios#get-injected-services\">debugElement.injector</a>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">當 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code> 測試程式以正在執行的計時器事件<strong>任務</strong>（排隊中的 <code>setTimeOut</code> 和 <code>setInterval</code> 的回呼(Callback)）結束時，測試會失敗，並顯示一條明確的錯誤資訊。<br>一般來講，測試程式應該以無排隊任務結束。當待執行計時器任務存在時，呼叫 <code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code> 來觸發<strong>任務</strong>佇列，防止該錯誤發生。</nt-wrapper><nt-wrapper translation-origin=\"off\">When a <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> test ends with pending timer event <em>tasks</em> (queued <code>setTimeOut</code> and <code>setInterval</code> callbacks), the test fails with a clear error message. <br> In general, a test should end with no queued tasks. When pending timer tasks are expected, call <code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code> to flush the <em>task</em> queue and avoid the error.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/flushMicrotasks\" class=\"code-anchor\">flushMicrotasks</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">當 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code> 測試程式以待執行<strong>微任務</strong>（比如未解析的 Promise ）結束時，測試會失敗並顯示明確的錯誤資訊。<br>一般來說，測試應該等待微任務結束。當待執行微任務存在時，呼叫 <code><a href=\"api/core/testing/flushMicrotasks\" class=\"code-anchor\">flushMicrotasks</a></code> 來觸發<strong>微任務</strong>佇列，防止該錯誤發生。</nt-wrapper><nt-wrapper translation-origin=\"off\">When a <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> test ends with pending <em>micro-tasks</em> such as unresolved promises, the test fails with a clear error message. <br> In general, a test should wait for micro-tasks to finish. When pending microtasks are expected, call <code><a href=\"api/core/testing/flushMicrotasks\" class=\"code-anchor\">flushMicrotasks</a></code> to flush the  <em>micro-task</em> queue and avoid the error.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">一個服務提供者令牌，用於開啟<a href=\"guide/testing-components-scenarios#automatic-change-detection\">自動變更檢測</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">A provider token for a service that turns on <a href=\"guide/testing-components-scenarios#automatic-change-detection\">automatic change detection</a>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">獲取當前 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 例項。通常用不上，因為 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的靜態類方法已經夠用。<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 例項有一些很少需要用到的方法，它們沒有對應的靜態方法。</nt-wrapper><nt-wrapper translation-origin=\"off\">Gets the current instance of the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>. Usually unnecessary because the static class methods of the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> class are typically sufficient. The <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> instance exposes a few rarely used members that are not available as static methods.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p><a id=\"testbed-class-summary\"></a></p>\n<h2 id=\"testbed-class-summary\" translation-result=\"on\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 類摘要<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#testbed-類摘要\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> class summary<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#testbed-class-summary\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 類是 Angular 測試工具的主要類之一。它的 API 很龐大，可能有點過於複雜，直到你一點一點的探索它們。閱讀本章前面的部分，瞭解了基本的知識以後，再試著瞭解完整 API。</p><p translation-origin=\"off\">The <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> class is one of the principal Angular testing utilities.\nIts API is quite large and can be overwhelming until you've explored it, a little at a time.\nRead the early part of this guide first to get the basics before trying to absorb the full API.</p>\n\n<p translation-result=\"on\">傳給 <code>configureTestingModule</code> 的模組定義是 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 元資料屬性的子集。</p><p translation-origin=\"off\">The module definition passed to <code>configureTestingModule</code> is a subset of the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> metadata properties.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\ntype <a href=\"api/core/testing/TestModuleMetadata\" class=\"code-anchor\">TestModuleMetadata</a> = {\n  providers?: any[];\n  declarations?: any[];\n  imports?: any[];\n  schemas?: Array&lt;<a href=\"api/core/SchemaMetadata\" class=\"code-anchor\">SchemaMetadata</a> | any[]&gt;;\n};\n\n</code-example>\n<p><a id=\"metadata-override-object\"></a></p>\n<p translation-result=\"on\">每一個重載方法接受一個 <code><a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&lt;T&gt;</code>，這裡 <code>T</code> 是適合這個方法的元資料型別，也就是 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>、<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>、<code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 或者 <code>@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code> 的引數。</p><p translation-origin=\"off\">Each override method takes a <code><a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&lt;T&gt;</code> where <code>T</code> is the kind of metadata appropriate to the method, that is, the parameter of an <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>, <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>, <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>, or <code>@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code>.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\ntype <a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&lt;T&gt; = {\n  add?: Partial&lt;T&gt;;\n  remove?: Partial&lt;T&gt;;\n  set?: Partial&lt;T&gt;;\n};\n\n</code-example>\n<p><a id=\"testbed-methods\"></a>\n<a id=\"testbed-api-summary\"></a></p>\n<p translation-result=\"on\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的 API 包含了一系列靜態類方法，它們更新或者參考<strong>全域</strong>的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 例項。</p><p translation-origin=\"off\">The <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> API consists of static class methods that either update or reference a <em>global</em> instance of the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>.</p>\n\n<p translation-result=\"on\">在內部，所有靜態方法在 <code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a>()</code> 函式返回的當前執行時間的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 例項上都有對應的方法。</p><p translation-origin=\"off\">Internally, all static methods cover methods of the current runtime <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> instance, which is also returned by the <code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a>()</code> function.</p>\n\n<p translation-result=\"on\">在 <code>BeforeEach()</code> 內呼叫 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 方法，以確保在執行每個單獨測試時，都有嶄新的開始。</p><p translation-origin=\"off\">Call <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> methods <em>within</em> a <code>beforeEach()</code> to ensure a fresh start before each individual test.</p>\n\n<p translation-result=\"on\">這裡列出了最重要的靜態方法，以使用頻率排序。</p><p translation-origin=\"off\">Here are the most important static methods, in order of likely utility.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">方法</nt-wrapper><nt-wrapper translation-origin=\"off\">Methods</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>configureTestingModule</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">測試墊片（<code>karma-test-shim</code>, <code>browser-test-shim</code>）建立了<a href=\"guide/testing\">初始測試環境</a>和預設測試模組。預設測試模組是使用基本宣告和一些 Angular 服務替代品，它們是所有測試程式都需要的。<br> 呼叫 <code>configureTestingModule</code> 來為一套特定的測試定義測試模組配置，新增和刪除匯入、（元件、指令和管道的）宣告和服務提供者。</nt-wrapper><nt-wrapper translation-origin=\"off\">The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>) establish the <a href=\"guide/testing\">initial test environment</a> and a default testing module. The default testing module is configured with basic declaratives and some Angular service substitutes that every tester needs. <br> Call <code>configureTestingModule</code> to refine the testing module configuration for a particular set of tests by adding and removing imports, declarations (of components, directives, and pipes), and providers.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>compileComponents</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在配置好測試模組之後，非同步編譯它。如果測試模組中的<em>任何一個</em>元件具有 <code>templateUrl</code> 或 <code>styleUrls</code>，那麼你<strong>必須</strong>呼叫這個方法，因為獲取元件的範本或樣式檔案必須是非同步的。參閱 <a href=\"guide/testing-components-scenarios#compile-components\">compileComponents</a>。<br>呼叫完 <code>compileComponents</code> 之後，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置就會在當前測試期間被凍結。</nt-wrapper><nt-wrapper translation-origin=\"off\">Compile the testing module asynchronously after you've finished configuring it. You <strong>must</strong> call this method if <em>any</em> of the testing module components have a <code>templateUrl</code> or <code>styleUrls</code> because fetching component template and style files is necessarily asynchronous. See <a href=\"guide/testing-components-scenarios#compile-components\">compileComponents</a>. <br> After calling <code>compileComponents</code>, the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration is frozen for the duration of the current spec.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>&lt;T&gt;</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">基於當前 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置建立一個類別型為 T 的元件例項。呼叫 <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> 之後，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置就會在當前測試期間被凍結。</nt-wrapper><nt-wrapper translation-origin=\"off\">Create an instance of a component of type <code>T</code> based on the current <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration. After calling <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code>, the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration is frozen for the duration of the current spec.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>overrideModule</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">替換指定的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的元資料。回想一下，模組可以匯入其它模組。<code>overrideModule</code> 方法可以深入到當前測試模組深處，修改其中一個內部模組。</nt-wrapper><nt-wrapper translation-origin=\"off\">Replace metadata for the given <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>. Recall that modules can import other modules. The <code>overrideModule</code> method can reach deeply into the current testing module to modify one of these inner modules.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>overrideComponent</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">替換指定元件類別的元資料，該元件類可能巢狀(Nesting)在一個很深的內部模組中。</nt-wrapper><nt-wrapper translation-origin=\"off\">Replace metadata for the given component class, which could be nested deeply within an inner module.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>overrideDirective</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">替換指定指令類別的元資料，該指令可能巢狀(Nesting)在一個很深的內部模組中。</nt-wrapper><nt-wrapper translation-origin=\"off\">Replace metadata for the given directive class, which could be nested deeply within an inner module.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>overridePipe</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">替換指定管道類別的元資料，該管道可能巢狀(Nesting)在一個很深的內部模組中。</nt-wrapper><nt-wrapper translation-origin=\"off\">Replace metadata for the given pipe class, which could be nested deeply within an inner module.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><a id=\"testbed-inject\"></a> <code>inject</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">從當前 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 注入器獲取一個服務。<code>inject</code> 函式通常都能勝任這項工作，但是如果它沒法提供該服務時就會丟擲一個例外。<br>如果該服務是可選的呢？<br> <code>TestBed.inject()</code> 方法可以接受可選的第二引數，當 Angular 找不到指定的服務提供者時，就會返回該物件（下面這個例子中是 <code>null</code>）：<code-example header=\"app/demo/demo.testbed.spec.ts\" path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"testbed-get-w-null\">\nexpect(TestBed.inject(NotProvided, null)).toBeNull();\n\n</code-example>呼叫了 <code>TestBed.inject</code> 之後然後透過呼叫，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置就會在當前測試期間被凍結。</nt-wrapper><nt-wrapper translation-origin=\"off\">Retrieve a service from the current <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> injector. The <code>inject</code> function is often adequate for this purpose. But <code>inject</code> throws an error if it can't provide the service. <br> What if the service is optional? <br> The <code>TestBed.inject()</code> method takes an optional second parameter, the object to return if Angular can't find the provider (<code>null</code> in this example): <code-example header=\"app/demo/demo.testbed.spec.ts\" path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"testbed-get-w-null\">\nexpect(TestBed.inject(NotProvided, null)).toBeNull();\n\n</code-example> After calling <code>TestBed.inject</code>, the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration is frozen for the duration of the current spec.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><a id=\"testbed-initTestEnvironment\"></a><code>initTestEnvironment</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">為整套測試的執行初始化測試環境。<br> 測試墊片(<code>karma-test-shim</code>, <code>browser-test-shim</code>)會為你呼叫它，所以你很少需要自己呼叫它。<br> 這個方法只能被呼叫<strong>一次</strong>。如果確實需要在測試程式執行期間改變這個預設設定，那麼先呼叫 <code>resetTestEnvironment</code>。<br>指定 Angular 編譯器工廠，<code><a href=\"api/core/PlatformRef\" class=\"code-anchor\">PlatformRef</a></code>，和預設 Angular 測試模組。以 <code>@angular/platform-&lt;platform_name&gt;/testing/&lt;platform_name&gt;</code> 的形式提供非瀏覽器平台的替代品。</nt-wrapper><nt-wrapper translation-origin=\"off\">Initialize the testing environment for the entire test run. <br> The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>) call it for you so there is rarely a reason for you to call it yourself. <br> Call this method <em>exactly once</em>. To change this default in the middle of a test run, call <code>resetTestEnvironment</code> first. <br> Specify the Angular compiler factory, a <code><a href=\"api/core/PlatformRef\" class=\"code-anchor\">PlatformRef</a></code>, and a default Angular testing module. Alternatives for non-browser platforms are available in the general form <code>@angular/platform-&lt;platform_name&gt;/testing/&lt;platform_name&gt;</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>resetTestEnvironment</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">重設初始測試環境，包括預設測試模組在內。</nt-wrapper><nt-wrapper translation-origin=\"off\">Reset the initial test environment, including the default testing module.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">少數 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 例項方法沒有對應的靜態方法。它們很少被使用。</p><p translation-origin=\"off\">A few of the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> instance methods are not covered by static <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> <em>class</em> methods.\nThese are rarely needed.</p>\n\n<p><a id=\"component-fixture-api-summary\"></a></p>\n<h2 id=\"the-componentfixture\" translation-result=\"on\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 類<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#componentfixture-類\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">The <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#the-componentfixture\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code>TestBed.createComponent&lt;T&gt;</code> 會建立一個元件 <code>T</code> 的例項，併為該元件返回一個強型別的 <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code>。</p><p translation-origin=\"off\">The <code>TestBed.createComponent&lt;T&gt;</code> creates an instance of the component <code>T</code> and returns a strongly typed <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> for that component.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 的屬性和方法提供了對元件、它的 DOM 和它的 Angular 環境方面的存取。</p><p translation-origin=\"off\">The <code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> properties and methods provide access to the component, its DOM representation, and aspects of its Angular environment.</p>\n\n<p><a id=\"component-fixture-properties\"></a></p>\n<h3 id=\"componentfixture-properties\" translation-result=\"on\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 的屬性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#componentfixture-的屬性\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> properties<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#componentfixture-properties\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">下面是對測試最重要的屬性，以使用頻率排序。</p><p translation-origin=\"off\">Here are the most important properties for testers, in order of likely utility.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">屬性</nt-wrapper><nt-wrapper translation-origin=\"off\">Properties</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>componentInstance</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">被 <code>TestBed.createComponent</code> 建立的元件類例項。</nt-wrapper><nt-wrapper translation-origin=\"off\">The instance of the component class created by <code>TestBed.createComponent</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>debugElement</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">與元件根元素關聯的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。<br><code>debugElement</code> 提供了在測試和除錯期間深入探查元件及其 DOM 元素的功能。它對於測試者是一個極其重要的屬性。它的大多數主要成員在<a href=\"guide/testing-utility-apis#debug-element-details\">後面</a>都有講解。</nt-wrapper><nt-wrapper translation-origin=\"off\">The <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> associated with the root element of the component. <br> The <code>debugElement</code> provides insight into the component and its DOM element during test and debugging. It's a critical property for testers. The most interesting members are covered <a href=\"guide/testing-utility-apis#debug-element-details\">below</a>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>nativeElement</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元件的原生根 DOM 元素。</nt-wrapper><nt-wrapper translation-origin=\"off\">The native DOM element at the root of the component.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>changeDetectorRef</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元件的 <code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code>。<br>在測試一個擁有 <code><a href=\"api/core/ChangeDetectionStrategy#OnPush\" class=\"code-anchor\">ChangeDetectionStrategy.OnPush</a></code> 的元件，或者在元件的變化測試在你的程式控制下時，<code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code> 是最重要的。</nt-wrapper><nt-wrapper translation-origin=\"off\">The <code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code> for the component. <br> The <code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code> is most valuable when testing a component that has the <code><a href=\"api/core/ChangeDetectionStrategy#OnPush\" class=\"code-anchor\">ChangeDetectionStrategy.OnPush</a></code> method or the component's change detection is under your programmatic control.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p><a id=\"component-fixture-methods\"></a></p>\n<h3 id=\"componentfixture-methods\" translation-result=\"on\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 方法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#componentfixture-方法\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> methods<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#componentfixture-methods\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><strong>fixture</strong> 方法使 Angular 對元件樹執行某些任務。在觸發 Angular 行為來模擬的使用者行為時，呼叫這些方法。</p><p translation-origin=\"off\">The <em>fixture</em> methods cause Angular to perform certain tasks on the component tree.\nCall these method to trigger Angular behavior in response to simulated user action.</p>\n\n<p translation-result=\"on\">下面是對測試最有用的方法。</p><p translation-origin=\"off\">Here are the most useful methods for testers.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">方法</nt-wrapper><nt-wrapper translation-origin=\"off\">Methods</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>detectChanges</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">為元件觸發一輪變化檢查。<br>呼叫它來初始化元件（它呼叫 <code>ngOnInit</code>）。或者在你的測試程式碼改變了元件的資料繫結屬性值後呼叫它。Angular 不能檢測到你已經改變了 <code>personComponent.name</code> 屬性，也不會更新 <code>name</code> 的繫結，直到你呼叫了 <code>detectChanges</code>。<br>之後，執行 <code>checkNoChanges</code>，來確認沒有迴圈更新，除非它被這樣呼叫：<code>detectChanges(false)</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Trigger a change detection cycle for the component. <br> Call it to initialize the component (it calls <code>ngOnInit</code>) and after your test code, change the component's data bound property values. Angular can't see that you've changed <code>personComponent.name</code> and won't update the <code>name</code> binding until you call <code>detectChanges</code>. <br> Runs <code>checkNoChanges</code> afterwards to confirm that there are no circular updates unless called as <code>detectChanges(false)</code>;</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>autoDetectChanges</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果你希望這個夾具自動檢測變更，就把這個設定為 <code>true</code>。<br>當自動檢測開啟時，測試 fixture 監聽 <strong>zone</strong> 事件，並呼叫 <code>detectChanges</code>。當你的測試程式碼直接修改了元件屬性值時，你還是要呼叫 <code>fixture.detectChanges</code> 來觸發資料繫結更新。<br>預設值是 <code>false</code>，喜歡對測試行為進行精細控制的測試者一般保持它為 <code>false</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Set this to <code>true</code> when you want the fixture to detect changes automatically. <br> When autodetect is <code>true</code>, the test fixture calls <code>detectChanges</code> immediately after creating the component. Then it listens for pertinent zone events and calls <code>detectChanges</code> accordingly. When your test code modifies component property values directly, you probably still have to call <code>fixture.detectChanges</code> to trigger data binding updates. <br> The default is <code>false</code>. Testers who prefer fine control over test behavior tend to keep it <code>false</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>checkNoChanges</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">執行一次變更檢測來確認沒有待處理的變化。如果有未處理的變化，它將丟擲一個錯誤。</nt-wrapper><nt-wrapper translation-origin=\"off\">Do a change detection run to make sure there are no pending changes. Throws an exceptions if there are.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>isStable</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果 fixture 當前是<strong>穩定的</strong>，則返回 <code>true</code>。如果有非同步任務沒有完成，則返回 <code>false</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">If the fixture is currently <em>stable</em>, returns <code>true</code>. If there are async tasks that have not completed, returns <code>false</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>whenStable</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">返回一個 Promise，在 fixture 穩定時解析。<br>要想在完成了非同步活動或非同步變更檢測之後再繼續測試，可以對那個 Promise 物件進行掛鉤。參閱 <a href=\"guide/testing-components-scenarios#when-stable\">whenStable</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Returns a promise that resolves when the fixture is stable. <br> To resume testing after completion of asynchronous activity or asynchronous change detection, hook that promise. See <a href=\"guide/testing-components-scenarios#when-stable\">whenStable</a>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>destroy</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">觸發元件的銷燬。</nt-wrapper><nt-wrapper translation-origin=\"off\">Trigger component destruction.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p><a id=\"debug-element-details\"></a></p>\n<h4 id=\"debugelement\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-utility-apis#debugelement\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 提供了對元件的 DOM 的存取。</p><p translation-origin=\"off\">The <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> provides crucial insights into the component's DOM representation.</p>\n\n<p translation-result=\"on\"><code>fixture.debugElement</code> 返回測試根元件的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>，透過它你可以存取（查詢）fixture 的整個元素和元件子樹。</p><p translation-origin=\"off\">From the test root component's <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> returned by <code>fixture.debugElement</code>, you can walk (and query) the fixture's entire element and component subtrees.</p>\n\n<p translation-result=\"on\">下面是 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 最有用的成員，以使用頻率排序。</p><p translation-origin=\"off\">Here are the most useful <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> members for testers, in approximate order of utility:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">成員</nt-wrapper><nt-wrapper translation-origin=\"off\">Members</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>nativeElement</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">對應於瀏覽器中的 DOM 元素</nt-wrapper><nt-wrapper translation-origin=\"off\">The corresponding DOM element in the browser</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">呼叫 <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&lt;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>&gt;)</code> 會在子樹的任意深度中查詢並返回能和<a href=\"guide/testing-utility-apis#query-predicate\">謂詞函式</a>匹配的第一個 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Calling <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&lt;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>&gt;)</code> returns the first <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> that matches the <a href=\"guide/testing-utility-apis#query-predicate\">predicate</a> at any depth in the subtree.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>queryAll</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">呼叫 <code>queryAll(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&lt;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>&gt;)</code> 會在子樹的任意深度中查詢能和<a href=\"guide/testing-utility-apis#query-predicate\">謂詞函式</a>匹配的所有 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Calling <code>queryAll(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&lt;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>&gt;)</code> returns all <code>DebugElements</code> that matches the <a href=\"guide/testing-utility-apis#query-predicate\">predicate</a> at any depth in subtree.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>injector</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">宿主依賴注入器。比如，根元素的元件例項注入器。</nt-wrapper><nt-wrapper translation-origin=\"off\">The host dependency injector. For example, the root element's component instance injector.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>componentInstance</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元素自己的元件例項（如果有）。</nt-wrapper><nt-wrapper translation-origin=\"off\">The element's own component instance, if it has one.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>context</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">為元素提供父級上下文的物件。通常是控制該元素的祖級元件例項。<br>當一個元素被 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 重複，它的上下文為 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code>，它的 <code>$implicit</code> 屬性值是該行的例項值。比如，<code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"</code> 裡的 <code>hero</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">An object that provides parent context for this element. Often an ancestor component instance that governs this element. <br> When an element is repeated within <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>, the context is an <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> whose <code>$implicit</code> property is the value of the row instance value. For example, the <code>hero</code> in <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>children</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 的直接子元素。可以透過繼續深入 <code>children</code> 來遍歷這棵樹。<div class=\"alert is-helpful\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 還有 <code>childNodes</code>，即 <code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> 物件列表。<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 從 <code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> 物件衍生，而且通常節點（node）比元素多。測試者通常忽略普通節點。</div></nt-wrapper><nt-wrapper translation-origin=\"off\">The immediate <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> children. Walk the tree by descending through <code>children</code>. <div class=\"alert is-helpful\"> <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> also has <code>childNodes</code>, a list of <code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> objects. <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> derives from <code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> objects and there are often more nodes than elements. Testers can usually ignore plain nodes. </div></nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>parent</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 的父級。如果 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 是根元素，<code>parent</code> 為 null。</nt-wrapper><nt-wrapper translation-origin=\"off\">The <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> parent. Null if this is the root element.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>name</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元素的標籤名字，如果它是一個元素的話。</nt-wrapper><nt-wrapper translation-origin=\"off\">The element tag name, if it is an element.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>triggerEventHandler</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果在該元素的 <code>listeners</code> 集合中有相應的監聽器，就根據名字觸發這個事件。第二個引數是該處理器函式所需的<em>事件物件</em>。參閱 <a href=\"guide/testing-components-scenarios#trigger-event-handler\">triggerEventHandler</a>。<br>如果事件缺乏監聽器，或者有其它問題，考慮呼叫 <code>nativeElement.dispatchEvent(eventObject)</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Triggers the event by its name if there is a corresponding listener in the element's <code>listeners</code> collection. The second parameter is the <em>event object</em> expected by the handler. See <a href=\"guide/testing-components-scenarios#trigger-event-handler\">triggerEventHandler</a>. <br> If the event lacks a listener or there's some other problem, consider calling <code>nativeElement.dispatchEvent(eventObject)</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>listeners</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元素的 <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 屬性以及/或者元素的事件屬性所附帶的回呼(Callback)函式。</nt-wrapper><nt-wrapper translation-origin=\"off\">The callbacks attached to the component's <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> properties and/or the element's event properties.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>providerTokens</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元件注入器的查詢令牌。包括元件自己的令牌和元件的 <code>providers</code> 元資料中列出來的令牌。</nt-wrapper><nt-wrapper translation-origin=\"off\">This component's injector lookup tokens. Includes the component itself plus the tokens that the component lists in its <code>providers</code> metadata.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>source</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">source 是在源元件範本中查詢這個元素的處所。</nt-wrapper><nt-wrapper translation-origin=\"off\">Where to find this element in the source component template.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>references</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">與模板本地變數（比如 <code>#foo</code>）關聯的詞典物件，關鍵字與本地變數名字配對。</nt-wrapper><nt-wrapper translation-origin=\"off\">Dictionary of objects associated with template local variables (for example, <code>#foo</code>), keyed by the local variable name.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p><a id=\"query-predicate\"></a></p>\n<p translation-result=\"on\"><code>DebugElement.query(predicate)</code> 和 <code>DebugElement.queryAll(predicate)</code> 方法接受一個條件方法，它過濾源元素的子樹，返回匹配的 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</p><p translation-origin=\"off\">The <code>DebugElement.query(predicate)</code> and <code>DebugElement.queryAll(predicate)</code> methods take a predicate that filters the source element's subtree for matching <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>.</p>\n\n<p translation-result=\"on\">這個條件方法是任何接受一個 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 並返回真值的方法。下面的例子查詢所有擁有名為 <code>content</code> 的模組本地變數的所有 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>：</p><p translation-origin=\"off\">The predicate is any method that takes a <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> and returns a <em>truthy</em> value.\nThe following example finds all <code>DebugElements</code> with a reference to a template local variable named \"content\":</p>\n\n<code-example header=\"app/demo/demo.testbed.spec.ts\" path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"custom-predicate\">\n// Filter for DebugElements with a #content reference\nconst contentRefs = el.queryAll( de =&gt; de.references['content']);\n\n</code-example>\n<p translation-result=\"on\">Angular 的 <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 類為常用條件方法提供了三個靜態方法：</p><p translation-origin=\"off\">The Angular <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> class has three static methods for common predicates:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">靜態方法</nt-wrapper><nt-wrapper translation-origin=\"off\">Static method</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>By.all</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">返回所有元素</nt-wrapper><nt-wrapper translation-origin=\"off\">Return all elements</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>By.css(selector)</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">返回符合 CSS 選擇器的元素</nt-wrapper><nt-wrapper translation-origin=\"off\">Return elements with matching CSS selectors</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>By.directive(directive)</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">返回 Angular 能匹配一個指令類例項的所有元素</nt-wrapper><nt-wrapper translation-origin=\"off\">Return elements that Angular matched to an instance of the directive class</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<code-example header=\"app/hero/hero-list.component.spec.ts\" path=\"testing/src/app/hero/hero-list.component.spec.ts\" region=\"by\">\n// Can find <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> either by css selector or by directive\nconst h2 = fixture.debugElement.query(By.css('h2'));\nconst directive = fixture.debugElement.query(By.directive(HighlightDirective));\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/DebugElement\n - guide/testing\n - guide/testing-components-scenarios\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/NgFor\n - api/common/NgForOf\n - api/core/ChangeDetectionStrategy#OnPush\n - api/core/ChangeDetectorRef\n - api/core/Component\n - api/core/DebugElement\n - api/core/DebugNode\n - api/core/Directive\n - api/core/NgModule\n - api/core/Output\n - api/core/Pipe\n - api/core/PlatformRef\n - api/core/Predicate\n - api/core/SchemaMetadata\n - api/core/createComponent\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixtureAutoDetect\n - api/core/testing/MetadataOverride\n - api/core/testing/TestBed\n - api/core/testing/TestModuleMetadata\n - api/core/testing/discardPeriodicTasks\n - api/core/testing/fakeAsync\n - api/core/testing/flushMicrotasks\n - api/core/testing/getTestBed\n - api/core/testing/tick\n - api/core/testing/waitForAsync\n - api/platform-browser/By\n - guide/testing\n - guide/testing-components-scenarios#automatic-change-detection\n - guide/testing-components-scenarios#compile-components\n - guide/testing-components-scenarios#fake-async\n - guide/testing-components-scenarios#get-injected-services\n - guide/testing-components-scenarios#tick\n - guide/testing-components-scenarios#trigger-event-handler\n - guide/testing-components-scenarios#waitForAsync\n - guide/testing-components-scenarios#when-stable\n - guide/testing-utility-apis#component-fixture-api-summary\n - guide/testing-utility-apis#componentfixture-methods\n - guide/testing-utility-apis#componentfixture-properties\n - guide/testing-utility-apis#componentfixture-方法\n - guide/testing-utility-apis#componentfixture-的屬性\n - guide/testing-utility-apis#componentfixture-類\n - guide/testing-utility-apis#debug-element-details\n - guide/testing-utility-apis#debugelement\n - guide/testing-utility-apis#query-predicate\n - guide/testing-utility-apis#testbed-api-summary\n - guide/testing-utility-apis#testbed-class-summary\n - guide/testing-utility-apis#testbed-類摘要\n - guide/testing-utility-apis#testing-utility-apis\n - guide/testing-utility-apis#the-componentfixture\n - guide/testing-utility-apis#測試實用工具-api\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/testing-utility-apis.md?message=docs%3A%20請簡述你的修改...\n - https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules\n-->"}