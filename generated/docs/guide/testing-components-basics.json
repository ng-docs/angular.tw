{"id":"guide/testing-components-basics","title":"Basics of testing components","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/testing-components-basics.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"basics-of-testing-components\" translation-result=\"on\">測試元件的基礎知識<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#basics-of-testing-components\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Basics of testing components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#basics-of-testing-components\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">元件與 Angular 應用的所有其它部分不同，它結合了 HTML 範本和 TypeScript 類別。事實上，元件就是由範本和類<em>一起工作的</em>。要想對元件進行充分的測試，你應該測試它們是否如預期般協同工作。</p><p translation-origin=\"off\">A component, unlike all other parts of an Angular application, combines an HTML template and a TypeScript class.\nThe component truly is the template and the class <em>working together</em>.\nTo adequately test a component, you should test that they work together as intended.</p>\n\n<p translation-result=\"on\">這些測試需要在瀏覽器 DOM 中建立該元件的宿主元素，就像 Angular 所做的那樣，然後檢查元件類與 DOM 的互動是否如範本中描述的那樣工作。</p><p translation-origin=\"off\">Such tests require creating the component's host element in the browser DOM, as Angular does, and investigating the component class's interaction with the DOM as described by its template.</p>\n\n<p translation-result=\"on\">Angular 的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 可以幫你做這種測試，正如你將在下面的章節中看到的那樣。但是，在很多情況下，<em>單獨測試元件類</em>（不需要 DOM 的參與），就能以更簡單，更明顯的方式驗證元件的大部分行為。</p><p translation-origin=\"off\">The Angular <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> facilitates this kind of testing as you'll see in the following sections.\nBut in many cases, <em>testing the component class alone</em>, without DOM involvement, can validate much of the component's behavior in a straightforward, more obvious way.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果你要試驗本指南中所講的應用，請<live-example name=\"testing\" nodownload=\"\">在瀏覽器中執行它</live-example>或<live-example name=\"testing\" downloadonly=\"\">下載並在本地執行它</live-example>。</p><p translation-origin=\"off\">If you'd like to experiment with the application that this guide describes, <live-example name=\"testing\" nodownload=\"\">run it in your browser</live-example> or <live-example name=\"testing\" downloadonly=\"\">download and run it locally</live-example>.</p>\n\n</div>\n<p><a id=\"component-class-testing\"></a></p>\n<h2 id=\"component-class-testing\" translation-result=\"on\">元件類測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#component-class-testing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Component class testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#component-class-testing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以像測試服務類那樣來測試一個元件類本身。</p><p translation-origin=\"off\">Test a component class on its own as you would test a service class.</p>\n\n<p translation-result=\"on\">元件類別的測試應該保持非常乾淨和簡單。它應該只測試一個單元。一眼看上去，你就應該能夠理解正在測試的物件。</p><p translation-origin=\"off\">Component class testing should be kept very clean and simple.\nIt should test only a single unit.\nAt first glance, you should be able to understand what the test is testing.</p>\n\n<p translation-result=\"on\">考慮這個 <code>LightswitchComponent</code>，當用戶單擊該按鈕時，它會開啟和關閉一個指示燈（用螢幕上的一條訊息表示）。</p><p translation-origin=\"off\">Consider this <code>LightswitchComponent</code> which toggles a light on and off (represented by an on-screen message) when the user clicks the button.</p>\n\n<code-example header=\"app/demo/demo.ts (LightswitchComp)\" path=\"testing/src/app/demo/demo.ts\" region=\"LightswitchComp\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lightswitch-comp',\n  template: `\n    &lt;button type=\"button\" (click)=\"clicked()\"&gt;Click me!&lt;/button&gt;\n    &lt;span&gt;{{message}}&lt;/span&gt;`\n})\nexport class LightswitchComponent {\n  isOn = false;\n  clicked() { this.isOn = !this.isOn; }\n  get message() { return `The light is ${this.isOn ? 'On' : 'Off'}`; }\n}\n\n</code-example>\n<p translation-result=\"on\">你可能要測試 <code>clicked()</code> 方法是否切換了燈的<em>開/關</em>狀態並正確設定了這個訊息。</p><p translation-origin=\"off\">You might decide only to test that the <code>clicked()</code> method toggles the light's <em>on/off</em> state and sets the message appropriately.</p>\n\n<p translation-result=\"on\">這個元件類沒有依賴。要測試這種型別的元件類，請遵循與沒有依賴的服務相同的步驟：</p><p translation-origin=\"off\">This component class has no dependencies.\nTo test these types of classes, follow the same steps as you would for a service that has no dependencies:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">使用 new 關鍵字建立一個元件。</p><p translation-origin=\"off\">Create a component using the new keyword.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">呼叫它的 API。</p><p translation-origin=\"off\">Poke at its API.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">對其公開狀態的期望值進行斷言。</p><p translation-origin=\"off\">Assert expectations on its public state.</p>\n\n</li>\n</ol>\n<code-example header=\"app/demo/demo.spec.ts (Lightswitch tests)\" path=\"testing/src/app/demo/demo.spec.ts\" region=\"Lightswitch\">\ndescribe('LightswitchComp', () =&gt; {\n  it('#clicked() should toggle #isOn', () =&gt; {\n    const comp = new LightswitchComponent();\n    expect(comp.isOn)\n      .withContext('off at first')\n      .toBe(false);\n    comp.clicked();\n    expect(comp.isOn)\n      .withContext('on after click')\n      .toBe(true);\n    comp.clicked();\n    expect(comp.isOn)\n      .withContext('off after second click')\n      .toBe(false);\n  });\n\n  it('#clicked() should set #message to \"is on\"', () =&gt; {\n    const comp = new LightswitchComponent();\n    expect(comp.message)\n      .withContext('off at first')\n      .toMatch(/is off/i);\n    comp.clicked();\n    expect(comp.message)\n      .withContext('on after clicked')\n      .toMatch(/is on/i);\n  });\n});\n\n</code-example>\n<p translation-result=\"on\">下面是“<em>英雄之旅</em>”課程中的 <code>DashboardHeroComponent</code>。</p><p translation-origin=\"off\">Here is the <code>DashboardHeroComponent</code> from the <em>Tour of Heroes</em> tutorial.</p>\n\n<code-example header=\"app/dashboard/dashboard-hero.component.ts (component)\" path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"class\">\nexport class DashboardHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() selected = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n<p translation-result=\"on\">它出現在父元件的範本中，把一個<em>英雄</em>繫結到了 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 屬性，並監聽透過<em>所選</em><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 屬性引發的一個事件。</p><p translation-origin=\"off\">It appears within the template of a parent component, which binds a <em>hero</em> to the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> property and listens for an event raised through the <em>selected</em> <code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> property.</p>\n\n<p translation-result=\"on\">你可以測試類程式碼的工作方式，而無需建立 <code>DashboardHeroComponent</code> 或它的父元件。</p><p translation-origin=\"off\">You can test that the class code works without creating the <code>DashboardHeroComponent</code> or its parent component.</p>\n\n<code-example header=\"app/dashboard/dashboard-hero.component.spec.ts (class tests)\" path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"class-only\">\nit('raises the selected event when clicked', () =&gt; {\n  const comp = new DashboardHeroComponent();\n  const hero: Hero = {id: 42, name: 'Test'};\n  comp.hero = hero;\n\n  comp.selected.pipe(first()).subscribe((selectedHero: Hero) =&gt; expect(selectedHero).toBe(hero));\n  comp.click();\n});\n\n</code-example>\n<p translation-result=\"on\">當元件有依賴時，你可能要使用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 來同時建立該元件及其依賴。</p><p translation-origin=\"off\">When a component has dependencies, you might want to use the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> to both create the component and its dependencies.</p>\n\n<p translation-result=\"on\">下列的 <code>WelcomeComponent</code> 依賴於 <code>UserService</code> 來了解要問候的使用者的名字。</p><p translation-origin=\"off\">The following <code>WelcomeComponent</code> depends on the <code>UserService</code> to know the name of the user to greet.</p>\n\n<code-example header=\"app/welcome/welcome.component.ts\" path=\"testing/src/app/welcome/welcome.component.ts\" region=\"class\">\nexport class WelcomeComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  welcome = '';\n  constructor(private userService: UserService) { }\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn ?\n      'Welcome, ' + this.userService.user.name : 'Please log in.';\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">你可以先建立一個能滿足本元件最低需求的 <code>UserService</code>。</p><p translation-origin=\"off\">You might start by creating a mock of the <code>UserService</code> that meets the minimum needs of this component.</p>\n\n<code-example header=\"app/welcome/welcome.component.spec.ts (MockUserService)\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"mock-user-service\">\nclass MockUserService {\n  isLoggedIn = true;\n  user = { name: 'Test User'};\n}\n\n</code-example>\n<p translation-result=\"on\">然後在 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置中提供並注入所有這些<strong>元件</strong>和<em>服務</em>。</p><p translation-origin=\"off\">Then provide and inject <em>both the</em> <strong>component</strong> <em>and the service</em> in the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration.</p>\n\n<code-example header=\"app/welcome/welcome.component.spec.ts (class-only setup)\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-before-each\">\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    // provide the component-under-test and dependent service\n    providers: [\n      WelcomeComponent,\n      { provide: UserService, useClass: MockUserService }\n    ]\n  });\n  // inject both the component and the dependent service.\n  comp = TestBed.inject(WelcomeComponent);\n  userService = TestBed.inject(UserService);\n});\n\n</code-example>\n<p translation-result=\"on\">然後，測驗元件類，別忘了要像 Angular 執行應用時一樣<a href=\"guide/lifecycle-hooks\">呼叫生命週期鉤子方法</a>。</p><p translation-origin=\"off\">Then exercise the component class, remembering to call the <a href=\"guide/lifecycle-hooks\">lifecycle hook methods</a> as Angular does when running the application.</p>\n\n<code-example header=\"app/welcome/welcome.component.spec.ts (class-only tests)\" path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-tests\">\nit('should not have welcome message after construction', () =&gt; {\n  expect(comp.welcome).toBe('');\n});\n\nit('should welcome logged in user after Angular calls ngOnInit', () =&gt; {\n  comp.ngOnInit();\n  expect(comp.welcome).toContain(userService.user.name);\n});\n\nit('should ask user to log in if not logged in after ngOnInit', () =&gt; {\n  userService.isLoggedIn = false;\n  comp.ngOnInit();\n  expect(comp.welcome).not.toContain(userService.user.name);\n  expect(comp.welcome).toContain('log in');\n});\n\n</code-example>\n<h2 id=\"component-dom-testing\" translation-result=\"on\">元件 DOM 測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#component-dom-testing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Component DOM testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#component-dom-testing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">測試元件<em>類</em><a href=\"guide/testing-services\">和測試服務</a>一樣簡單。</p><p translation-origin=\"off\">Testing the component <em>class</em> is as straightforward as <a href=\"guide/testing-services\">testing a service</a>.</p>\n\n<p translation-result=\"on\">但元件不僅僅是它的類別。元件還會與 DOM 以及其他元件進行互動。<em>只對類</em>的測試可以告訴你類別的行為。但它們無法告訴你這個元件是否能正確渲染、響應使用者輸入和手勢，或是整合到它的父元件和子元件中。</p><p translation-origin=\"off\">But a component is more than just its class.\nA component interacts with the DOM and with other components.\nThe <em>class-only</em> tests can tell you about class behavior.\nThey cannot tell you if the component is going to render properly, respond to user input and gestures, or integrate with its parent and child components.</p>\n\n<p translation-result=\"on\">以上所有<em>只對類</em>的測試都不能回答有關元件會如何在螢幕上實際執行方面的關鍵問題。</p><p translation-origin=\"off\">None of the preceding <em>class-only</em> tests can answer key questions about how the components actually behave on screen.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>Lightswitch.clicked()</code> 繫結到了什麼？使用者可以呼叫它嗎？</p><p translation-origin=\"off\">Is <code>Lightswitch.clicked()</code> bound to anything such that the user can invoke it?</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>Lightswitch.message</code> 是否顯示過？</p><p translation-origin=\"off\">Is the <code>Lightswitch.message</code> displayed?</p>\n\n</li>\n<li>\n<p translation-result=\"on\">使用者能否真正選中由 <code>DashboardHeroComponent</code> 顯示的英雄？</p><p translation-origin=\"off\">Can the user actually select the hero displayed by <code>DashboardHeroComponent</code>?</p>\n\n</li>\n<li>\n<p translation-result=\"on\">英雄名字是否按預期顯示的（比如大寫字母）？</p><p translation-origin=\"off\">Is the hero name displayed as expected (such as uppercase)?</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>WelcomeComponent</code> 的範本是否顯示了歡迎資訊？</p><p translation-origin=\"off\">Is the welcome message displayed by the template of <code>WelcomeComponent</code>?</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">對於上面描述的那些簡單元件來說，這些問題可能並不麻煩。但是很多元件都與範本中描述的 DOM 元素進行了複雜的互動，導致一些 HTML 會在元件狀態發生變化時出現和消失。</p><p translation-origin=\"off\">These might not be troubling questions for the preceding simple components illustrated.\nBut many components have complex interactions with the DOM elements described in their templates, causing HTML to appear and disappear as the component state changes.</p>\n\n<p translation-result=\"on\">要回答這些問題，你必須建立與元件關聯的 DOM 元素，你必須檢查 DOM 以確認元件狀態是否在適當的時候正確顯示了，並且你必須模擬使用者與螢幕的互動以確定這些互動是否正確。判斷該元件的行為是否符合預期。</p><p translation-origin=\"off\">To answer these kinds of questions, you have to create the DOM elements associated with the components, you must examine the DOM to confirm that component state displays properly at the appropriate times, and you must simulate user interaction with the screen to determine whether those interactions cause the component to behave as expected.</p>\n\n<p translation-result=\"on\">為了編寫這些型別的測試，你將使用 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的其它特性以及其他的測試輔助函式。</p><p translation-origin=\"off\">To write these kinds of test, you'll use additional features of the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> as well as other testing helpers.</p>\n\n<h3 id=\"cli-generated-tests\" translation-result=\"on\">CLI 產生的測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#cli-generated-tests\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">CLI-generated tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#cli-generated-tests\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當你要求 CLI 產生一個新元件時，它會預設為你建立一個初始的測試檔案。</p><p translation-origin=\"off\">The CLI creates an initial test file for you by default when you ask it to generate a new component.</p>\n\n<p translation-result=\"on\">比如，下列 CLI 命令會在 <code>app/banner</code> 資料夾中產生帶有內聯範本和內聯樣式的 <code>BannerComponent</code>：</p><p translation-origin=\"off\">For example, the following CLI command generates a <code>BannerComponent</code> in the <code>app/banner</code> folder (with inline template and styles):</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng generate component banner --inline-template --inline-style --module app\n\n</code-example>\n<p translation-result=\"on\">它還會產生一個初始測試檔案 <code>banner-external.component.spec.ts</code>，如下所示：</p><p translation-origin=\"off\">It also generates an initial test file for the component, <code>banner-external.component.spec.ts</code>, that looks like this:</p>\n\n<code-example header=\"app/banner/banner-external.component.spec.ts (initial)\" path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v1\">\nimport { <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\n\nimport { BannerComponent } from './banner.component';\n\ndescribe('BannerComponent', () =&gt; {\n  let component: BannerComponent;\n  let fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;BannerComponent&gt;;\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() =&gt; {\n    TestBed.configureTestingModule({declarations: [BannerComponent]}).compileComponents();\n  }));\n\n  beforeEach(() =&gt; {\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () =&gt; {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">由於 <code>compileComponents</code> 是非同步的，所以它使用從 <code>@angular/core/testing</code> 中匯入的實用工具函式 <a href=\"api/core/testing/waitForAsync\"><code>waitForAsync</code></a>。</p><p translation-origin=\"off\">Because <code>compileComponents</code> is asynchronous, it uses the <a href=\"api/core/testing/waitForAsync\"><code>waitForAsync</code></a> utility function imported from <code>@angular/core/testing</code>.</p>\n\n<p translation-result=\"on\">欲知詳情，請參閱 <a href=\"guide/testing-components-scenarios#waitForAsync\">waitForAsync 部分。</a>。</p><p translation-origin=\"off\">Refer to the <a href=\"guide/testing-components-scenarios#waitForAsync\">waitForAsync</a> section for more details.</p>\n\n</div>\n<h3 id=\"reduce-the-setup\" translation-result=\"on\">減少設定程式碼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#reduce-the-setup\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Reduce the setup<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#reduce-the-setup\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">只有這個檔案的最後三行才是真正測試元件的，並且所有這些都斷言了 Angular 可以建立該元件。</p><p translation-origin=\"off\">Only the last three lines of this file actually test the component and all they do is assert that Angular can create the component.</p>\n\n<p translation-result=\"on\">該檔案的其它部分是做設定用的樣板程式碼，<em>可以</em>預見，如果元件演變得更具實質性內容，就會需要更進階的測試。</p><p translation-origin=\"off\">The rest of the file is boilerplate setup code anticipating more advanced tests that <em>might</em> become necessary if the component evolves into something substantial.</p>\n\n<p translation-result=\"on\">下面你將學習這些高階測試特性。現在，你可以從根本上把這個測試檔案減少到一個更容易管理的大小：</p><p translation-origin=\"off\">You'll learn about these advanced test features in the following sections.\nFor now, you can radically reduce this test file to a more manageable size:</p>\n\n<code-example header=\"app/banner/banner-initial.component.spec.ts (minimal)\" path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v2\">\ndescribe('BannerComponent (minimal)', () =&gt; {\n  it('should create', () =&gt; {\n    TestBed.configureTestingModule({declarations: [BannerComponent]});\n    const fixture = TestBed.createComponent(BannerComponent);\n    const component = fixture.componentInstance;\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<p translation-result=\"on\">在這個例子中，傳給 <code>TestBed.configureTestingModule</code> 的元資料物件只是聲明瞭要測試的元件 <code>BannerComponent</code>。</p><p translation-origin=\"off\">In this example, the metadata object passed to <code>TestBed.configureTestingModule</code> simply declares <code>BannerComponent</code>, the component to test.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"configureTestingModule\">\nTestBed.configureTestingModule({declarations: [BannerComponent]});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">沒有必要宣告或匯入任何其他東西。預設的測試模組預先配置了像來自 <code>@angular/platform-browser</code> 的 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 這樣的東西。</p><p translation-origin=\"off\">There's no need to declare or import anything else.\nThe default test module is pre-configured with something like the <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> from <code>@angular/platform-browser</code>.</p>\n\n<p translation-result=\"on\">稍後你會用 <code>imports</code>、<code>providers</code> 和更多可宣告物件的引數來呼叫 <code>TestBed.configureTestingModule()</code>，以滿足你的測試需求。可選方法 <code>override</code> 可以進一步微調此配置的各個方面。</p><p translation-origin=\"off\">Later you'll call <code>TestBed.configureTestingModule()</code> with imports, providers, and more declarations to suit your testing needs.\nOptional <code>override</code> methods can further fine-tune aspects of the configuration.</p>\n\n</div>\n<p><a id=\"create-component\"></a></p>\n<h3 id=\"createcomponent\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#createcomponent\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">在配置好 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 之後，你就可以呼叫它的 <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> 方法了。</p><p translation-origin=\"off\">After configuring <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>, you call its <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a>()</code> method.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"createComponent\">\nconst fixture = TestBed.createComponent(BannerComponent);\n\n</code-example>\n<p translation-result=\"on\"><code>TestBed.createComponent()</code> 會建立 <code>BannerComponent</code> 的例項，它把一個對應元素新增到了測試執行器的 DOM 中，並返回一個<a href=\"guide/testing-components-basics#component-fixture\"><code>ComponentFixture</code></a> 物件。</p><p translation-origin=\"off\"><code>TestBed.createComponent()</code> creates an instance of the <code>BannerComponent</code>, adds a corresponding element to the test-runner DOM, and returns a <a href=\"guide/testing-components-basics#component-fixture\"><code>ComponentFixture</code></a>.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">呼叫 <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> 後不能再重新配置 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>。</p><p translation-origin=\"off\">Do not re-configure <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> after calling <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code>.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> 方法會凍結當前的 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 定義，並把它關閉以防止進一步的配置。</p><p translation-origin=\"off\">The <code><a href=\"api/core/createComponent\" class=\"code-anchor\">createComponent</a></code> method freezes the current <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> definition, closing it to further configuration.</p>\n\n<p translation-result=\"on\">你不能再呼叫任何 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置方法，無論是 <code>configureTestingModule()</code>、<code>get()</code> 還是 <code>override...</code> 方法都不行。如果你這樣做，<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 會丟擲一個錯誤。</p><p translation-origin=\"off\">You cannot call any more <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration methods, not <code>configureTestingModule()</code>, nor <code>get()</code>, nor any of the <code>override...</code> methods.\nIf you try, <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> throws an error.</p>\n\n</div>\n<p><a id=\"component-fixture\"></a></p>\n<h3 id=\"componentfixture\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#componentfixture\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\"><a href=\"api/core/testing/ComponentFixture\">ComponentFixture</a> 是一個測試挽具，用於與所建立的元件及其對應的元素進行互動。</p><p translation-origin=\"off\">The <a href=\"api/core/testing/ComponentFixture\">ComponentFixture</a> is a test harness for interacting with the created component and its corresponding element.</p>\n\n<p translation-result=\"on\">可以透過測試夾具（fixture）存取元件例項，並用 Jasmine 的期望斷言來確認它是否存在：</p><p translation-origin=\"off\">Access the component instance through the fixture and confirm it exists with a Jasmine expectation:</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"componentInstance\">\nconst component = fixture.componentInstance;\nexpect(component).toBeDefined();\n\n</code-example>\n<h3 id=\"beforeeach\"><code>beforeEach()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#beforeeach\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">隨著這個元件的發展，你會新增更多的測試。你不必為每個測試複製 <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的配置程式碼，而是把它重構到 Jasmine 的 <code>beforeEach()</code> 和一些支援變數中：</p><p translation-origin=\"off\">You will add more tests as this component evolves.\nRather than duplicate the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> configuration for each test, you refactor to pull the setup into a Jasmine <code>beforeEach()</code> and some supporting variables:</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v3\">\ndescribe('BannerComponent (with beforeEach)', () =&gt; {\n  let component: BannerComponent;\n  let fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;BannerComponent&gt;;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({declarations: [BannerComponent]});\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should create', () =&gt; {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<p translation-result=\"on\">現在新增一個測試程式，它從 <code>fixture.nativeElement</code> 中獲取元件的元素，並查詢預期的文字。</p><p translation-origin=\"off\">Now add a test that gets the component's element from <code>fixture.nativeElement</code> and looks for the expected text.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-2\">\nit('should contain \"banner works!\"', () =&gt; {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  expect(bannerElement.textContent).toContain('banner works!');\n});\n\n</code-example>\n<p><a id=\"native-element\"></a></p>\n<h3 id=\"nativeelement\"><code>nativeElement</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#nativeelement\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\"><code><a href=\"api/core/testing/ComponentFixture#nativeElement\" class=\"code-anchor\">ComponentFixture.nativeElement</a></code> 的值是 <code>any</code> 型別的。稍後你會遇到 <code><a href=\"api/core/DebugElement#nativeElement\" class=\"code-anchor\">DebugElement.nativeElement</a></code>，它也是 <code>any</code> 型別的。</p><p translation-origin=\"off\">The value of <code><a href=\"api/core/testing/ComponentFixture#nativeElement\" class=\"code-anchor\">ComponentFixture.nativeElement</a></code> has the <code>any</code> type.\nLater you'll encounter the <code><a href=\"api/core/DebugElement#nativeElement\" class=\"code-anchor\">DebugElement.nativeElement</a></code> and it too has the <code>any</code> type.</p>\n\n<p translation-result=\"on\">Angular 在編譯時不知道 <code>nativeElement</code> 是什麼樣的 HTML 元素，甚至可能不是 HTML 元素。該應用可能執行在<em>非瀏覽器平台</em>（如伺服器或 <a href=\"https://developer.mozilla.org/docs/Web/API/Web_Workers_API\">Web Worker）上</a>，在那裡本元素可能具有一個縮小版的 API，甚至根本不存在。</p><p translation-origin=\"off\">Angular can't know at compile time what kind of HTML element the <code>nativeElement</code> is or if it even is an HTML element.\nThe application might be running on a <em>non-browser platform</em>, such as the server or a <a href=\"https://developer.mozilla.org/docs/Web/API/Web_Workers_API\">Web Worker</a>, where the element might have a diminished API or not exist at all.</p>\n\n<p translation-result=\"on\">本指南中的測試都是為了在瀏覽器中執行而設計的，因此 <code>nativeElement</code> 的值始終是 <code>HTMLElement</code> 或其派生類之一。</p><p translation-origin=\"off\">The tests in this guide are designed to run in a browser so a <code>nativeElement</code> value will always be an <code>HTMLElement</code> or one of its derived classes.</p>\n\n<p translation-result=\"on\">知道了它是某種 <code>HTMLElement</code>，就可以用標準的 HTML <code>querySelector</code> 深入瞭解元素樹。</p><p translation-origin=\"off\">Knowing that it is an <code>HTMLElement</code> of some sort, use the standard HTML <code>querySelector</code> to dive deeper into the element tree.</p>\n\n<p translation-result=\"on\">這是另一個呼叫 <code>HTMLElement.querySelector</code> 來獲取段落元素並查詢橫幅文字的測試：</p><p translation-origin=\"off\">Here's another test that calls <code>HTMLElement.querySelector</code> to get the paragraph element and look for the banner text:</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-3\">\nit('should have &lt;p&gt; with \"banner works!\"', () =&gt; {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  const p = bannerElement.querySelector('p')!;\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<p><a id=\"debug-element\"></a></p>\n<h3 id=\"debugelement\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#debugelement\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">Angular 的<em>測試夾具</em>可以直接透過 <code>fixture.nativeElement</code> 提供元件的元素。</p><p translation-origin=\"off\">The Angular <em>fixture</em> provides the component's element directly through the <code>fixture.nativeElement</code>.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"nativeElement\">\nconst bannerElement: HTMLElement = fixture.nativeElement;\n\n</code-example>\n<p translation-result=\"on\">它實際上是一個便利方法，其最終實現為 <code>fixture.debugElement.nativeElement</code>。</p><p translation-origin=\"off\">This is actually a convenience method, implemented as <code>fixture.debugElement.nativeElement</code>.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"debugElement-nativeElement\">\nconst bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\nconst bannerEl: HTMLElement = bannerDe.nativeElement;\n\n</code-example>\n<p translation-result=\"on\">使用這種迂迴的路徑存取元素是有充分理由的。</p><p translation-origin=\"off\">There's a good reason for this circuitous path to the element.</p>\n\n<p translation-result=\"on\"><code>nativeElement</code> 的屬性依賴於其執行時環境。你可以在<em>非瀏覽器</em>平臺上執行這些測試，那些平臺上可能沒有 DOM，或者其模擬的 DOM 不支援完整的 <code>HTMLElement</code> API。</p><p translation-origin=\"off\">The properties of the <code>nativeElement</code> depend upon the runtime environment.\nYou could be running these tests on a <em>non-browser</em> platform that doesn't have a DOM or whose DOM-emulation doesn't support the full <code>HTMLElement</code> API.</p>\n\n<p translation-result=\"on\">Angular 依靠 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 抽象來在其支援的<em>所有平臺上</em>安全地工作。Angular 不會建立 HTML 元素樹，而會建立一個 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 樹來封裝執行時平臺上的<em>原生元素</em>。<code>nativeElement</code> 屬性會解開封裝 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 並返回特定於平台的元素物件。</p><p translation-origin=\"off\">Angular relies on the <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> abstraction to work safely across <em>all supported platforms</em>.\nInstead of creating an HTML element tree, Angular creates a <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> tree that wraps the <em>native elements</em> for the runtime platform.\nThe <code>nativeElement</code> property unwraps the <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> and returns the platform-specific element object.</p>\n\n<p translation-result=\"on\">由於本指南的範例測試只能在瀏覽器中執行，因此 <code>nativeElement</code> 在這些測試中始終是 <code>HTMLElement</code>，你可以在測試中探索熟悉的方法和屬性。</p><p translation-origin=\"off\">Because the sample tests for this guide are designed to run only in a browser, a <code>nativeElement</code> in these tests is always an <code>HTMLElement</code> whose familiar methods and properties you can explore within a test.</p>\n\n<p translation-result=\"on\">下面是把前述測試用 <code>fixture.debugElement.nativeElement</code> 重新實現的版本：</p><p translation-origin=\"off\">Here's the previous test, re-implemented with <code>fixture.debugElement.nativeElement</code>:</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-4\">\nit('should find the &lt;p&gt; with fixture.debugElement.nativeElement)', () =&gt; {\n  const bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\n  const bannerEl: HTMLElement = bannerDe.nativeElement;\n  const p = bannerEl.querySelector('p')!;\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<p translation-result=\"on\">這些 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 還有另一些在測試中很有用的方法和屬性，你可以在本指南的其他地方看到。</p><p translation-origin=\"off\">The <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> has other methods and properties that are useful in tests, as you'll see elsewhere in this guide.</p>\n\n<p translation-result=\"on\">你可以從 Angular 的 core 庫中匯入 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 符號。</p><p translation-origin=\"off\">You import the <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> symbol from the Angular core library.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"import-debug-element\">\nimport { <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> } from '@angular/core';\n\n</code-example>\n<p><a id=\"by-css\"></a></p>\n<h3 id=\"bycss\"><code><a href=\"api/platform-browser/By#css\" class=\"code-anchor\">By.css()</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing-components-basics#bycss\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">雖然本指南中的測試都是在瀏覽器中執行的，但有些應用可能至少要在某些時候執行在不同的平臺上。</p><p translation-origin=\"off\">Although the tests in this guide all run in the browser, some applications might run on a different platform at least some of the time.</p>\n\n<p translation-result=\"on\">比如，作為最佳化策略的一部分，該元件可能會首先在伺服器端渲染，以便在連線不良的裝置上更快地啟動本應用。伺服器端渲染器可能不支援完整的 HTML 元素 API。如果它不支援 <code>querySelector</code>，之前的測試就會失敗。</p><p translation-origin=\"off\">For example, the component might render first on the server as part of a strategy to make the application launch faster on poorly connected devices.\nThe server-side renderer might not support the full HTML element API.\nIf it doesn't support <code>querySelector</code>, the previous test could fail.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 提供了適用於其支援的所有平台的查詢方法。這些查詢方法接受一個<em>謂詞</em>函式，當 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 樹中的一個節點與選擇條件匹配時，該函式返回 <code>true</code>。</p><p translation-origin=\"off\">The <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> offers query methods that work for all supported platforms.\nThese query methods take a <em>predicate</em> function that returns <code>true</code> when a node in the <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> tree matches the selection criteria.</p>\n\n<p translation-result=\"on\">你可以藉助從庫中為執行時平台匯入 <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 類來建立一個<em>謂詞</em>。這裡的 <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 是從瀏覽器平台匯入的。</p><p translation-origin=\"off\">You create a <em>predicate</em> with the help of a <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> class imported from a library for the runtime platform.\nHere's the <code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> import for the browser platform:</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"import-by\">\nimport { <a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a> } from '@angular/platform-browser';\n\n</code-example>\n<p translation-result=\"on\">下面的例子用 <code><a href=\"api/core/DebugElement#query\" class=\"code-anchor\">DebugElement.query()</a></code> 和瀏覽器的 <code>By.css</code> 方法重新實現了前面的測試。</p><p translation-origin=\"off\">The following example re-implements the previous test with <code><a href=\"api/core/DebugElement#query\" class=\"code-anchor\">DebugElement.query()</a></code> and the browser's <code>By.css</code> method.</p>\n\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-5\">\nit('should find the &lt;p&gt; with fixture.debugElement.query(By.css)', () =&gt; {\n  const bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\n  const paragraphDe = bannerDe.query(By.css('p'));\n  const p: HTMLElement = paragraphDe.nativeElement;\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<p translation-result=\"on\">一些值得注意的地方：</p><p translation-origin=\"off\">Some noteworthy observations:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/platform-browser/By#css\" class=\"code-anchor\">By.css()</a></code> 靜態方法使用<a href=\"https://developer.mozilla.org/docs/Web/Guide/CSS/Getting_started/Selectors\" title=\"CSS 選擇器\">標準 CSS 選擇器</a>選擇 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 節點。</p><p translation-origin=\"off\">The <code><a href=\"api/platform-browser/By#css\" class=\"code-anchor\">By.css()</a></code> static method selects <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> nodes with a <a href=\"https://developer.mozilla.org/docs/Web/Guide/CSS/Getting_started/Selectors\" title=\"CSS selectors\">standard CSS selector</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">該查詢為 p 元素返回了一個 <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</p><p translation-origin=\"off\">The query returns a <code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> for the paragraph.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你必須解開封裝那個結果才能得到 p 元素。</p><p translation-origin=\"off\">You must unwrap that result to get the paragraph element.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">當你使用 CSS 選擇器進行過濾並且只測試瀏覽器<em>原生元素</em>的屬性時，用 <code>By.css</code> 方法可能會有點過度。</p><p translation-origin=\"off\">When you're filtering by CSS selector and only testing properties of a browser's <em>native element</em>, the <code>By.css</code> approach might be overkill.</p>\n\n<p translation-result=\"on\">用 <code>HTMLElement</code> 方法（比如 <code>querySelector()</code> 或 <code>querySelectorAll()</code>）進行過濾通常更簡單，更清晰。</p><p translation-origin=\"off\">It's often more straightforward and clear to filter with a standard <code>HTMLElement</code> method such as <code>querySelector()</code> or <code>querySelectorAll()</code>.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/DebugElement\n - guide/testing\n - guide/testing-components-scenarios\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/DebugElement\n - api/core/DebugElement#nativeElement\n - api/core/DebugElement#query\n - api/core/EventEmitter\n - api/core/Input\n - api/core/OnInit\n - api/core/Output\n - api/core/createComponent\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixture#nativeElement\n - api/core/testing/TestBed\n - api/core/testing/waitForAsync\n - api/platform-browser/BrowserModule\n - api/platform-browser/By\n - api/platform-browser/By#css\n - guide/lifecycle-hooks\n - guide/testing-components-basics#basics-of-testing-components\n - guide/testing-components-basics#beforeeach\n - guide/testing-components-basics#bycss\n - guide/testing-components-basics#cli-generated-tests\n - guide/testing-components-basics#cli-產生的測試\n - guide/testing-components-basics#component-class-testing\n - guide/testing-components-basics#component-dom-testing\n - guide/testing-components-basics#component-fixture\n - guide/testing-components-basics#componentfixture\n - guide/testing-components-basics#createcomponent\n - guide/testing-components-basics#debugelement\n - guide/testing-components-basics#nativeelement\n - guide/testing-components-basics#reduce-the-setup\n - guide/testing-components-basics#減少設定程式碼\n - guide/testing-components-basics#測試元件的基礎知識\n - guide/testing-components-basics#元件-dom-測試\n - guide/testing-components-basics#元件類測試\n - guide/testing-components-scenarios#waitForAsync\n - guide/testing-services\n - https://developer.mozilla.org/docs/Web/API/Web_Workers_API\n - https://developer.mozilla.org/docs/Web/Guide/CSS/Getting_started/Selectors\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/testing-components-basics.md?message=docs%3A%20請簡述你的修改...\n-->"}