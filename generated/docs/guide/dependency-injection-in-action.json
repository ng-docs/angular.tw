{"id":"guide/dependency-injection-in-action","title":"Dependency injection in action","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/dependency-injection-in-action.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"dependency-injection-in-action\" translation-result=\"on\">依賴注入實戰<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#dependency-injection-in-action\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Dependency injection in action<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#dependency-injection-in-action\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本章涉及到 Angular 依賴注入（DI）的很多特性。</p><p translation-origin=\"off\">This guide explores many of the features of dependency injection (DI) in Angular.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">包含本指南中程式碼片段的可工作範例，參閱<live-example></live-example>。</p><p translation-origin=\"off\">See the <live-example></live-example> for a working example containing the code snippets in this guide.</p>\n\n</div>\n<p><a id=\"multiple-service-instances\"></a></p>\n<h2 id=\"multiple-service-instances-sandboxing\" translation-result=\"on\">多個服務例項（沙箱式隔離）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#multiple-service-instances-sandboxing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Multiple service instances (sandboxing)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#multiple-service-instances-sandboxing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在元件樹的<em>同一個級別</em>上，有時需要一個服務的多個例項。</p><p translation-origin=\"off\">Sometimes you want multiple instances of a service at <em>the same level</em> of the component hierarchy.</p>\n\n<p translation-result=\"on\">一個用來儲存其伴生元件的例項狀態的服務就是個好例子。每個元件都需要該服務的單獨例項。每個服務有自己的工作狀態，與其它元件的服務和狀態隔離。這叫做<em>沙箱化</em>，因為每個服務和元件例項都在自己的沙箱裡執行。</p><p translation-origin=\"off\">A good example is a service that holds state for its companion component instance.\nYou need a separate instance of the service for each component.\nEach service has its own work-state, isolated from the service-and-state of a different component.\nThis is called <em>sandboxing</em> because each service and component instance has its own sandbox to play in.</p>\n\n<p><a id=\"hero-bios-component\"></a></p>\n<p translation-result=\"on\">在這個例子中，<code>HeroBiosComponent</code> 渲染了 <code>HeroBioComponent</code> 的三個例項。</p><p translation-origin=\"off\">In this example, <code>HeroBiosComponent</code> presents three instances of <code>HeroBioComponent</code>.</p>\n\n<code-example header=\"src/app/hero-bios.component.ts\" path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"simple\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-bios',\n  template: `\n    &lt;app-hero-bio [heroId]=\"1\"&gt;&lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"2\"&gt;&lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"3\"&gt;&lt;/app-hero-bio&gt;`,\n  providers: [HeroService]\n})\nexport class HeroBiosComponent {\n}\n\n</code-example>\n<p translation-result=\"on\">每個 <code>HeroBioComponent</code> 都能編輯一個英雄的生平。<code>HeroBioComponent</code> 依賴 <code>HeroCacheService</code> 服務來對該英雄進行讀取、快取和執行其它持久化操作。</p><p translation-origin=\"off\">Each <code>HeroBioComponent</code> can edit a single hero's biography.\n<code>HeroBioComponent</code> relies on <code>HeroCacheService</code> to fetch, cache, and perform other persistence operations on that hero.</p>\n\n<code-example header=\"src/app/hero-cache.service.ts\" path=\"dependency-injection-in-action/src/app/hero-cache.service.ts\" region=\"service\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroCacheService {\n  hero!: Hero;\n  constructor(private heroService: HeroService) {}\n\n  fetchCachedHero(id: number) {\n    if (!this.hero) {\n      this.hero = this.heroService.getHeroById(id);\n    }\n    return this.hero;\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">這三個 <code>HeroBioComponent</code> 例項不能共享同一個 <code>HeroCacheService</code> 例項。否則它們會相互衝突，爭相把自己的英雄放在快取裡面。</p><p translation-origin=\"off\">Three instances of <code>HeroBioComponent</code> can't share the same instance of <code>HeroCacheService</code>, as they'd be competing with each other to determine which hero to cache.</p>\n\n<p translation-result=\"on\">它們應該透過在自己的元資料（metadata）<code>providers</code> 數組裡面列出 <code>HeroCacheService</code>, 這樣每個 <code>HeroBioComponent</code> 就能<em>擁有</em>自己獨立的 <code>HeroCacheService</code> 例項了。</p><p translation-origin=\"off\">Instead, each <code>HeroBioComponent</code> gets its <em>own</em> <code>HeroCacheService</code> instance by listing <code>HeroCacheService</code> in its metadata <code>providers</code> array.</p>\n\n<code-example header=\"src/app/hero-bio.component.ts\" path=\"dependency-injection-in-action/src/app/hero-bio.component.ts\" region=\"component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-bio',\n  template: `\n    &lt;h4&gt;{{hero.name}}&lt;/h4&gt;\n    &lt;ng-content&gt;&lt;/ng-content&gt;\n    &lt;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> cols=\"25\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.description\"&gt;&lt;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>&gt;`,\n  providers: [HeroCacheService]\n})\n\nexport class HeroBioComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>  {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() heroId = 0;\n\n  constructor(private heroCache: HeroCacheService) { }\n\n  ngOnInit() { this.heroCache.fetchCachedHero(this.heroId); }\n\n  get hero() { return this.heroCache.hero; }\n}\n\n</code-example>\n<p translation-result=\"on\">父元件 <code>HeroBiosComponent</code> 把一個值繫結到 <code>heroId</code>。<code>ngOnInit</code> 把該 <code>id</code> 傳遞到服務，然後服務獲取和快取英雄。<code>hero</code> 屬性的 getter 從服務裡面獲取快取的英雄，並在範本裡顯示它繫結到屬性值。</p><p translation-origin=\"off\">The parent <code>HeroBiosComponent</code> binds a value to <code>heroId</code>.\n<code>ngOnInit</code> passes that ID to the service, which fetches and caches the hero.\nThe getter for the <code>hero</code> property pulls the cached hero from the service.\nThe template displays this data-bound property.</p>\n\n<p translation-result=\"on\">到<live-example name=\"dependency-injection-in-action\">現場演練</live-example>中找到這個例子，確認三個 <code>HeroBioComponent</code> 例項擁有自己獨立的英雄資料快取。</p><p translation-origin=\"off\">Find this example in <live-example name=\"dependency-injection-in-action\">live code</live-example> and confirm that the three <code>HeroBioComponent</code> instances have their own cached hero data.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Bios\" src=\"generated/images/guide/dependency-injection-in-action/hero-bios.png\" width=\"199\" height=\"317\">\n</div>\n<p><a id=\"qualify-dependency-lookup\"></a></p>\n<h2 id=\"qualify-dependency-lookup-with-parameter-decorators\" translation-result=\"on\">使用引數裝飾器來限定依賴查詢方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#qualify-dependency-lookup-with-parameter-decorators\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Qualify dependency lookup with parameter decorators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#qualify-dependency-lookup-with-parameter-decorators\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">當類需要某個依賴項時，該依賴項就會作為引數新增到類別的建構函式中。當 Angular 需要例項化該類時，就會呼叫 DI 框架來提供該依賴。預設情況下，DI 框架會在注入器樹中查詢一個提供者，從該元件的區域性注入器開始，如果需要，則沿著注入器樹向上冒泡，直到根注入器。</p><p translation-origin=\"off\">When a class requires a dependency, that dependency is added to the constructor as a parameter.\nWhen Angular needs to instantiate the class, it calls upon the DI framework to supply the dependency.\nBy default, the DI framework searches for a provider in the injector hierarchy, starting at the component's local injector, and if necessary bubbling up through the injector tree until it reaches the root injector.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">第一個配置過該提供者的注入器就會把依賴（服務例項或值）提供給這個建構函式</p><p translation-origin=\"off\">The first injector configured with a provider supplies the dependency (a service instance or value) to the constructor</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果在根注入器中也沒有找到提供者，則 DI 框架將會丟擲一個錯誤</p><p translation-origin=\"off\">If no provider is found in the root injector, the DI framework throws an error</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">透過在類別的建構函式中對服務引數使用<em>引數裝飾器</em>，可以提供一些選項來修改預設的搜尋行為。</p><p translation-origin=\"off\">There are a number of options for modifying the default search behavior, using <em>parameter decorators</em> on the service-valued parameters of a class constructor.</p>\n\n<p><a id=\"optional\"></a></p>\n<h3 id=\"make-a-dependency-optional-and-limit-search-with-host\" translation-result=\"on\">用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 來讓依賴是可選的，以及使用 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 來限定搜尋方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#用-optional-來讓依賴是可選的以及使用-host-來限定搜尋方式\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Make a dependency <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> and limit search with <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#make-a-dependency-optional-and-limit-search-with-host\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">依賴可以註冊在元件樹的任何層級上。當元件請求某個依賴時，Angular 會從該元件的注入器找起，沿著注入器樹向上，直到找到了第一個滿足要求的提供者。如果沒找到依賴，Angular 就會丟擲一個錯誤。</p><p translation-origin=\"off\">Dependencies can be registered at any level in the component hierarchy.\nWhen a component requests a dependency, Angular starts with that component's injector and walks up the injector tree until it finds the first suitable provider.\nAngular throws an error if it can't find the dependency during that walk.</p>\n\n<p translation-result=\"on\">某些情況下，你需要限制搜尋，或容忍依賴項的缺失。你可以使用元件建構函式引數上的 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 和 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 這兩個限定裝飾器來修改 Angular 的搜尋行為。</p><p translation-origin=\"off\">In some cases, you need to limit the search or accommodate a missing dependency.\nYou can modify Angular's search behavior with the <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> and <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> qualifying decorators on a service-valued parameter of the component's constructor.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 屬性裝飾器告訴 Angular 當找不到依賴時就返回 null</p><p translation-origin=\"off\">The <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> property decorator tells Angular to return null when it can't find the dependency</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 屬性裝飾器會禁止在<em>宿主元件</em>以上的搜尋。宿主元件通常就是請求該依賴的那個元件。不過，當該元件投影進某個<em>父</em>元件時，那個父元件就會變成宿主。下面的例子中介紹了第二種情況。</p><p translation-origin=\"off\">The <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> property decorator stops the upward search at the <em>host component</em>.\nThe host component is typically the component requesting the dependency.\nHowever, when this component is projected into a <em>parent</em> component, that parent component becomes the host.\nThe following example covers this second case.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">如下例所示，這些裝飾器可以獨立使用，也可以同時使用。這個 <code>HeroBiosAndContactsComponent</code> 是你<a href=\"guide/dependency-injection-in-action#hero-bios-component\">以前</a>見過的那個 <code>HeroBiosComponent</code> 的修改版。</p><p translation-origin=\"off\">These decorators can be used individually or together, as shown in the example.\nThis <code>HeroBiosAndContactsComponent</code> is a revision of <code>HeroBiosComponent</code> which you looked at <a href=\"guide/dependency-injection-in-action#hero-bios-component\">above</a>.</p>\n\n<code-example header=\"src/app/hero-bios.component.ts (HeroBiosAndContactsComponent)\" path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"hero-bios-and-contacts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-bios-and-contacts',\n  template: `\n    &lt;app-hero-bio [heroId]=\"1\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"2\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"3\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;`,\n  providers: [HeroService]\n})\nexport class HeroBiosAndContactsComponent {\n  constructor(logger: LoggerService) {\n    logger.logInfo('Creating HeroBiosAndContactsComponent');\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">注意看範本：</p><p translation-origin=\"off\">Focus on the template:</p>\n\n<code-example header=\"src/app/hero-bios.component.ts\" path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"template\">\ntemplate: `\n  &lt;app-hero-bio [heroId]=\"1\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n  &lt;app-hero-bio [heroId]=\"2\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n  &lt;app-hero-bio [heroId]=\"3\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;`,\n\n</code-example>\n<p translation-result=\"on\">在 <code>&lt;hero-bio&gt;</code> 標籤中是一個新的 <code>&lt;hero-contact&gt;</code> 元素。Angular 就會把相應的 <code>HeroContactComponent</code><em>投影</em>或透傳（<em>transclude</em>）進 <code>HeroBioComponent</code> 的視圖裡，將它放在 <code>HeroBioComponent</code> 範本的 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 標籤槽裡。</p><p translation-origin=\"off\">Now there's a new <code>&lt;hero-contact&gt;</code> element between the <code>&lt;hero-bio&gt;</code> tags.\nAngular <em>projects</em>, or <em>transcludes</em>, the corresponding <code>HeroContactComponent</code> into the <code>HeroBioComponent</code> view, placing it in the <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> slot of the <code>HeroBioComponent</code> template.</p>\n\n<code-example header=\"src/app/hero-bio.component.ts (template)\" path=\"dependency-injection-in-action/src/app/hero-bio.component.ts\" region=\"template\">\ntemplate: `\n  &lt;h4&gt;{{hero.name}}&lt;/h4&gt;\n  &lt;ng-content&gt;&lt;/ng-content&gt;\n  &lt;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> cols=\"25\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.description\"&gt;&lt;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>&gt;`,\n\n</code-example>\n<p translation-result=\"on\">從 <code>HeroContactComponent</code> 獲得的英雄電話號碼，被投影到上面的英雄描述裡，結果如下：</p><p translation-origin=\"off\">The result is shown below, with the hero's telephone number from <code>HeroContactComponent</code> projected above the hero description.</p>\n\n<div class=\"lightbox\">\n<img alt=\"bio and contact\" src=\"generated/images/guide/dependency-injection-in-action/hero-bio-and-content.png\" width=\"199\" height=\"92\">\n</div>\n<p translation-result=\"on\">這裡的 <code>HeroContactComponent</code> 示範了限定型裝飾器。</p><p translation-origin=\"off\">Here's <code>HeroContactComponent</code>, which demonstrates the qualifying decorators.</p>\n\n<code-example header=\"src/app/hero-contact.component.ts\" path=\"dependency-injection-in-action/src/app/hero-contact.component.ts\" region=\"component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-contact',\n  template: `\n  &lt;div&gt;Phone #: {{phoneNumber}}\n  &lt;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hasLogger\"&gt;!!!&lt;/span&gt;&lt;/div&gt;`\n})\nexport class HeroContactComponent {\n\n  hasLogger = false;\n\n  constructor(\n      @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() // limit to the host component's instance of the HeroCacheService\n      private heroCache: HeroCacheService,\n\n      @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()     // limit search for logger; hides the application-wide logger\n      @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() // ok if the logger doesn't exist\n      private loggerService?: LoggerService\n  ) {\n    if (loggerService) {\n      this.hasLogger = true;\n      loggerService.logInfo('HeroContactComponent can log!');\n    }\n  }\n\n  get phoneNumber() { return this.heroCache.hero.phone; }\n\n}\n\n</code-example>\n<p translation-result=\"on\">注意建構函式的引數。</p><p translation-origin=\"off\">Focus on the constructor parameters.</p>\n\n<code-example header=\"src/app/hero-contact.component.ts\" path=\"dependency-injection-in-action/src/app/hero-contact.component.ts\" region=\"ctor-params\">\n@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() // limit to the host component's instance of the HeroCacheService\nprivate heroCache: HeroCacheService,\n\n@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()     // limit search for logger; hides the application-wide logger\n@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() // ok if the logger doesn't exist\nprivate loggerService?: LoggerService\n\n</code-example>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 函式是建構函式屬性 <code>heroCache</code> 的裝飾器，確保從其父元件 <code>HeroBioComponent</code> 得到一個快取服務。如果該父元件中沒有該服務，Angular 就會丟擲錯誤，即使元件樹裡的再上級有某個元件擁有這個服務，還是會丟擲錯誤。</p><p translation-origin=\"off\">The <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> function decorating the  <code>heroCache</code> constructor property ensures that you get a reference to the cache service from the parent <code>HeroBioComponent</code>.\nAngular throws an error if the parent lacks that service, even if a component higher in the component tree includes it.</p>\n\n<p translation-result=\"on\">另一個 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 函式是建構函式屬性 <code>loggerService</code> 的裝飾器。在本應用程式中只有一個在 <code>AppComponent</code> 級提供的 <code>LoggerService</code> 例項。該宿主 <code>HeroBioComponent</code> 沒有自己的 <code>LoggerService</code> 提供者。</p><p translation-origin=\"off\">A second <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> function decorates the <code>loggerService</code> constructor property.\nThe only <code>LoggerService</code> instance in the application is provided at the <code>AppComponent</code> level.\nThe host <code>HeroBioComponent</code> doesn't have its own <code>LoggerService</code> provider.</p>\n\n<p translation-result=\"on\">如果沒有同時使用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 裝飾器的話，Angular 就會丟擲錯誤。當該屬性帶有 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 標記時，Angular 就會把 <code>loggerService</code> 設定為 null，並繼續執行元件而不會丟擲錯誤。</p><p translation-origin=\"off\">Angular throws an error if you haven't also decorated the property with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>.\nWhen the property is marked as optional, Angular sets <code>loggerService</code> to null and the rest of the component adapts.</p>\n\n<p translation-result=\"on\">下面是 <code>HeroBiosAndContactsComponent</code> 的執行結果：</p><p translation-origin=\"off\">Here's <code>HeroBiosAndContactsComponent</code> in action.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Bios with contact into\" src=\"generated/images/guide/dependency-injection-in-action/hero-bios-and-contacts.png\" width=\"206\" height=\"393\">\n</div>\n<p translation-result=\"on\">如果註釋掉 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 裝飾器，Angular 就會沿著注入器樹往上走，直到在 <code>AppComponent</code> 中找到該日誌服務。日誌服務的邏輯加了進來，所顯示的英雄資訊增加了 \"!!!\" 標記，這表明確實找到了日誌服務。</p><p translation-origin=\"off\">If you comment out the <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> decorator, Angular walks up the injector ancestor tree until it finds the logger at the <code>AppComponent</code> level.\nThe logger logic kicks in and the hero display updates with the \"!!!\" marker to indicate that the logger was found.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Without @Host\" src=\"generated/images/guide/dependency-injection-in-action/hero-bio-contact-no-host.png\" width=\"199\" height=\"93\">\n</div>\n<p translation-result=\"on\">如果你恢復 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 裝飾器並註釋掉 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code>，應用程式在宿主元件級別找不到所需的記錄器時會丟擲例外。</p><p translation-origin=\"off\">If you restore the <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> decorator and comment out <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code>, the application throws an exception when it cannot find the required logger at the host component level.</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nEXCEPTION: No provider for LoggerService! (HeroContactComponent -&gt; LoggerService)\n\n</code-example>\n<h3 id=\"supply-a-custom-provider-with-inject\" translation-result=\"on\">使用 <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 指定自訂提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#使用-inject-指定自訂提供者\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Supply a custom provider with <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#supply-a-custom-provider-with-inject\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">自訂提供者讓你可以為隱含依賴提供一個具體的實現，比如內建瀏覽器 API。下面的例子使用 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 來提供 <a href=\"https://developer.mozilla.org/docs/Web/API/Window/localStorage\">localStorage</a>，將其作為 <code>BrowserStorageService</code> 的依賴項。</p><p translation-origin=\"off\">Using a custom provider allows you to provide a concrete implementation for implicit dependencies, such as built-in browser APIs.\nThe following example uses an <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> to provide the <a href=\"https://developer.mozilla.org/docs/Web/API/Window/localStorage\">localStorage</a> browser API as a dependency in the <code>BrowserStorageService</code>.</p>\n\n<code-example header=\"src/app/storage.service.ts\" path=\"dependency-injection-in-action/src/app/storage.service.ts\">\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>, <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>, <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const BROWSER_STORAGE = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&lt;Storage&gt;('Browser Storage', {\n  providedIn: 'root',\n  factory: () =&gt; localStorage\n});\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class BrowserStorageService {\n  constructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(BROWSER_STORAGE) public storage: Storage) {}\n\n  get(key: string) {\n    return this.storage.getItem(key);\n  }\n\n  set(key: string, value: string) {\n    this.storage.setItem(key, value);\n  }\n\n  remove(key: string) {\n    this.storage.removeItem(key);\n  }\n\n  clear() {\n    this.storage.clear();\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\"><code>factory</code> 函式返回 window 物件上的 <code>localStorage</code> 屬性。<code><a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 裝飾器修飾一個建構函式引數，用於為某個依賴提供自訂提供者。現在，就可以在測試期間使用 <code>localStorage</code> 的 Mock API 來覆蓋這個提供者了，而不必與真實的瀏覽器 API 進行互動。</p><p translation-origin=\"off\">The <code>factory</code> function returns the <code>localStorage</code> property that is attached to the browser window object.\nThe <code><a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> decorator is a constructor parameter used to specify a custom provider of a dependency.\nThis custom provider can now be overridden during testing with a mock API of <code>localStorage</code> instead of interacting with real browser APIs.</p>\n\n<p><a id=\"skip\"></a></p>\n<h3 id=\"modify-the-provider-search-with-self-and-skipself\" translation-result=\"on\">使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 和 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 來修改提供者的搜尋方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#使用-self-和-skipself-來修改提供者的搜尋方式\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Modify the provider search with <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> and <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#modify-the-provider-search-with-self-and-skipself\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">注入器也可以透過建構函式的引數裝飾器來指定範圍。下面的例子就在 <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 類別的 <code>providers</code> 中使用瀏覽器的 <code>sessionStorage</code> API 覆蓋了 <code>BROWSER_STORAGE</code> 令牌。同一個 <code>BrowserStorageService</code> 在建構函式中使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 和 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 裝飾器注入了兩次，來分別指定由哪個注入器來提供依賴。</p><p translation-origin=\"off\">Providers can also be scoped by injector through constructor parameter decorators.\nThe following example overrides the <code>BROWSER_STORAGE</code> token in the <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> class <code>providers</code> with the <code>sessionStorage</code> browser API.\nThe same <code>BrowserStorageService</code> is injected twice in the constructor, decorated with <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> and <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> to define which injector handles the provider dependency.</p>\n\n<code-example header=\"src/app/storage.component.ts\" path=\"dependency-injection-in-action/src/app/storage.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/Self\" class=\"code-anchor\">Self</a>, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> } from '@angular/core';\nimport { BROWSER_STORAGE, BrowserStorageService } from './storage.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-storage',\n  template: `\n    Open the inspector to see the local/session storage keys:\n\n    &lt;h3&gt;Session Storage&lt;/h3&gt;\n    &lt;button type=\"button\" (click)=\"setSession()\"&gt;Set Session Storage&lt;/button&gt;\n\n    &lt;h3&gt;Local Storage&lt;/h3&gt;\n    &lt;button type=\"button\" (click)=\"setLocal()\"&gt;Set Local Storage&lt;/button&gt;\n  `,\n  providers: [\n    BrowserStorageService,\n    { provide: BROWSER_STORAGE, useFactory: () =&gt; sessionStorage }\n  ]\n})\nexport class StorageComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n\n  constructor(\n    @<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>() private sessionStorageService: BrowserStorageService,\n    @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() private localStorageService: BrowserStorageService,\n  ) { }\n\n  ngOnInit() {\n  }\n\n  setSession() {\n    this.sessionStorageService.set('hero', 'Dr Nice - Session');\n  }\n\n  setLocal() {\n    this.localStorageService.set('hero', 'Dr Nice - Local');\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 裝飾器時，注入器只在該元件的注入器中查詢提供者。<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 裝飾器可以讓你跳過區域性注入器，並在注入器樹中向上查詢，以發現哪個提供者滿足該依賴。<code>sessionStorageService</code> 例項使用瀏覽器的 <code>sessionStorage</code> 來跟 <code>BrowserStorageService</code> 打交道，而 <code>localStorageService</code> 跳過了區域性注入器，使用根注入器提供的 <code>BrowserStorageService</code>，它使用瀏覽器的 <code>localStorage</code> API。</p><p translation-origin=\"off\">Using the <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> decorator, the injector only looks at the component's injector for its providers.\nThe <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> decorator allows you to skip the local injector and look up in the hierarchy to find a provider that satisfies this dependency.\nThe <code>sessionStorageService</code> instance interacts with the <code>BrowserStorageService</code> using the <code>sessionStorage</code> browser API, while the <code>localStorageService</code> skips the local injector and uses the root <code>BrowserStorageService</code> that uses the <code>localStorage</code> browser API.</p>\n\n<p><a id=\"component-element\"></a></p>\n<h2 id=\"inject-the-components-dom-element\" translation-result=\"on\">注入元件的 DOM 元素<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#inject-the-components-dom-element\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Inject the component's DOM element<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#inject-the-components-dom-element\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">即便開發者極力避免，仍然會有很多視覺效果和第三方工具（比如 jQuery）需要存取 DOM。這會讓你不得不存取元件所在的 DOM 元素。</p><p translation-origin=\"off\">Although developers strive to avoid it, many visual effects and third-party tools, such as jQuery, require DOM access.\nAs a result, you might need to access a component's DOM element.</p>\n\n<p translation-result=\"on\">為了說明這一點，請看<a href=\"guide/attribute-directives\">屬性型指令</a>中那個 <code>HighlightDirective</code> 的簡化版。</p><p translation-origin=\"off\">To illustrate, here's a minimal version of <code>HighlightDirective</code> from the <a href=\"guide/attribute-directives\">Attribute Directives</a> page.</p>\n\n<code-example header=\"src/app/highlight.directive.ts\" path=\"dependency-injection-in-action/src/app/highlight.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appHighlight') highlightColor = '';\n\n  private el: HTMLElement;\n\n  constructor(el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) {\n    this.el = el.nativeElement;\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseenter') onMouseEnter() {\n    this.highlight(this.highlightColor || 'cyan');\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseleave') onMouseLeave() {\n    this.highlight('');\n  }\n\n  private highlight(color: string) {\n    this.el.style.backgroundColor = color;\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">當用戶把滑鼠移到 DOM 元素上時，指令將指令所在的元素的背景設定為一個高亮顏色。</p><p translation-origin=\"off\">The directive sets the background to a highlight color when the user mouses over the DOM element to which the directive is applied.</p>\n\n<p translation-result=\"on\">Angular 把建構函式引數 <code>el</code> 設定為注入的 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>，該 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code> 代表了宿主的 DOM 元素，它的 <code>nativeElement</code> 屬性把該 DOM 元素暴露給了指令。</p><p translation-origin=\"off\">Angular sets the constructor's <code>el</code> parameter to the injected <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>.\n(An <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code> is a wrapper around a DOM element, whose <code>nativeElement</code> property exposes the DOM element for the directive to manipulate.)</p>\n\n<p translation-result=\"on\">下面的程式碼把指令的 <code>appHighlight</code> 屬性（Attribute）填加到兩個 <code>&lt;div&gt;</code> 標籤裡，一個沒有賦值，一個賦值了顏色。</p><p translation-origin=\"off\">The sample code applies the directive's <code>appHighlight</code> attribute to two <code>&lt;div&gt;</code> tags, first without a value (yielding the default color) and then with an assigned color value.</p>\n\n<code-example header=\"src/app/app.component.html (highlight)\" path=\"dependency-injection-in-action/src/app/app.component.html\" region=\"highlight\">\n&lt;div id=\"highlight\"  class=\"di-component\"  appHighlight&gt;\n  &lt;h3&gt;Hero Bios and Contacts&lt;/h3&gt;\n  &lt;div appHighlight=\"yellow\"&gt;\n    &lt;app-hero-bios-and-contacts&gt;&lt;/app-hero-bios-and-contacts&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n</code-example>\n<p translation-result=\"on\">下圖顯示了滑鼠移到 <code>&lt;hero-bios-and-contacts&gt;</code> 標籤上的效果：</p><p translation-origin=\"off\">The following image shows the effect of mousing over the <code>&lt;hero-bios-and-contacts&gt;</code> tag.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Highlighted bios\" src=\"generated/images/guide/dependency-injection-in-action/highlight.png\" width=\"318\" height=\"196\">\n</div>\n<p><a id=\"defining-providers\"></a></p>\n<h3 id=\"defining-providers\" translation-result=\"on\">定義提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#defining-providers\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Defining providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#defining-providers\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">用於例項化類別的預設方法不一定總適合用來建立依賴。你可以到<a href=\"guide/dependency-injection-providers\">依賴提供者</a>部分檢視其它方法。<code>HeroOfTheMonthComponent</code> 例子示範了一些替代方案，展示了為什麼需要它們。它看起來很簡單：一些屬性和一些由 logger 產生的日誌。</p><p translation-origin=\"off\">A dependency can't always be created by the default method of instantiating a class.\nYou learned about some other methods in <a href=\"guide/dependency-injection-providers\">Dependency Providers</a>.\nThe following <code>HeroOfTheMonthComponent</code> example demonstrates many of the alternatives and why you need them.\nIt's visually simple: a few properties and the logs produced by a logger.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Hero of the month\" src=\"generated/images/guide/dependency-injection-in-action/hero-of-month.png\" width=\"300\" height=\"165\">\n</div>\n<p translation-result=\"on\">它背後的程式碼客製了 DI 框架提供依賴項的方法和位置。這個例子闡明瞭透過<em>提供</em>物件字面量來把物件的定義和 DI 令牌關聯起來的另一種方式。</p><p translation-origin=\"off\">The code behind it customizes how and where the DI framework provides dependencies.\nThe use cases illustrate different ways to use the <em>provide</em> object literal to associate a definition object with a DI token.</p>\n\n<code-example header=\"hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"hero-of-the-month\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> } from '@angular/core';\n\nimport { DateLoggerService } from './date-logger.service';\nimport { Hero } from './hero';\nimport { HeroService } from './hero.service';\nimport { LoggerService } from './logger.service';\nimport { MinimalLogger } from './minimal-logger.service';\nimport { RUNNERS_UP,\n         runnersUpFactory } from './runners-up';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-of-the-month',\n  templateUrl: './hero-of-the-month.component.html',\n  providers: [\n    { provide: Hero,          useValue:    someHero },\n    { provide: TITLE,         useValue:   'Hero of the Month' },\n    { provide: HeroService,   useClass:    HeroService },\n    { provide: LoggerService, useClass:    DateLoggerService },\n    { provide: MinimalLogger, useExisting: LoggerService },\n    { provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }\n  ]\n})\nexport class HeroOfTheMonthComponent {\n  logs: string[] = [];\n\n  constructor(\n      logger: MinimalLogger,\n      public heroOfTheMonth: Hero,\n      @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(RUNNERS_UP) public runnersUp: string,\n      @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(TITLE) public title: string)\n  {\n    this.logs = logger.logs;\n    logger.logInfo('starting up');\n  }\n}\n\n</code-example>\n<p translation-result=\"on\"><code>providers</code> 陣列展示了你可以如何使用其它的鍵來定義提供者：<code>useValue</code>、<code>useClass</code>、<code>useExisting</code> 或 <code>useFactory</code>。</p><p translation-origin=\"off\">The <code>providers</code> array shows how you might use the different provider-definition keys:\n<code>useValue</code>, <code>useClass</code>, <code>useExisting</code>, or <code>useFactory</code>.</p>\n\n<p><a id=\"usevalue\"></a></p>\n<h4 id=\"value-providers-usevalue\" translation-result=\"on\">值提供者：<code>useValue</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#value-providers-usevalue\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Value providers: <code>useValue</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#value-providers-usevalue\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code>useValue</code> 鍵讓你可以為 DI 令牌關聯一個固定的值。使用該技巧來進行<em>執行期常量設定</em>，比如網站的基礎地址和功能標誌等。你也可以在單元測試中使用<em>值提供者</em>，來用一個 Mock 資料來代替一個生產環境下的資料服務。</p><p translation-origin=\"off\">The <code>useValue</code> key lets you associate a fixed value with a DI token.\nUse this technique to provide <em>runtime configuration constants</em> such as website base addresses and feature flags.\nYou can also use a value provider in a unit test to provide mock data in place of a production data service.</p>\n\n<p translation-result=\"on\"><code>HeroOfTheMonthComponent</code> 例子中有兩個<em>值-提供者</em>。</p><p translation-origin=\"off\">The <code>HeroOfTheMonthComponent</code> example has two value providers.</p>\n\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-value\">\n{ provide: Hero,          useValue:    someHero },\n{ provide: TITLE,         useValue:   'Hero of the Month' },\n\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\">第一處提供了用於 <code>Hero</code> 令牌的 <code>Hero</code> 類別的現有例項，而不是要求注入器使用 <code>new</code> 來建立一個新例項或使用它自己的快取例項。這裡令牌就是這個類本身。</p><p translation-origin=\"off\">The first provides an existing instance of the <code>Hero</code> class to use for the <code>Hero</code> token, rather than requiring the injector to create a new instance with <code>new</code> or use its own cached instance.\nHere, the token is the class itself.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">第二處為 <code>TITLE</code> 令牌指定了一個字串字面量資源。<code>TITLE</code> 提供者的令牌<em>不是一個類別</em>，而是一個特別的提供者查詢鍵，名叫<a href=\"guide/dependency-injection-in-action#injection-token\">InjectionToken</a>，表示一個 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 例項。</p><p translation-origin=\"off\">The second specifies a literal string resource to use for the <code>TITLE</code> token.\nThe <code>TITLE</code> provider token is <em>not</em> a class, but is instead a special kind of provider lookup key called an <a href=\"guide/dependency-injection-in-action#injection-token\">injection token</a>, represented by an <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> instance.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">你可以把 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 用作任何型別的提供者的令牌，但是當依賴是簡單型別（比如字串、數字、函式）時，它會特別有用。</p><p translation-origin=\"off\">You can use an injection token for any kind of provider but it's particularly helpful when the dependency is a simple value like a string, a number, or a function.</p>\n\n<p translation-result=\"on\">一個<em>值-提供者</em>的值必須在指定之前定義。比如標題字串就是立即可用的。該例中的 <code>someHero</code> 變數是以前在如下的檔案中定義的。你不能使用那些要等以後才能定義其值的變數。</p><p translation-origin=\"off\">The value of a <em>value provider</em> must be defined before you specify it here.\nThe title string literal is immediately available.\nThe <code>someHero</code> variable in this example was set earlier in the file as shown below.\nYou can't use a variable whose value will be defined later.</p>\n\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"some-hero\">\nconst someHero = new Hero(42, 'Magma', 'Had a great month!', '555-555-5555');\n\n</code-example>\n<p translation-result=\"on\">其它型別的提供者都會<em>惰性建立</em>它們的值，也就是說只在需要注入它們的時候才建立。</p><p translation-origin=\"off\">Other types of providers can create their values <em>lazily</em>; that is, when they're needed for injection.</p>\n\n<p><a id=\"useclass\"></a></p>\n<h4 id=\"class-providers-useclass\" translation-result=\"on\">類提供者：<code>useClass</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#class-providers-useclass\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Class providers: <code>useClass</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#class-providers-useclass\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code>useClass</code> 提供的鍵讓你可以建立並返回指定類別的新例項。</p><p translation-origin=\"off\">The <code>useClass</code> provider key lets you create and return a new instance of the specified class.</p>\n\n<p translation-result=\"on\">你可以使用這類提供者來為公共類或預設類換上一個<em>替代實現</em>。比如，這個替代實現可以實現一種不同的策略來擴充預設類，或在測試環境中模擬真實類別的行為。</p><p translation-origin=\"off\">You can use this type of provider to substitute an <em>alternative implementation</em> for a common or default class.\nThe alternative implementation could, for example, implement a different strategy, extend the default class, or emulate the behavior of the real class in a test case.</p>\n\n<p translation-result=\"on\">請看下面 <code>HeroOfTheMonthComponent</code> 裡的兩個例子：</p><p translation-origin=\"off\">The following code shows two examples in <code>HeroOfTheMonthComponent</code>.</p>\n\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-class\">\n{ provide: HeroService,   useClass:    HeroService },\n{ provide: LoggerService, useClass:    DateLoggerService },\n\n</code-example>\n<p translation-result=\"on\">第一個提供者是<em>展開了語法糖的</em>，是一個典型情況的展開。一般來說，被新建的類（<code>HeroService</code>）同時也是該提供者的注入令牌。通常都選用縮寫形式，完整形式可以讓細節更明確。</p><p translation-origin=\"off\">The first provider is the <em>de-sugared</em>, expanded form of the most typical case in which the class to be created (<code>HeroService</code>) is also the provider's dependency injection token.\nThe short form is generally preferred; this long form makes the details explicit.</p>\n\n<p translation-result=\"on\">第二個提供者使用 <code>DateLoggerService</code> 來滿足 <code>LoggerService</code>。該 <code>LoggerService</code> 在 <code>AppComponent</code> 級別已經被註冊。當<em>這個元件</em>要求 <code>LoggerService</code> 的時候，它得到的卻是 <code>DateLoggerService</code> 服務的例項。</p><p translation-origin=\"off\">The second provider substitutes <code>DateLoggerService</code> for <code>LoggerService</code>.\n<code>LoggerService</code> is already registered at the <code>AppComponent</code> level.\nWhen this child component requests <code>LoggerService</code>, it receives a <code>DateLoggerService</code> instance instead.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">這個元件及其子元件會得到 <code>DateLoggerService</code> 例項。這個元件樹之外的元件得到的仍是 <code>LoggerService</code> 例項。</p><p translation-origin=\"off\">This component and its tree of child components receive <code>DateLoggerService</code> instance.\nComponents outside the tree continue to receive the original <code>LoggerService</code> instance.</p>\n\n</div>\n<p translation-result=\"on\"><code>DateLoggerService</code> 從 <code>LoggerService</code> 繼承；它把當前的日期/時間附加到每條資訊上。</p><p translation-origin=\"off\"><code>DateLoggerService</code> inherits from <code>LoggerService</code>; it appends the current date/time to each message:</p>\n\n<code-example header=\"src/app/date-logger.service.ts\" path=\"dependency-injection-in-action/src/app/date-logger.service.ts\" region=\"date-logger-service\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class DateLoggerService extends LoggerService\n{\n  override logInfo(msg: any)  { super.logInfo(stamp(msg)); }\n  override logDebug(msg: any) { super.logInfo(stamp(msg)); }\n  override logError(msg: any) { super.logError(stamp(msg)); }\n}\n\nfunction stamp(msg: any) { return msg + ' at ' + new Date(); }\n\n</code-example>\n<p><a id=\"useexisting\"></a></p>\n<h4 id=\"alias-providers-useexisting\" translation-result=\"on\">別名提供者：<code>useExisting</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#alias-providers-useexisting\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Alias providers: <code>useExisting</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#alias-providers-useexisting\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code>useExisting</code> 提供了一個鍵，讓你可以把一個令牌對映成另一個令牌。實際上，第一個令牌就是第二個令牌所關聯的服務的<em>別名</em>，這樣就建立了存取同一個服務物件的兩種途徑。</p><p translation-origin=\"off\">The <code>useExisting</code> provider key lets you map one token to another.\nIn effect, the first token is an <em>alias</em> for the service associated with the second token, creating two ways to access the same service object.</p>\n\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-existing\">\n{ provide: MinimalLogger, useExisting: LoggerService },\n\n</code-example>\n<p translation-result=\"on\">你可以使用別名介面來窄化 API。下面的例子中使用別名就是為了這個目的。</p><p translation-origin=\"off\">You can use this technique to narrow an API through an aliasing interface.\nThe following example shows an alias introduced for that purpose.</p>\n\n<p translation-result=\"on\">想象 <code>LoggerService</code> 有個很大的 API 介面，遠超過現有的三個方法和一個屬性。你可能希望把 API 介面收窄到只有兩個你確實需要的成員。在這個例子中，<code>MinimalLogger</code><a href=\"guide/dependency-injection-in-action#class-interface\"><em>類-介面</em></a>，就這個 API 成功縮小到了只有兩個成員：</p><p translation-origin=\"off\">Imagine that <code>LoggerService</code> had a large API, much larger than the actual three methods and a property.\nYou might want to shrink that API surface to just the members you actually need.\nIn this example, the <code>MinimalLogger</code> <a href=\"guide/dependency-injection-in-action#class-interface\">class-interface</a> reduces the API to two members:</p>\n\n<code-example header=\"src/app/minimal-logger.service.ts\" path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\">\n// Class used as a \"narrowing\" interface that exposes a minimal logger\n// Other members of the actual implementation are invisible\nexport abstract class MinimalLogger {\n  abstract logs: string[];\n  abstract logInfo: (msg: string) =&gt; void;\n}\n\n</code-example>\n<p translation-result=\"on\">下面的例子在一個簡化版的 <code>HeroOfTheMonthComponent</code> 中使用 <code>MinimalLogger</code>。</p><p translation-origin=\"off\">The following example puts <code>MinimalLogger</code> to use in a simplified version of <code>HeroOfTheMonthComponent</code>.</p>\n\n<code-example header=\"src/app/hero-of-the-month.component.ts (minimal version)\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.1.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-of-the-month',\n  templateUrl: './hero-of-the-month.component.html',\n  // TODO: move this aliasing, `useExisting` provider to the AppModule\n  providers: [{ provide: MinimalLogger, useExisting: LoggerService }]\n})\nexport class HeroOfTheMonthComponent {\n  logs: string[] = [];\n  constructor(logger: MinimalLogger) {\n    logger.logInfo('starting up');\n  }\n}\n\n</code-example>\n<p translation-result=\"on\"><code>HeroOfTheMonthComponent</code> 建構函式的 <code>logger</code> 引數是一個 <code>MinimalLogger</code> 型別，在支援 TypeScript 感知的編輯器裡，只能看到它的兩個成員 <code>logs</code> 和 <code>logInfo</code>：</p><p translation-origin=\"off\">The <code>HeroOfTheMonthComponent</code> constructor's <code>logger</code> parameter is typed as <code>MinimalLogger</code>, so only the <code>logs</code> and <code>logInfo</code> members are visible in a TypeScript-aware editor.</p>\n\n<div class=\"lightbox\">\n<img alt=\"MinimalLogger restricted API\" src=\"generated/images/guide/dependency-injection-in-action/minimal-logger-intellisense.png\" width=\"532\" height=\"60\">\n</div>\n<p translation-result=\"on\">實際上，Angular 把 <code>logger</code> 引數設定為注入器裡 <code>LoggerService</code> 令牌下注冊的完整服務，該令牌恰好是<a href=\"guide/dependency-injection-in-action#useclass\">以前提供的那個</a> <code>DateLoggerService</code> 例項。</p><p translation-origin=\"off\">Behind the scenes, Angular sets the <code>logger</code> parameter to the full service registered under the <code>LoggingService</code> token, which happens to be the <code>DateLoggerService</code> instance that was <a href=\"guide/dependency-injection-in-action#useclass\">provided above</a>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">在下面的圖片中，顯示了日誌日期，可以確認這一點：</p><p translation-origin=\"off\">This is illustrated in the following image, which displays the logging date.</p>\n\n<div class=\"lightbox\">\n<img alt=\"DateLoggerService entry\" src=\"generated/images/guide/dependency-injection-in-action/date-logger-entry.png\" width=\"300\" height=\"32\">\n</div>\n</div>\n<p><a id=\"usefactory\"></a></p>\n<h4 id=\"factory-providers-usefactory\" translation-result=\"on\">工廠提供者：<code>useFactory</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#factory-providers-usefactory\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Factory providers: <code>useFactory</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#factory-providers-usefactory\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code>useFactory</code> 提供了一個鍵，讓你可以透過呼叫一個工廠函式來建立依賴例項，如下面的例子所示。</p><p translation-origin=\"off\">The <code>useFactory</code> provider key lets you create a dependency object by calling a factory function, as in the following example.</p>\n\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-factory\">\n{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }\n\n</code-example>\n<p translation-result=\"on\">注入器透過呼叫你用 <code>useFactory</code> 鍵指定的工廠函式來提供該依賴的值。\n注意，提供者的這種形態還有第三個鍵 <code>deps</code>，它指定了供 <code>useFactory</code> 函式使用的那些依賴。</p><p translation-origin=\"off\">The injector provides the dependency value by invoking a factory function, that you provide as the value of the <code>useFactory</code> key.\nNotice that this form of provider has a third key, <code>deps</code>, which specifies dependencies for the <code>useFactory</code> function.</p>\n\n<p translation-result=\"on\">使用這項技術，可以用包含了一些<strong><em>依賴服務和本地狀態</em></strong>輸入的工廠函式來<strong><em>建立一個依賴物件</em></strong>。</p><p translation-origin=\"off\">Use this technique to create a dependency object with a factory function whose inputs are a combination of <em>injected services</em> and <em>local state</em>.</p>\n\n<p translation-result=\"on\">這個依賴物件（由工廠函式返回的）通常是一個類別例項，不過也可以是任何其它東西。在這個例子中，依賴物件是一個表示 \"月度英雄\" 參賽者名稱的字串。</p><p translation-origin=\"off\">The dependency object (returned by the factory function) is typically a class instance, but can be other things as well.\nIn this example, the dependency object is a string of the names of the runners-up to the \"Hero of the Month\" contest.</p>\n\n<p translation-result=\"on\">在這個例子中，區域性狀態是數字 <code>2</code>，也就是元件應該顯示的參賽者數量。該狀態的值傳給了 <code>runnersUpFactory()</code> 作為引數。<code>runnersUpFactory()</code> 返回了<em>提供者的工廠函式</em>，它可以使用傳入的狀態值和注入的服務 <code>Hero</code> 和 <code>HeroService</code>。</p><p translation-origin=\"off\">In the example, the local state is the number <code>2</code>, the number of runners-up that the component should show.\nThe state value is passed as an argument to <code>runnersUpFactory()</code>.\nThe <code>runnersUpFactory()</code> returns the <em>provider factory function</em>, which can use both the passed-in state value and the injected services <code>Hero</code> and <code>HeroService</code>.</p>\n\n<code-example header=\"runners-up.ts (excerpt)\" path=\"dependency-injection-in-action/src/app/runners-up.ts\" region=\"factory-synopsis\">\nexport function runnersUpFactory(take: number) {\n  return (winner: Hero, heroService: HeroService): string =&gt;\n    /* ... */\n}\n\n</code-example>\n<p translation-result=\"on\">由 <code>runnersUpFactory()</code> 返回的提供者的工廠函式返回了實際的依賴物件，也就是表示名字的字串。</p><p translation-origin=\"off\">The provider factory function (returned by <code>runnersUpFactory()</code>) returns the actual dependency object, the string of names.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">該函式以獲勝的 <code>Hero</code> 和 <code>HeroService</code> 作為引數。Angular 從 <code>deps</code> 陣列中的兩個<em>令牌</em>標識的注入值提供這些引數。</p><p translation-origin=\"off\">The function takes a winning <code>Hero</code> and a <code>HeroService</code> as arguments.\nAngular supplies these arguments from injected values identified by the two <em>tokens</em> in the <code>deps</code> array.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">該函式返回名字的字串，Angular 可以把它們注入到 <code>HeroOfTheMonthComponent</code> 的 <code>runnersUp</code> 引數中。</p><p translation-origin=\"off\">The function returns the string of names, which Angular then injects into the <code>runnersUp</code> parameter of <code>HeroOfTheMonthComponent</code></p>\n\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">該函式從 <code>HeroService</code> 中接受候選的英雄，從中取 <code>2</code> 個參加競賽，並把他們的名字串接起來返回。\n參閱 <live-example name=\"dependency-injection-in-action\"></live-example> 檢視完整原始碼。</p><p translation-origin=\"off\">The function retrieves candidate heroes from the <code>HeroService</code>, takes <code>2</code> of them to be the runners-up, and returns their concatenated names.\nLook at the <live-example name=\"dependency-injection-in-action\"></live-example> for the full source code.</p>\n\n</div>\n<p><a id=\"tokens\"></a></p>\n<h2 id=\"provider-token-alternatives-class-interface-and-injectiontoken\" translation-result=\"on\">提供替代令牌：類介面與 'InjectionToken'<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#provider-token-alternatives-class-interface-and-injectiontoken\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Provider token alternatives: class interface and 'InjectionToken'<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#provider-token-alternatives-class-interface-and-injectiontoken\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">當使用類作為令牌，同時也把它作為返回依賴物件或服務的型別時，Angular 依賴注入使用起來最容易。</p><p translation-origin=\"off\">Angular dependency injection is easiest when the provider token is a class that is also the type of the returned dependency object, or service.</p>\n\n<p translation-result=\"on\">但令牌不一定都是類，就算它是一個類別，它也不一定都返回型別相同的物件。這是下一節的主題。</p><p translation-origin=\"off\">However, a token doesn't have to be a class and even when it is a class, it doesn't have to be the same type as the returned object.\nThat's the subject of the next section.</p>\n\n<p><a id=\"class-interface\"></a></p>\n<h3 id=\"class-interface\" translation-result=\"on\">類-介面<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#class-interface\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Class interface<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#class-interface\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">前面的<em>月度英雄</em>的例子使用了 <code>MinimalLogger</code> 類作為 <code>LoggerService</code> 提供者的令牌。</p><p translation-origin=\"off\">The previous <em>Hero of the Month</em> example used the <code>MinimalLogger</code> class as the token for a provider of <code>LoggerService</code>.</p>\n\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-existing\">\n{ provide: MinimalLogger, useExisting: LoggerService },\n\n</code-example>\n<p translation-result=\"on\">該 <code>MinimalLogger</code> 是一個抽象類別。</p><p translation-origin=\"off\"><code>MinimalLogger</code> is an abstract class.</p>\n\n<code-example header=\"src/app/minimal-logger.service.ts\" path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\">\n// Class used as a \"narrowing\" interface that exposes a minimal logger\n// Other members of the actual implementation are invisible\nexport abstract class MinimalLogger {\n  abstract logs: string[];\n  abstract logInfo: (msg: string) =&gt; void;\n}\n\n</code-example>\n<p translation-result=\"on\">你通常從一個可擴充的抽象類別繼承。但這個應用中<em>並沒有</em>類會繼承 <code>MinimalLogger</code>。<code>LoggerService</code> 和 <code>DateLoggerService</code><em>本可以</em>從 <code>MinimalLogger</code> 中繼承。\n它們也可以實現 <code>MinimalLogger</code>，而不用單獨定義介面。\n但它們沒有。\n<code>MinimalLogger</code> 在這裡僅僅被用作一個 \"依賴注入令牌\"。</p><p translation-origin=\"off\">An abstract class is usually a base class that you can extend.\nIn this app, however there is no class that inherits from <code>MinimalLogger</code>.\nThe <code>LoggerService</code> and the <code>DateLoggerService</code> could have inherited from <code>MinimalLogger</code>, or they could have implemented it instead, in the manner of an interface.\nBut they did neither.\n<code>MinimalLogger</code> is used only as a dependency injection token.</p>\n\n<p translation-result=\"on\">當你透過這種方式使用類時，它稱作<em>類介面</em>。</p><p translation-origin=\"off\">When you use a class this way, it's called a <em>class interface</em>.</p>\n\n<p translation-result=\"on\">就像<a href=\"guide/dependency-injection-providers\">配置依賴提供者</a>中提到的那樣，介面不是有效的 DI 令牌，因為它是 TypeScript 自己用的，在執行期間不存在。使用這種抽象類別介面不但可以獲得像介面一樣的強型別，而且可以像普通類一樣把它用作提供者令牌。</p><p translation-origin=\"off\">As mentioned in <a href=\"guide/dependency-injection-providers\">Configuring dependency providers</a>,\nan interface is not a valid DI token because it is a TypeScript artifact that doesn't exist at run time.\nUse this abstract class interface to get the strong typing of an interface,\nand also use it as a provider token in the way you would a normal class.</p>\n\n<p translation-result=\"on\">類介面應該<em>只</em>定義允許它的消費者呼叫的成員。窄的介面有助於解耦該類別的具體實現和它的消費者。</p><p translation-origin=\"off\">A class interface should define <em>only</em> the members that its consumers are allowed to call.\nSuch a narrowing interface helps decouple the concrete class from its consumers.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">用類作為介面可以讓你獲得真實 JavaScript 物件中的介面的特性。但是，為了最小化記憶體開銷，該類應該是<em>沒有實現</em>的。對於建構函式，<code>MinimalLogger</code> 會轉譯成未最佳化過的、預先最小化過的 JavaScript。</p><p translation-origin=\"off\">Using a class as an interface gives you the characteristics of an interface in a real JavaScript object.\nTo minimize memory cost, however, the class should have <em>no implementation</em>.\nThe <code>MinimalLogger</code> transpiles to this unoptimized, pre-minified JavaScript for a constructor function.</p>\n\n<code-example header=\"src/app/minimal-logger.service.ts\" path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" region=\"minimal-logger-transpiled\">\nvar MinimalLogger = (function () {\n  function MinimalLogger() {}\n  return MinimalLogger;\n}());\nexports(\"MinimalLogger\", MinimalLogger);\n\n</code-example>\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n它沒有任何成員。無論你新增到類中的成員有多少，它都不會增長大小，因為這些成員只是型別而沒有實現。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nIt doesn't have any members.\nIt never grows no matter how many members you add to the class, as long as those members are typed but not implemented.</p>\n\n<p translation-result=\"on\">你可以再看看 TypeScript 的 <code>MinimalLogger</code> 類，確定一下它是沒有實現的。</p><p translation-origin=\"off\">Look again at the TypeScript <code>MinimalLogger</code> class to confirm that it has no implementation.</p>\n\n</div>\n<p><a id=\"injection-token\"></a></p>\n<h3 id=\"injectiontoken-objects\" translation-result=\"on\">'InjectionToken' 物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#injectiontoken-objects\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">'InjectionToken' objects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#injectiontoken-objects\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">依賴物件可以是一個簡單的值，比如日期，數字和字串，或者一個無形的物件，比如陣列和函式。</p><p translation-origin=\"off\">Dependency objects can be simple values like dates, numbers, and strings, or shapeless objects like arrays and functions.</p>\n\n<p translation-result=\"on\">這樣的物件沒有應用程式介面，所以不能用一個類別來表示。更適合表示它們的是：唯一的和符號性的令牌，一個 JavaScript 物件，擁有一個友好的名字，但不會與其它的同名令牌發生衝突。</p><p translation-origin=\"off\">Such objects don't have application interfaces and therefore aren't well represented by a class.\nThey're better represented by a token that is both unique and symbolic, a JavaScript object that has a friendly name but won't conflict with another token that happens to have the same name.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 具有這些特徵。在<em>Hero of the Month</em>例子中遇見它們兩次，一個是 <em>title</em> 的值，一個是 <em>runnersUp</em> 工廠提供者。</p><p translation-origin=\"off\"><code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> has these characteristics.\nYou encountered them twice in the <em>Hero of the Month</em> example, in the <em>title</em> value provider and in the <em>runnersUp</em> factory provider.</p>\n\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"provide-injection-token\">\n{ provide: TITLE,         useValue:   'Hero of the Month' },\n{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }\n\n</code-example>\n<p translation-result=\"on\">這樣建立 <code>TITLE</code> 令牌：</p><p translation-origin=\"off\">You created the <code>TITLE</code> token like this:</p>\n\n<code-example header=\"src/app/hero-of-the-month.component.ts\" path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"injection-token\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const TITLE = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&lt;string&gt;('title');\n\n</code-example>\n<p translation-result=\"on\">型別引數，雖然是可選的，但可以向開發者和開發工具傳達型別資訊。而且這個令牌的描述資訊也可以為開發者提供幫助。</p><p translation-origin=\"off\">The type parameter, while optional, conveys the dependency's type to developers and tooling.\nThe token description is another developer aid.</p>\n\n<p><a id=\"di-inheritance\"></a></p>\n<h2 id=\"inject-into-a-derived-class\" translation-result=\"on\">注入到派生類<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#inject-into-a-derived-class\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Inject into a derived class<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#inject-into-a-derived-class\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">當編寫一個繼承自另一個元件的元件時，要格外小心。如果基礎元件有依賴注入，必須要在派生類中重新提供和重新注入它們，並將它們透過建構函式傳給基底類別。</p><p translation-origin=\"off\">Take care when writing a component that inherits from another component.\nIf the base component has injected dependencies, you must re-provide and re-inject them in the derived class and then pass them down to the base class through the constructor.</p>\n\n<p translation-result=\"on\">在這個刻意產生的例子裡，<code>SortedHeroesComponent</code> 繼承自 <code>HeroesBaseComponent</code>，顯示一個<em>被排序</em>的英雄列表。</p><p translation-origin=\"off\">In this contrived example, <code>SortedHeroesComponent</code> inherits from <code>HeroesBaseComponent</code> to display a <em>sorted</em> list of heroes.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Sorted Heroes\" src=\"generated/images/guide/dependency-injection-in-action/sorted-heroes.png\" width=\"135\" height=\"107\">\n</div>\n<p translation-result=\"on\"><code>HeroesBaseComponent</code> 能自己獨立執行。它在自己的例項裡要求 <code>HeroService</code>，用來得到英雄，並將他們按照資料庫返回的順序顯示出來。</p><p translation-origin=\"off\">The <code>HeroesBaseComponent</code> can stand on its own.\nIt demands its own instance of <code>HeroService</code> to get heroes and displays them in the order they arrive from the database.</p>\n\n<code-example header=\"src/app/sorted-heroes.component.ts (HeroesBaseComponent)\" path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"heroes-base\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-unsorted-heroes',\n  template: '&lt;div *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero.name}}&lt;/div&gt;',\n  providers: [HeroService]\n})\nexport class HeroesBaseComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private heroService: HeroService) { }\n\n  heroes: Hero[] = [];\n\n  ngOnInit() {\n    this.heroes = this.heroService.getAllHeroes();\n    this.afterGetHeroes();\n  }\n\n  // Post-process heroes in derived class override.\n  protected afterGetHeroes() {}\n\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<h3 id=\"keep-constructors-simple\" translation-result=\"on\">讓建構函式保持簡單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#keep-constructors-simple\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Keep constructors simple<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#keep-constructors-simple\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">建構函式應該只用來初始化變數。這條規則讓元件在測試環境中可以放心地構造元件，以免在構造它們時，無意中做出一些非常戲劇化的動作(比如與伺服器進行會話)。這就是為什麼你要在 <code>ngOnInit</code> 裡面呼叫 <code>HeroService</code>，而不是在建構函式中。</p><p translation-origin=\"off\">Constructors should do little more than initialize variables.\nThis rule makes the component safe to construct under test without fear that it will do something dramatic like talk to the server.\nThat's why you call the <code>HeroService</code> from within the <code>ngOnInit</code> rather than the constructor.</p>\n\n</div>\n<p translation-result=\"on\">使用者希望看到英雄按字母順序排序。與其修改原始的元件，不如派生它，新建 <code>SortedHeroesComponent</code>，以便展示英雄之前進行排序。<code>SortedHeroesComponent</code> 讓基底類別來獲取英雄。</p><p translation-origin=\"off\">Users want to see the heroes in alphabetical order.\nRather than modify the original component, subclass it and create a <code>SortedHeroesComponent</code> that sorts the heroes before presenting them.\nThe <code>SortedHeroesComponent</code> lets the base class fetch the heroes.</p>\n\n<p translation-result=\"on\">可惜，Angular 不能直接在基底類別裡直接注入 <code>HeroService</code>。必須在<em>這個</em>元件裡再次提供 <code>HeroService</code>，然後透過建構函式傳給基底類別。</p><p translation-origin=\"off\">Unfortunately, Angular cannot inject the <code>HeroService</code> directly into the base class.\nYou must provide the <code>HeroService</code> again for <em>this</em> component, then pass it down to the base class inside the constructor.</p>\n\n<code-example header=\"src/app/sorted-heroes.component.ts (SortedHeroesComponent)\" path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"sorted-heroes\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-sorted-heroes',\n  template: '&lt;div *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero.name}}&lt;/div&gt;',\n  providers: [HeroService]\n})\nexport class SortedHeroesComponent extends HeroesBaseComponent {\n  constructor(heroService: HeroService) {\n    super(heroService);\n  }\n\n  protected override afterGetHeroes() {\n    this.heroes = this.heroes.sort((h1, h2) =&gt; h1.name &lt; h2.name ? -1 :\n            (h1.name &gt; h2.name ? 1 : 0));\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">現在，請注意 <code>afterGetHeroes()</code> 方法。\n你的第一反應是在 <code>SortedHeroesComponent</code> 元件裡面建一個 <code>ngOnInit</code> 方法來做排序。但是 Angular 會先呼叫<em>派生</em>類別的 <code>ngOnInit</code>，後呼叫基底類別的 <code>ngOnInit</code>，\n所以可能在<em>英雄到達之前</em>就開始排序。這就產生了一個討厭的錯誤。</p><p translation-origin=\"off\">Now take notice of the <code>afterGetHeroes()</code> method.\nYour first instinct might have been to create an <code>ngOnInit</code> method in <code>SortedHeroesComponent</code> and do the sorting there.\nBut Angular calls the <em>derived</em> class's <code>ngOnInit</code> <em>before</em> calling the base class's <code>ngOnInit</code> so you'd be sorting the heroes array <em>before they arrived</em>.\nThat produces a nasty error.</p>\n\n<p translation-result=\"on\">覆蓋基底類別的 <code>afterGetHeroes()</code> 方法可以解決這個問題。</p><p translation-origin=\"off\">Overriding the base class's <code>afterGetHeroes()</code> method solves the problem.</p>\n\n<p translation-result=\"on\">分析上面的這些複雜性是為了強調<em>避免使用元件繼承</em>這一點。</p><p translation-origin=\"off\">These complications argue for <em>avoiding component inheritance</em>.</p>\n\n<p><a id=\"forwardref\"></a></p>\n<h2 id=\"resolve-circular-dependencies-with-a-forward-class-reference-forwardref\" translation-result=\"on\">使用一個前向參考（<em>forwardRef</em>）來解析迴圈依賴<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#resolve-circular-dependencies-with-a-forward-class-reference-forwardref\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Resolve circular dependencies with a forward class reference (<em>forwardRef</em>)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-in-action#resolve-circular-dependencies-with-a-forward-class-reference-forwardref\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在 TypeScript 裡面，類宣告的順序是很重要的。如果一個類別尚未定義，就不能參考它。</p><p translation-origin=\"off\">The order of class declaration matters in TypeScript.\nYou can't refer directly to a class until it's been defined.</p>\n\n<p translation-result=\"on\">這通常不是一個問題，特別是當你遵循<em>一個檔案一個類別</em>規則的時候。但是有時候迴圈參考可能不能避免。例如，當一個類別 'A' 參考類 'B'，同時 'B' 參考 'A' 的時候，它們中間的某一個必須要先定義。</p><p translation-origin=\"off\">This isn't usually a problem, especially if you adhere to the recommended <em>one class per file</em> rule.\nBut sometimes circular references are unavoidable.\nFor example, when class 'A' refers to class 'B' and 'B' refers to 'A'.\nOne of them has to be defined first.</p>\n\n<p translation-result=\"on\">Angular 的 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> 函式建立一個<em>間接地</em>參考，Angular 可以隨後解析。</p><p translation-origin=\"off\">The Angular <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> function creates an <em>indirect</em> reference that Angular can resolve later.</p>\n\n<p translation-result=\"on\">這個關於<em>父查詢器</em>的例子中全都是沒辦法打破的迴圈類參考。</p><p translation-origin=\"off\">The <em>Parent Finder</em> sample is full of circular class references that are impossible to break.</p>\n\n<p translation-result=\"on\">當一個類別<em>需要參考自身</em>的時候，你面臨同樣的困境，就像在 <code>AlexComponent</code> 的 <code>providers</code> 陣列中遇到的困境一樣。該 <code>providers</code> 陣列是一個 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 裝飾器函式的一個屬性，它必須在類定義<em>之前</em>出現。</p><p translation-origin=\"off\">You face this dilemma when a class makes <em>a reference to itself</em> as does <code>AlexComponent</code> in its <code>providers</code> array.\nThe <code>providers</code> array is a property of the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator function which must appear <em>above</em> the class definition.</p>\n\n<p translation-result=\"on\">使用 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a></code> 來打破這種迴圈：</p><p translation-origin=\"off\">Break the circularity with <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a></code>.</p>\n\n<code-example header=\"parent-finder.component.ts (AlexComponent providers)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; AlexComponent) }],\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/Host\n - api/core/SkipSelf\n - errors/NG0200\n - guide/creating-injectable-service\n - guide/dependency-injection\n - guide/dependency-injection-navtree\n - guide/dependency-injection-providers\n - guide/hierarchical-dependency-injection\n-->\n<!-- links from this doc:\n - api/common/NgFor\n - api/common/NgIf\n - api/core/Component\n - api/core/Directive\n - api/core/ElementRef\n - api/core/Host\n - api/core/HostListener\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Input\n - api/core/OnInit\n - api/core/Optional\n - api/core/Self\n - api/core/SkipSelf\n - api/core/forwardRef\n - api/core/ng-content\n - api/forms/DefaultValueAccessor\n - api/forms/NgModel\n - guide/attribute-directives\n - guide/dependency-injection-in-action#alias-providers-useexisting\n - guide/dependency-injection-in-action#class-interface\n - guide/dependency-injection-in-action#class-providers-useclass\n - guide/dependency-injection-in-action#defining-providers\n - guide/dependency-injection-in-action#dependency-injection-in-action\n - guide/dependency-injection-in-action#factory-providers-usefactory\n - guide/dependency-injection-in-action#hero-bios-component\n - guide/dependency-injection-in-action#inject-into-a-derived-class\n - guide/dependency-injection-in-action#inject-the-components-dom-element\n - guide/dependency-injection-in-action#injection-token\n - guide/dependency-injection-in-action#injectiontoken-objects\n - guide/dependency-injection-in-action#injectiontoken-物件\n - guide/dependency-injection-in-action#keep-constructors-simple\n - guide/dependency-injection-in-action#make-a-dependency-optional-and-limit-search-with-host\n - guide/dependency-injection-in-action#modify-the-provider-search-with-self-and-skipself\n - guide/dependency-injection-in-action#multiple-service-instances-sandboxing\n - guide/dependency-injection-in-action#provider-token-alternatives-class-interface-and-injectiontoken\n - guide/dependency-injection-in-action#qualify-dependency-lookup-with-parameter-decorators\n - guide/dependency-injection-in-action#resolve-circular-dependencies-with-a-forward-class-reference-forwardref\n - guide/dependency-injection-in-action#supply-a-custom-provider-with-inject\n - guide/dependency-injection-in-action#useclass\n - guide/dependency-injection-in-action#value-providers-usevalue\n - guide/dependency-injection-in-action#使用-inject-指定自訂提供者\n - guide/dependency-injection-in-action#使用-self-和-skipself-來修改提供者的搜尋方式\n - guide/dependency-injection-in-action#使用一個前向參考forwardref來解析迴圈依賴\n - guide/dependency-injection-in-action#使用引數裝飾器來限定依賴查詢方式\n - guide/dependency-injection-in-action#依賴注入實戰\n - guide/dependency-injection-in-action#值提供者usevalue\n - guide/dependency-injection-in-action#別名提供者useexisting\n - guide/dependency-injection-in-action#多個服務例項沙箱式隔離\n - guide/dependency-injection-in-action#定義提供者\n - guide/dependency-injection-in-action#工廠提供者usefactory\n - guide/dependency-injection-in-action#提供替代令牌類介面與-injectiontoken\n - guide/dependency-injection-in-action#注入到派生類\n - guide/dependency-injection-in-action#注入元件的-dom-元素\n - guide/dependency-injection-in-action#用-optional-來讓依賴是可選的以及使用-host-來限定搜尋方式\n - guide/dependency-injection-in-action#類-介面\n - guide/dependency-injection-in-action#類提供者useclass\n - guide/dependency-injection-in-action#讓建構函式保持簡單\n - guide/dependency-injection-providers\n - https://developer.mozilla.org/docs/Web/API/Window/localStorage\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/dependency-injection-in-action.md?message=docs%3A%20請簡述你的修改...\n-->"}