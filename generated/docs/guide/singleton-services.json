{"id":"guide/singleton-services","title":"Singleton services","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/singleton-services.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"singleton-services\" translation-result=\"on\">單例服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#singleton-services\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Singleton services<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#singleton-services\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">單例服務是指在應用中只存在一個例項的服務。</p><p translation-origin=\"off\">A singleton service is a service for which only one instance exists in an application.</p>\n\n<p translation-result=\"on\">本頁中描述的這種全應用級單例服務的例子位於<live-example name=\"ngmodules\"></live-example>，它示範了 NgModule 的所有已文件化的特性。</p><p translation-origin=\"off\">For a sample application using the app-wide singleton service that this page describes, see the <live-example name=\"ngmodules\"></live-example> showcasing all the documented features of NgModules.</p>\n\n<h2 id=\"providing-a-singleton-service\" translation-result=\"on\">提供單例服務<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#providing-a-singleton-service\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Providing a singleton service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#providing-a-singleton-service\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在 Angular 中有兩種方式來產生單例服務：</p><p translation-origin=\"off\">There are two ways to make a service a singleton in Angular:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">把 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 中的 <code>providedIn</code> 屬性設定為 <code>\"root\"</code></p><p translation-origin=\"off\">Set the <code>providedIn</code> property of the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> to <code>\"root\"</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">把該服務包含在 <code>AppModule</code> 或某個只會被 <code>AppModule</code> 匯入的模組中。</p><p translation-origin=\"off\">Include the service in the <code>AppModule</code> or in a module that is only imported by the <code>AppModule</code></p>\n\n</li>\n</ul>\n<p><a id=\"providedIn\"></a></p>\n<h3 id=\"using-providedin\" translation-result=\"on\">使用 <code>providedIn</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#using-providedin\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Using <code>providedIn</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#using-providedin\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">從 Angular 6.0 開始，建立單例服務的首選方式就是在那個服務類別的 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 裝飾器上把 <code>providedIn</code> 設定為 <code>root</code>。這會告訴 Angular 在應用的根上提供此服務。</p><p translation-origin=\"off\">Beginning with Angular 6.0, the preferred way to create a singleton service is to set <code>providedIn</code> to <code>root</code> on the service's <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator.\nThis tells Angular to provide the service in the application root.</p>\n\n<code-example path=\"providers/src/app/user.service.0.ts\" header=\"src/app/user.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class UserService {\n}\n\n\n</code-example>\n<p translation-result=\"on\">要想深入瞭解關於服務的資訊，參閱<a href=\"tutorial/tour-of-heroes\">《英雄之旅》課程</a>中的<a href=\"tutorial/tour-of-heroes/toh-pt4\">服務</a>一章。</p><p translation-origin=\"off\">For more detailed information on services, see the <a href=\"tutorial/tour-of-heroes/toh-pt4\">Services</a> chapter of the <a href=\"tutorial/tour-of-heroes\">Tour of Heroes tutorial</a>.</p>\n\n<h3 id=\"ngmodule-providers-array\" translation-result=\"on\">NgModule 的 <code>providers</code> 陣列<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#ngmodule-providers-array\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">NgModule <code>providers</code> array<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#ngmodule-providers-array\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在基於 Angular 6.0 以前的版本建構的應用中，服務是註冊在 NgModule 的 <code>providers</code> 陣列中的，就像這樣：</p><p translation-origin=\"off\">In applications built with Angular versions prior to 6.0, services are registered NgModule <code>providers</code> arrays as follows:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  …\n  providers: [UserService],\n  …\n})\n\n</code-example>\n<p translation-result=\"on\">如果這個 NgModule 是根模組 <code>AppModule</code>，此 <code>UserService</code> 就會是單例的，並且在整個應用中都可用。雖然你可能會看到這種形式的程式碼，但是最好使用在服務自身的 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 裝飾器上設定 <code>providedIn</code> 屬性的形式，因為 Angular 6.0 可以對這些服務進行搖樹最佳化。</p><p translation-origin=\"off\">If this NgModule were the root <code>AppModule</code>, the <code>UserService</code> would be a singleton and available throughout the application.\nThough you may see it coded this way, using the <code>providedIn</code> property of the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator on the service itself is preferable as of Angular 6.0 as it makes your services tree-shakable.</p>\n\n<p><a id=\"forRoot\"></a></p>\n<h2 id=\"the-forroot-pattern\" translation-result=\"on\"><code>forRoot()</code> 模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#the-forroot-pattern\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">The <code>forRoot()</code> pattern<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#the-forroot-pattern\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">通常，你只需要用 <code>providedIn</code> 提供服務，用 <code>forRoot()</code>/<code>forChild()</code> 提供路由即可。不過，理解 <code>forRoot()</code> 為何能夠確保服務只有單個例項，可以讓你學會更深層次的開發知識。</p><p translation-origin=\"off\">Generally, you'll only need <code>providedIn</code> for providing services and <code>forRoot()</code>/<code>forChild()</code> for routing.\nHowever, understanding how <code>forRoot()</code> works to make sure a service is a singleton will inform your development at a deeper level.</p>\n\n<p translation-result=\"on\">如果模組同時定義了 providers（服務）和 declarations（元件、指令、管道），那麼，當你同時在多個特性模組中載入此模組時，這些服務就會被註冊在多個地方。這會導致出現多個服務例項，並且該服務的行為不再像單例一樣。</p><p translation-origin=\"off\">If a module defines both providers and declarations (components, directives, pipes), then loading the module in multiple feature modules would duplicate the registration of the service.\nThis could result in multiple service instances and the service would no longer behave as a singleton.</p>\n\n<p translation-result=\"on\">有多種方式來防止這種現象：</p><p translation-origin=\"off\">There are multiple ways to prevent this:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">用 <a href=\"guide/singleton-services#providedIn\"><code>providedIn</code> 語法</a>代替在模組中註冊服務的方式。</p><p translation-origin=\"off\">Use the <a href=\"guide/singleton-services#providedIn\"><code>providedIn</code> syntax</a> instead of registering the service in the module.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把你的服務分離到它們自己的模組中。</p><p translation-origin=\"off\">Separate your services into their own module.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在模組中分別定義 <code>forRoot()</code> 和 <code>forChild()</code> 方法。</p><p translation-origin=\"off\">Define <code>forRoot()</code> and <code>forChild()</code> methods in the module.</p>\n\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n有兩個範例應用可以讓你檢視這種情況，更進階的方式參閱 <live-example nodownload=\"\" name=\"ngmodules\">NgModules 現場演練</live-example>，它在路由模組中包含 <code>forRoot()</code> 和 <code>forChild()</code>，而 <code>GreetingModule</code> 是一個比較簡單的<live-example name=\"lazy-loading-ngmodules\" nodownload=\"\">延遲載入範例</live-example>。在<a href=\"guide/lazy-loading-ngmodules\">延遲載入模組</a>中有簡要的解釋。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThere are two example applications where you can see this scenario; the more advanced <live-example nodownload=\"\" name=\"ngmodules\">NgModules live example</live-example>, which contains <code>forRoot()</code> and <code>forChild()</code> in the routing modules and the <code>GreetingModule</code>, and the simpler <live-example name=\"lazy-loading-ngmodules\" nodownload=\"\">Lazy Loading live example</live-example>.\nFor an introductory explanation see the <a href=\"guide/lazy-loading-ngmodules\">Lazy Loading Feature Modules</a> guide.</p>\n\n</div>\n<p translation-result=\"on\">使用 <code>forRoot()</code> 來把提供者從該模組中分離出去，這樣你就能在根模組中匯入該模組時帶上 <code>providers</code>，並且在子模組中匯入它時不帶 <code>providers</code>。</p><p translation-origin=\"off\">Use <code>forRoot()</code> to separate providers from a module so you can import that module into the root module with <code>providers</code> and child modules without <code>providers</code>.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">在該模組中建立一個靜態方法 <code>forRoot()</code>。</p><p translation-origin=\"off\">Create a static method <code>forRoot()</code> on the module.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把這些提供者放進 <code>forRoot()</code> 方法中。</p><p translation-origin=\"off\">Place the providers into the <code>forRoot()</code> method.</p>\n\n</li>\n</ol>\n<code-example header=\"src/app/greeting/greeting.module.ts\" path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"for-root\">\n<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: UserServiceConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&lt;GreetingModule&gt; {\n  return {\n    ngModule: GreetingModule,\n    providers: [\n      {provide: UserServiceConfig, useValue: config }\n    ]\n  };\n}\n\n</code-example>\n<p><a id=\"forRoot-router\"></a></p>\n<h3 id=\"forroot-and-the-router\" translation-result=\"on\"><code>forRoot()</code> 和 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#forroot-和-router\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\"><code>forRoot()</code> and the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#forroot-and-the-router\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 中提供了 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 服務，同時還有一些路由指令，比如 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 和 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 等。應用的根模組匯入了 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>，以便應用中有一個 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 服務，並且讓應用的根元件可以存取各個路由器指令。任何一個特性模組也必須匯入 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>，這樣它們的元件範本中才能使用這些路由器指令。</p><p translation-origin=\"off\"><code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> provides the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> service, as well as router directives, such as <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> and <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code>.\nThe root application module imports <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> so that the application has a <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> and the root application components can access the router directives.\nAny feature modules must also import <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> so that their components can place router directives into their templates.</p>\n\n<p translation-result=\"on\">如果 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 沒有 <code>forRoot()</code>，那麼每個特性模組都會例項化一個新的 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 例項，而這會破壞應用的正常邏輯，因為應用中只能有一個 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 例項。透過使用 <code>forRoot()</code> 方法，應用的根模組中會匯入 <code>RouterModule.forRoot(...)</code>，從而獲得一個 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 例項，而所有的特性模組要匯入 <code>RouterModule.forChild(...)</code>，它就不會例項化另外的 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>。</p><p translation-origin=\"off\">If the <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> didn't have <code>forRoot()</code> then each feature module would instantiate a new <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> instance, which would break the application as there can only be one <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>.\nBy using the <code>forRoot()</code> method, the root application module imports <code>RouterModule.forRoot(...)</code> and gets a <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>, and all feature modules import <code>RouterModule.forChild(...)</code> which does not instantiate another <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n如果你的某個模組也同時有 providers 和 declarations，你也<em>可以</em>使用這種技巧來把它們分開。你可能會在某些傳統應用中看到這種模式。\n不過，從 Angular 6.0 開始，提供服務的最佳實踐是使用 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 的 <code>providedIn</code> 屬性。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nIf you have a module which has both providers and declarations, you <em>can</em> use this technique to separate them out and you may see this pattern in legacy applications.\nHowever, since Angular 6.0, the best practice for providing services is with the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> <code>providedIn</code> property.</p>\n\n</div>\n<h3 id=\"how-forroot-works\" translation-result=\"on\"><code>forRoot()</code> 的工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#how-forroot-works\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">How <code>forRoot()</code> works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#how-forroot-works\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>forRoot()</code> 會接受一個服務配置物件，並返回一個 <a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a> 物件，它帶有下列屬性：</p><p translation-origin=\"off\"><code>forRoot()</code> takes a service configuration object and returns a <a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>, which is a simple object with the following properties:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">屬性</nt-wrapper><nt-wrapper translation-origin=\"off\">Properties</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>ngModule</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在這個例子中，就是 <code>GreetingModule</code> 類別。</nt-wrapper><nt-wrapper translation-origin=\"off\">In this example, the <code>GreetingModule</code> class</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>providers</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">配置好的服務提供者</nt-wrapper><nt-wrapper translation-origin=\"off\">The configured providers</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">在這個 <live-example name=\"ngmodules\">現場演練</live-example>中，根模組 <code>AppModule</code> 匯入了 <code>GreetingModule</code>，並把它的 <code>providers</code> 新增到了 <code>AppModule</code> 的服務提供者列表中。特別是，Angular 會把所有從其它模組匯入的提供者追加到本模組的 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 中列出的提供者之前。這種順序可以確保你在 <code>AppModule</code> 的 <code>providers</code> 中顯式列出的提供者，其優先順序高於匯入模組中給出的提供者。</p><p translation-origin=\"off\">In the <live-example name=\"ngmodules\">live example</live-example> the root <code>AppModule</code> imports the <code>GreetingModule</code> and adds the <code>providers</code> to the <code>AppModule</code> providers.\nSpecifically, Angular accumulates all imported providers before appending the items listed in <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>.\nThis sequence ensures that whatever you add explicitly to the <code>AppModule</code> providers takes precedence over the providers of imported modules.</p>\n\n<p translation-result=\"on\">在這個範例應用中，匯入 <code>GreetingModule</code>，並只在 <code>AppModule</code> 中呼叫一次它的 <code>forRoot()</code> 方法。像這樣註冊它一次就可以防止出現多個例項。</p><p translation-origin=\"off\">The sample application imports <code>GreetingModule</code> and uses its <code>forRoot()</code> method one time, in <code>AppModule</code>.\nRegistering it once like this prevents multiple instances.</p>\n\n<p translation-result=\"on\">你還可以在 <code>GreetingModule</code> 中新增一個用於配置 <code>UserService</code> 的 <code>forRoot()</code> 方法。</p><p translation-origin=\"off\">You can also add a <code>forRoot()</code> method in the <code>GreetingModule</code> that configures the greeting <code>UserService</code>.</p>\n\n<p translation-result=\"on\">在下面的例子中，可選的注入 <code>UserServiceConfig</code> 擴充了 <code>UserService</code>。如果 <code>UserServiceConfig</code> 存在，就從這個配置中設定使用者名稱。</p><p translation-origin=\"off\">In the following example, the optional, injected <code>UserServiceConfig</code> extends the greeting <code>UserService</code>.\nIf a <code>UserServiceConfig</code> exists, the <code>UserService</code> sets the user name from that config.</p>\n\n<code-example header=\"src/app/greeting/user.service.ts (constructor)\" path=\"ngmodules/src/app/greeting/user.service.ts\" region=\"ctor\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() config?: UserServiceConfig) {\n  if (config) { this._userName = config.userName; }\n}\n\n</code-example>\n<p translation-result=\"on\">下面是一個接受 <code>UserServiceConfig</code> 引數的 <code>forRoot()</code> 方法：</p><p translation-origin=\"off\">Here's <code>forRoot()</code> that takes a <code>UserServiceConfig</code> object:</p>\n\n<code-example header=\"src/app/greeting/greeting.module.ts (forRoot)\" path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"for-root\">\n<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: UserServiceConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&lt;GreetingModule&gt; {\n  return {\n    ngModule: GreetingModule,\n    providers: [\n      {provide: UserServiceConfig, useValue: config }\n    ]\n  };\n}\n\n</code-example>\n<p translation-result=\"on\">最後，在 <code>AppModule</code> 的 <code>imports</code><em>列表</em>中呼叫它。在下面的程式碼片段中，省略了檔案的另一部分。要檢視完整檔案，參閱 <live-example name=\"ngmodules\"></live-example> 或繼續閱讀本文件的後續章節。</p><p translation-origin=\"off\">Lastly, call it within the <code>imports</code> list of the <code>AppModule</code>.\nIn the following snippet, other parts of the file are left out.\nFor the complete file, see the <live-example name=\"ngmodules\"></live-example>, or continue to the next section of this document.</p>\n\n<code-example header=\"src/app/app.module.ts (imports)\" path=\"ngmodules/src/app/app.module.ts\" region=\"import-for-root\">\nimport { GreetingModule } from './greeting/greeting.module';\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    GreetingModule.forRoot({userName: 'Miss Marple'}),\n  ],\n})\n\n</code-example>\n<p translation-result=\"on\">該應用不再顯示預設的 “Sherlock Holmes”，而是用 “Miss Marple” 作為使用者名稱稱。</p><p translation-origin=\"off\">The application displays \"Miss Marple\" as the user instead of the default \"Sherlock Holmes\".</p>\n\n<p translation-result=\"on\">記住：在本檔案的頂部要以 JavaScript import 形式匯入 <code>GreetingModule</code>，並且不要把它多次加入到本 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>imports</code> 列表中。</p><p translation-origin=\"off\">Remember to import <code>GreetingModule</code> as a Javascript import at the top of the file and don't add it to more than one <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> <code>imports</code> list.</p>\n\n<h2 id=\"prevent-reimport-of-the-greetingmodule\" translation-result=\"on\">防止重複匯入 <code>GreetingModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#prevent-reimport-of-the-greetingmodule\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Prevent reimport of the <code>GreetingModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#prevent-reimport-of-the-greetingmodule\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">只有根模組 <code>AppModule</code> 才能匯入 <code>GreetingModule</code>。如果一個延遲載入模組也匯入了它，該應用就會為服務產生<a href=\"guide/ngmodule-faq#q-why-bad\">多個例項</a>。</p><p translation-origin=\"off\">Only the root <code>AppModule</code> should import the <code>GreetingModule</code>.\nIf a lazy-loaded module imports it too, the application can generate <a href=\"guide/ngmodule-faq#q-why-bad\">multiple instances</a> of a service.</p>\n\n<p translation-result=\"on\">要想防止延遲載入模組重複匯入 <code>GreetingModule</code>，可以新增如下的 <code>GreetingModule</code> 建構函式。</p><p translation-origin=\"off\">To guard against a lazy loaded module re-importing <code>GreetingModule</code>, add the following <code>GreetingModule</code> constructor.</p>\n\n<code-example header=\"src/app/greeting/greeting.module.ts\" path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"ctor\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule?: GreetingModule) {\n  if (parentModule) {\n    throw new Error(\n      'GreetingModule is already loaded. Import it in the AppModule only');\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">該建構函式要求 Angular 把 <code>GreetingModule</code> 注入它自己。如果 Angular 在<em>當前</em>注入器中查詢 <code>GreetingModule</code>，這次注入就會導致死迴圈，但是 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 裝飾器的意思是 \"在注入器樹中層次高於我的祖先注入器中查詢 <code>GreetingModule</code>。\"</p><p translation-origin=\"off\">The constructor tells Angular to inject the <code>GreetingModule</code> into itself.\nThe injection would be circular if Angular looked for <code>GreetingModule</code> in the <em>current</em> injector, but the <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> decorator means \"look for <code>GreetingModule</code> in an ancestor injector, above me in the injector hierarchy.\"</p>\n\n<p translation-result=\"on\">預設情況下，當注入器找不到想找的提供者時，會丟擲一個錯誤。但 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 裝飾器表示找不到該服務也無所謂。於是注入器會返回 <code>null</code>，<code>parentModule</code> 引數也就被賦成了空值，而建構函式沒有任何例外。</p><p translation-origin=\"off\">By default, the injector throws an error when it can't find a requested provider.\nThe <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> decorator means not finding the service is OK.\nThe injector returns <code>null</code>, the <code>parentModule</code> parameter is null, and the constructor concludes uneventfully.</p>\n\n<p translation-result=\"on\">但如果你把 <code>GreetingModule</code> 匯入到像 <code>CustomersModule</code> 這樣的延遲載入模組中，事情就不一樣了。</p><p translation-origin=\"off\">It's a different story if you improperly import <code>GreetingModule</code> into a lazy loaded module such as <code>CustomersModule</code>.</p>\n\n<p translation-result=\"on\">Angular 建立延遲載入模組時會給它一個自己的注入器，它是根注入器的<em>子注入器</em>。<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 讓 Angular 在其父注入器中查詢 <code>GreetingModule</code>，這次，它的父注入器是根注入器（而上次的父注入器是空）。當然，這次它找到了由根模組 <code>AppModule</code> 匯入的例項。該建構函式檢測到存在 <code>parentModule</code>，於是丟擲一個錯誤。</p><p translation-origin=\"off\">Angular creates a lazy loaded module with its own injector, a child of the root injector.\n<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> causes Angular to look for a <code>GreetingModule</code> in the parent injector, which this time is the root injector.\nOf course it finds the instance imported by the root <code>AppModule</code>.\nNow <code>parentModule</code> exists and the constructor throws the error.</p>\n\n<p translation-result=\"on\">以下這兩個檔案僅供參考：</p><p translation-origin=\"off\">Here are the two files in their entirety for reference:</p>\n\n<code-tabs>\n   <code-pane header=\"app.module.ts\" path=\"ngmodules/src/app/app.module.ts\">\n\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\n\n/* App Root */\nimport { AppComponent } from './app.component';\n\n/* Feature Modules */\nimport { ContactModule } from './contact/contact.module';\nimport { GreetingModule } from './greeting/greeting.module';\n\n/* Routing Module */\nimport { AppRoutingModule } from './app-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    ContactModule,\n    GreetingModule.forRoot({userName: 'Miss Marple'}),\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n\n</code-pane>\n   <code-pane header=\"greeting.module.ts\" region=\"whole-greeting-module\" path=\"ngmodules/src/app/greeting/greeting.module.ts\">\nimport { <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>, <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> } from '@angular/core';\n\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\n\nimport { GreetingComponent } from './greeting.component';\nimport { UserServiceConfig } from './user.service';\n\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> ],\n  declarations: [ GreetingComponent ],\n  exports:      [ GreetingComponent ]\n})\nexport class GreetingModule {\n  constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule?: GreetingModule) {\n    if (parentModule) {\n      throw new Error(\n        'GreetingModule is already loaded. Import it in the AppModule only');\n    }\n  }\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: UserServiceConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&lt;GreetingModule&gt; {\n    return {\n      ngModule: GreetingModule,\n      providers: [\n        {provide: UserServiceConfig, useValue: config }\n      ]\n    };\n  }\n}\n\n</code-pane>\n</code-tabs>\n<h2 id=\"more-on-ngmodules\" translation-result=\"on\">關於 NgModule 的更多知識<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#more-on-ngmodules\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">More on NgModules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#more-on-ngmodules\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你還可能對下列內容感興趣：</p><p translation-origin=\"off\">You may also be interested in:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"guide/sharing-ngmodules\">共享模組</a>解釋了本頁中涉及的這些概念</p><p translation-origin=\"off\"><a href=\"guide/sharing-ngmodules\">Sharing Modules</a>, which elaborates on the concepts covered on this page</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/lazy-loading-ngmodules\">延遲載入模組</a></p><p translation-origin=\"off\"><a href=\"guide/lazy-loading-ngmodules\">Lazy Loading Modules</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/ngmodule-faq\">NgModule 常見問題</a></p><p translation-origin=\"off\"><a href=\"guide/ngmodule-faq\">NgModule FAQ</a></p>\n\n</li>\n</ul>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/creating-libraries\n - guide/lazy-loading-ngmodules\n - guide/module-types\n - guide/ngmodule-faq\n - guide/providers\n - guide/router-tutorial\n - guide/router-tutorial-toh\n-->\n<!-- links from this doc:\n - api/common/CommonModule\n - api/core/Injectable\n - api/core/ModuleWithProviders\n - api/core/NgModule\n - api/core/NgModule#providers\n - api/core/Optional\n - api/core/SkipSelf\n - api/platform-browser/BrowserModule\n - api/router/Router\n - api/router/RouterLink\n - api/router/RouterModule\n - api/router/RouterOutlet\n - api/upgrade/static\n - guide/lazy-loading-ngmodules\n - guide/ngmodule-faq\n - guide/ngmodule-faq#q-why-bad\n - guide/sharing-ngmodules\n - guide/singleton-services#forroot-and-the-router\n - guide/singleton-services#forroot-和-router\n - guide/singleton-services#forroot-模式\n - guide/singleton-services#forroot-的工作原理\n - guide/singleton-services#how-forroot-works\n - guide/singleton-services#more-on-ngmodules\n - guide/singleton-services#ngmodule-providers-array\n - guide/singleton-services#ngmodule-的-providers-陣列\n - guide/singleton-services#prevent-reimport-of-the-greetingmodule\n - guide/singleton-services#providedIn\n - guide/singleton-services#providing-a-singleton-service\n - guide/singleton-services#singleton-services\n - guide/singleton-services#the-forroot-pattern\n - guide/singleton-services#using-providedin\n - guide/singleton-services#使用-providedin\n - guide/singleton-services#關於-ngmodule-的更多知識\n - guide/singleton-services#單例服務\n - guide/singleton-services#提供單例服務\n - guide/singleton-services#防止重複匯入-greetingmodule\n - tutorial/tour-of-heroes\n - tutorial/tour-of-heroes/toh-pt4\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/singleton-services.md?message=docs%3A%20請簡述你的修改...\n-->"}