{"id":"guide/aot-compiler","title":"Ahead-of-time (AOT) compilation","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/aot-compiler.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"ahead-of-time-aot-compilation\" translation-result=\"on\">預先（AOT）編譯器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#ahead-of-time-aot-compilation\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Ahead-of-time (AOT) compilation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#ahead-of-time-aot-compilation\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">Angular 應用主要由元件及其 HTML 範本組成。由於瀏覽器無法直接理解 Angular 所提供的元件和範本，因此 Angular 應用程式需要先進行編譯才能在瀏覽器中執行。</p><p translation-origin=\"off\">An Angular application consists mainly of components and their HTML templates.\nBecause the components and templates provided by Angular cannot be understood by the browser directly, Angular applications require a compilation process before they can run in a browser.</p>\n\n<p translation-result=\"on\">在瀏覽器下載和執行程式碼<em>之前</em>的編譯階段，Angular 預先（AOT）編譯器會先把你的 Angular HTML 和 TypeScript 程式碼轉換成高效的 JavaScript 程式碼。在建構期間編譯應用可以讓瀏覽器中的渲染更快速。</p><p translation-origin=\"off\">The Angular <a href=\"guide/glossary#aot\">ahead-of-time (AOT) compiler</a> converts your Angular HTML and TypeScript code into efficient JavaScript code during the build phase <em>before</em> the browser downloads and runs that code.\nCompiling your application during the build process provides a faster rendering in the browser.</p>\n\n<p translation-result=\"on\">本指南中解釋瞭如何指定元資料，並使用一些編譯器選項以藉助 AOT 編譯器來更有效的編譯應用。</p><p translation-origin=\"off\">This guide explains how to specify metadata and apply available compiler options to compile your applications efficiently using the AOT compiler.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><a href=\"https://www.youtube.com/watch?v=anphffaCZrQ\">觀看 Alex Rickabaugh 在 AngularConnect 2019 解釋 Angular 編譯器的演講</a>。</p><p translation-origin=\"off\"><a href=\"https://www.youtube.com/watch?v=anphffaCZrQ\">Watch Alex Rickabaugh explain the Angular compiler</a> at AngularConnect 2019.</p>\n\n</div>\n<p><a id=\"why-aot\"></a></p>\n<p translation-result=\"on\">下面是你可能要使用 AOT 的部分原因。</p><p translation-origin=\"off\">Here are some reasons you might want to use AOT.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">原因</nt-wrapper><nt-wrapper translation-origin=\"off\">Reasons</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">更快的渲染方式</nt-wrapper><nt-wrapper translation-origin=\"off\">Faster rendering</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">使用 AOT，瀏覽器會下載應用程式的預編譯版本。瀏覽器載入可執行程式碼，以便立即渲染應用程式，而無需等待先編譯應用程式。</nt-wrapper><nt-wrapper translation-origin=\"off\">With AOT, the browser downloads a pre-compiled version of the application. The browser loads executable code so it can render the application immediately, without waiting to compile the application first.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">更少的非同步請求</nt-wrapper><nt-wrapper translation-origin=\"off\">Fewer asynchronous requests</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">編譯器在應用程式 JavaScript 中<em>內聯</em>外部 HTML 範本和 CSS 樣式表，消除對這些原始檔的單個 ajax 請求。</nt-wrapper><nt-wrapper translation-origin=\"off\">The compiler <em>inlines</em> external HTML templates and CSS style sheets within the application JavaScript, eliminating separate ajax requests for those source files.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">更小的 Angular 框架下載大小</nt-wrapper><nt-wrapper translation-origin=\"off\">Smaller Angular framework download size</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果應用程式已被編譯，則無需下載 Angular 編譯器。編譯器大約是 Angular 本身的一半，因此省略它會大大減少應用程式的體積。</nt-wrapper><nt-wrapper translation-origin=\"off\">There's no need to download the Angular compiler if the application is already compiled. The compiler is roughly half of Angular itself, so omitting it dramatically reduces the application payload.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">及早檢測範本錯誤</nt-wrapper><nt-wrapper translation-origin=\"off\">Detect template errors earlier</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">AOT 編譯器會在使用者看到之前在建構步驟中檢測並報告範本繫結錯誤。</nt-wrapper><nt-wrapper translation-origin=\"off\">The AOT compiler detects and reports template binding errors during the build step before users can see them.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">更好的安全性</nt-wrapper><nt-wrapper translation-origin=\"off\">Better security</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">AOT 會在 HTML 範本和元件提供給客戶端之前就將它們編譯為 JavaScript 檔案。由於沒有要讀取的範本，也沒有危險的客戶端 HTML 或 JavaScript 求值，因此注入攻擊的機會更少。</nt-wrapper><nt-wrapper translation-origin=\"off\">AOT compiles HTML templates and components into JavaScript files long before they are served to the client. With no templates to read and no risky client-side HTML or JavaScript evaluation, there are fewer opportunities for injection attacks.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p><a id=\"overview\"></a></p>\n<h2 id=\"choosing-a-compiler\" translation-result=\"on\">選擇編譯器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#choosing-a-compiler\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Choosing a compiler<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#choosing-a-compiler\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 提供了兩種方式來編譯你的應用：</p><p translation-origin=\"off\">Angular offers two ways to compile your application:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">Angular 編譯方式</nt-wrapper><nt-wrapper translation-origin=\"off\">Angular compile</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">即時（JIT）</nt-wrapper><nt-wrapper translation-origin=\"off\">Just-in-Time (JIT)</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">當執行時在瀏覽器中編譯你的應用程式。在 Angular 8 之前，這是預設值。</nt-wrapper><nt-wrapper translation-origin=\"off\">Compiles your application in the browser at runtime. This was the default until Angular 8.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">預先（AOT）</nt-wrapper><nt-wrapper translation-origin=\"off\">Ahead-of-Time (AOT)</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在建構時編譯你的應用程式和庫。這是從 Angular 9 開始的預設值。</nt-wrapper><nt-wrapper translation-origin=\"off\">Compiles your application and libraries at build time. This is the default starting in Angular 9.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">當執行 CLI 命令 <a href=\"cli/build\"><code>ng build</code></a> （只建構）或 <a href=\"cli/serve\"><code>ng serve</code></a>（建構並啟動本地伺服器）時，編譯型別（JIT 或 AOT）取決於你在 <code>angular.json</code> 中的建構配置所指定的 <code>aot</code> 屬性。預設情況下，對於新的 CLI 應用，其 <code>aot</code> 為 <code>true</code>。</p><p translation-origin=\"off\">When you run the <a href=\"cli/build\"><code>ng build</code></a> (build only) or <a href=\"cli/serve\"><code>ng serve</code></a> (build and serve locally) CLI commands, the type of compilation (JIT or AOT) depends on the value of the <code>aot</code> property in your build configuration specified in <code>angular.json</code>.\nBy default, <code>aot</code> is set to <code>true</code> for new CLI applications.</p>\n\n<p translation-result=\"on\">要了解更多，參閱<a href=\"cli\">CLI 文件</a>，和 <a href=\"guide/build\">建構與執行 Angular 應用</a>。</p><p translation-origin=\"off\">See the <a href=\"cli\">CLI command reference</a> and <a href=\"guide/build\">Building and serving Angular apps</a> for more information.</p>\n\n<h2 id=\"how-aot-works\" translation-result=\"on\">AOT 工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#how-aot-works\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">How AOT works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#how-aot-works\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular AOT 編譯器會提取<strong>元資料</strong>來解釋應由 Angular 管理的應用程式部分。你可以在<strong>裝飾器</strong>（比如 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 和 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>）中顯式指定元資料，也可以在<strong>被裝飾的類</strong>的建構函式宣告中隱含指定元資料。元資料告訴 Angular 要如何構造應用程式類別的例項並在執行時與它們進行互動。</p><p translation-origin=\"off\">The Angular AOT compiler extracts <strong>metadata</strong> to interpret the parts of the application that Angular is supposed to manage.\nYou can specify the metadata explicitly in <strong>decorators</strong> such as <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> and <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, or implicitly in the constructor declarations of the decorated classes.\nThe metadata tells Angular how to construct instances of your application classes and interact with them at runtime.</p>\n\n<p translation-result=\"on\">在下列範例中，<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 元資料物件和類別的建構函式會告訴 Angular 如何建立和顯示 <code>TypicalComponent</code> 的例項。</p><p translation-origin=\"off\">In the following example, the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> metadata object and the class constructor tell Angular how to create and display an instance of <code>TypicalComponent</code>.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-typical',\n  template: '&lt;div&gt;A typical component for {{data.name}}&lt;/div&gt;'\n})\nexport class TypicalComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() data: TypicalData;\n  constructor(private someService: SomeService) { … }\n}\n\n</code-example>\n<p translation-result=\"on\">Angular 編譯器只提取<strong>一次</strong>元資料，並且為 <code>TypicalComponent</code> 產生一個<strong>工廠</strong>。當它需要建立 <code>TypicalComponent</code> 的例項時，Angular 呼叫這個工廠，工廠會產生一個新的可視元素，並且把它（及其依賴）繫結到元件類別的一個新例項上。</p><p translation-origin=\"off\">The Angular compiler extracts the metadata <em>once</em> and generates a <em>factory</em> for <code>TypicalComponent</code>.\nWhen it needs to create a <code>TypicalComponent</code> instance, Angular calls the factory, which produces a new visual element, bound to a new instance of the component class with its injected dependency.</p>\n\n<h3 id=\"compilation-phases\" translation-result=\"on\">編譯的各個階段<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#compilation-phases\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Compilation phases<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#compilation-phases\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">AOT 編譯分為三個階段。</p><p translation-origin=\"off\">There are three phases of AOT compilation.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">階段</nt-wrapper><nt-wrapper translation-origin=\"off\">Phase</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">程式碼分析</nt-wrapper><nt-wrapper translation-origin=\"off\">code analysis</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在此階段，TypeScript 編譯器和<em>AOT 收集器</em>會建立原始碼的表示。收集器不會嘗試解釋它收集的元資料。它會盡可能地表示元資料，並在檢測到元資料語法違規時記錄錯誤。</nt-wrapper><nt-wrapper translation-origin=\"off\">In this phase, the TypeScript compiler and <em>AOT collector</em> create a representation of the source. The collector does not attempt to interpret the metadata it collects. It represents the metadata as best it can and records errors when it detects a metadata syntax violation.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">程式碼產生器</nt-wrapper><nt-wrapper translation-origin=\"off\">code generation</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在此階段，編譯器的 <code>StaticReflector</code> 會解釋在階段 1 收集的元資料，對元資料執行額外的驗證，如果檢測到違反元資料限制，則會丟擲錯誤。</nt-wrapper><nt-wrapper translation-origin=\"off\">In this phase, the compiler's <code>StaticReflector</code> interprets the metadata collected in phase 1, performs additional validation of the metadata, and throws an error if it detects a metadata restriction violation.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">範本型別檢查</nt-wrapper><nt-wrapper translation-origin=\"off\">template type checking</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在此可選階段，Angular <em>範本編譯器</em>使用 TypeScript 編譯器來驗證範本中的繫結表示式。你可以透過設定 <code>strictTemplates</code> 配置選項來明確啟用此階段。請參閱 <a href=\"guide/angular-compiler-options\">Angular 編譯器選項</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">In this optional phase, the Angular <em>template compiler</em> uses the TypeScript compiler to validate the binding expressions in templates. You can enable this phase explicitly by setting the <code>strictTemplates</code> configuration option; see <a href=\"guide/angular-compiler-options\">Angular compiler options</a>.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<h3 id=\"metadata-restrictions\" translation-result=\"on\">元資料的限制<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-restrictions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Metadata restrictions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-restrictions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你只能使用 TypeScript 的一個<strong>子集</strong>書寫元資料，它必須滿足下列限制：</p><p translation-origin=\"off\">You write metadata in a <em>subset</em> of TypeScript that must conform to the following general constraints:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"guide/aot-compiler#expression-syntax\">表示式語法</a>只支援 JavaScript 的一個有限的子集</p><p translation-origin=\"off\">Limit <a href=\"guide/aot-compiler#expression-syntax\">expression syntax</a> to the supported subset of JavaScript</p>\n\n</li>\n<li>\n<p translation-result=\"on\">只能參考<a href=\"guide/aot-compiler#code-folding\">程式碼收縮</a>後匯出的符號</p><p translation-origin=\"off\">Only reference exported symbols after <a href=\"guide/aot-compiler#code-folding\">code folding</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\">只能呼叫編譯器<a href=\"guide/aot-compiler#supported-functions\">支援的函式</a></p><p translation-origin=\"off\">Only call <a href=\"guide/aot-compiler#supported-functions\">functions supported</a> by the compiler</p>\n\n</li>\n<li>\n<p translation-result=\"on\">輸入屬性、輸出屬性和用於資料繫結的類成員必須是公共（public）的或受保護的（protected）。</p><p translation-origin=\"off\">Input/Outputs and data-bound class members must be public or protected.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">關於準備 AOT 編譯應用程式的其它準則和說明，參閱 <a href=\"https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f\">Angular：編寫 AOT 友好的應用程式</a>。</p><p translation-origin=\"off\">For additional guidelines and instructions on preparing an application for AOT compilation, see <a href=\"https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f\">Angular: Writing AOT-friendly applications</a>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">AOT 編譯中的錯誤通常是由於元資料不符合編譯器的要求而發生的（下面將更全面地介紹）。為了幫助你理解和解決這些問題，參閱 <a href=\"guide/aot-metadata-errors\">AOT 元資料錯誤</a>。</p><p translation-origin=\"off\">Errors in AOT compilation commonly occur because of metadata that does not conform to the compiler's requirements (as described more fully below).\nFor help in understanding and resolving these problems, see <a href=\"guide/aot-metadata-errors\">AOT Metadata Errors</a>.</p>\n\n</div>\n<h3 id=\"configuring-aot-compilation\" translation-result=\"on\">配置 AOT 編譯<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#configuring-aot-compilation\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Configuring AOT compilation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#configuring-aot-compilation\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以在 <a href=\"guide/typescript-configuration\">TypeScript 配置檔案</a>中提供控制編譯過程的選項。關於可用選項的完整列表，參閱 <a href=\"guide/angular-compiler-options\">Angular 編譯器</a>選項。</p><p translation-origin=\"off\">You can provide options in the <a href=\"guide/typescript-configuration\">TypeScript configuration file</a> that controls the compilation process.\nSee <a href=\"guide/angular-compiler-options\">Angular compiler options</a> for a complete list of available options.</p>\n\n<h2 id=\"phase-1-code-analysis\" translation-result=\"on\">階段 1：分析<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-1-code-analysis\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Phase 1: Code analysis<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-1-code-analysis\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">TypeScript 編譯器會做一些初步的分析工作，它會產生<strong>型別定義檔案</strong><code>.d.ts</code>，其中帶有型別資訊，Angular 編譯器需要藉助它們來產生程式碼。\n同時，AOT <strong>收集器（collector）</strong> 會記錄 Angular 裝飾器中的元資料，並把它們輸出到<strong><code>.metadata.json</code></strong>檔案中，和每個 <code>.d.ts</code> 檔案相對應。</p><p translation-origin=\"off\">The TypeScript compiler does some of the analytic work of the first phase.\nIt emits the <code>.d.ts</code> <em>type definition files</em> with type information that the AOT compiler needs to generate application code.\nAt the same time, the AOT <strong>collector</strong> analyzes the metadata recorded in the Angular decorators and outputs metadata information in <strong><code>.metadata.json</code></strong> files, one per <code>.d.ts</code> file.</p>\n\n<p translation-result=\"on\">你可以把 <code>.metadata.json</code> 檔案看做一個包括全部裝飾器的元資料的全景圖，就像<a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">抽象語法樹（AST）</a>一樣。</p><p translation-origin=\"off\">You can think of <code>.metadata.json</code> as a diagram of the overall structure of a decorator's metadata, represented as an <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">abstract syntax tree (AST)</a>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">Angular 的 <a href=\"https://github.com/angular/angular/blob/main/packages/compiler-cli/src/metadata/schema.ts\">schema.ts</a> 會將 JSON 格式描述為 TypeScript 介面的集合。</p><p translation-origin=\"off\">Angular's <a href=\"https://github.com/angular/angular/blob/main/packages/compiler-cli/src/metadata/schema.ts\">schema.ts</a> describes the JSON format as a collection of TypeScript interfaces.</p>\n\n</div>\n<p><a id=\"expression-syntax\"></a></p>\n<h3 id=\"expression-syntax-limitations\" translation-result=\"on\">表示式語法限制<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#expression-syntax-limitations\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Expression syntax limitations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#expression-syntax-limitations\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">AOT 收集器只能理解 JavaScript 的一個子集。定義元資料物件時要遵循下列語法限制：</p><p translation-origin=\"off\">The AOT collector only understands a subset of JavaScript.\nDefine metadata objects with the following limited syntax:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">語法</nt-wrapper><nt-wrapper translation-origin=\"off\">Syntax</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">範例</nt-wrapper><nt-wrapper translation-origin=\"off\">Example</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">物件字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Literal object</nt-wrapper></td>\n<td align=\"left\"><code>{cherry: true, apple: true, mincemeat: false}</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">陣列字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Literal array</nt-wrapper></td>\n<td align=\"left\"><code>['cherries', 'flour', 'sugar']</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">展開陣列字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Spread in literal array</nt-wrapper></td>\n<td align=\"left\"><code>['apples', 'flour', ...]</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">函式呼叫</nt-wrapper><nt-wrapper translation-origin=\"off\">Calls</nt-wrapper></td>\n<td align=\"left\"><code>bake(ingredients)</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">新建物件</nt-wrapper><nt-wrapper translation-origin=\"off\">New</nt-wrapper></td>\n<td align=\"left\"><code>new Oven()</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">屬性存取</nt-wrapper><nt-wrapper translation-origin=\"off\">Property access</nt-wrapper></td>\n<td align=\"left\"><code>pie.slice</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">陣列索引存取</nt-wrapper><nt-wrapper translation-origin=\"off\">Array index</nt-wrapper></td>\n<td align=\"left\"><code>ingredients[0]</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">參考識別符號</nt-wrapper><nt-wrapper translation-origin=\"off\">Identity reference</nt-wrapper></td>\n<td align=\"left\"><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">範本字串</nt-wrapper><nt-wrapper translation-origin=\"off\">A template string</nt-wrapper></td>\n<td align=\"left\"><code>`pie is ${multiplier} times better than cake`</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">字串字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Literal string</nt-wrapper></td>\n<td align=\"left\"><code>'pi'</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">數字字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Literal number</nt-wrapper></td>\n<td align=\"left\"><code>3.14153265</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">邏輯字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Literal boolean</nt-wrapper></td>\n<td align=\"left\"><code>true</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">null 字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Literal null</nt-wrapper></td>\n<td align=\"left\"><code>null</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">受支援的字首運算子</nt-wrapper><nt-wrapper translation-origin=\"off\">Supported prefix operator</nt-wrapper></td>\n<td align=\"left\"><code>!cake</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">受支援的二元運算子</nt-wrapper><nt-wrapper translation-origin=\"off\">Supported binary operator</nt-wrapper></td>\n<td align=\"left\"><code>a+b</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">條件運算子</nt-wrapper><nt-wrapper translation-origin=\"off\">Conditional operator</nt-wrapper></td>\n<td align=\"left\"><code>a ? b : c</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">括號</nt-wrapper><nt-wrapper translation-origin=\"off\">Parentheses</nt-wrapper></td>\n<td align=\"left\"><code>(a+b)</code></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">如果表示式使用了不支援的語法，收集器就會往 <code>.metadata.json</code> 檔案中寫入一個錯誤節點。稍後，如果編譯器用到元資料中的這部分內容來產生應用程式碼，它就會報告這個錯誤。</p><p translation-origin=\"off\">If an expression uses unsupported syntax, the collector writes an error node to the <code>.metadata.json</code> file.\nThe compiler later reports the error if it needs that piece of metadata to generate the application code.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果你希望 <code>ngc</code> 立即彙報這些語法錯誤，而不要產生帶有錯誤資訊的 <code>.metadata.json</code> 檔案，可以到 TypeScript 的配置檔案中設定 <code>strictMetadataEmit</code> 選項。</p><p translation-origin=\"off\">If you want <code>ngc</code> to report syntax errors immediately rather than produce a <code>.metadata.json</code> file with errors, set the <code>strictMetadataEmit</code> option in the TypeScript configuration file.</p>\n\n<code-example format=\"json\" language=\"json\">\n\n\"angularCompilerOptions\": {\n  …\n  \"strictMetadataEmit\" : true\n}\n\n</code-example>\n<p translation-result=\"on\">Angular 庫透過這個選項來確保所有的 Angular <code>.metadata.json</code> 檔案都是乾淨的。當你要建構自己的程式碼庫時，這也同樣是一項最佳實踐。</p><p translation-origin=\"off\">Angular libraries have this option to ensure that all Angular <code>.metadata.json</code> files are clean and it is a best practice to do the same when building your own libraries.</p>\n\n</div>\n<p><a id=\"function-expression\"></a>\n<a id=\"arrow-functions\"></a></p>\n<h3 id=\"no-arrow-functions\" translation-result=\"on\">不要有箭頭函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#no-arrow-functions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">No arrow functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#no-arrow-functions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">AOT 編譯器不支援<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/function\">函式表示式</a>和<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭頭函式</a>，也叫 <em>lambda</em> 函式。</p><p translation-origin=\"off\">The AOT compiler does not support <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/function\">function expressions</a>\nand <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">arrow functions</a>, also called <em>lambda</em> functions.</p>\n\n<p translation-result=\"on\">考慮如下元件裝飾器：</p><p translation-origin=\"off\">Consider the following component decorator:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  …\n  providers: [{provide: server, useFactory: () =&gt; new Server()}]\n})\n\n</code-example>\n<p translation-result=\"on\">AOT 的收集器不支援在元資料表示式中出現箭頭函式 <code>() =&gt; new Server()</code>。它會在該函式中就地產生一個錯誤節點。稍後，當編譯器解釋該節點時，它就會報告一個錯誤，讓你把這個箭頭函式轉換成一個<em>匯出的函式</em>。</p><p translation-origin=\"off\">The AOT collector does not support the arrow function, <code>() =&gt; new Server()</code>, in a metadata expression.\nIt generates an error node in place of the function.\nWhen the compiler later interprets this node, it reports an error that invites you to turn the arrow function into an <em>exported function</em>.</p>\n\n<p translation-result=\"on\">你可以把它改寫成這樣來修復這個錯誤：</p><p translation-origin=\"off\">You can fix the error by converting to this:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport function serverFactory() {\n  return new Server();\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  …\n  providers: [{provide: server, useFactory: serverFactory}]\n})\n\n</code-example>\n<p translation-result=\"on\">在版本 5 和更高版本中，編譯器會在發出 <code>.js</code> 檔案時自動執行此重寫。</p><p translation-origin=\"off\">In version 5 and later, the compiler automatically performs this rewriting while emitting the <code>.js</code> file.</p>\n\n<p><a id=\"exported-symbols\"></a>\n<a id=\"code-folding\"></a></p>\n<h3 id=\"code-folding\" translation-result=\"on\">程式碼摺疊<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#code-folding\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Code folding<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#code-folding\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">編譯器只會解析到<strong><em>已匯出</em></strong>符號的參考。收集器可以在收集期間執行表示式，並用其結果記錄到 <code>.metadata.json</code> 中（而不是原始表示式中）。這樣可以讓你把非匯出符號的使用限制在表示式中。</p><p translation-origin=\"off\">The compiler can only resolve references to <strong><em>exported</em></strong> symbols.\nThe collector, however, can evaluate an expression during collection and record the result in the <code>.metadata.json</code>, rather than the original expression.\nThis allows you to make limited use of non-exported symbols within expressions.</p>\n\n<p translation-result=\"on\">比如，收集器可以估算表示式 <code>1 + 2 + 3 + 4</code> 並將其替換為結果 <code>10</code>。這個過程稱為<em>摺疊</em>。可以用這種方式簡化的表示式是<em>可摺疊的</em>。</p><p translation-origin=\"off\">For example, the collector can evaluate the expression <code>1 + 2 + 3 + 4</code> and replace it with the result, <code>10</code>.\nThis process is called <em>folding</em>.\nAn expression that can be reduced in this manner is <em>foldable</em>.</p>\n\n<p><a id=\"var-declaration\"></a></p>\n<p translation-result=\"on\">收集器可以計算對模組區域變數的 <code>const</code> 宣告和初始化過的 <code>var</code> 和 <code>let</code> 宣告，並從 <code>.metadata.json</code> 檔案中移除它們。</p><p translation-origin=\"off\">The collector can evaluate references to module-local <code>const</code> declarations and initialized <code>var</code> and <code>let</code> declarations, effectively removing them from the <code>.metadata.json</code> file.</p>\n\n<p translation-result=\"on\">考慮下列元件定義：</p><p translation-origin=\"off\">Consider the following component definition:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst template = '&lt;div&gt;{{hero.name}}&lt;/div&gt;';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n</code-example>\n<p translation-result=\"on\">編譯器不能參考 <code>template</code> 常量，因為它是未匯出的。但是收集器可以透過內聯 <code>template</code> 常量的方式把它<em>摺疊</em>進元資料定義中。最終的結果和你以前的寫法是一樣的：</p><p translation-origin=\"off\">The compiler could not refer to the <code>template</code> constant because it isn't exported.\nThe collector, however, can fold the <code>template</code> constant into the metadata definition by in-lining its contents.\nThe effect is the same as if you had written:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: '&lt;div&gt;{{hero.name}}&lt;/div&gt;'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n</code-example>\n<p translation-result=\"on\">這裡沒有對 <code>template</code> 的參考，因此，當編譯器稍後對位於 <code>.metadata.json</code> 中的收集器輸出進行解釋時，不會再出問題。</p><p translation-origin=\"off\">There is no longer a reference to <code>template</code> and, therefore, nothing to trouble the compiler when it later interprets the <em>collector's</em> output in <code>.metadata.json</code>.</p>\n\n<p translation-result=\"on\">你還可以透過把 <code>template</code> 常量包含在其它表示式中來讓這個例子深入一點：</p><p translation-origin=\"off\">You can take this example a step further by including the <code>template</code> constant in another expression:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst template = '&lt;div&gt;{{hero.name}}&lt;/div&gt;';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template + '&lt;div&gt;{{hero.title}}&lt;/div&gt;'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n</code-example>\n<p translation-result=\"on\">收集器把該表示式縮減成其等價的<em>已摺疊</em>字串：</p><p translation-origin=\"off\">The collector reduces this expression to its equivalent <em>folded</em> string:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n'&lt;div&gt;{{hero.name}}&lt;/div&gt;&lt;div&gt;{{hero.title}}&lt;/div&gt;'\n\n</code-example>\n<h4 id=\"foldable-syntax\" translation-result=\"on\">可摺疊的語法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#foldable-syntax\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Foldable syntax<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#foldable-syntax\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">下表中描述了收集器可以摺疊以及不能摺疊哪些表示式：</p><p translation-origin=\"off\">The following table describes which expressions the collector can and cannot fold:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">語法</nt-wrapper><nt-wrapper translation-origin=\"off\">Syntax</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">可摺疊？</nt-wrapper><nt-wrapper translation-origin=\"off\">Foldable</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">物件字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Literal object</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">陣列字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Literal array</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">展開陣列字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Spread in literal array</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">否</nt-wrapper><nt-wrapper translation-origin=\"off\">no</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">函式呼叫</nt-wrapper><nt-wrapper translation-origin=\"off\">Calls</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">否</nt-wrapper><nt-wrapper translation-origin=\"off\">no</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">新建物件</nt-wrapper><nt-wrapper translation-origin=\"off\">New</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">否</nt-wrapper><nt-wrapper translation-origin=\"off\">no</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">屬性存取</nt-wrapper><nt-wrapper translation-origin=\"off\">Property access</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果目標物件也是可摺疊的，則是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes, if target is foldable</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">陣列索引存取</nt-wrapper><nt-wrapper translation-origin=\"off\">Array index</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果目標陣列和索引都是可摺疊的，則是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes, if target and index are foldable</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">參考識別符號</nt-wrapper><nt-wrapper translation-origin=\"off\">Identity reference</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果參考的是區域性識別符號，則是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes, if it is a reference to a local</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">沒有替換表示式的範本字串</nt-wrapper><nt-wrapper translation-origin=\"off\">A template with no substitutions</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">有替換表示式的範本字串</nt-wrapper><nt-wrapper translation-origin=\"off\">A template with substitutions</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果替換表示式是可摺疊的，則是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes, if the substitutions are foldable</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">字串字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Literal string</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">數字字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Literal number</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">邏輯字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Literal boolean</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">null 字面量</nt-wrapper><nt-wrapper translation-origin=\"off\">Literal null</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">受支援的字首運算子</nt-wrapper><nt-wrapper translation-origin=\"off\">Supported prefix operator</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果運算元是可摺疊的，則是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes, if operand is foldable</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">受支援的二元運算子</nt-wrapper><nt-wrapper translation-origin=\"off\">Supported binary operator</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果左運算元和右運算元都是可摺疊的，則是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes, if both left and right are foldable</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">條件運算子</nt-wrapper><nt-wrapper translation-origin=\"off\">Conditional operator</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果條件是可摺疊的，則是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes, if condition is foldable</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">括號</nt-wrapper><nt-wrapper translation-origin=\"off\">Parentheses</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果表示式是可摺疊的，則是</nt-wrapper><nt-wrapper translation-origin=\"off\">yes, if the expression is foldable</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">如果表示式是不可摺疊的，那麼收集器就會把它作為一個 <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST</a>（抽象語法樹）寫入 <code>.metadata.json</code> 中，留給編譯器去解析。</p><p translation-origin=\"off\">If an expression is not foldable, the collector writes it to <code>.metadata.json</code> as an <a href=\"https://en.wikipedia.org/wiki/Abstract*syntax*tree\">AST</a> for the compiler to resolve.</p>\n\n<h2 id=\"phase-2-code-generation\" translation-result=\"on\">階段 2：程式碼產生器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-2-code-generation\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Phase 2: code generation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-2-code-generation\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">收集器不會試圖理解它收集並輸出到 <code>.metadata.json</code> 中的元資料，它所能做的只是儘可能準確的表述這些元資料，並在檢測到元資料中的語法違規時記錄這些錯誤。解釋這些 <code>.metadata.json</code> 是編譯器在程式碼產生器階段要承擔的工作。</p><p translation-origin=\"off\">The collector makes no attempt to understand the metadata that it collects and outputs to <code>.metadata.json</code>.\nIt represents the metadata as best it can and records errors when it detects a metadata syntax violation.\nIt's the compiler's job to interpret the <code>.metadata.json</code> in the code generation phase.</p>\n\n<p translation-result=\"on\">編譯器理解收集器支援的所有語法形式，但是它也可能拒絕那些雖然<em>語法正確</em>但<em>語義</em>違反了編譯器規則的元資料。</p><p translation-origin=\"off\">The compiler understands all syntax forms that the collector supports, but it may reject <em>syntactically</em> correct metadata if the <em>semantics</em> violate compiler rules.</p>\n\n<h3 id=\"public-or-protected-symbols\" translation-result=\"on\">公共的或受保護的符號<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#public-or-protected-symbols\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Public or protected symbols<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#public-or-protected-symbols\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">編譯器只能參考<em>已匯出的符號</em>。</p><p translation-origin=\"off\">The compiler can only reference <em>exported symbols</em>.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">帶有裝飾器的類成員必須是公開的（public）或保護的（protected）。你不可能把一個私有屬性做成 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>。</p><p translation-origin=\"off\">Decorated component class members must be public or protected.\nYou cannot make an <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> property private.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">資料繫結的屬性同樣必須是公開的（public）或保護的（protected）</p><p translation-origin=\"off\">Data bound properties must also be public or protected</p>\n\n</li>\n</ul>\n<p><a id=\"supported-functions\"></a></p>\n<h3 id=\"supported-classes-and-functions\" translation-result=\"on\">支援的類和函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#supported-classes-and-functions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Supported classes and functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#supported-classes-and-functions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">只要語法有效，收集器就可以用 <code>new</code> 來表示函式呼叫或物件建立。但是，編譯器在後面可以拒絕產生對<em>特定</em>函式的呼叫或對<em>特定</em>物件的建立。</p><p translation-origin=\"off\">The collector can represent a function call or object creation with <code>new</code> as long as the syntax is valid.\nThe compiler, however, can later refuse to generate a call to a <em>particular</em> function or creation of a <em>particular</em> object.</p>\n\n<p translation-result=\"on\">編譯器只能建立某些類別的例項，僅支援核心裝飾器，並且僅支援對返回表示式的宏（函式或靜態方法）的呼叫。</p><p translation-origin=\"off\">The compiler can only create instances of certain classes, supports only core decorators, and only supports calls to macros (functions or static methods) that return expressions.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">編譯器動作</nt-wrapper><nt-wrapper translation-origin=\"off\">Compiler action</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">新建例項</nt-wrapper><nt-wrapper translation-origin=\"off\">New instances</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">編譯器只允許建立來自 <code>@angular/core</code> 的 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 類建立例項。</nt-wrapper><nt-wrapper translation-origin=\"off\">The compiler only allows metadata that create instances of the class <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> from <code>@angular/core</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">支援的裝飾器</nt-wrapper><nt-wrapper translation-origin=\"off\">Supported decorators</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">編譯器只支援來自 <a href=\"api/core#decorators\"><code>@angular/core</code> 模組</a>的 Angular 裝飾器的元資料。</nt-wrapper><nt-wrapper translation-origin=\"off\">The compiler only supports metadata for the <a href=\"api/core#decorators\">Angular decorators in the <code>@angular/core</code> module</a>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">函式呼叫</nt-wrapper><nt-wrapper translation-origin=\"off\">Function calls</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">工廠函式必須匯出為命名函式。AOT 編譯器不支援用 Lambda 表示式（箭頭函式）充當工廠函式。</nt-wrapper><nt-wrapper translation-origin=\"off\">Factory functions must be exported, named functions. The AOT compiler does not support lambda expressions (\"arrow functions\") for factory functions.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p><a id=\"function-calls\"></a></p>\n<h3 id=\"functions-and-static-method-calls\" translation-result=\"on\">函式和靜態方法呼叫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#functions-and-static-method-calls\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Functions and static method calls<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#functions-and-static-method-calls\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">收集器接受任何只包含一個 <code>return</code> 陳述式的函式或靜態方法。編譯器也支援在返回表示式的函式或靜態函式中使用<em>宏</em>。</p><p translation-origin=\"off\">The collector accepts any function or static method that contains a single <code>return</code> statement.\nThe compiler, however, only supports macros in the form of functions or static methods that return an <em>expression</em>.</p>\n\n<p translation-result=\"on\">考慮下面的函式：</p><p translation-origin=\"off\">For example, consider the following function:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport function wrapInArray&lt;T&gt;(value: T): T[] {\n  return [value];\n}\n\n</code-example>\n<p translation-result=\"on\">你可以在元資料定義中呼叫 <code>wrapInArray</code>，因為它所返回的表示式的值滿足編譯器支援的 JavaScript 受限子集。</p><p translation-origin=\"off\">You can call the <code>wrapInArray</code> in a metadata definition because it returns the value of an expression that conforms to the compiler's restrictive JavaScript subset.</p>\n\n<p translation-result=\"on\">你還可以這樣使用 <code>wrapInArray()</code>：</p><p translation-origin=\"off\">You might use  <code>wrapInArray()</code> like this:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: wrapInArray(TypicalComponent)\n})\nexport class TypicalModule {}\n\n</code-example>\n<p translation-result=\"on\">編譯器會把這種用法處理成你以前的寫法：</p><p translation-origin=\"off\">The compiler treats this usage as if you had written:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [TypicalComponent]\n})\nexport class TypicalModule {}\n\n</code-example>\n<p translation-result=\"on\">Angular 的 <a href=\"api/router/RouterModule\"><code>RouterModule</code></a> 匯出了兩個靜態宏函式 <code>forRoot</code> 和 <code>forChild</code>，以幫助宣告根路由和子路由。\n檢視這些方法的<a href=\"https://github.com/angular/angular/blob/main/packages/router/src/router_module.ts#L139\" title=\"RouterModule.forRoot source code\">原始碼</a>，以瞭解宏函式是如何簡化複雜的 <a href=\"guide/ngmodules\">NgModule</a> 配置的。</p><p translation-origin=\"off\">The Angular <a href=\"api/router/RouterModule\"><code>RouterModule</code></a> exports two macro static methods, <code>forRoot</code> and <code>forChild</code>, to help declare root and child routes.\nReview the <a href=\"https://github.com/angular/angular/blob/main/packages/router/src/router_module.ts#L139\" title=\"RouterModule.forRoot source code\">source code</a>\nfor these methods to see how macros can simplify configuration of complex <a href=\"guide/ngmodules\">NgModules</a>.</p>\n\n<p><a id=\"metadata-rewriting\"></a></p>\n<h3 id=\"metadata-rewriting\" translation-result=\"on\">元資料重寫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-rewriting\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Metadata rewriting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-rewriting\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">編譯器會對含有 <code>useClass</code>、<code>useValue</code>、<code>useFactory</code> 和 <code>data</code> 的物件字面量進行特殊處理，把用這些欄位之一初始化的表示式轉換成一個匯出的變數，並用它替換該表示式。這個重寫表示式的過程，會消除它們受到的所有限制，因為編譯器並不需要知道該表示式的值，它只要能產生對該值的參考就行了。</p><p translation-origin=\"off\">The compiler treats object literals containing the fields <code>useClass</code>, <code>useValue</code>, <code>useFactory</code>, and <code>data</code> specially, converting the expression initializing one of these fields into an exported variable that replaces the expression.\nThis process of rewriting these expressions removes all the restrictions on what can be in them because\nthe compiler doesn't need to know the expression's value —it just needs to be able to generate a reference to the value.</p>\n\n<p translation-result=\"on\">你可以這樣寫：</p><p translation-origin=\"off\">You might write something like:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass TypicalServer {\n\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: () =&gt; TypicalServer}]\n})\nexport class TypicalModule {}\n\n</code-example>\n<p translation-result=\"on\">如果不重寫，這就是無效的，因為這裡不支援 Lambda 表示式，而且 <code>TypicalServer</code> 也沒有被匯出。為了支援這種寫法，編譯器自動把它重寫成了這樣：</p><p translation-origin=\"off\">Without rewriting, this would be invalid because lambdas are not supported and <code>TypicalServer</code> is not exported.\nTo allow this, the compiler automatically rewrites this to something like:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass TypicalServer {\n\n}\n\nexport const θ0 = () =&gt; new TypicalServer();\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: θ0}]\n})\nexport class TypicalModule {}\n\n</code-example>\n<p translation-result=\"on\">這就讓編譯器能在工廠中產生一個對 <code>θ0</code> 的參考，而不用知道 <code>θ0</code> 中包含的值到底是什麼。</p><p translation-origin=\"off\">This allows the compiler to generate a reference to <code>θ0</code> in the factory without having to know what the value of <code>θ0</code> contains.</p>\n\n<p translation-result=\"on\">編譯器會在產生 <code>.js</code> 檔案期間進行這種重寫。它不會重寫 <code>.d.ts</code> 檔案，所以 TypeScript 也不會把這個變數當做一項匯出，因此也就不會汙染 ES 模組中匯出的 API。</p><p translation-origin=\"off\">The compiler does the rewriting during the emit of the <code>.js</code> file.\nIt does not, however, rewrite the <code>.d.ts</code> file, so TypeScript doesn't recognize it as being an export.\nAnd it does not interfere with the ES module's exported API.</p>\n\n<p><a id=\"binding-expression-validation\"></a></p>\n<h2 id=\"phase-3-template-type-checking\" translation-result=\"on\">階段 3：範本型別檢查<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-3-template-type-checking\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Phase 3: Template type checking<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-3-template-type-checking\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 編譯器最有用的功能之一就是能夠對範本中的表示式進行型別檢查，在由於出錯而導致執行時崩潰之前就捕獲任何錯誤。在範本型別檢查階段，Angular 範本編譯器會使用 TypeScript 編譯器來驗證範本中的繫結表示式。</p><p translation-origin=\"off\">One of the Angular compiler's most helpful features is the ability to type-check expressions within templates, and catch any errors before they cause crashes at runtime.\nIn the template type-checking phase, the Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates.</p>\n\n<p translation-result=\"on\">透過在該專案的 TypeScript 配置檔案中的 <code>\"angularCompilerOptions\"</code> 中新增編譯器選項 <code>\"fullTemplateTypeCheck\"</code>，可以顯式啟用本階段（見<a href=\"guide/angular-compiler-options\">Angular 編譯器選項</a>）。</p><p translation-origin=\"off\">Enable this phase explicitly by adding the compiler option <code>\"fullTemplateTypeCheck\"</code> in the <code>\"angularCompilerOptions\"</code> of the project's TypeScript configuration file\n(see <a href=\"guide/angular-compiler-options\">Angular Compiler Options</a>).</p>\n\n<p translation-result=\"on\">當範本繫結表示式中檢測到型別錯誤時，進行範本驗證時就會產生錯誤。這和 TypeScript 編譯器在處理 <code>.ts</code> 檔案中的程式碼時報告錯誤很相似。</p><p translation-origin=\"off\">Template validation produces error messages when a type error is detected in a template binding\nexpression, similar to how type errors are reported by the TypeScript compiler against code in a <code>.ts</code>\nfile.</p>\n\n<p translation-result=\"on\">比如，考慮下列元件：</p><p translation-origin=\"off\">For example, consider the following component:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{person.addresss.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n\n</code-example>\n<p translation-result=\"on\">這會產生如下錯誤：</p><p translation-origin=\"off\">This produces the following error:</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nmy.component.ts.MyComponent.html(1,1): : Property 'addresss' does not exist on type 'Person'. Did you mean 'address'?\n\n</code-example>\n<p translation-result=\"on\">錯誤資訊中彙報的檔名 <code>my.component.ts.MyComponent.html</code> 是一個由範本編譯器產生出的合成檔案，用於儲存 <code>MyComponent</code> 類別的範本內容。編譯器永遠不會把這個檔案寫入磁碟。這個例子中，這裡的行號和列號都是相對於 <code>MyComponent</code> 的 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 註解中的範本字串的。如果元件使用 <code>templateUrl</code> 來代替 <code>template</code>，這些錯誤就會在 <code>templateUrl</code> 參考的 HTML 檔案中彙報，而不是這個合成檔案中。</p><p translation-origin=\"off\">The file name reported in the error message, <code>my.component.ts.MyComponent.html</code>, is a synthetic file\ngenerated by the template compiler that holds contents of the <code>MyComponent</code> class template.\nThe compiler never writes this file to disk.\nThe line and column numbers are relative to the template string in the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> annotation of the class, <code>MyComponent</code> in this case.\nIf a component uses <code>templateUrl</code> instead of <code>template</code>, the errors are reported in the HTML file referenced by the <code>templateUrl</code> instead of a synthetic file.</p>\n\n<p translation-result=\"on\">錯誤的位置是從包含出錯的插值表示式的那個文字節點開始的。如果錯誤是一個屬性繫結，比如 <code>[value]=\"person.address.street\"</code>，錯誤的位置就是那個包含錯誤的屬性的位置。</p><p translation-origin=\"off\">The error location is the beginning of the text node that contains the interpolation expression with the error.\nIf the error is in an attribute binding such as <code>[value]=\"person.address.street\"</code>, the error\nlocation is the location of the attribute that contains the error.</p>\n\n<p translation-result=\"on\">驗證使用 TypeScript 型別檢查器和提供給 TypeScript 編譯器的選項來控制型別驗證的詳細程度。比如，如果指定了 <code>strictTypeChecks</code>，則會報告</p><p translation-origin=\"off\">The validation uses the TypeScript type checker and the options supplied to the TypeScript compiler to control how detailed the type validation is.\nFor example, if the <code>strictTypeChecks</code> is specified, the error</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nmy.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'\n\n</code-example>\n<p translation-result=\"on\">錯誤以及上述錯誤訊息。</p><p translation-origin=\"off\">is reported as well as the above error message.</p>\n\n<h3 id=\"type-narrowing\" translation-result=\"on\">型別窄化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#type-narrowing\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Type narrowing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#type-narrowing\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 指令中使用的表示式用來在 Angular 範本編譯器中窄化聯合型別，就像 TypeScript 中的 <code>if</code> 表示式一樣。比如，要在上述範本中消除 <code>Object is possibly 'undefined'</code> 錯誤，可以把它改成只在 <code>person</code> 的值初始化過的時候才產生這個插值。</p><p translation-origin=\"off\">The expression used in an <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> directive is used to narrow type unions in the Angular\ntemplate compiler, the same way the <code>if</code> expression does in TypeScript.\nFor example, to avoid <code>Object is possibly 'undefined'</code> error in the template above, modify it to only emit the interpolation if the value of <code>person</code> is initialized as shown below:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '<span *ngif=\"person\"> {{person.address.street}} </span>'\n})\nclass MyComponent {\n  person?: Person;\n}\n\n</code-example>\n<p translation-result=\"on\">使用 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 能讓 TypeScript 編譯器推斷出這個繫結表示式中使用的 <code>person</code> 永遠不會是 <code>undefined</code>。</p><p translation-origin=\"off\">Using <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> allows the TypeScript compiler to infer that the <code>person</code> used in the binding expression will never be <code>undefined</code>.</p>\n\n<p translation-result=\"on\">關於輸入型別窄化的更多資訊，參閱<a href=\"guide/structural-directives#directive-type-checks\">為自訂指令強化範本型別檢查</a>。</p><p translation-origin=\"off\">For more information about input type narrowing, see <a href=\"guide/structural-directives#directive-type-checks\">Improving template type checking for custom directives</a>.</p>\n\n<h3 id=\"non-null-type-assertion-operator\" translation-result=\"on\">非空型別斷言運運算元<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#non-null-type-assertion-operator\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Non-null type assertion operator<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#non-null-type-assertion-operator\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">使用 <a href=\"guide/template-expression-operators#non-null-assertion-operator\">非空型別斷言運運算元</a>可以在不方便使用 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 或 當元件中的某些約束可以確保這個繫結表示式在求值時永遠不會為空時，防止出現 <code>Object is possibly 'undefined'</code> 錯誤。</p><p translation-origin=\"off\">Use the <a href=\"guide/template-expression-operators#non-null-assertion-operator\">non-null type assertion operator</a> to suppress the <code>Object is possibly 'undefined'</code> error when it is inconvenient to use <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or when some constraint in the component ensures that the expression is always non-null when the binding expression is interpolated.</p>\n\n<p translation-result=\"on\">在下面的例子中，<code>person</code> 和 <code>address</code> 屬性總是一起出現的，如果 <code>person</code> 非空，則 <code>address</code> 也一定非空。沒有一種簡便的寫法可以向 TypeScript 和範本編譯器描述這種約束。但是這個例子中使用 <code>address!.street</code> 避免了報錯。</p><p translation-origin=\"off\">In the following example, the <code>person</code> and <code>address</code> properties are always set together, implying that <code>address</code> is always non-null if <code>person</code> is non-null.\nThere is no convenient way to describe this constraint to TypeScript and the template compiler, but the error is suppressed in the example by using <code>address!.street</code>.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&lt;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"&gt; {{person.name}} lives on {{address!.street}} &lt;/span&gt;'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">應該保守點使用非空斷言運運算元，因為將來對元件的重構可能會破壞這個約束。</p><p translation-origin=\"off\">The non-null assertion operator should be used sparingly as refactoring of the component might break this constraint.</p>\n\n<p translation-result=\"on\">這個例子中，更建議在 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 中包含對 <code>address</code> 的檢查，程式碼如下：</p><p translation-origin=\"off\">In this example it is recommended to include the checking of <code>address</code> in the <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> as shown below:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&lt;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person &amp;&amp; address\"&gt; {{person.name}} lives on {{address.street}} &lt;/span&gt;'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/upgrade\n - api/upgrade/UpgradeAdapter\n - api/upgrade/UpgradeAdapterRef\n - guide/angular-compiler-options\n - guide/aot-metadata-errors\n - guide/architecture-next-steps\n - guide/creating-libraries\n - guide/deployment\n - guide/deprecations\n - guide/file-structure\n - guide/npm-packages\n - guide/template-expression-operators\n - guide/universal\n - guide/upgrade\n - guide/upgrade-performance\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/common/NgIf\n - api/core#decorators\n - api/core/Component\n - api/core/InjectionToken\n - api/core/Input\n - api/core/NgModule\n - api/router/RouterModule\n - cli\n - cli/build\n - cli/serve\n - guide/angular-compiler-options\n - guide/aot-compiler#ahead-of-time-aot-compilation\n - guide/aot-compiler#aot-工作原理\n - guide/aot-compiler#choosing-a-compiler\n - guide/aot-compiler#code-folding\n - guide/aot-compiler#compilation-phases\n - guide/aot-compiler#configuring-aot-compilation\n - guide/aot-compiler#expression-syntax\n - guide/aot-compiler#expression-syntax-limitations\n - guide/aot-compiler#foldable-syntax\n - guide/aot-compiler#functions-and-static-method-calls\n - guide/aot-compiler#how-aot-works\n - guide/aot-compiler#metadata-restrictions\n - guide/aot-compiler#metadata-rewriting\n - guide/aot-compiler#no-arrow-functions\n - guide/aot-compiler#non-null-type-assertion-operator\n - guide/aot-compiler#phase-1-code-analysis\n - guide/aot-compiler#phase-2-code-generation\n - guide/aot-compiler#phase-3-template-type-checking\n - guide/aot-compiler#public-or-protected-symbols\n - guide/aot-compiler#supported-classes-and-functions\n - guide/aot-compiler#supported-functions\n - guide/aot-compiler#type-narrowing\n - guide/aot-compiler#不要有箭頭函式\n - guide/aot-compiler#程式碼摺疊\n - guide/aot-compiler#元資料的限制\n - guide/aot-compiler#元資料重寫\n - guide/aot-compiler#公共的或受保護的符號\n - guide/aot-compiler#函式和靜態方法呼叫\n - guide/aot-compiler#可摺疊的語法\n - guide/aot-compiler#支援的類和函式\n - guide/aot-compiler#型別窄化\n - guide/aot-compiler#編譯的各個階段\n - guide/aot-compiler#表示式語法限制\n - guide/aot-compiler#選擇編譯器\n - guide/aot-compiler#配置-aot-編譯\n - guide/aot-compiler#階段-1分析\n - guide/aot-compiler#階段-2程式碼產生器\n - guide/aot-compiler#階段-3範本型別檢查\n - guide/aot-compiler#非空型別斷言運運算元\n - guide/aot-compiler#預先aot編譯器\n - guide/aot-metadata-errors\n - guide/build\n - guide/glossary#aot\n - guide/ngmodules\n - guide/structural-directives#directive-type-checks\n - guide/template-expression-operators#non-null-assertion-operator\n - guide/typescript-configuration\n - https://developer.mozilla.org/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n - https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/function\n - https://en.wikipedia.org/wiki/Abstract*syntax*tree\n - https://en.wikipedia.org/wiki/Abstract_syntax_tree\n - https://github.com/angular/angular/blob/main/packages/compiler-cli/src/metadata/schema.ts\n - https://github.com/angular/angular/blob/main/packages/router/src/router_module.ts#L139\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/aot-compiler.md?message=docs%3A%20請簡述你的修改...\n - https://medium.com/sparkles-blog/angular-writing-aot-friendly-applications-7b64c8afbe3f\n - https://www.youtube.com/watch?v=anphffaCZrQ\n-->"}