{"id":"guide/form-validation","title":"Validating form input","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/form-validation.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"validating-form-input\" translation-result=\"on\">驗證表單輸入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validating-form-input\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Validating form input<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validating-form-input\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">透過驗證使用者輸入的準確性和完整性，可以提高整體的資料品質。該頁面顯示瞭如何從 UI 驗證使用者輸入，以及如何在響應式表單和範本驅動表單中顯示有用的驗證訊息。</p><p translation-origin=\"off\">You can improve overall data quality by validating user input for accuracy and completeness.\nThis page shows how to validate user input from the UI and display useful validation messages, in both reactive and template-driven forms.</p>\n\n<h2 id=\"prerequisites\" translation-result=\"on\">前提條件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#prerequisites\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Prerequisites<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在閱讀表單驗證之前，你應該對這些內容有一個基本的瞭解。</p><p translation-origin=\"off\">Before reading about form validation, you should have a basic understanding of the following.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"https://www.typescriptlang.org/\" title=\"TypeScript 語言\">TypeScript</a>和 HTML5 程式設計</p><p translation-origin=\"off\"><a href=\"https://www.typescriptlang.org/\" title=\"The TypeScript language\">TypeScript</a> and HTML5  programming</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/architecture\" title=\"Angular 應用設計概念簡介\">Angular 應用設計</a>的基本概念</p><p translation-origin=\"off\">Fundamental concepts of <a href=\"guide/architecture\" title=\"Introduction to Angular application-design concepts\">Angular application design</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/forms-overview\" title=\"Angular 表單簡介\">Angular 支援的兩類表單</a></p><p translation-origin=\"off\">The <a href=\"guide/forms-overview\" title=\"Introduction to Angular forms\">two types of forms that Angular supports</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/forms\" title=\"範本驅動表單指南\">範本驅動表單</a>或<a href=\"guide/reactive-forms\" title=\"響應式表單指南\">響應式表單</a>的基礎知識</p><p translation-origin=\"off\">Basics of either <a href=\"guide/forms\" title=\"Template-driven forms guide\">Template-driven Forms</a> or <a href=\"guide/reactive-forms\" title=\"Reactive forms guide\">Reactive Forms</a></p>\n\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">要獲取這裡用講解表單驗證的響應式表單和範本驅動表單的完整範例程式碼。請執行<live-example></live-example>。</p><p translation-origin=\"off\">Get the complete example code for the reactive and template-driven forms used here to illustrate form validation.\nRun the <live-example></live-example>.</p>\n\n</div>\n<p><a id=\"template-driven-validation\"></a></p>\n<h2 id=\"validating-input-in-template-driven-forms\" translation-result=\"on\">在範本驅動表單中驗證輸入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validating-input-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Validating input in template-driven forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validating-input-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">為了往範本驅動表單中新增驗證機制，你要新增一些驗證屬性，就像<a href=\"https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation\">原生的 HTML 表單驗證器</a>一樣。\nAngular 會用指令來匹配這些具有驗證功能的指令。</p><p translation-origin=\"off\">To add validation to a template-driven form, you add the same validation attributes as you would with <a href=\"https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation\">native HTML form validation</a>.\nAngular uses directives to match these attributes with validator functions in the framework.</p>\n\n<p translation-result=\"on\">每當表單控制項中的值發生變化時，Angular 就會進行驗證，並產生一個驗證錯誤的列表（對應著 <code>INVALID</code> 狀態）或者 null（對應著 VALID 狀態）。</p><p translation-origin=\"off\">Every time the value of a form control changes, Angular runs validation and generates either a list of validation errors that results in an <code>INVALID</code> status, or null, which results in a VALID status.</p>\n\n<p translation-result=\"on\">你可以透過把 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 匯出成區域性範本變數來檢視該控制項的狀態。\n比如下面這個例子就把 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 匯出成了一個名叫 <code>name</code> 的變數：</p><p translation-origin=\"off\">You can then inspect the control's state by exporting <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> to a local template variable.\nThe following example exports <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> into a variable called <code>name</code>:</p>\n\n<code-example header=\"template/hero-form-template.component.html (name)\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"name-with-error-msg\">\n&lt;input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\"\n      required <a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>=\"4\" appForbiddenName=\"bob\"\n      [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" #name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"&gt;\n\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.invalid &amp;&amp; (name.dirty || name.touched)\"\n    class=\"alert\"&gt;\n\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['required']\"&gt;\n    Name is required.\n  &lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['<a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>']\"&gt;\n    Name must be at least 4 characters long.\n  &lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['forbiddenName']\"&gt;\n    Name cannot be Bob.\n  &lt;/div&gt;\n\n&lt;/div&gt;\n\n</code-example>\n<p translation-result=\"on\">注意這個例子講解的如下特性。</p><p translation-origin=\"off\">Notice the following features illustrated by the example.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>&lt;input&gt;</code> 元素帶有一些 HTML 驗證屬性：<code>required</code> 和 <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>。它還帶有一個自訂的驗證器指令 <code>forbiddenName</code>。欲知詳情，參閱<a href=\"guide/form-validation#custom-validators\">自訂驗證器</a>一節。</p><p translation-origin=\"off\">The <code>&lt;input&gt;</code> element carries the HTML validation attributes: <code>required</code> and <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>.\nIt also carries a custom validator directive, <code>forbiddenName</code>.\nFor more information, see the <a href=\"guide/form-validation#custom-validators\">Custom validators</a> section.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>#name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"</code> 把 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 匯出成了一個名叫 <code>name</code> 的區域變數。<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 把自己控制的 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項的屬性映射出去，讓你能在範本中檢查控制項的狀態，比如 <code>valid</code> 和 <code>dirty</code>。要了解完整的控制項屬性，參閱 API 參考手冊中的<a href=\"api/forms/AbstractControl\">AbstractControl</a>。</p><p translation-origin=\"off\"><code>#name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"</code> exports <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> into a local variable called <code>name</code>.\n<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> mirrors many of the properties of its underlying <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance, so you can use this in the template to check for control states such as <code>valid</code> and <code>dirty</code>.\nFor a full list of control properties, see the <a href=\"api/forms/AbstractControl\">AbstractControl</a> API reference.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>&lt;div&gt;</code> 元素的 <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 展示了一組巢狀(Nesting)的訊息 <code>div</code>，但是隻在有“name”錯誤和控制器為 <code>dirty</code> 或者 <code>touched</code> 時才出現。</p><p translation-origin=\"off\">The <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> on the <code>&lt;div&gt;</code> element reveals a set of nested message <code>divs</code> but only if the <code>name</code> is invalid and the control is either <code>dirty</code> or <code>touched</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">每個巢狀(Nesting)的 <code>&lt;div&gt;</code> 為其中一個可能出現的驗證錯誤顯示一條自訂訊息。比如 <code>required</code>、<code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code> 和 <code>forbiddenName</code>。</p><p translation-origin=\"off\">Each nested <code>&lt;div&gt;</code> can present a custom message for one of the possible validation errors.\nThere are messages for <code>required</code>, <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>, and <code>forbiddenName</code>.</p>\n\n</li>\n</ul>\n</li>\n</ul>\n<p><a id=\"dirty-or-touched\"></a></p>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">為防止驗證程式在使用者有機會編輯表單之前就顯示錯誤，你應該檢查控制項的 <code>dirty</code> 狀態或 <code>touched</code> 狀態。</p><p translation-origin=\"off\">To prevent the validator from displaying errors before the user has a chance to edit the form, you should check for either the <code>dirty</code> or <code>touched</code> states in a control.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">當用戶在被監視的欄位中修改該值時，控制項就會被標記為 <code>dirty</code>（髒）</p><p translation-origin=\"off\">When the user changes the value in the watched field, the control is marked as \"dirty\"</p>\n\n</li>\n<li>\n<p translation-result=\"on\">當用戶的表單控制項失去焦點時，該控制項就會被標記為 <code>touched</code>（已接觸）</p><p translation-origin=\"off\">When the user blurs the form control element, the control is marked as \"touched\"</p>\n\n</li>\n</ul>\n</div>\n<p><a id=\"reactive-form-validation\"></a></p>\n<h2 id=\"validating-input-in-reactive-forms\" translation-result=\"on\">在響應式表單中驗證輸入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validating-input-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Validating input in reactive forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validating-input-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在響應式表單中，事實之源是其元件類別。不應該透過範本上的屬性來新增驗證器，而應該在元件類中直接把驗證器函式新增到表單控制項模型上（<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>）。然後，一旦控制項發生了變化，Angular 就會呼叫這些函式。</p><p translation-origin=\"off\">In a reactive form, the source of truth is the component class.\nInstead of adding validators through attributes in the template, you add validator functions directly to the form control model in the component class.\nAngular then calls these functions whenever the value of the control changes.</p>\n\n<h3 id=\"validator-functions\" translation-result=\"on\">驗證器（Validator）函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validator-functions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Validator functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validator-functions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">驗證器函式可以是同步函式，也可以是非同步函式。</p><p translation-origin=\"off\">Validator functions can be either synchronous or asynchronous.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">驗證器型別</nt-wrapper><nt-wrapper translation-origin=\"off\">Validator type</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳細資訊</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">同步驗證器</nt-wrapper><nt-wrapper translation-origin=\"off\">Sync validators</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">這些同步函式接受一個控制項例項，然後返回一組驗證錯誤或 <code>null</code>。可以在例項化一個 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 時把它作為建構函式的第二個引數傳進去。</nt-wrapper><nt-wrapper translation-origin=\"off\">Synchronous functions that take a control instance and immediately return either a set of validation errors or <code>null</code>. Pass these in as the second argument when you instantiate a <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">非同步驗證器</nt-wrapper><nt-wrapper translation-origin=\"off\">Async validators</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">這些非同步函式接受一個控制項例項並返回一個 Promise 或 Observable，它稍後會發出一組驗證錯誤或 <code>null</code>。在例項化 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 時，可以把它們作為第三個引數傳入。</nt-wrapper><nt-wrapper translation-origin=\"off\">Asynchronous functions that take a control instance and return a Promise or Observable that later emits a set of validation errors or <code>null</code>. Pass these in as the third argument when you instantiate a <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">出於效能方面的考慮，只有在所有同步驗證器都透過之後，Angular 才會執行非同步驗證器。當每一個非同步驗證器都執行完之後，才會設定這些驗證錯誤。</p><p translation-origin=\"off\">For performance reasons, Angular only runs async validators if all sync validators pass.\nEach must complete before errors are set.</p>\n\n<h3 id=\"built-in-validator-functions\" translation-result=\"on\">內建驗證器函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#built-in-validator-functions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Built-in validator functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#built-in-validator-functions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以選擇<a href=\"guide/form-validation#custom-validators\">編寫自己的驗證器函式</a>，也可以使用 Angular 的一些內建驗證器。</p><p translation-origin=\"off\">You can choose to <a href=\"guide/form-validation#custom-validators\">write your own validator functions</a>, or you can use some of Angular's built-in validators.</p>\n\n<p translation-result=\"on\">在範本驅動表單中用作屬性的那些內建驗證器，比如 <code>required</code> 和 <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>，也都可以作為 <code><a href=\"api/forms/Validators\" class=\"code-anchor\">Validators</a></code> 類中的函式使用。關於內建驗證器的完整列表，參閱 API 參考手冊中的<a href=\"api/forms/Validators\">驗證器</a>部分。</p><p translation-origin=\"off\">The same built-in validators that are available as attributes in template-driven forms, such as <code>required</code> and <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>, are all available to use as functions from the <code><a href=\"api/forms/Validators\" class=\"code-anchor\">Validators</a></code> class.\nFor a full list of built-in validators, see the <a href=\"api/forms/Validators\">Validators</a> API reference.</p>\n\n<p translation-result=\"on\">要想把這個英雄表單改造成一個響應式表單，還是要用那些內建驗證器，但這次改為用它們的函式形態。參閱下面的例子。</p><p translation-origin=\"off\">To update the hero form to be a reactive form, use some of the same\nbuilt-in validators —this time, in function form, as in the following example.</p>\n\n<p><a id=\"reactive-component-class\"></a></p>\n<code-example header=\"reactive/hero-form-reactive.component.ts (validator functions)\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.1.ts\" region=\"form-group\">\nngOnInit(): void {\n  this.heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n    name: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.name, [\n      Validators.required,\n      Validators.minLength(4),\n      forbiddenNameValidator(/bob/i) // &lt;-- Here's how you pass in the custom validator.\n    ]),\n    alterEgo: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.alterEgo),\n    power: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.power, Validators.required)\n  });\n\n}\n\nget name() { return this.heroForm.get('name'); }\n\nget power() { return this.heroForm.get('power'); }\n\n</code-example>\n<p translation-result=\"on\">在這個例子中，<code>name</code> 控制項設定了兩個內建驗證器 - <code>Validators.required</code> 和 <code>Validators.minLength(4)</code> 以及一個自訂驗證器 <code>forbiddenNameValidator</code>。（欲知詳情，參閱下面的<a href=\"guide/form-validation#custom-validators\">自訂驗證器</a>部分。）</p><p translation-origin=\"off\">In this example, the <code>name</code> control sets up two built-in validators —<code>Validators.required</code> and <code>Validators.minLength(4)</code>— and one custom validator, <code>forbiddenNameValidator</code>.\n(For more details see <a href=\"guide/form-validation#custom-validators\">custom validators</a>.)</p>\n\n<p translation-result=\"on\">所有這些驗證器都是同步的，所以它們作為第二個引數傳遞。注意，你可以透過把這些函式放到一個數組中傳入來支援多個驗證器。</p><p translation-origin=\"off\">All of these validators are synchronous, so they are passed as the second argument.\nNotice that you can support multiple validators by passing the functions in as an array.</p>\n\n<p translation-result=\"on\">這個例子還添加了一些 getter 方法。在響應式表單中，你通常會透過它所屬的控制項組（FormGroup）的 <code>get</code> 方法來存取表單控制項，但有時候為範本定義一些 getter 作為簡短形式。</p><p translation-origin=\"off\">This example also adds a few getter methods.\nIn a reactive form, you can always access any form control through the <code>get</code> method on its parent group, but sometimes it's useful to define getters as shorthand for the template.</p>\n\n<p translation-result=\"on\">如果你到範本中找到 <code>name</code> 輸入框，就會發現它和範本驅動的例子很相似。</p><p translation-origin=\"off\">If you look at the template for the <code>name</code> input again, it is fairly similar to the template-driven example.</p>\n\n<code-example header=\"reactive/hero-form-reactive.component.html (name with error msg)\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" region=\"name-with-error-msg\">\n&lt;input type=\"text\" id=\"name\" class=\"form-control\"\n      <a href=\"api/forms/FormControlName\" class=\"code-anchor\">formControlName</a>=\"name\" required&gt;\n\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.invalid &amp;&amp; (name.dirty || name.touched)\"\n    class=\"alert alert-danger\"&gt;\n\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['required']\"&gt;\n    Name is required.\n  &lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['<a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>']\"&gt;\n    Name must be at least 4 characters long.\n  &lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors?.['forbiddenName']\"&gt;\n    Name cannot be Bob.\n  &lt;/div&gt;\n&lt;/div&gt;\n\n</code-example>\n<p translation-result=\"on\">這個表單與範本驅動的版本不同，它不再匯出任何指令。相反，它使用元件類中定義的 <code>name</code> 讀取器（getter）。</p><p translation-origin=\"off\">This form differs from the template-driven version in that it no longer exports any directives.\nInstead, it uses the <code>name</code> getter defined in  the component class.</p>\n\n<p translation-result=\"on\">請注意，<code>required</code> 屬性仍然出現在範本中。雖然它對於驗證來說不是必須的，但為了無障礙性，還是應該保留它。</p><p translation-origin=\"off\">Notice that the <code>required</code> attribute is still present in the template.\nAlthough it's not necessary for validation, it should be retained to for accessibility purposes.</p>\n\n<p><a id=\"custom-validators\"></a></p>\n<h2 id=\"defining-custom-validators\" translation-result=\"on\">定義自訂驗證器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#defining-custom-validators\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Defining custom validators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#defining-custom-validators\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">內建的驗證器並不是總能精確匹配應用中的使用案例，因此有時你需要建立一個自訂驗證器。</p><p translation-origin=\"off\">The built-in validators don't always match the exact use case of your application, so you sometimes need to create a custom validator.</p>\n\n<p translation-result=\"on\">考慮前面的<a href=\"guide/form-validation#reactive-component-class\">響應式式表單中</a>的 <code>forbiddenNameValidator</code> 函式。該函式的定義如下。</p><p translation-origin=\"off\">Consider the <code>forbiddenNameValidator</code> function from previous <a href=\"guide/form-validation#reactive-component-class\">reactive-form examples</a>.\nHere's what the definition of that function looks like.</p>\n\n<code-example header=\"shared/forbidden-name.directive.ts (forbiddenNameValidator)\" path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"custom-validator\">\n/** A hero's name can't match the given regular expression */\nexport function forbiddenNameValidator(nameRe: RegExp): <a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a> {\n  return (control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null =&gt; {\n    const forbidden = nameRe.test(control.value);\n    return forbidden ? {forbiddenName: {value: control.value}} : null;\n  };\n}\n\n</code-example>\n<p translation-result=\"on\">這個函式是一個工廠，它接受一個用來檢測指定名字是否已被禁用的正則表示式，並返回一個驗證器函式。</p><p translation-origin=\"off\">The function is a factory that takes a regular expression to detect a <em>specific</em> forbidden name and returns a validator function.</p>\n\n<p translation-result=\"on\">在本例中，禁止的名字是“bob”；\n驗證器會拒絕任何帶有“bob”的英雄名字。\n在其它地方，只要配置的正則表示式可以匹配上，它可能拒絕“alice”或者任何其它名字。</p><p translation-origin=\"off\">In this sample, the forbidden name is \"bob\", so the validator rejects any hero name containing \"bob\".\nElsewhere it could reject \"alice\" or any name that the configuring regular expression matches.</p>\n\n<p translation-result=\"on\"><code>forbiddenNameValidator</code> 工廠函式返回配置好的驗證器函式。\n該函式接受一個 Angular 控制項物件，並在控制項值有效時返回 null，或無效時返回驗證錯誤物件。\n驗證錯誤物件通常有一個屬性，其屬性名（<code>'forbiddenName'</code>）是驗證的鍵名，其值為一個任意值字典，你可以用來插入錯誤資訊（<code>{name}</code>）。</p><p translation-origin=\"off\">The <code>forbiddenNameValidator</code> factory returns the configured validator function.\nThat function takes an Angular control object and returns <em>either</em> null if the control value is valid <em>or</em> a validation error object.\nThe validation error object typically has a property whose name is the validation key, <code>'forbiddenName'</code>, and whose value is an arbitrary dictionary of values that you could insert into an error message, <code>{name}</code>.</p>\n\n<p translation-result=\"on\">自訂非同步驗證器和同步驗證器很像，只是它們必須返回一個稍後會輸出 null 或“驗證錯誤物件”的承諾（Promise）或可觀察物件，如果是可觀察物件，那麼它必須在某個時間點被完成（complete），那時候這個表單就會使用它輸出的最後一個值作為驗證結果。（譯註：HTTP 服務是自動完成的，但是某些自訂的可觀察物件可能需要手動呼叫 complete 方法）</p><p translation-origin=\"off\">Custom async validators are similar to sync validators, but they must instead return a Promise or observable that later emits null or a validation error object.\nIn the case of an observable, the observable must complete, at which point the form uses the last value emitted for validation.</p>\n\n<p><a id=\"adding-to-reactive-forms\"></a></p>\n<h3 id=\"adding-custom-validators-to-reactive-forms\" translation-result=\"on\">把自訂驗證器新增到響應式表單中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-custom-validators-to-reactive-forms\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Adding custom validators to reactive forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-custom-validators-to-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在響應式表單中，透過直接把該函式傳給 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 來新增自訂驗證器。</p><p translation-origin=\"off\">In reactive forms, add a custom validator by passing the function directly to the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>.</p>\n\n<code-example header=\"reactive/hero-form-reactive.component.ts (validator functions)\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.1.ts\" region=\"custom-validator\">\nthis.heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  name: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.name, [\n    Validators.required,\n    Validators.minLength(4),\n    forbiddenNameValidator(/bob/i) // &lt;-- Here's how you pass in the custom validator.\n  ]),\n  alterEgo: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.alterEgo),\n  power: new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.power, Validators.required)\n});\n\n</code-example>\n<p><a id=\"adding-to-template-driven-forms\"></a></p>\n<h3 id=\"adding-custom-validators-to-template-driven-forms\" translation-result=\"on\">為範本驅動表單中新增自訂驗證器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-custom-validators-to-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Adding custom validators to template-driven forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-custom-validators-to-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在範本驅動表單中，要為範本新增一個指令，該指令包含了 validator 函式。比如，對應的 <code>ForbiddenValidatorDirective</code> 用作 <code>forbiddenNameValidator</code> 的包裝器。</p><p translation-origin=\"off\">In template-driven forms, add a directive to the template, where the directive wraps the validator function.\nFor example, the corresponding <code>ForbiddenValidatorDirective</code> serves as a wrapper around the <code>forbiddenNameValidator</code>.</p>\n\n<p translation-result=\"on\">Angular 在驗證過程中會識別出該指令的作用，因為該指令把自己註冊成了 <code><a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a></code> 提供者，如下例所示。<code><a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a></code> 是一個帶有可擴充驗證器集合的預定義提供者。</p><p translation-origin=\"off\">Angular recognizes the directive's role in the validation process because the directive registers itself with the <code><a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a></code> provider, as shown in the following example.\n<code><a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a></code> is a predefined provider with an extensible collection of validators.</p>\n\n<code-example header=\"shared/forbidden-name.directive.ts (providers)\" path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive-providers\">\nproviders: [{provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>, useExisting: ForbiddenValidatorDirective, multi: true}]\n\n</code-example>\n<p translation-result=\"on\">然後該指令類實現了 <code><a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a></code> 介面，以便它能簡單的與 Angular 表單整合在一起。這個指令的其餘部分有助於你理解它們是如何協作的：</p><p translation-origin=\"off\">The directive class then implements the <code><a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a></code> interface, so that it can easily integrate with Angular forms.\nHere is the rest of the directive to help you get an idea of how it all comes together.</p>\n\n<code-example header=\"shared/forbidden-name.directive.ts (directive)\" path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appForbiddenName]',\n  providers: [{provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>, useExisting: ForbiddenValidatorDirective, multi: true}]\n})\nexport class ForbiddenValidatorDirective implements <a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appForbiddenName') forbiddenName = '';\n\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null {\n    return this.forbiddenName ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control)\n                              : null;\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">一旦 <code>ForbiddenValidatorDirective</code> 寫好了，你只要把 <code>forbiddenName</code> 選擇器新增到輸入框上就可以啟用這個驗證器了。比如：</p><p translation-origin=\"off\">Once the <code>ForbiddenValidatorDirective</code> is ready, you can add its selector, <code>appForbiddenName</code>, to any input element to activate it.\nFor example:</p>\n\n<code-example header=\"template/hero-form-template.component.html (forbidden-name-input)\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"name-input\">\n&lt;input type=\"text\" id=\"name\" name=\"name\" class=\"form-control\"\n      required <a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>=\"4\" appForbiddenName=\"bob\"\n      [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" #name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"&gt;\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">注意，自訂驗證指令是用 <code>useExisting</code> 而不是 <code>useClass</code> 來例項化的。註冊的驗證程式必須是 <code>ForbiddenValidatorDirective</code> <em>例項本身</em> - 表單中的例項，也就是表單中 <code>forbiddenName</code> 屬性被繫結到了\"bob\"的那個。</p><p translation-origin=\"off\">Notice that the custom validation directive is instantiated with <code>useExisting</code> rather than <code>useClass</code>.\nThe registered validator must be <em>this instance</em> of the <code>ForbiddenValidatorDirective</code> —the instance in the form with its <code>forbiddenName</code> property bound to \"bob\".</p>\n\n<p translation-result=\"on\">如果用 <code>useClass</code> 來代替 <code>useExisting</code>，就會註冊一個新的類例項，而它是沒有 <code>forbiddenName</code> 的。</p><p translation-origin=\"off\">If you were to replace <code>useExisting</code> with <code>useClass</code>, then you'd be registering a new class instance, one that doesn't have a <code>forbiddenName</code>.</p>\n\n</div>\n<h2 id=\"control-status-css-classes\" translation-result=\"on\">表示控制項狀態的 CSS 類<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#control-status-css-classes\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Control status CSS classes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#control-status-css-classes\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 會自動把很多控制項屬性作為 CSS 類對映到控制項所在的元素上。你可以使用這些類來根據表單狀態給表單控制項元素新增樣式。目前支援下列類：</p><p translation-origin=\"off\">Angular automatically mirrors many control properties onto the form control element as CSS classes.\nUse these classes to style form control elements according to the state of the form.\nThe following classes are currently supported.</p>\n\n<ul>\n<li>\n<p><code>.ng-valid</code></p>\n</li>\n<li>\n<p><code>.ng-invalid</code></p>\n</li>\n<li>\n<p><code>.ng-pending</code></p>\n</li>\n<li>\n<p><code>.ng-pristine</code></p>\n</li>\n<li>\n<p><code>.ng-dirty</code></p>\n</li>\n<li>\n<p><code>.ng-untouched</code></p>\n</li>\n<li>\n<p><code>.ng-touched</code></p>\n</li>\n<li>\n<p translation-result=\"on\"><code>.ng-submitted</code>（只對 form 元素新增）</p><p translation-origin=\"off\"><code>.ng-submitted</code> (enclosing form element only)</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">在下面的例子中，這個英雄表單使用 <code>.ng-valid</code> 和 <code>.ng-invalid</code> 來設定每個表單控制項的邊框顏色。</p><p translation-origin=\"off\">In the following example, the hero form uses the <code>.ng-valid</code> and <code>.ng-invalid</code> classes to\nset the color of each form control's border.</p>\n\n<code-example header=\"forms.css (status classes)\" path=\"form-validation/src/assets/forms.css\">\n\n.ng-valid[required], .ng-valid.required  {\n  border-left: 5px solid #42A948; /* green */\n}\n\n.ng-invalid:not(form)  {\n  border-left: 5px solid #a94442; /* red */\n}\n\n.alert div {\n  background-color: #fed3d3;\n  color: #820000;\n  padding: 1rem;\n  margin-bottom: 1rem;\n}\n\n.form-group {\n  margin-bottom: 1rem;\n}\n\nlabel {\n  display: block;\n  margin-bottom: .5rem;\n}\n\nselect {\n  width: 100%;\n  padding: .5rem;\n}\n\n\n</code-example>\n<h2 id=\"cross-field-validation\" translation-result=\"on\">跨欄位交叉驗證<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#cross-field-validation\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Cross-field validation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#cross-field-validation\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">跨欄位交叉驗證器是一種<a href=\"guide/form-validation#custom-validators\" title=\"閱讀自訂驗證器\">自訂驗證器</a>，可以對表單中不同欄位的值進行比較，並針對它們的組合進行接受或拒絕。比如，你可能有一個提供互不相容選項的表單，以便讓使用者選擇 A 或 B，而不能兩者都選。某些欄位值也可能依賴於其它值；使用者可能只有當選擇了 A 之後才能選擇 B。</p><p translation-origin=\"off\">A cross-field validator is a <a href=\"guide/form-validation#custom-validators\" title=\"Read about custom validators\">custom validator</a> that compares the values of different fields in a form and accepts or rejects them in combination.\nFor example, you might have a form that offers mutually incompatible options, so that if the user can choose A or B, but not both.\nSome field values might also depend on others; a user might be allowed to choose B only if A is also chosen.</p>\n\n<p translation-result=\"on\">下列交叉驗證的例子說明了如何進行如下操作：</p><p translation-origin=\"off\">The following cross validation examples show how to do the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">根據兩個兄弟控制項的值驗證響應式表單或範本驅動表單的輸入，</p><p translation-origin=\"off\">Validate reactive or template-based form input based on the values of two sibling controls,</p>\n\n</li>\n<li>\n<p translation-result=\"on\">當用戶與表單互動過，且驗證失敗後，就會顯示描述性的錯誤資訊。</p><p translation-origin=\"off\">Show a descriptive error message after the user interacted with the form and the validation failed.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">這些例子使用了交叉驗證，以確保英雄們不會透過填寫 Hero 表單來暴露自己的真實身份。驗證器會透過檢查英雄的名字和第二人格是否匹配來做到這一點。</p><p translation-origin=\"off\">The examples use cross-validation to ensure that heroes do not reveal their true identities by filling out the Hero Form.\nThe validators do this by checking that the hero names and alter egos do not match.</p>\n\n<h3 id=\"adding-cross-validation-to-reactive-forms\" translation-result=\"on\">為響應式表單新增交叉驗證<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-cross-validation-to-reactive-forms\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Adding cross-validation to reactive forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-cross-validation-to-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">該表單具有以下結構：</p><p translation-origin=\"off\">The form has the following structure:</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>()\n});\n\n</code-example>\n<p translation-result=\"on\">注意，<code>name</code> 和 <code>alterEgo</code> 是兄弟控制項。要想在單個自訂驗證器中計算這兩個控制項，你就必須在它們共同的祖先控制項中執行驗證：<code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code>。你可以在 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 中查詢它的子控制項，從而讓你能比較它們的值。</p><p translation-origin=\"off\">Notice that the <code>name</code> and <code>alterEgo</code> are sibling controls.\nTo evaluate both controls in a single custom validator, you must perform the validation in a common ancestor control: the <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code>.\nYou query the <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> for its child controls so that you can compare their values.</p>\n\n<p translation-result=\"on\">要想給 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 新增驗證器，就要在建立時把一個新的驗證器傳給它的第二個引數。</p><p translation-origin=\"off\">To add a validator to the <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code>, pass the new validator in as the second argument on creation.</p>\n\n<code-example format=\"javascript\" language=\"javascript\">\n\nconst heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(),\n  'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>()\n}, { validators: identityRevealedValidator });\n\n</code-example>\n<p translation-result=\"on\">驗證器的程式碼如下。</p><p translation-origin=\"off\">The validator code is as follows.</p>\n\n<code-example header=\"shared/identity-revealed.directive.ts\" path=\"form-validation/src/app/shared/identity-revealed.directive.ts\" region=\"cross-validation-validator\">\n/** A hero's name can't match the hero's alter ego */\nexport const identityRevealedValidator: <a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a> = (control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null =&gt; {\n  const name = control.get('name');\n  const alterEgo = control.get('alterEgo');\n\n  return name &amp;&amp; alterEgo &amp;&amp; name.value === alterEgo.value ? { identityRevealed: true } : null;\n};\n\n</code-example>\n<p translation-result=\"on\">這個 <code>identity</code> 驗證器實現了 <code><a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a></code> 介面。它接收一個 Angular 表單控制項物件作為引數，當表單有效時，它返回一個 null，否則返回 <code><a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a></code> 物件。</p><p translation-origin=\"off\">The <code>identity</code> validator implements the <code><a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a></code> interface.\nIt takes an Angular control object as an argument and returns either null if the form is valid, or <code><a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a></code> otherwise.</p>\n\n<p translation-result=\"on\">該驗證器透過呼叫 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 的 <a href=\"api/forms/AbstractControl#get\">get</a> 方法來檢索這些子控制項，然後比較 <code>name</code> 和 <code>alterEgo</code> 控制項的值。</p><p translation-origin=\"off\">The validator retrieves the child controls by calling the <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code>'s <a href=\"api/forms/AbstractControl#get\">get</a> method, then compares the values of the <code>name</code> and <code>alterEgo</code> controls.</p>\n\n<p translation-result=\"on\">如果值不匹配，則 hero 的身份保持秘密，兩者都有效，且 validator 返回 null。如果匹配，就說明英雄的身份已經暴露了，驗證器必須透過返回一個錯誤物件來把這個表單標記為無效的。</p><p translation-origin=\"off\">If the values do not match, the hero's identity remains secret, both are valid, and the validator returns null.\nIf they do match, the hero's identity is revealed and the validator must mark the form as invalid by returning an error object.</p>\n\n<p translation-result=\"on\">為了提供更好的使用者體驗，當表單無效時，範本還會顯示一條恰當的錯誤資訊。</p><p translation-origin=\"off\">To provide better user experience, the template shows an appropriate error message when the form is invalid.</p>\n\n<code-example header=\"reactive/hero-form-template.component.html\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" region=\"cross-validation-error-message\">\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"heroForm.errors?.['identityRevealed'] &amp;&amp; (heroForm.touched || heroForm.dirty)\" class=\"cross-validation-error-message alert alert-danger\"&gt;\n    Name cannot match alter ego.\n&lt;/div&gt;\n\n</code-example>\n<p translation-result=\"on\">如果 <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> 中有一個由 <code>identityRevealed</code> 驗證器返回的交叉驗證錯誤，<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 就會顯示錯誤，但只有當該使用者已經<a href=\"guide/form-validation#dirty-or-touched\">與表單進行過互動</a>的時候才顯示。</p><p translation-origin=\"off\">This <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> displays the error if the <code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code> has the cross validation error returned by the <code>identityRevealed</code> validator, but only if the user finished <a href=\"guide/form-validation#dirty-or-touched\">interacting with the form</a>.</p>\n\n<h3 id=\"adding-cross-validation-to-template-driven-forms\" translation-result=\"on\">為範本驅動表單新增交叉驗證<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-cross-validation-to-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Adding cross-validation to template-driven forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-cross-validation-to-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">對於範本驅動表單，你必須建立一個指令來包裝驗證器函式。你可以使用<a href=\"guide/form-validation#adding-to-template-driven-forms\" title=\"瞭解如何提供驗證器\"><code>NG_VALIDATORS</code> 令牌</a>來把該指令提供為驗證器，如下例所示。</p><p translation-origin=\"off\">For a template-driven form, you must create a directive to wrap the validator function.\nYou provide that directive as the validator using the <a href=\"guide/form-validation#adding-to-template-driven-forms\" title=\"Read about providing validators\"><code>NG_VALIDATORS</code> token</a>, as shown in the following example.</p>\n\n<code-example header=\"shared/identity-revealed.directive.ts\" path=\"form-validation/src/app/shared/identity-revealed.directive.ts\" region=\"cross-validation-directive\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appIdentityRevealed]',\n  providers: [{ provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>, useExisting: IdentityRevealedValidatorDirective, multi: true }]\n})\nexport class IdentityRevealedValidatorDirective implements <a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a> {\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): <a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null {\n    return identityRevealedValidator(control);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">你必須把這個新指令新增到 HTML 範本中。由於驗證器必須註冊在表單的最高層，因此下列範本會把該指令放在 <code>form</code> 標籤上。</p><p translation-origin=\"off\">You must add the new directive to the HTML template.\nBecause the validator must be registered at the highest level in the form, the following template puts the directive on the <code>form</code> tag.</p>\n\n<code-example header=\"template/hero-form-template.component.html\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"cross-validation-register-validator\">\n&lt;form #heroForm=\"<a href=\"api/forms/NgForm\" class=\"code-anchor\">ngForm</a>\" appIdentityRevealed&gt;\n\n</code-example>\n<p translation-result=\"on\">為了提供更好的使用者體驗，當表單無效時，我們要顯示一個恰當的錯誤資訊。</p><p translation-origin=\"off\">To provide better user experience, an appropriate error message appears when the form is invalid.</p>\n\n<code-example header=\"template/hero-form-template.component.html\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"cross-validation-error-message\">\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"heroForm.errors?.['identityRevealed'] &amp;&amp; (heroForm.touched || heroForm.dirty)\" class=\"cross-validation-error-message alert\"&gt;\n    Name cannot match alter ego.\n&lt;/div&gt;\n\n</code-example>\n<p translation-result=\"on\">這在範本驅動表單和響應式表單中都是一樣的。</p><p translation-origin=\"off\">This is the same in both template-driven and reactive forms.</p>\n\n<h2 id=\"creating-asynchronous-validators\" translation-result=\"on\">建立非同步驗證器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#creating-asynchronous-validators\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Creating asynchronous validators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#creating-asynchronous-validators\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">非同步驗證器實現了 <code><a href=\"api/forms/AsyncValidatorFn\" class=\"code-anchor\">AsyncValidatorFn</a></code> 和 <code><a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a></code> 介面。它們與其同步版本非常相似，但有以下不同之處。</p><p translation-origin=\"off\">Asynchronous validators implement the <code><a href=\"api/forms/AsyncValidatorFn\" class=\"code-anchor\">AsyncValidatorFn</a></code> and <code><a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a></code> interfaces.\nThese are very similar to their synchronous counterparts, with the following differences.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>validate()</code> 函式必須返回一個 Promise 或可觀察物件，</p><p translation-origin=\"off\">The <code>validate()</code> functions must return a Promise or an observable,</p>\n\n</li>\n<li>\n<p translation-result=\"on\">返回的可觀察物件必須是有盡的，這意味著它必須在某個時刻完成（complete）。要把無盡的可觀察物件轉換成有盡的，可以在管道中加入過濾運運算元，比如 <code>first</code>、<code>last</code>、<code>take</code> 或 <code>takeUntil</code>。</p><p translation-origin=\"off\">The observable returned must be finite, meaning it must complete at some point.\nTo convert an infinite observable into a finite one, pipe the observable through a filtering operator such as <code>first</code>, <code>last</code>, <code>take</code>, or <code>takeUntil</code>.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">非同步驗證在同步驗證完成後才會發生，並且只有在同步驗證成功時才會執行。如果更基本的驗證方法已經發現了無效輸入，那麼這種檢查順序就可以讓表單避免使用昂貴的非同步驗證流程（比如 HTTP 請求）。</p><p translation-origin=\"off\">Asynchronous validation happens after the synchronous validation, and is performed only if the synchronous validation is successful.\nThis check lets forms avoid potentially expensive async validation processes (such as an HTTP request) if the more basic validation methods have already found invalid input.</p>\n\n<p translation-result=\"on\">非同步驗證開始之後，表單控制項就會進入 <code>pending</code> 狀態。可以檢查控制項的 <code>pending</code> 屬性，並用它來給出對驗證中的視覺反饋。</p><p translation-origin=\"off\">After asynchronous validation begins, the form control enters a <code>pending</code> state.\nInspect the control's <code>pending</code> property and use it to give visual feedback about the ongoing validation operation.</p>\n\n<p translation-result=\"on\">一種常見的 UI 模式是在執行非同步驗證時顯示 Spinner（轉輪）。下面的例子展示瞭如何在範本驅動表單中實現這一點。</p><p translation-origin=\"off\">A common UI pattern is to show a spinner while the async validation is being performed.\nThe following example shows how to achieve this in a template-driven form.</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"name\" #model=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\" appSomeAsyncValidator&gt;\n&lt;app-spinner *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"model.pending\"&gt;&lt;/app-spinner&gt;\n\n</code-example>\n<h3 id=\"implementing-a-custom-async-validator\" translation-result=\"on\">實現自訂非同步驗證器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#implementing-a-custom-async-validator\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Implementing a custom async validator<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#implementing-a-custom-async-validator\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在下面的例子中，非同步驗證器可以確保英雄們選擇了一個尚未採用的第二人格。新英雄不斷湧現，老英雄也會離開，所以無法提前找到可用的人格列表。為了驗證潛在的第二人格條目，驗證器必須啟動一個非同步操作來查詢包含所有在編英雄的中央資料庫。</p><p translation-origin=\"off\">In the following example, an async validator ensures that heroes pick an alter ego that is not already taken.\nNew heroes are constantly enlisting and old heroes are leaving the service, so the list of available alter egos cannot be retrieved ahead of time.\nTo validate the potential alter ego entry, the validator must initiate an asynchronous operation to consult a central database of all currently enlisted heroes.</p>\n\n<p translation-result=\"on\">下面的程式碼建立了一個驗證器類 <code>UniqueAlterEgoValidator</code>，它實現了 <code><a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a></code> 介面。</p><p translation-origin=\"off\">The following code creates the validator class, <code>UniqueAlterEgoValidator</code>, which implements the <code><a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a></code> interface.</p>\n\n<code-example path=\"form-validation/src/app/shared/alter-ego.directive.ts\" region=\"async-validator\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({ providedIn: 'root' })\nexport class UniqueAlterEgoValidator implements <a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a> {\n  constructor(private heroesService: HeroesService) {}\n\n  validate(\n    control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>\n  ): Observable&lt;<a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null&gt; {\n    return this.heroesService.isAlterEgoTaken(control.value).pipe(\n      map(isTaken =&gt; (isTaken ? { uniqueAlterEgo: true } : null)),\n      catchError(() =&gt; of(null))\n    );\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">建構函式中注入了 <code>HeroesService</code>，它定義瞭如下介面。</p><p translation-origin=\"off\">The constructor injects the <code>HeroesService</code>, which defines the following interface.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\ninterface HeroesService {\n  isAlterEgoTaken: (alterEgo: string) =&gt; Observable&lt;boolean&gt;;\n}\n\n</code-example>\n<p translation-result=\"on\">在真實的應用中，<code>HeroesService</code> 會負責向英雄資料庫發起一個 HTTP 請求，以檢查該第二人格是否可用。\n從該驗證器的視角看，此服務的具體實現無關緊要，所以這個例子僅僅針對 <code>HeroesService</code> 介面來寫實現程式碼。</p><p translation-origin=\"off\">In a real world application, the <code>HeroesService</code> would be responsible for making an HTTP request to the hero database to check if the alter ego is available.\nFrom the validator's point of view, the actual implementation of the service is not important, so the example can just code against the <code>HeroesService</code> interface.</p>\n\n<p translation-result=\"on\">當驗證開始的時候，<code>UniqueAlterEgoValidator</code> 把任務委託給 <code>HeroesService</code> 的 <code>isAlterEgoTaken()</code> 方法，並傳入當前控制項的值。這時候，該控制項會被標記為 <code>pending</code> 狀態，直到 <code>validate()</code> 方法所返回的可觀察物件完成（complete）了。</p><p translation-origin=\"off\">As the validation begins, the <code>UniqueAlterEgoValidator</code> delegates to the <code>HeroesService</code> <code>isAlterEgoTaken()</code> method with the current control value.\nAt this point the control is marked as <code>pending</code> and remains in this state until the observable chain returned from the <code>validate()</code> method completes.</p>\n\n<p translation-result=\"on\"><code>isAlterEgoTaken()</code> 方法會排程一個 HTTP 請求來檢查第二人格是否可用，並返回 <code>Observable&lt;boolean&gt;</code> 作為結果。<code>validate()</code> 方法透過 <code>map</code> 運運算元來對響應物件進行管道化處理，並把它轉換成驗證結果。</p><p translation-origin=\"off\">The <code>isAlterEgoTaken()</code> method dispatches an HTTP request that checks if the alter ego is available, and returns <code>Observable&lt;boolean&gt;</code> as the result.\nThe <code>validate()</code> method pipes the response through the <code>map</code> operator and transforms it into a validation result.</p>\n\n<p translation-result=\"on\">與任何驗證器一樣，如果表單有效，該方法返回 <code>null</code>，如果無效，則返回 <code><a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a></code>。這個驗證器使用 <code>catchError</code> 運運算元來處理任何潛在的錯誤。在這個例子中，驗證器將 <code>isAlterEgoTaken()</code> 錯誤視為成功的驗證，因為未能發出驗證請求並不一定意味著這個第二人格無效。你也可以用不同的方式處理這種錯誤，比如返回 <code>ValidationError</code> 物件。</p><p translation-origin=\"off\">The method then, like any validator, returns <code>null</code> if the form is valid, and <code><a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a></code> if it is not.\nThis validator handles any potential errors with the <code>catchError</code> operator.\nIn this case, the validator treats the <code>isAlterEgoTaken()</code> error as a successful validation, because failure to make a validation request does not necessarily mean that the alter ego is invalid.\nYou could handle the error differently and return the <code>ValidationError</code> object instead.</p>\n\n<p translation-result=\"on\">一段時間過後，這條可觀察物件鏈完成，非同步驗證也就完成了。<code>pending</code> 標誌位也設定為 <code>false</code>，該表單的有效性也已更新。</p><p translation-origin=\"off\">After some time passes, the observable chain completes and the asynchronous validation is done.\nThe <code>pending</code> flag is set to <code>false</code>, and the form validity is updated.</p>\n\n<h3 id=\"adding-async-validators-to-reactive-forms\" translation-result=\"on\">將非同步驗證器新增到響應式表單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-async-validators-to-reactive-forms\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Adding async validators to reactive forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-async-validators-to-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要以響應式表單使用非同步驗證器，請首先將驗證器注入元件類別的建構函式。</p><p translation-origin=\"off\">To use an async validator in reactive forms, begin by injecting the validator into the constructor of the component class.</p>\n\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.2.ts\" region=\"async-validator-inject\">\nconstructor(private alterEgoValidator: UniqueAlterEgoValidator) {}\n\n</code-example>\n<p translation-result=\"on\">然後，將驗證器函式直接傳遞給 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 以應用它。</p><p translation-origin=\"off\">Then, pass the validator function directly to the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> to apply it.</p>\n\n<p translation-result=\"on\">在以下範例中，<code>UniqueAlterEgoValidator</code> 的 <code>validate</code> 函式將其傳遞給控制項的 <code>asyncValidators</code> 選項並將其繫結到注入到 <code>HeroFormReactiveComponent</code> 中的 <code>UniqueAlterEgoValidator</code> 例項，最終將其應用於 <code>alterEgoControl</code>。<code>asyncValidators</code> 的值可以是單個非同步驗證器函式，也可以是函式陣列。要了解有關 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 選項的更多資訊，參閱<a href=\"api/forms/AbstractControlOptions\">AbstractControlOptions</a> API 參考。</p><p translation-origin=\"off\">In the following example, the <code>validate</code> function of <code>UniqueAlterEgoValidator</code> is applied to <code>alterEgoControl</code> by passing it to the control's <code>asyncValidators</code> option and binding it to the instance of <code>UniqueAlterEgoValidator</code> that was injected into <code>HeroFormReactiveComponent</code>.\nThe value of <code>asyncValidators</code> can be either a single async validator function, or an array of functions.\nTo learn more about <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> options, see the <a href=\"api/forms/AbstractControlOptions\">AbstractControlOptions</a> API reference.</p>\n\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.2.ts\" region=\"async-validator-usage\">\nconst alterEgoControl = new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('', {\n  asyncValidators: [this.alterEgoValidator.validate.bind(this.alterEgoValidator)],\n  updateOn: 'blur'\n});\n\n</code-example>\n<h3 id=\"adding-async-validators-to-template-driven-forms\" translation-result=\"on\">將非同步驗證器新增到範本驅動表單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-async-validators-to-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Adding async validators to template-driven forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-async-validators-to-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要在範本驅動表單中使用非同步驗證器，請建立一個新指令並在其上註冊 <code><a href=\"api/forms/NG_ASYNC_VALIDATORS\" class=\"code-anchor\">NG_ASYNC_VALIDATORS</a></code> 提供者。</p><p translation-origin=\"off\">To use an async validator in template-driven forms, create a new directive and register the <code><a href=\"api/forms/NG_ASYNC_VALIDATORS\" class=\"code-anchor\">NG_ASYNC_VALIDATORS</a></code> provider on it.</p>\n\n<p translation-result=\"on\">在下面的範例中，該指令注入包含實際驗證邏輯的 <code>UniqueAlterEgoValidator</code> 類，並在應該進行驗證時由 Angular 觸發的 <code>validate</code> 函式中呼叫它。</p><p translation-origin=\"off\">In the example below, the directive injects the <code>UniqueAlterEgoValidator</code> class that contains the actual validation logic and invokes it in the <code>validate</code> function, triggered by Angular when validation should happen.</p>\n\n<code-example path=\"form-validation/src/app/shared/alter-ego.directive.ts\" region=\"async-validator-directive\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appUniqueAlterEgo]',\n  providers: [\n    {\n      provide: <a href=\"api/forms/NG_ASYNC_VALIDATORS\" class=\"code-anchor\">NG_ASYNC_VALIDATORS</a>,\n      useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; UniqueAlterEgoValidatorDirective),\n      multi: true\n    }\n  ]\n})\nexport class UniqueAlterEgoValidatorDirective implements <a href=\"api/forms/AsyncValidator\" class=\"code-anchor\">AsyncValidator</a> {\n  constructor(private validator: UniqueAlterEgoValidator) {}\n\n  validate(\n    control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>\n  ): Observable&lt;<a href=\"api/forms/ValidationErrors\" class=\"code-anchor\">ValidationErrors</a> | null&gt; {\n    return this.validator.validate(control);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">然後，與使用同步驗證器一樣，將指令的選擇器新增到輸入以啟用它。</p><p translation-origin=\"off\">Then, as with synchronous validators, add the directive's selector to an input to activate it.</p>\n\n<code-example header=\"template/hero-form-template.component.html (unique-alter-ego-input)\" path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"alterEgo-input\">\n&lt;input type=\"text\"\n         id=\"alterEgo\"\n         name=\"alterEgo\"\n         #alterEgo=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"\n         [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.alterEgo\"\n         [ngModelOptions]=\"{ updateOn: 'blur' }\"\n         appUniqueAlterEgo&gt;\n\n</code-example>\n<h3 id=\"optimizing-performance-of-async-validators\" translation-result=\"on\">最佳化非同步驗證器的效能<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#optimizing-performance-of-async-validators\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Optimizing performance of async validators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#optimizing-performance-of-async-validators\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">預設情況下，所有驗證程式在每次表單值更改後都會執行。對於同步驗證器，這通常不會對應用效能產生明顯的影響。但是，非同步驗證器通常會執行某種 HTTP 請求來驗證控制項。每次按鍵後排程一次 HTTP 請求都會給後端 API 帶來壓力，應該儘可能避免。</p><p translation-origin=\"off\">By default, all validators run after every form value change.\nWith synchronous validators, this does not normally have a noticeable impact on application performance.\nAsync validators, however, commonly perform some kind of HTTP request to validate the control.\nDispatching an HTTP request after every keystroke could put a strain on the backend API, and should be avoided if possible.</p>\n\n<p translation-result=\"on\">你可以把 <code>updateOn</code> 屬性從 <code>change</code>（預設值）改成 <code>submit</code> 或 <code>blur</code> 來推遲表單驗證的更新時機。</p><p translation-origin=\"off\">You can delay updating the form validity by changing the <code>updateOn</code> property from <code>change</code> (default) to <code>submit</code> or <code>blur</code>.</p>\n\n<p translation-result=\"on\">使用範本驅動表單時，可以在範本中設定該屬性。</p><p translation-origin=\"off\">With template-driven forms, set the property in the template.</p>\n\n<code-example format=\"html\" language=\"html\">\n\n&lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"name\" [ngModelOptions]=\"{updateOn: 'blur'}\"&gt;\n\n</code-example>\n<p translation-result=\"on\">使用響應式表單時，可以在 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項中設定該屬性。</p><p translation-origin=\"off\">With reactive forms, set the property in the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nnew <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('', {updateOn: 'blur'});\n\n</code-example>\n<h2 id=\"interaction-with-native-html-form-validation\" translation-result=\"on\">與原生 HTML 表單驗證器互動<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#interaction-with-native-html-form-validation\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Interaction with native HTML form validation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#interaction-with-native-html-form-validation\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">預設情況下，Angular 透過在 <code>&lt;form&gt;</code> 元素上新增 <code>novalidate</code> 屬性來禁用<a href=\"https://developer.mozilla.org/docs/Web/Guide/HTML/Constraint_validation\">原生 HTML 表單驗證</a>，並使用指令將這些屬性與框架中的驗證器函式相匹配。如果你想將原生驗證與基於 Angular 的驗證<strong>結合</strong>使用，你可以使用 <code>ngNativeValidate</code> 指令來重新啟用它。欲知詳情，參閱<a href=\"api/forms/NgForm#native-dom-validation-ui\"> API 文件</a>。</p><p translation-origin=\"off\">By default, Angular disables <a href=\"https://developer.mozilla.org/docs/Web/Guide/HTML/Constraint_validation\">native HTML form validation</a> by adding the <code>novalidate</code> attribute on the enclosing <code>&lt;form&gt;</code> and uses directives to match these attributes with validator functions in the framework.\nIf you want to use native validation <strong>in combination</strong> with Angular-based validation, you can re-enable it with the <code>ngNativeValidate</code> directive.\nSee the <a href=\"api/forms/NgForm#native-dom-validation-ui\">API docs</a> for details.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/forms/CheckboxRequiredValidator\n - api/forms/EmailValidator\n - api/forms/MaxLengthValidator\n - api/forms/MaxValidator\n - api/forms/MinLengthValidator\n - api/forms/MinValidator\n - api/forms/PatternValidator\n - api/forms/RequiredValidator\n - guide/dynamic-form\n - guide/example-apps-list\n - guide/forms-overview\n - guide/glossary\n - guide/reactive-forms\n-->\n<!-- links from this doc:\n - api/common/NgIf\n - api/core/Directive\n - api/core/Injectable\n - api/core/Input\n - api/core/forwardRef\n - api/forms/AbstractControl\n - api/forms/AbstractControl#get\n - api/forms/AbstractControlOptions\n - api/forms/AsyncValidator\n - api/forms/AsyncValidatorFn\n - api/forms/FormControl\n - api/forms/FormControlName\n - api/forms/FormGroup\n - api/forms/MinLengthValidator\n - api/forms/NG_ASYNC_VALIDATORS\n - api/forms/NG_VALIDATORS\n - api/forms/NgForm\n - api/forms/NgForm#native-dom-validation-ui\n - api/forms/NgModel\n - api/forms/ValidationErrors\n - api/forms/Validator\n - api/forms/ValidatorFn\n - api/forms/Validators\n - guide/architecture\n - guide/form-validation#adding-async-validators-to-reactive-forms\n - guide/form-validation#adding-async-validators-to-template-driven-forms\n - guide/form-validation#adding-cross-validation-to-reactive-forms\n - guide/form-validation#adding-cross-validation-to-template-driven-forms\n - guide/form-validation#adding-custom-validators-to-reactive-forms\n - guide/form-validation#adding-custom-validators-to-template-driven-forms\n - guide/form-validation#adding-to-template-driven-forms\n - guide/form-validation#built-in-validator-functions\n - guide/form-validation#control-status-css-classes\n - guide/form-validation#creating-asynchronous-validators\n - guide/form-validation#cross-field-validation\n - guide/form-validation#custom-validators\n - guide/form-validation#defining-custom-validators\n - guide/form-validation#dirty-or-touched\n - guide/form-validation#implementing-a-custom-async-validator\n - guide/form-validation#interaction-with-native-html-form-validation\n - guide/form-validation#optimizing-performance-of-async-validators\n - guide/form-validation#prerequisites\n - guide/form-validation#reactive-component-class\n - guide/form-validation#validating-form-input\n - guide/form-validation#validating-input-in-reactive-forms\n - guide/form-validation#validating-input-in-template-driven-forms\n - guide/form-validation#validator-functions\n - guide/form-validation#與原生-html-表單驗證器互動\n - guide/form-validation#為響應式表單新增交叉驗證\n - guide/form-validation#為範本驅動表單中新增自訂驗證器\n - guide/form-validation#為範本驅動表單新增交叉驗證\n - guide/form-validation#最佳化非同步驗證器的效能\n - guide/form-validation#內建驗證器函式\n - guide/form-validation#建立非同步驗證器\n - guide/form-validation#前提條件\n - guide/form-validation#在響應式表單中驗證輸入\n - guide/form-validation#在範本驅動表單中驗證輸入\n - guide/form-validation#定義自訂驗證器\n - guide/form-validation#實現自訂非同步驗證器\n - guide/form-validation#將非同步驗證器新增到響應式表單\n - guide/form-validation#將非同步驗證器新增到範本驅動表單\n - guide/form-validation#把自訂驗證器新增到響應式表單中\n - guide/form-validation#表示控制項狀態的-css-類\n - guide/form-validation#跨欄位交叉驗證\n - guide/form-validation#驗證器validator函式\n - guide/form-validation#驗證表單輸入\n - guide/forms\n - guide/forms-overview\n - guide/reactive-forms\n - https://developer.mozilla.org/docs/Web/Guide/HTML/Constraint_validation\n - https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/form-validation.md?message=docs%3A%20請簡述你的修改...\n - https://www.typescriptlang.org/\n-->"}