{"id":"guide/angular-package-format","title":"Angular package format","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/angular-package-format.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"angular-package-format\" translation-result=\"on\">Angular 套件格式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#angular-package-format\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Angular package format<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#angular-package-format\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本文件描述了 Angular 套件格式 (APF)。APF 是針對 npm 套件結構和格式的 Angular 專用規範，所有第一方 Angular 套件（<code>@angular/core</code> 、 <code>@angular/material</code> 等）和大多數第三方 Angular 函式庫都使用了該規範。</p><p translation-origin=\"off\">This document describes the Angular Package Format (APF).\nAPF is an Angular specific specification for the structure and format of npm packages that is used by all first-party Angular packages (<code>@angular/core</code>, <code>@angular/material</code>, etc.) and most third-party Angular libraries.</p>\n\n<p translation-result=\"on\">APF 能讓套件在使用 Angular 的大多數常見場景下無縫工作。使用 APF 的套件與 Angular 團隊提供的工具以及更廣泛的 JavaScript 生態系統相容。建議第三方函式庫開發者也都遵循這種格式。</p><p translation-origin=\"off\">APF enables a package to work seamlessly under most common scenarios that use Angular.\nPackages that use APF are compatible with the tooling offered by the Angular team as well as wider JavaScript ecosystem.\nIt is recommended that third-party library developers follow the same npm package format.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">APF（Angular Package Format）一直在跟隨 Angular 的版本而發展，每個主要版本都會改進套件格式。你可以在這份 <a href=\"https://docs.google.com/document/d/1CZC2rcpxffTDfRDs6p1cfbmKNLA6x5O-NtkJglDaBVs/preview\">google 文件</a>中找到 v13 之前的版本規範。</p><p translation-origin=\"off\">APF is versioned along with the rest of Angular, and every major version improves the package format.\nYou can find the versions of the specification prior to v13 in this <a href=\"https://docs.google.com/document/d/1CZC2rcpxffTDfRDs6p1cfbmKNLA6x5O-NtkJglDaBVs/preview\">google doc</a>.</p>\n\n</div>\n<h2 id=\"why-specify-a-package-format\" translation-result=\"on\">為什麼要指定套件格式？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#why-specify-a-package-format\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Why specify a package format?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#why-specify-a-package-format\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在當今的 JavaScript 環境中，開發人員將使用多種不同的工具鏈（Webpack、rollup、esbuild 等）以多種不同的方式使用套件。這些工具可能理解並需要不同的輸入 —— 一些工具能處理最新的 ES 語言版本，而其他工具也許要直接使用較舊的 ES 版本。</p><p translation-origin=\"off\">In today's JavaScript landscape, developers consume packages in many different ways, using many different toolchains (Webpack, rollup, esbuild, etc.).\nThese tools may understand and require different inputs - some tools may be able to process the latest ES language version, while others may benefit from directly consuming an older ES version.</p>\n\n<p translation-result=\"on\">這種 Angular 分發格式支援所有常用的開發工具和工作流，並著重於最佳化，從而縮小應用程式有效負載大小或縮短開發迭代週期（建構時間）。</p><p translation-origin=\"off\">The Angular distribution format supports all of the commonly used development tools and workflows, and adds emphasis on optimizations that result either in smaller application payload size or faster development iteration cycle (build time).</p>\n\n<p translation-result=\"on\">開發人員可以依靠 Angular CLI 和 <a href=\"https://github.com/ng-packagr/ng-packagr\">ng-packagr</a>（Angular CLI 使用的建構工具）來產生 APF 格式的套件。有關更多詳細資訊，參閱<a href=\"guide/creating-libraries\">建立函式庫</a>指南。</p><p translation-origin=\"off\">Developers can rely on Angular CLI and <a href=\"https://github.com/ng-packagr/ng-packagr\">ng-packagr</a> (a build tool Angular CLI uses) to produce packages in the Angular package format.\nSee the <a href=\"guide/creating-libraries\">Creating Libraries</a> guide for more details.</p>\n\n<h2 id=\"file-layout\" translation-result=\"on\">檔案佈局<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#file-layout\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">File layout<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#file-layout\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">以下範例顯示了 <code>@angular/core</code> 套件檔案佈局的簡化版本，並附有對套件中每個檔案的解釋。</p><p translation-origin=\"off\">The following example shows a simplified version of the <code>@angular/core</code> package's file layout, with an explanation for each file in the package.</p>\n\n<div class=\"filetree\">\n    <div class=\"file\">\n      node_modules/@angular/core\n    </div>\n    <div class=\"children\">\n        <div class=\"file\">\n          README.md &nbsp; <!-- // &lt;-- Package README, used by npmjs web UI. -->\n        </div>\n        <div class=\"file\">\n          package.json &nbsp; <!-- // &lt;-- Primary package.json, describing the package itself as well as all available entrypoints and code formats. This file contains the \"exports\" mapping used by runtimes and tools to perform module resolution. -->\n        </div>\n        <div class=\"file\">\n          index.d.ts &nbsp; <!-- // &lt;-- Bundled .d.ts for the primary entrypoint &commat;angular/core. -->\n        </div>\n        <div class=\"file\">\n          esm2022 &nbsp; <!-- // &lt;-- Tree of &commat;angular/core sources in unflattened ES2022 format. -->\n        </div>\n        <div class=\"children\">\n            <div class=\"file\">\n              core.mjs\n            </div>\n            <div class=\"file\">\n              index.mjs\n            </div>\n            <div class=\"file\">\n              public_api.mjs\n            </div>\n            <div class=\"file\">\n              testing &nbsp; <!-- // &lt;-- Tree of the &commat;angular/core/testing entrypoint in unflattened ES2022 format. -->\n            </div>\n        </div>\n        <div class=\"file\">\n          fesm2022 &nbsp; <!-- // &lt;-- Code for all entrypoints in flattened \\(FESM\\) ES2022 format, along with sourcemaps. -->\n        </div>\n        <div class=\"children\">\n            <div class=\"file\">\n              core.mjs\n            </div>\n            <div class=\"file\">\n              core.mjs.map\n            </div>\n            <div class=\"file\">\n              testing.mjs\n            </div>\n            <div class=\"file\">\n              testing.mjs.map\n            </div>\n        </div>\n        <div class=\"file\">\n          testing &nbsp; <!-- // &lt;-- Directory representing the \"testing\" entrypoint. -->\n        </div>\n        <div class=\"children\">\n            <div class=\"file\">\n              index.d.ts &nbsp; <!-- // &lt;-- Bundled .d.ts for the &commat;angular/core/testing entrypoint. -->\n            </div>\n        </div>\n    </div>\n</div>\n<p translation-result=\"on\">此表描述了 <code>node_modules/@angular/core</code> 下的檔案佈局，註釋為描述檔案和目錄的用途：</p><p translation-origin=\"off\">This table describes the file layout under <code>node_modules/@angular/core</code> annotated to describe the purpose of files and directories:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">檔案</nt-wrapper><nt-wrapper translation-origin=\"off\">Files</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">用途</nt-wrapper><nt-wrapper translation-origin=\"off\">Purpose</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>README.md</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">套件 README，由 npmjs web UI 使用。</nt-wrapper><nt-wrapper translation-origin=\"off\">Package README, used by npmjs web UI.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>package.json</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">主要的 <code>package.json</code>，描述套件本身以及所有可用的入口點和程式碼格式。此檔案包含供執行時使用的 <code>\"exports\"</code> 對映和一些用於執行模組解析的工具。</nt-wrapper><nt-wrapper translation-origin=\"off\">Primary <code>package.json</code>, describing the package itself as well as all available entrypoints and code formats. This file contains the \"exports\" mapping used by runtimes and tools to perform module resolution.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>index.d.ts</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">主入口點 <code>@angular/core</code> 捆綁的 <code>.d.ts</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Bundled <code>.d.ts</code> for the primary entrypoint <code>@angular/core</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>esm2022/</code> <br> &nbsp;&nbsp;─ <code>core.mjs</code> <br> &nbsp;&nbsp;─ <code>index.mjs</code> <br> &nbsp;&nbsp;─ <code>public_api.mjs</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">未展平的 ES2022 格式的 <code>@angular/core</code> 原始碼樹。</nt-wrapper><nt-wrapper translation-origin=\"off\">Tree of <code>@angular/core</code> sources in unflattened ES2022 format.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>esm2022/testing/</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">未展平 ES2022 格式的 <code>@angular/core/testing</code> 入口點樹。</nt-wrapper><nt-wrapper translation-origin=\"off\">Tree of the <code>@angular/core/testing</code> entrypoint in unflattened ES2022 format.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>fesm2022/</code> <br> &nbsp;&nbsp;─ <code>core.mjs</code> <br> &nbsp;&nbsp;─ <code>core.mjs.map</code> <br> &nbsp;&nbsp;─ <code>testing.mjs</code> <br> &nbsp;&nbsp;─ <code>testing.mjs.map</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">扁平化 (FESM) ES2022 格式的所有入口點程式碼以及源對映。</nt-wrapper><nt-wrapper translation-origin=\"off\">Code for all entrypoints in flattened (FESM) ES2022 format, along with source maps.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>testing/</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">代表 <code>testing</code> 入口點的目錄。</nt-wrapper><nt-wrapper translation-origin=\"off\">Directory representing the \"testing\" entrypoint.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>testing/index.d.ts</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">為 <code>@angular/core/testing</code> 入口點打套件的 <code>.d.ts</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Bundled <code>.d.ts</code> for the <code>@angular/core/testing</code> entrypoint.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<h2 id=\"packagejson\"><code>package.json</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#packagejson\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\">主 <code>package.json</code> 包含重要的套件元資料(metadata)，包括以下內容：</p><p translation-origin=\"off\">The primary <code>package.json</code> contains important package metadata, including the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">它把此套件<a href=\"guide/angular-package-format#esm-declaration\">宣告</a>為 EcmaScript 模組 (ESM) 格式</p><p translation-origin=\"off\">It <a href=\"guide/angular-package-format#esm-declaration\">declares</a> the package to be in EcmaScript Module (ESM) format</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它包含一個 <a href=\"guide/angular-package-format#exports\"><code>\"exports\"</code> 欄位</a>，用於定義所有入口點的可用原始碼格式</p><p translation-origin=\"off\">It contains an <a href=\"guide/angular-package-format#exports\"><code>\"exports\"</code> field</a> which defines the available source code formats of all entrypoints</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它包含定義主入口點 <code>@angular/core</code> 的可用原始碼格式的<a href=\"guide/angular-package-format#legacy-resolution-keys\">一些鍵</a>，供不理解 <code>\"exports\"</code> 的工具使用。這些鍵已棄用，隨著對 <code>\"exports\"</code> 的支援在整個生態系統中逐步退出，這些鍵將被刪除。</p><p translation-origin=\"off\">It contains <a href=\"guide/angular-package-format#legacy-resolution-keys\">keys</a> which define the available source code formats of the primary <code>@angular/core</code> entrypoint, for tools which do not understand <code>\"exports\"</code>.\nThese keys are considered deprecated, and could be removed as the support for <code>\"exports\"</code> rolls out across the ecosystem.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它宣告此套件是否包含<a href=\"guide/angular-package-format#side-effects\">副作用</a></p><p translation-origin=\"off\">It declares whether the package contains <a href=\"guide/angular-package-format#side-effects\">side effects</a></p>\n\n</li>\n</ul>\n<h3 id=\"esm-declaration\" translation-result=\"on\">ESM 宣告<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#esm-declaration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">ESM declaration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#esm-declaration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">最上層 <code>package.json</code> 包含此鍵：</p><p translation-origin=\"off\">The top-level <code>package.json</code> contains the key:</p>\n\n<code-example language=\"javascript\">\n\n{\n  \"type\": \"module\"\n}\n\n</code-example>\n<p translation-result=\"on\">這會通知解析器，此套件中的程式碼正在使用 EcmaScript 模組而不是 CommonJS 模組。</p><p translation-origin=\"off\">This informs resolvers that code within the package is using EcmaScript Modules as opposed to CommonJS modules.</p>\n\n<h3 id=\"exports\"><code>\"exports\"</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#exports\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\"><code>\"exports\"</code> 欄位具有以下結構：</p><p translation-origin=\"off\">The <code>\"exports\"</code> field has the following structure:</p>\n\n<code-example language=\"javascript\">\n\n\"exports\": {\n  \"./schematics/*\": {\n    \"default\": \"./schematics/*.js\"\n  },\n  \"./package.json\": {\n    \"default\": \"./package.json\"\n  },\n  \".\": {\n    \"types\": \"./core.d.ts\",\n    \"esm\": \"./esm2022/core.mjs\",\n    \"esm2022\": \"./esm2022/core.mjs\",\n    \"default\": \"./fesm2022/core.mjs\"\n  },\n  \"./testing\": {\n    \"types\": \"./testing/testing.d.ts\",\n    \"esm\": \"./esm2022/testing/testing.mjs\",\n    \"esm2022\": \"./esm2022/testing/testing.mjs\",\n    \"default\": \"./fesm2022/testing.mjs\"\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">主要看 <code>\".\"</code> 和 <code>\"./testing\"</code> 這兩個鍵，它們分別定義了 <code>@angular/core</code> 主要入口點和 <code>@angular/core/testing</code> 次要入口點的可用程式碼格式。對於每個入口點，可用的格式為：</p><p translation-origin=\"off\">Of primary interest are the <code>\".\"</code> and the <code>\"./testing\"</code> keys, which define the available code formats for the <code>@angular/core</code> primary entrypoint and the <code>@angular/core/testing</code> secondary entrypoint, respectively.\nFor each entrypoint, the available formats are:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">格式</nt-wrapper><nt-wrapper translation-origin=\"off\">Formats</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">型別定義（<code>.d.ts</code> 檔案）</nt-wrapper><nt-wrapper translation-origin=\"off\">Typings (<code>.d.ts</code> files)</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">TypeScript 在依賴於給定套件時使用 <code>.d.ts</code> 檔案。</nt-wrapper><nt-wrapper translation-origin=\"off\"><code>.d.ts</code> files are used by TypeScript when depending on a given package.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>es2022</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">ES2022 程式碼扁平化為單個原始檔。</nt-wrapper><nt-wrapper translation-origin=\"off\">ES2022 code flattened into a single source file.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>esm2022</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">未展平原始檔中的 ES2022 程式碼（包含此格式用於實驗 - 有關詳細<a href=\"guide/angular-package-format#note-about-the-defaults-in-packagejson\">資訊，請參閱預設值討論</a>）。</nt-wrapper><nt-wrapper translation-origin=\"off\">ES2022 code in unflattened source files (this format is included for experimentation - see <a href=\"guide/angular-package-format#note-about-the-defaults-in-packagejson\">this discussion of defaults</a> for details).</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>default</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">ES2022 程式碼扁平化為單一原始碼。</nt-wrapper><nt-wrapper translation-origin=\"off\">ES2022 code flattened into a single source.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">能理解這些鍵名的工具可以優先從 <code>\"exports\"</code> 中選擇所需的程式碼格式。</p><p translation-origin=\"off\">Tooling that is aware of these keys may preferentially select a desirable code format from <code>\"exports\"</code>.</p>\n\n<p translation-result=\"on\">庫可能希望公開其他靜態檔案，這些檔案沒有被基於 JavaScript 的入口點（比如 Sass mixins 或預編譯的 CSS）的匯出所捕獲。</p><p translation-origin=\"off\">Libraries may want to expose additional static files which are not captured by the exports of the JavaScript-based entry-points such as Sass mixins or pre-compiled CSS.</p>\n\n<p translation-result=\"on\">有關更多資訊，參閱<a href=\"guide/creating-libraries#managing-assets-in-a-library\">管理函式庫中的資產</a>。</p><p translation-origin=\"off\">For more information, see <a href=\"guide/creating-libraries#managing-assets-in-a-library\">Managing assets in a library</a>.</p>\n\n<h3 id=\"legacy-resolution-keys\" translation-result=\"on\">舊版解析鍵<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#legacy-resolution-keys\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Legacy resolution keys<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#legacy-resolution-keys\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">除了 <code>\"exports\"</code> 之外，最上層 <code>package.json</code> 還為不支援 <code>\"exports\"</code> 的解析器定義了舊模組解析鍵。對於 <code>@angular/core</code>，這些是：</p><p translation-origin=\"off\">In addition to <code>\"exports\"</code>, the top-level <code>package.json</code> also defines legacy module resolution keys for resolvers that don't support <code>\"exports\"</code>.\nFor <code>@angular/core</code> these are:</p>\n\n<code-example language=\"javascript\">\n\n{\n  \"module\": \"./fesm2022/core.mjs\",\n  \"typings\": \"./core.d.ts\",\n}\n\n</code-example>\n<p translation-result=\"on\">如前述程式碼片段所示，模組解析器可以用這些鍵來載入特定的程式碼格式。</p><p translation-origin=\"off\">As shown in the preceding code snippet, a module resolver can use these keys to load a specific code format.</p>\n\n<h3 id=\"side-effects\" translation-result=\"on\">副作用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#side-effects\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Side effects<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#side-effects\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>package.json</code> 的最後一個功能是宣告此套件是否有<a href=\"guide/angular-package-format#sideeffects-flag\">副作用</a>。</p><p translation-origin=\"off\">The last function of <code>package.json</code> is to declare whether the package has <a href=\"guide/angular-package-format#sideeffects-flag\">side effects</a>.</p>\n\n<code-example language=\"javascript\">\n\n{\n  \"sideEffects\": false\n}\n\n</code-example>\n<p translation-result=\"on\">大多數 Angular 套件不應該依賴於最上層副作用，因此應該包含這個宣告。</p><p translation-origin=\"off\">Most Angular packages should not depend on top-level side effects, and thus should include this declaration.</p>\n\n<h2 id=\"entrypoints-and-code-splitting\" translation-result=\"on\">入口點和程式碼拆分<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#entrypoints-and-code-splitting\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Entrypoints and code splitting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#entrypoints-and-code-splitting\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">APF 格式的套件，包含一個主要入口點和零到多個次要入口點（比如 <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a></code>）。入口點有多種功能。</p><p translation-origin=\"off\">Packages in the Angular Package Format contain one primary entrypoint and zero or more secondary entrypoints (for example, <code>@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a></code>).\nEntrypoints serve several functions.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">它們定義了使用者要從中匯入程式碼的模組說明符（比如，<code>@angular/core</code> 和 <code>@angular/core/testing</code>）。</p><p translation-origin=\"off\">They define the module specifiers from which users import code (for example, <code>@angular/core</code> and <code>@angular/core/testing</code>).</p>\n\n<p translation-result=\"on\">使用者通常將這些入口點視為具有不同用途或能力的不同符號組。</p><p translation-origin=\"off\">Users typically perceive these entrypoints as distinct groups of symbols, with different purposes or capability.</p>\n\n<p translation-result=\"on\">特定入口點可能僅用於特殊目的，比如測試。此類 API 可以與主入口點分離，以減少它們被意外或錯誤使用的機會。</p><p translation-origin=\"off\">Specific entrypoints might only be used for special purposes, such as testing.\nSuch APIs can be separated out from the primary entrypoint to reduce the chance of them being used accidentally or incorrectly.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它們定義了可以延遲載入程式碼的粒度。</p><p translation-origin=\"off\">They define the granularity at which code can be lazily loaded.</p>\n\n<p translation-result=\"on\">許多現代建構工具只能在 ES 模組級別進行“程式碼拆分”（又名延遲載入）。APF 主要為每個入口點使用一個“扁平” ES 模組。這意味著大多數建構工具無法將單個入口點中的程式碼拆分為多個輸出塊。</p><p translation-origin=\"off\">Many modern build tools are only capable of \"code splitting\" (aka lazy loading) at the ES Module level.\nThe Angular Package Format uses primarily a single \"flat\" ES Module per entry point. This means that most build tooling is not able to split code with a single entry point into multiple output chunks.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">APF 套件的一般規則是為儘可能小的邏輯相關程式碼集使用入口點。比如，Angular Material 套件將每個邏輯元件或一組元件作為單獨的入口點發布 - 一個用於按鈕，一個用於選項卡等。如果需要，這允許單獨延遲載入每個 Material 元件。</p><p translation-origin=\"off\">The general rule for APF packages is to use entrypoints for the smallest sets of logically connected code possible.\nFor example, the Angular Material package publishes each logical component or set of components as a separate entrypoint - one for Button, one for Tabs, etc.\nThis allows each Material component to be lazily loaded separately, if desired.</p>\n\n<p translation-result=\"on\">並非所有庫都需要這樣的粒度。大多數具有單一邏輯目的的函式庫應該作為單一入口點發布。比如 <code>@angular/core</code> 為執行時使用單個入口點，因為 Angular 執行時通常用作單個實體。</p><p translation-origin=\"off\">Not all libraries require such granularity.\nMost libraries with a single logical purpose should be published as a single entrypoint.\n<code>@angular/core</code> for example uses a single entrypoint for the runtime, because the Angular runtime is generally used as a single entity.</p>\n\n<h3 id=\"resolution-of-secondary-entry-points\" translation-result=\"on\">次要入口點的解析<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#resolution-of-secondary-entry-points\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Resolution of secondary entry points<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#resolution-of-secondary-entry-points\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">可以透過套件的 <code>package.json</code> 的 <code>\"exports\"</code> 欄位解析輔助入口點。</p><p translation-origin=\"off\">Secondary entrypoints can be resolved via the <code>\"exports\"</code> field of the <code>package.json</code> for the package.</p>\n\n<h2 id=\"readmemd\" translation-result=\"on\">自述檔案<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#readmemd\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">README.md<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#readmemd\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Markdown 格式的 README 檔案，用於在 npm 和 GitHub 上顯示套件的描述。</p><p translation-origin=\"off\">The README file in the Markdown format that is used to display description of a package on npm and GitHub.</p>\n\n<p translation-result=\"on\">@angular/core 套件的 README 內容範例：</p><p translation-origin=\"off\">Example README content of @angular/core package:</p>\n\n<code-example language=\"html\">\n\nAngular\n=======\n\nThe sources for this package are in the main [Angular](https://github.com/angular/angular) repo.Please file issues and pull requests against that repo.\n\nLicense: MIT\n\n</code-example>\n<h2 id=\"partial-compilation\" translation-result=\"on\">部分編譯<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#partial-compilation\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Partial compilation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#partial-compilation\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">APF 格式的函式庫必須以“部分編譯”模式釋出。這是 <code>ngc</code> 的一種編譯模式，它產生不依賴於特定 Angular 執行時版本的已編譯 Angular 程式碼，與用於應用程式的完整編譯形成對比，其中 Angular 編譯器和執行時版本必須完全匹配。</p><p translation-origin=\"off\">Libraries in the Angular Package Format must be published in \"partial compilation\" mode.\nThis is a compilation mode for <code>ngc</code> which produces compiled Angular code that is not tied to a specific Angular runtime version, in contrast to the full compilation used for applications, where the Angular compiler and runtime versions must match exactly.</p>\n\n<p translation-result=\"on\">要部分編譯 Angular 程式碼，請在 <code>tsconfig.json</code> 中的 <code>\"angularCompilerOptions\"</code> 屬性中使用 <code>\"compilationMode\"</code> 標誌：</p><p translation-origin=\"off\">To partially compile Angular code, use the <code>compilationMode</code> flag in the <code>angularCompilerOptions</code> property of your <code>tsconfig.json</code>:</p>\n\n<code-example language=\"javascript\">\n\n{\n  …\n  \"angularCompilerOptions\": {\n    \"compilationMode\": \"partial\",\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">然後，在應用程式建構過程中，Angular CLI 將部分編譯的函式庫程式碼轉換為完全編譯的程式碼。</p><p translation-origin=\"off\">Partially compiled library code is then converted to fully compiled code during the application build process by the Angular CLI.</p>\n\n<p translation-result=\"on\">如果你的建構管道不使用 Angular CLI，參閱<a href=\"guide/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli\">在 Angular CLI 之外使用部分編譯的 Ivy 程式碼</a>指南。</p><p translation-origin=\"off\">If your build pipeline does not use the Angular CLI then refer to the <a href=\"guide/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli\">Consuming partial ivy code outside the Angular CLI</a> guide.</p>\n\n<h2 id=\"optimizations\" translation-result=\"on\">最佳化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#optimizations\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Optimizations<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#optimizations\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"flattening-of-es-modules\" translation-result=\"on\">ES 模組的扁平化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#flattening-of-es-modules\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Flattening of ES modules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#flattening-of-es-modules\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">APF 指定程式碼要以“扁平化”的 ES 模組格式釋出。這顯著減少了 Angular 應用程式的建構時間以及最終應用程式套件的下載和解析時間。請檢視 Nolan Lawson 發表的優秀文章<a href=\"https://nolanlawson.com/2016/08/15/the-cost-of-small-modules\">“小模組的成本”</a>。</p><p translation-origin=\"off\">The Angular Package Format specifies that code be published in \"flattened\" ES module format.\nThis significantly reduces the build time of Angular applications as well as download and parse time of the final application bundle.\nPlease check out the excellent post <a href=\"https://nolanlawson.com/2016/08/15/the-cost-of-small-modules\">\"The cost of small modules\"</a> by Nolan Lawson.</p>\n\n<p translation-result=\"on\">Angular 編譯器可以產生索引 ES 模組檔案。像 Rollup 這樣的工具可以用這些檔案以扁平化 ES 模組（FESM）檔案格式產生扁平化模組。</p><p translation-origin=\"off\">The Angular compiler can generate index ES module files. Tools like Rollup can use these files to generate flattened modules in a <em>Flattened ES Module</em> (FESM) file format.</p>\n\n<p translation-result=\"on\">FESM 是一種檔案格式，它會將所有可從入口點存取的 ES 模組扁平化為單個 ES 模組。它是透過追蹤套件中的所有匯入並將該程式碼複製到單個檔案中而產生的，同時保留所有公共 ES 匯出並刪除所有私有匯入。</p><p translation-origin=\"off\">FESM is a file format created by flattening all ES Modules accessible from an entrypoint into a single ES Module.\nIt's formed by following all imports from a package and copying that code into a single file while preserving all public ES exports and removing all private imports.</p>\n\n<p translation-result=\"on\">縮寫名稱 FESM，發音為<em>phe-som</em>，後面可以跟一個數字，例如 FESM2020。該數字是指模組內 JavaScript 的語言級別。因此，FESM2022 檔案將是 ESM+ES2022 格式的，並且包括匯入/匯出陳述式和 ES2022 原始碼。</p><p translation-origin=\"off\">The abbreviated name, FESM, pronounced <em>phe-som</em>, can be followed by a number such as FESM2020.\nThe number refers to the language level of the JavaScript inside the module.\nAccordingly a FESM2022 file would be ESM+ES2022 and include import/export statements and ES2022 source code.</p>\n\n<p translation-result=\"on\">要產生扁平化的 ES 模組索引檔案，請在 tsconfig.json 檔案中使用以下配置選項：</p><p translation-origin=\"off\">To generate a flattened ES Module index file, use the following configuration options in your tsconfig.json file:</p>\n\n<code-example language=\"javascript\">\n\n{\n  \"compilerOptions\": {\n    …\n    \"module\": \"esnext\",\n    \"target\": \"es2022\",\n    …\n  },\n  \"angularCompilerOptions\": {\n    …\n    \"flatModuleOutFile\": \"my-ui-lib.js\",\n    \"flatModuleId\": \"my-ui-lib\"\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">一旦 ngc 生成了索引檔案（比如 <code>my-ui-lib.js</code>），打包器和最佳化器（如 Rollup）就可用於產生扁平化的 ESM 檔案。</p><p translation-origin=\"off\">Once the index file (for example, <code>my-ui-lib.js</code>) is generated by ngc, bundlers and optimizers like Rollup can be used to produce the flattened ESM file.</p>\n\n<h4 id=\"note-about-the-defaults-in-packagejson\" translation-result=\"on\">注意 package.json 中的預設值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#note-about-the-defaults-in-packagejson\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Note about the defaults in package.json<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#note-about-the-defaults-in-packagejson\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">從 webpack v4 開始，ES 模組最佳化的扁平化對於 webpack 使用者來說不再是必需的。當不扁平化 webpack 中的模組時，可以獲得更好的程式碼拆分效果。在實踐中，當使用未展平的模組作為 webpack v4 的輸入時，仍然可能出現體積迴歸現象（也就是體積反而變大了）。這就是為什麼 package.json 中的 <code>module</code> 和 <code>es2022</code> 條目仍然指向 FESM 檔案的原因。這個問題正在調查中。預計在解決體積迴歸問題後，會將 package.json 中的 <code>module</code> 和 <code>es2022</code> 入口點切換為未展平的檔案。APF 目前包含未扁平化的 ESM2022 程式碼，用於驗證這種未來可能出現的更改。</p><p translation-origin=\"off\">As of webpack v4, the flattening of ES modules optimization should not be necessary for webpack users. It should be possible to get better code-splitting without flattening of modules in webpack.\nIn practice, size regressions can still be seen when using unflattened modules as input for webpack v4.\nThis is why <code>module</code> and <code>es2022</code> package.json entries still point to FESM files.\nThis issue is being investigated. It is expected to switch the <code>module</code> and <code>es2022</code> package.json entry points to unflattened files after the size regression issue is resolved.\nThe APF currently includes unflattened ESM2022 code for the purpose of validating such a future change.</p>\n\n<h3 id=\"sideeffects-flag\" translation-result=\"on\">“副作用”標誌<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#sideeffects-flag\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">\"sideEffects\" flag<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#sideeffects-flag\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">預設情況下，EcmaScript 模組是有副作用的：從模組匯入可確保該模組最上層的任何程式碼都將執行。這通常是不可取的，因為典型模組中的大多數副作用程式碼並不是真正的副作用，而是僅影響特定符號。如果沒有匯入和使用這些符號，通常需要在稱為 tree-shaking 的最佳化過程中將它們刪除，而副作用程式碼可以防止這種情況發生。</p><p translation-origin=\"off\">By default, EcmaScript Modules are side-effectful: importing from a module ensures that any code at the top level of that module should run.\nThis is often undesirable, as most side-effectful code in typical modules is not truly side-effectful, but instead only affects specific symbols.\nIf those symbols are not imported and used, it's often desirable to remove them in an optimization process known as tree-shaking, and the side-effectful code can prevent this.</p>\n\n<p translation-result=\"on\">諸如 Webpack 之類別的建構工具支援一個標誌，該標誌允許套件宣告它們並不依賴於其模組最上層的副作用程式碼，從而使工具可以更自由地對套件中的程式碼進行搖樹最佳化。這些最佳化的最終結果應該是較小的套件大小和程式碼拆分後包塊中更好的程式碼分佈。如果此最佳化包含非本地副作用，則此最佳化可能會破壞你的程式碼 - 然而，這在 Angular 應用程式中並不常見，並且通常是糟糕設計的標誌。建議讓所有套件透過將 <code>sideEffects</code> 屬性設定為 <code>false</code> 來宣告無副作用狀態，並且讓開發人員遵循 <a href=\"/guide/styleguide\">Angular 風格指南</a>，這自然會導致程式碼沒有非本地副作用。</p><p translation-origin=\"off\">Build tools such as Webpack support a flag which allows packages to declare that they do not depend on side-effectful code at the top level of their modules, giving the tools more freedom to tree-shake code from the package.\nThe end result of these optimizations should be smaller bundle size and better code distribution in bundle chunks after code-splitting.\nThis optimization can break your code if it contains non-local side-effects - this is however not common in Angular applications and it's usually a sign of bad design.\nThe recommendation is for all packages to claim the side-effect free status by setting the <code>sideEffects</code> property to <code>false</code>, and that developers follow the <a href=\"/guide/styleguide\">Angular Style Guide</a> which naturally results in code without non-local side-effects.</p>\n\n<p translation-result=\"on\">更多資訊：<a href=\"https://github.com/webpack/webpack/tree/master/examples/side-effects\">關於副作用的 webpack 文件</a></p><p translation-origin=\"off\">More info: <a href=\"https://github.com/webpack/webpack/tree/master/examples/side-effects\">webpack docs on side effects</a></p>\n\n<h3 id=\"es2022-language-level\" translation-result=\"on\">ES2022 語言級別<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#es2022-language-level\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">ES2022 language level<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#es2022-language-level\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">ES2022 語言級別現在是 Angular CLI 和其他工具使用的預設語言級別。Angular CLI 在應用程式建構時會將捆綁套件降級到所有目標瀏覽器都支援的語言級別。</p><p translation-origin=\"off\">ES2022 Language level is now the default language level that is consumed by Angular CLI and other tooling.\nThe Angular CLI down-levels the bundle to a language level that is supported by all targeted browsers at application build time.</p>\n\n<h3 id=\"dts-bundling--type-definition-flattening\" translation-result=\"on\">d.ts 捆綁/型別定義的扁平化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#dts-bundling--type-definition-flattening\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">d.ts bundling / type definition flattening<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#dts-bundling--type-definition-flattening\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">從 APF v8 開始，更建議執行 <a href=\"https://api-extractor.com\">API Extractor</a> 來打包 TypeScript 定義，以便讓全部 API 都出現在單個檔案中。</p><p translation-origin=\"off\">As of APF v8 it is now preferred to run <a href=\"https://api-extractor.com\">API Extractor</a>, to bundle TypeScript definitions so that the entire API appears in a single file.</p>\n\n<p translation-result=\"on\">在之前的 APF 版本中，每個入口點都會在 .d.ts 入口點旁邊有一個 <code>src</code> 目錄，該目錄包含與原始原始碼結構匹配的單個 d.ts 檔案。雖然這種分發格式仍然被允許和支援，但非常不鼓勵它，因為它會弄暈 IDE 之類別的工具，然後提供錯誤的自動完成，並允許使用者依賴深度匯入的路徑，這些路徑通常不被認為是庫或套件的公共 API。</p><p translation-origin=\"off\">In prior APF versions each entry point would have a <code>src</code> directory next to the .d.ts entry point and this directory contained individual d.ts files matching the structure of the original source code.\nWhile this distribution format is still allowed and supported, it is highly discouraged because it confuses tools like IDEs that then offer incorrect autocompletion, and allows users to depend on deep-import paths which are typically not considered to be public API of a library or a package.</p>\n\n<h3 id=\"tslib\" translation-result=\"on\">庫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#tslib\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Tslib<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#tslib\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">從 APF v10 開始，建議新增 tslib 作為主要入口點的直接依賴項。這是因為 tslib 版本與用來編譯庫的 TypeScript 版本相關聯。</p><p translation-origin=\"off\">As of APF v10, it is recommended to add tslib as a direct dependency of your primary entry-point.\nThis is because the tslib version is tied to the TypeScript version used to compile your library.</p>\n\n<h2 id=\"examples\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#examples\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#examples\"><i class=\"material-icons\">link</i></a></h2>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"https://unpkg.com/browse/@angular/core@13.0.0-rc.0\">@angular/core 套件</a></p><p translation-origin=\"off\"><a href=\"https://unpkg.com/browse/@angular/core@13.0.0-rc.0\">@angular/core package</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"https://unpkg.com/browse/@angular/material@13.0.0-rc.0\">@angular/material 套件</a></p><p translation-origin=\"off\"><a href=\"https://unpkg.com/browse/@angular/material@13.0.0-rc.0\">@angular/material package</a></p>\n\n</li>\n</ul>\n<h2 id=\"definition-of-terms\" translation-result=\"on\">術語定義<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#definition-of-terms\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Definition of terms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#definition-of-terms\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本文件中特意使用了以下術語。在本節中會定義所有這些以便更清晰。</p><p translation-origin=\"off\">The following terms are used throughout this document intentionally.\nIn this section are the definitions of all of them to provide additional clarity.</p>\n\n<h4 id=\"package\" translation-result=\"on\">套件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#package\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Package<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#package\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">釋出到 NPM 並一起安裝的最小檔案集，比如 <code>@angular/core</code>。該套件中包含一個名為 package.json 的清單、編譯後的原始碼、TypeScript 定義檔案、原始碼對映、元資料等。該套件是透過 <code>npm install @angular/core</code> 安裝的。</p><p translation-origin=\"off\">The smallest set of files that are published to NPM and installed together, for example <code>@angular/core</code>.\nThis package includes a manifest called package.json, compiled source code, typescript definition files, source maps, metadata, etc.\nThe package is installed with <code>npm install @angular/core</code>.</p>\n\n<h4 id=\"symbol\" translation-result=\"on\">符號<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#symbol\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Symbol<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#symbol\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">包含在模組中的類、函式、常量或變數，可選擇透過模組匯出，以便對外界可見。</p><p translation-origin=\"off\">A class, function, constant, or variable contained in a module and optionally made visible to the external world via a module export.</p>\n\n<h4 id=\"module\" translation-result=\"on\">模組<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#module\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Module<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#module\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">ECMAScript 模組的縮寫。包含匯入和匯出符號的陳述式的檔案。這與 ECMAScript 規範中模組的定義相同。</p><p translation-origin=\"off\">Short for ECMAScript Modules.\nA file containing statements that import and export symbols.\nThis is identical to the definition of modules in the ECMAScript spec.</p>\n\n<h4 id=\"esm\">ESM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#esm\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\">ECMAScript 模組的縮寫（見上文）。</p><p translation-origin=\"off\">Short for ECMAScript Modules (see above).</p>\n\n<h4 id=\"fesm\">FESM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#fesm\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\">Flattened ES Modules 的縮寫，由一種檔案格式組成，該檔案格式是透過將所有可從入口點存取的 ES 模組扁平化為單個 ES 模組而建立的。</p><p translation-origin=\"off\">Short for Flattened ES Modules and consists of a file format created by flattening all ES Modules accessible from an entry point into a single ES Module.</p>\n\n<h4 id=\"module-id\" translation-result=\"on\">模組標識<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#module-id\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Module ID<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#module-id\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">匯入陳述式中使用的模組的識別符號（比如 <code>@angular/core</code>）。此 ID 通常直接對映到檔案系統上的路徑，但由於有各種模組解析策略，情況也並非總是如此。</p><p translation-origin=\"off\">The identifier of a module used in the import statements (for example, <code>@angular/core</code>).\nThe ID often maps directly to a path on the filesystem, but this is not always the case due to various module resolution strategies.</p>\n\n<h4 id=\"module-specifier\" translation-result=\"on\">模組說明符<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#module-specifier\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Module specifier<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#module-specifier\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">模組識別符號（見上文）。</p><p translation-origin=\"off\">A module identifier (see above).</p>\n\n<h4 id=\"module-resolution-strategy\" translation-result=\"on\">模組解析策略<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#module-resolution-strategy\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Module resolution strategy<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#module-resolution-strategy\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">用於將模組 ID 轉換為檔案系統路徑的演算法。Node.js 就有一個良好定義且廣泛使用的，TypeScript 支援多種模組解析策略，<a href=\"https://developers.google.com/closure/compiler\">Closure Compiler</a> 還有另一種策略。</p><p translation-origin=\"off\">Algorithm used to convert Module IDs to paths on the filesystem.\nNode.js has one that is well specified and widely used, TypeScript supports several module resolution strategies, <a href=\"https://developers.google.com/closure/compiler\">Closure Compiler</a> has yet another strategy.</p>\n\n<h4 id=\"module-format\" translation-result=\"on\">模組格式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#module-format\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Module format<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#module-format\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">模組語法規範，至少涵蓋從檔案匯入和匯出的語法。常見的模組格式是 CommonJS（CJS，通常用於 Node.js 應用程式）或 ECMAScript 模組 (ESM)。模組格式僅表示單個模組的封裝，而不表示用於構成模組內容的 JavaScript 語言特性。正因為如此，Angular 團隊經常使用語言級別說明符作為模組格式的字尾，（例如 ESM+ES2022 指定模組為 ESM 格式幷包含 ES2022 程式碼）。</p><p translation-origin=\"off\">Specification of the module syntax that covers at minimum the syntax for the importing and exporting from a file.\nCommon module formats are CommonJS (CJS, typically used for Node.js applications) or ECMAScript Modules (ESM).\nThe module format indicates only the packaging of the individual modules, but not the JavaScript language features used to make up the module content.\nBecause of this, the Angular team often uses the language level specifier as a suffix to the module format, (for example, ESM+ES2022 specifies that the module is in ESM format and contains ES2022 code).</p>\n\n<h4 id=\"bundle\" translation-result=\"on\">捆綁套件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#bundle\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Bundle<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#bundle\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">單個 JS 檔案形式的工件，由建構工具（比如 <a href=\"https://webpack.js.org\">Webpack</a>或<a href=\"https://rollupjs.org/\">Rollup</a>）產生，其中包含源自一個或多個模組的符號。捆綁套件是一種瀏覽器專用的解決方案，可減少瀏覽器開始下載數百甚至數萬個檔案時可能造成的網路壓力。Node.js 通常不使用捆綁套件。常見的捆綁套件格式是 UMD 和 System.register。</p><p translation-origin=\"off\">An artifact in the form of a single JS file, produced by a build tool (for example, <a href=\"https://webpack.js.org\">Webpack</a> or <a href=\"https://rollupjs.org\">Rollup</a>) that contains symbols originating in one or more modules.\nBundles are a browser-specific workaround that reduce network strain that would be caused if browsers were to start downloading hundreds if not tens of thousands of files.\nNode.js typically doesn't use bundles.\nCommon bundle formats are UMD and System.register.</p>\n\n<h4 id=\"language-level\" translation-result=\"on\">語言級別<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#language-level\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Language level<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#language-level\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">程式碼的語言 (ES2022)。獨立於模組格式。</p><p translation-origin=\"off\">The language of the code (ES2022).\nIndependent of the module format.</p>\n\n<h4 id=\"entry-point\" translation-result=\"on\">入口點<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#entry-point\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Entry point<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#entry-point\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">旨在由使用者匯入的模組。它由唯一的模組 ID 參考，並匯出該模組 ID 參考的公共 API。一個例子是 <code>@angular/core</code> 或 <code>@angular/core/testing</code>。<code>@angular/core</code> 套件中存在兩個入口點，但它們匯出不同的符號。一個套件可以有許多入口點。</p><p translation-origin=\"off\">A module intended to be imported by the user.\nIt is referenced by a unique module ID and exports the public API referenced by that module ID.\nAn example is <code>@angular/core</code> or <code>@angular/core/testing</code>.\nBoth entry points exist in the <code>@angular/core</code> package, but they export different symbols.\nA package can have many entry points.</p>\n\n<h4 id=\"deep-import\" translation-result=\"on\">深度匯入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#deep-import\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Deep import<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#deep-import\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">從不是入口點的模組中檢索符號的過程。這些模組 ID 通常被認為是私有 API，它們可以在專案的生命週期內或在建立給定套件的捆綁套件時更改。</p><p translation-origin=\"off\">A process of retrieving symbols from modules that are not Entry Points.\nThese module IDs are usually considered to be private APIs that can change over the lifetime of the project or while the bundle for the given package is being created.</p>\n\n<h4 id=\"top-level-import\" translation-result=\"on\">最上層匯入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#top-level-import\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Top-Level import<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#top-level-import\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">來自入口點的匯入。可用的最上層匯入定義了公共 API，並在“@angular/name”模組中公開，比如 <code>@angular/core</code> 或 <code>@angular/common</code>。</p><p translation-origin=\"off\">An import coming from an entry point.\nThe available top-level imports are what define the public API and are exposed in \"@angular/name\" modules, such as <code>@angular/core</code> or <code>@angular/common</code>.</p>\n\n<h4 id=\"tree-shaking\" translation-result=\"on\">搖樹最佳化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#tree-shaking\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Tree-shaking<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#tree-shaking\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">識別和刪除應用程式中未使用的程式碼的過程 - 也稱為死程式碼消除。這是使用 <a href=\"https://rollupjs.org\">Rollup</a> 、 <a href=\"https://developers.google.com/closure/compiler\">Closure Compiler</a> 或 <a href=\"https://github.com/terser/terser/\">Terser</a> 等工具在應用程式級別執行的全域最佳化。</p><p translation-origin=\"off\">The process of identifying and removing code not used by an application - also known as dead code elimination.\nThis is a global optimization performed at the application level using tools like <a href=\"https://rollupjs.org\">Rollup</a>, <a href=\"https://developers.google.com/closure/compiler\">Closure Compiler</a>, or <a href=\"https://github.com/terser/terser\">Terser</a>.</p>\n\n<h4 id=\"aot-compiler\" translation-result=\"on\">AOT 編譯器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#aot-compiler\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">AOT compiler<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#aot-compiler\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">Angular 的預先編譯器。</p><p translation-origin=\"off\">The Ahead of Time Compiler for Angular.</p>\n\n<h4 id=\"flattened-type-definitions\" translation-result=\"on\">扁平型別定義<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#flattened-type-definitions\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Flattened type definitions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/angular-package-format#flattened-type-definitions\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">從 <a href=\"https://api-extractor.com\">API Extractor</a> 產生的捆綁 TypeScript 定義。</p><p translation-origin=\"off\">The bundled TypeScript definitions generated from <a href=\"https://api-extractor.com\">API Extractor</a>.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：3/6/2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/glossary\n-->\n<!-- links from this doc:\n - /guide/styleguide\n - api/common/http\n - guide/angular-package-format#angular-package-format\n - guide/angular-package-format#angular-套件格式\n - guide/angular-package-format#aot-compiler\n - guide/angular-package-format#aot-編譯器\n - guide/angular-package-format#bundle\n - guide/angular-package-format#deep-import\n - guide/angular-package-format#definition-of-terms\n - guide/angular-package-format#dts-bundling--type-definition-flattening\n - guide/angular-package-format#dts-捆綁型別定義的扁平化\n - guide/angular-package-format#entry-point\n - guide/angular-package-format#entrypoints-and-code-splitting\n - guide/angular-package-format#es-模組的扁平化\n - guide/angular-package-format#es2022-language-level\n - guide/angular-package-format#es2022-語言級別\n - guide/angular-package-format#esm\n - guide/angular-package-format#esm-declaration\n - guide/angular-package-format#esm-宣告\n - guide/angular-package-format#examples\n - guide/angular-package-format#exports\n - guide/angular-package-format#fesm\n - guide/angular-package-format#file-layout\n - guide/angular-package-format#flattened-type-definitions\n - guide/angular-package-format#flattening-of-es-modules\n - guide/angular-package-format#language-level\n - guide/angular-package-format#legacy-resolution-keys\n - guide/angular-package-format#module\n - guide/angular-package-format#module-format\n - guide/angular-package-format#module-id\n - guide/angular-package-format#module-resolution-strategy\n - guide/angular-package-format#module-specifier\n - guide/angular-package-format#note-about-the-defaults-in-packagejson\n - guide/angular-package-format#optimizations\n - guide/angular-package-format#package\n - guide/angular-package-format#packagejson\n - guide/angular-package-format#partial-compilation\n - guide/angular-package-format#readmemd\n - guide/angular-package-format#resolution-of-secondary-entry-points\n - guide/angular-package-format#side-effects\n - guide/angular-package-format#sideeffects-flag\n - guide/angular-package-format#symbol\n - guide/angular-package-format#top-level-import\n - guide/angular-package-format#tree-shaking\n - guide/angular-package-format#tslib\n - guide/angular-package-format#why-specify-a-package-format\n - guide/angular-package-format#為什麼要指定套件格式\n - guide/angular-package-format#最佳化\n - guide/angular-package-format#例子\n - guide/angular-package-format#入口點\n - guide/angular-package-format#入口點和程式碼拆分\n - guide/angular-package-format#副作用\n - guide/angular-package-format#副作用標誌\n - guide/angular-package-format#包\n - guide/angular-package-format#庫\n - guide/angular-package-format#扁平型別定義\n - guide/angular-package-format#捆綁套件\n - guide/angular-package-format#搖樹最佳化\n - guide/angular-package-format#檔案佈局\n - guide/angular-package-format#舊版解析鍵\n - guide/angular-package-format#術語定義\n - guide/angular-package-format#模組\n - guide/angular-package-format#模組標識\n - guide/angular-package-format#模組格式\n - guide/angular-package-format#模組解析策略\n - guide/angular-package-format#模組說明符\n - guide/angular-package-format#次要入口點的解析\n - guide/angular-package-format#注意-packagejson-中的預設值\n - guide/angular-package-format#深度匯入\n - guide/angular-package-format#符號\n - guide/angular-package-format#自述檔案\n - guide/angular-package-format#語言級別\n - guide/angular-package-format#部分編譯\n - guide/angular-package-format#最上層匯入\n - guide/creating-libraries\n - guide/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli\n - guide/creating-libraries#managing-assets-in-a-library\n - https://api-extractor.com\n - https://developers.google.com/closure/compiler\n - https://docs.google.com/document/d/1CZC2rcpxffTDfRDs6p1cfbmKNLA6x5O-NtkJglDaBVs/preview\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/angular-package-format.md?message=docs%3A%20請簡述你的修改...\n - https://github.com/ng-packagr/ng-packagr\n - https://github.com/terser/terser\n - https://github.com/terser/terser/\n - https://github.com/webpack/webpack/tree/master/examples/side-effects\n - https://nolanlawson.com/2016/08/15/the-cost-of-small-modules\n - https://rollupjs.org\n - https://rollupjs.org/\n - https://unpkg.com/browse/@angular/core@13.0.0-rc.0\n - https://unpkg.com/browse/@angular/material@13.0.0-rc.0\n - https://webpack.js.org\n-->"}