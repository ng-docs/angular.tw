{"id":"guide/cli-builder","title":"Angular CLI builders","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/cli-builder.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"angular-cli-builders\" translation-result=\"on\">Angular CLI 建構器（Builder）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#angular-cli-builders\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Angular CLI builders<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#angular-cli-builders\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">很多 Angular CLI 命令都要在你的程式碼上執行一些複雜的處理，比如風格檢查（lint）建構或測試。這些命令會透過一個叫做建築師（Architect）的內部工具來執行 <em>CLI 建構器</em>，而這些建構器會運用一些第三方工具來完成目標任務。</p><p translation-origin=\"off\">A number of Angular CLI commands run a complex process on your code, such as linting, building, or testing.\nThe commands use an internal tool called Architect to run <em>CLI builders</em>, which apply another tool to accomplish the wanted task.</p>\n\n<p translation-result=\"on\">在 Angular 的版本 8 中，CLI 建構器的 API 是穩定的，想要透過新增或修改命令來自訂 Angular CLI 的開發人員可以使用它。比如，你可以提供一個建構器來執行全新的任務，或者更改一個現有命令所使用的第三方工具。</p><p translation-origin=\"off\">With Angular version 8, the CLI Builder API is stable and available to developers who want to customize the Angular CLI by adding or modifying commands.\nFor example, you could supply a builder to perform an entirely new task, or to change which third-party tool is used by an existing command.</p>\n\n<p translation-result=\"on\">本文件介紹了 CLI 建構器是如何與工作區配置檔案整合的，還展示瞭如何建立你自己的建構器。</p><p translation-origin=\"off\">This document explains how CLI builders integrate with the workspace configuration file, and shows how you can create your own builder.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">可以在這個 <a href=\"https://github.com/mgechev/cli-builders-demo\">GitHub 儲存庫</a>中的例子中找到程式碼。</p><p translation-origin=\"off\">Find the code from the examples used here in this <a href=\"https://github.com/mgechev/cli-builders-demo\">GitHub repository</a>.</p>\n\n</div>\n<h2 id=\"cli-builders\" translation-result=\"on\">CLI 建構器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#cli-builders\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">CLI builders<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#cli-builders\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">內部建築師工具會把工作委託給名叫<a href=\"guide/glossary#builder\"><em>建構器</em></a>的處理器函式。處理器函式接收兩個引數：一組 <code>options</code> 輸入（JSON 物件）和一個 <code>context</code>（<code>BuilderContext</code> 物件）。</p><p translation-origin=\"off\">The internal Architect tool delegates work to handler functions called <a href=\"guide/glossary#builder\"><em>builders</em></a>.\nA builder handler function receives two arguments; a set of input <code>options</code> (a JSON object), and a <code>context</code> (a <code>BuilderContext</code> object).</p>\n\n<p translation-result=\"on\">這裡對關注點的分離和<a href=\"guide/glossary#schematic\">原理圖</a>中是一樣的，它也適用於其它要接觸（touch）程式碼的 CLI 命令（比如 <code>ng generate</code>）。</p><p translation-origin=\"off\">The separation of concerns here is the same as with <a href=\"guide/glossary#schematic\">schematics</a>, which are used for other CLI commands that touch your code (such as <code>ng generate</code>).</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">此 <code>options</code> 物件是由本 CLI 的使用者提供的，而 <code>context</code> 物件則由 CLI 建構器的 API 提供</p><p translation-origin=\"off\">The <code>options</code> object is provided by the CLI user, while the <code>context</code> object is provided by the CLI Builder API</p>\n\n</li>\n<li>\n<p translation-result=\"on\">除了上下文資訊之外，此 <code>context</code> 物件（它是 <code>BuilderContext</code> 的例項）還允許你存取排程方法 <code>context.scheduleTarget()</code>。排程器會用指定的<a href=\"guide/glossary#target\">目標配置</a>來執行建構器處理函式。</p><p translation-origin=\"off\">In addition to the contextual information, the <code>context</code> object, which is an instance of the <code>BuilderContext</code>, also provides access to a scheduling method, <code>context.scheduleTarget()</code>.\nThe scheduler executes the builder handler function with a given <a href=\"guide/glossary#target\">target configuration</a>.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">這個建構器處理函式可以是同步的（返回一個值）或非同步的（返回一個 Promise），也可以監視並返回多個值（返回一個 Observable）。最終返回的值全都是 <code>BuilderOutput</code> 型別的。該物件包含一個邏輯欄位 <code>success</code> 和一個可以包含錯誤資訊的可選欄位 <code>error</code>。</p><p translation-origin=\"off\">The builder handler function can be synchronous (return a value) or asynchronous (return a Promise), or it can watch and return multiple values (return an Observable).\nThe return value or values must always be of type <code>BuilderOutput</code>.\nThis object contains a Boolean <code>success</code> field and an optional <code>error</code> field that can contain an error message.</p>\n\n<p translation-result=\"on\">Angular 提供了一些建構器，供 CLI 命令使用，如 <code>ng build</code> 和 <code>ng test</code> 等。這些內建 CLI 建構器的預設目標配置可以在<a href=\"guide/workspace-config\">工作區配置檔案</a> <code>angular.json</code> 的 <code>architect</code> 部分找到（並進行自訂）。可以透過建立自己的建構器來擴充和自訂 Angular，你可以使用 <a href=\"cli/run\"><code>ng run</code> CLI 命令</a>來執行你自己的建構器。</p><p translation-origin=\"off\">Angular provides some builders that are used by the CLI for commands such as <code>ng build</code> and <code>ng test</code>.\nDefault target configurations for these and other built-in CLI builders can be found (and customized) in the \"architect\" section of the <a href=\"guide/workspace-config\">workspace configuration file</a>, <code>angular.json</code>.\nAlso, extend and customize Angular by creating your own builders, which you can run using the <a href=\"cli/run\"><code>ng run</code> CLI command</a>.</p>\n\n<h3 id=\"builder-project-structure\" translation-result=\"on\">建構器的專案結構<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-project-structure\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Builder project structure<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-project-structure\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">建構器位於一個 <code>project</code> 資料夾中，該資料夾的結構類似於 Angular 工作區，包括位於最上層的全域配置檔案，以及位於工作程式碼所在原始檔夾中的更具體的配置。比如，<code>myBuilder</code> 資料夾中可能包含如下檔案。</p><p translation-origin=\"off\">A builder resides in a \"project\" folder that is similar in structure to an Angular workspace, with global configuration files at the top level, and more specific configuration in a source folder with the code files that define the behavior.\nFor example, your <code>myBuilder</code> folder could contain the following files.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">檔案</nt-wrapper><nt-wrapper translation-origin=\"off\">Files</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">用途</nt-wrapper><nt-wrapper translation-origin=\"off\">Purpose</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>src/my-builder.ts</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">這個建構器定義的主要原始碼。</nt-wrapper><nt-wrapper translation-origin=\"off\">Main source file for the builder definition.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>src/my-builder.spec.ts</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">測試的原始碼。</nt-wrapper><nt-wrapper translation-origin=\"off\">Source file for tests.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>src/schema.json</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">建構器輸入選項的定義。</nt-wrapper><nt-wrapper translation-origin=\"off\">Definition of builder input options.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>builders.json</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">測試配置。</nt-wrapper><nt-wrapper translation-origin=\"off\">Builders definition.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>package.json</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">相依套件。參閱 <a href=\"https://docs.npmjs.com/files/package.json%E3%80%82\">https://docs.npmjs.com/files/package.json。</a></nt-wrapper><nt-wrapper translation-origin=\"off\">Dependencies. See <a href=\"https://docs.npmjs.com/files/package.json\">https://docs.npmjs.com/files/package.json</a>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>tsconfig.json</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">TypeScript 配置檔案</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\"><a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">TypeScript configuration</a>.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">將此建構器釋出到 <code>npm</code>（參閱<a href=\"guide/creating-libraries#publishing-your-library\">釋出你的函式庫</a>）。如果你將其釋出為 <code>&amp;commat;example/my-builder</code>，請使用以下命令安裝它。</p><p translation-origin=\"off\">Publish the builder to <code>npm</code> (see <a href=\"guide/creating-libraries#publishing-your-library\">Publishing your Library</a>).\nIf you publish it as <code>@example/my-builder</code>, install it using the following command.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @example/my-builder\n\n</code-example>\n<h2 id=\"creating-a-builder\" translation-result=\"on\">建立建構器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#creating-a-builder\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Creating a builder<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#creating-a-builder\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">舉個例子，讓我們建立一個用來複制檔案的建構器。要建立建構器，請使用 CLI 建構器函式 <code>createBuilder()</code>，並返回一個 <code>Promise&lt;BuilderOutput&gt;</code> 物件。</p><p translation-origin=\"off\">As an example, create a builder that copies a file.\nTo create a builder, use the <code>createBuilder()</code> CLI Builder function, and return a <code>Promise&lt;BuilderOutput&gt;</code> object.</p>\n\n<code-example header=\"src/my-builder.ts (builder skeleton)\" path=\"cli-builder/src/my-builder.ts\" region=\"builder-skeleton\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\nasync function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&lt;BuilderOutput&gt; {\n}\n\n\n</code-example>\n<p translation-result=\"on\">現在，讓我們為它新增一些邏輯。下列程式碼會從使用者選項中獲取原始檔和目標檔案的路徑，並且把原始檔複製到目標檔案（使用 <a href=\"https://nodejs.org/api/fs.html#fs_fspromises_copyfile_src_dest_mode\">NodeJS 內建函式 <code>copyFile()</code> 的 Promise 版本</a>）。如果檔案操作失敗了，它會返回一個帶有底層錯誤資訊的 error 物件。</p><p translation-origin=\"off\">Now let's add some logic to it.\nThe following code retrieves the source and destination file paths from user options and copies the file from the source to the destination (using the <a href=\"https://nodejs.org/api/fs.html#fs_fspromises_copyfile_src_dest_mode\">Promise version of the built-in NodeJS <code>copyFile()</code> function</a>).\nIf the copy operation fails, it returns an error with a message about the underlying problem.</p>\n\n<code-example header=\"src/my-builder.ts (builder)\" path=\"cli-builder/src/my-builder.ts\" region=\"builder\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\nasync function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&lt;BuilderOutput&gt; {\n  try {\n    await fs.copyFile(options.source, options.destination);\n  } catch (err) {\n    return {\n      success: false,\n      error: err.message,\n    };\n  }\n\n  return { success: true };\n}\n\n\n</code-example>\n<h3 id=\"handling-output\" translation-result=\"on\">處理輸出<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#handling-output\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Handling output<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#handling-output\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">預設情況下，<code>copyFile()</code> 方法不會往標準輸出或標準錯誤中列印任何資訊。如果發生了錯誤，可能很難理解建構器到底做了什麼。可以使用 <code>Logger</code> API 來記錄一些額外的資訊，以提供額外的上下文。這樣還能讓建構器本身可以在一個單獨的處理序中執行，即使其標準輸出和標準錯誤被停用了也無所謂（就像在 <a href=\"https://electronjs.org/\">Electron 應用中一樣</a>）。</p><p translation-origin=\"off\">By default, <code>copyFile()</code> does not print anything to the process standard output or error.\nIf an error occurs, it might be difficult to understand exactly what the builder was trying to do when the problem occurred.\nAdd some additional context by logging additional information using the <code>Logger</code> API.\nThis also lets the builder itself be executed in a separate process, even if the standard output and error are deactivated (as in an <a href=\"https://electronjs.org\">Electron app</a>).</p>\n\n<p translation-result=\"on\">你可以從上下文中檢索一個 <code>Logger</code> 例項。</p><p translation-origin=\"off\">You can retrieve a <code>Logger</code> instance from the context.</p>\n\n<code-example header=\"src/my-builder.ts (handling output)\" path=\"cli-builder/src/my-builder.ts\" region=\"handling-output\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\nasync function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&lt;BuilderOutput&gt; {\n  try {\n    await fs.copyFile(options.source, options.destination);\n  } catch (err) {\n    context.logger.error('Failed to copy file.');\n    return {\n      success: false,\n      error: err.message,\n    };\n  }\n\n  return { success: true };\n}\n\n\n</code-example>\n<h3 id=\"progress-and-status-reporting\" translation-result=\"on\">進度和狀態報告<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#progress-and-status-reporting\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Progress and status reporting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#progress-and-status-reporting\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">CLI 建構器 API 包含一些進度報告和狀態報告工具，可以為某些函式和介面提供提示資訊。</p><p translation-origin=\"off\">The CLI Builder API includes progress and status reporting tools, which can provide hints for certain functions and interfaces.</p>\n\n<p translation-result=\"on\">要報告進度，請使用 <code>context.reportProgress()</code> 方法，它接受一個當前值（value）、一個（可選的）總值（total）和狀態（status）字串作為引數。總值可以是任意數字，比如，如果你知道有多少個檔案需要處理，那麼總值可能是這些檔案的數量，而當前值是已處理過的數量。除非傳入了新的字串，否則這個狀態字串不會改變。</p><p translation-origin=\"off\">To report progress, use the <code>context.reportProgress()</code> method, which takes a current value, (optional) total, and status string as arguments.\nThe total can be any number; for example, if you know how many files you have to process, the total could be the number of files, and current should be the number processed so far.\nThe status string is unmodified unless you pass in a new string value.</p>\n\n<p translation-result=\"on\">你可以看看 <code>tslint</code> 建構器如何報告進度的<a href=\"https://github.com/angular/angular-cli/blob/ba21c855c0c8b778005df01d4851b5a2176edc6f/packages/angular_devkit/build_angular/src/tslint/index.ts#L107\">例子</a>。</p><p translation-origin=\"off\">You can see an <a href=\"https://github.com/angular/angular-cli/blob/ba21c855c0c8b778005df01d4851b5a2176edc6f/packages/angular_devkit/build_angular/src/tslint/index.ts#L107\">example</a> of how the <code>tslint</code> builder reports progress.</p>\n\n<p translation-result=\"on\">在我們的例子中，這種複製操作或者已完成或者正在執行，所以不需要進度報告，但是可以報告狀態，以便呼叫此建構器的父建構器知道發生了什麼。可以用 <code>context.reportStatus()</code> 方法產生一個任意長度的狀態字串。</p><p translation-origin=\"off\">In our example, the copy operation either finishes or is still executing, so there's no need for a progress report, but you can report status so that a parent builder that called our builder would know what's going on.\nUse the <code>context.reportStatus()</code> method to generate a status string of any length.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n無法保證長字串會完全顯示出來，可以裁剪它以適應介面顯示。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThere's no guarantee that a long string will be shown entirely; it could be cut to fit the UI that displays it.</p>\n\n</div>\n<p translation-result=\"on\">傳入一個空字串可以移除狀態。</p><p translation-origin=\"off\">Pass an empty string to remove the status.</p>\n\n<code-example header=\"src/my-builder.ts (progress reporting)\" path=\"cli-builder/src/my-builder.ts\" region=\"progress-reporting\">\nimport { BuilderContext, BuilderOutput, createBuilder } from '@angular-devkit/architect';\nimport { JsonObject } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ninterface Options extends JsonObject {\n  source: string;\n  destination: string;\n}\n\nexport default createBuilder(copyFileBuilder);\n\nasync function copyFileBuilder(\n  options: Options,\n  context: BuilderContext,\n): Promise&lt;BuilderOutput&gt; {\n  context.reportStatus(`Copying ${options.source} to ${options.destination}.`);\n  try {\n    await fs.copyFile(options.source, options.destination);\n  } catch (err) {\n    context.logger.error('Failed to copy file.');\n    return {\n      success: false,\n      error: err.message,\n    };\n  }\n\n  context.reportStatus('Done.');\n  return { success: true };\n}\n\n\n</code-example>\n<h2 id=\"builder-input\" translation-result=\"on\">建構器的輸入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-input\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Builder input<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#builder-input\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以透過 CLI 命令間接呼叫一個建構器，也可以直接用 Angular CLI 的 <code>ng run</code> 命令來呼叫它。無論哪種情況，你都必須提供所需的輸入，但是可以用特定<a href=\"guide/glossary#target\"><em>目標</em></a>中預配置的值作為其預設值，然後指定一個預定義的、指定的配置進行覆蓋，最後在命令列中進一步覆蓋這些選項的值。</p><p translation-origin=\"off\">You can invoke a builder indirectly through a CLI command, or directly with the Angular CLI <code>ng run</code> command.\nIn either case, you must provide required inputs, but can let other inputs default to values that are pre-configured for a specific <a href=\"guide/glossary#target\"><em>target</em></a>, provide a pre-defined, named override configuration, and provide further override option values on the command line.</p>\n\n<h3 id=\"input-validation\" translation-result=\"on\">對輸入的驗證<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#input-validation\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Input validation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#input-validation\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以在該建構器的相關 JSON 模式中定義建構器都有哪些輸入。建築師工具會把解析後的輸入值收集到一個 <code>options</code> 物件中，並在將其傳給建構器函式之前先根據這個模式驗證它們的型別。（Schematics 庫也對使用者輸入做了同樣的驗證）。</p><p translation-origin=\"off\">You define builder inputs in a JSON schema associated with that builder.\nThe Architect tool collects the resolved input values into an <code>options</code> object, and validates their types against the schema before passing them to the builder function.\n(The Schematics library does the same kind of validation of user input.)</p>\n\n<p translation-result=\"on\">對於這個範例建構器，你希望 <code>options</code> 的值是帶有兩個鍵的 <code>JsonObject</code>：一個是 <code>source</code>，一個是 <code>destination</code>，它們都是字串。</p><p translation-origin=\"off\">For our example builder, you expect the <code>options</code> value to be a <code>JsonObject</code> with two keys:\nA <code>source</code> and a <code>destination</code>, each of which are a string.</p>\n\n<p translation-result=\"on\">你可以提供如下模式來對這些值的型別進行驗證。</p><p translation-origin=\"off\">You can provide the following schema for type validation of these values.</p>\n\n<code-example header=\"src/schema.json\" format=\"json\" language=\"json\">\n\n{\n  \"$schema\": \"http://json-schema.org/schema\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"source\": {\n      \"type\": \"string\"\n    },\n    \"destination\": {\n      \"type\": \"string\"\n    }\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">這是一個非常簡單的例子，但這種模式驗證也可以非常強大。欲知詳情，參閱 <a href=\"http://json-schema.org\">JSON 模式網站</a>。</p><p translation-origin=\"off\">This is a very simple example, but the use of a schema for validation can be very powerful.\nFor more information, see the <a href=\"http://json-schema.org\">JSON schemas website</a>.</p>\n\n</div>\n<p translation-result=\"on\">要把建構器的實現與它的模式和名稱關聯起來，你需要建立一個<em>建構器定義</em>檔案，可以在 <code>package.json</code> 中指向該檔案。</p><p translation-origin=\"off\">To link our builder implementation with its schema and name, you need to create a <em>builder definition</em> file, which you can point to in <code>package.json</code>.</p>\n\n<p translation-result=\"on\">建立一個名為 <code>builders.json</code> 檔案，它看起來像這樣。</p><p translation-origin=\"off\">Create a file named <code>builders.json</code> that looks like this:</p>\n\n<code-example header=\"builders.json\" format=\"json\" language=\"json\">\n\n{\n  \"builders\": {\n    \"copy\": {\n      \"implementation\": \"./dist/my-builder.js\",\n      \"schema\": \"./src/schema.json\",\n      \"description\": \"Copies a file.\"\n    }\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">在 <code>package.json</code> 檔案中，新增一個 <code>builders</code> 鍵，告訴建築師工具可以在哪裡找到這個建構器定義檔案。</p><p translation-origin=\"off\">In the <code>package.json</code> file, add a <code>builders</code> key that tells the Architect tool where to find our builder definition file.</p>\n\n<code-example header=\"package.json\" format=\"json\" language=\"json\">\n\n{\n  \"name\": \"@example/copy-file\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Builder for copying files\",\n  \"builders\": \"builders.json\",\n  \"dependencies\": {\n    \"@angular-devkit/architect\": \"~0.1200.0\",\n    \"@angular-devkit/core\": \"^12.0.0\"\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">現在，這個建構器的正式名字是 <code>@example/copy-file:copy</code>。第一部分是套件名稱（使用 node 方案進行解析），第二部分是建構器名稱（使用 <code>builders.json</code> 檔案進行解析）。</p><p translation-origin=\"off\">The official name of our builder is now <code>@example/copy-file:copy</code>.\nThe first part of this is the package name (resolved using node resolution), and the second part is the builder name (resolved using the <code>builders.json</code> file).</p>\n\n<p translation-result=\"on\">使用某個 <code>options</code> 是非常簡單的。在上一節，你就曾用過 <code>options.source</code> 和 <code>options.destination</code>。</p><p translation-origin=\"off\">Using one of our <code>options</code> is very straightforward.\nYou did this in the previous section when you accessed <code>options.source</code> and <code>options.destination</code>.</p>\n\n<code-example header=\"src/my-builder.ts (report status)\" path=\"cli-builder/src/my-builder.ts\" region=\"report-status\">\ncontext.reportStatus(`Copying ${options.source} to ${options.destination}.`);\ntry {\n  await fs.copyFile(options.source, options.destination);\n} catch (err) {\n  context.logger.error('Failed to copy file.');\n  return {\n    success: false,\n    error: err.message,\n  };\n}\n\ncontext.reportStatus('Done.');\nreturn { success: true };\n\n</code-example>\n<h3 id=\"target-configuration\" translation-result=\"on\">目標配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-configuration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Target configuration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-configuration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">建構器必須有一個已定義的目標，此目標會把建構器與特定的輸入配置和<a href=\"guide/glossary#project\">專案</a>關聯起來。</p><p translation-origin=\"off\">A builder must have a defined target that associates it with a specific input configuration and <a href=\"guide/glossary#project\">project</a>.</p>\n\n<p translation-result=\"on\">目標是在 <a href=\"guide/workspace-config\">CLI 配置檔案</a> <code>angular.json</code> 中定義的。目標用於指定要使用的建構器、預設的選項配置，以及指定的備用配置。建築師工具使用目標定義來為一次特定的執行解析輸入選項。</p><p translation-origin=\"off\">Targets are defined in the <code>angular.json</code> <a href=\"guide/workspace-config\">CLI configuration file</a>.\nA target specifies the builder to use, its default options configuration, and named alternative configurations.\nThe Architect tool uses the target definition to resolve input options for a given run.</p>\n\n<p translation-result=\"on\"><code>angular.json</code> 檔案中為每個專案都有一節配置，每個專案的 <code>architect</code> 部分都會為 CLI 命令（比如 <code>build</code>、<code>test</code> 和 <code>lint</code>）配置建構器目標。預設情況下，<code>build</code> 命令會執行 <code>@angular-devkit/build-angular:<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a></code> 建構器來執行 <code>build</code> 任務，並傳入 <code>angular.json</code> 中為 <code>build</code> 目標指定的預設選項值。</p><p translation-origin=\"off\">The <code>angular.json</code> file has a section for each project, and the \"architect\" section of each project configures targets for builders used by CLI commands such as 'build', 'test', and 'lint'.\nBy default, for example, the <code>build</code> command runs the builder <code>@angular-devkit/build-angular:<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a></code> to perform the build task, and passes in default option values as specified for the <code>build</code> target in <code>angular.json</code>.</p>\n\n<code-example format=\"json\" header=\"angular.json\" language=\"json\">\n{\n  \"myApp\": {\n    …\n    \"architect\": {\n      \"build\": {\n        \"builder\": \"@angular-devkit/build-angular:browser\",\n        \"options\": {\n          \"outputPath\": \"dist/myApp\",\n          \"index\": \"src/index.html\",\n          …\n        },\n        \"configurations\": {\n          \"production\": {\n            \"fileReplacements\": [\n              {\n                \"replace\": \"src/environments/environment.ts\",\n                \"with\": \"src/environments/environment.prod.ts\"\n              }\n            ],\n            \"optimization\": true,\n            \"outputHashing\": \"all\",\n            …\n          }\n        }\n      },\n      …\n\n</code-example>\n<p translation-result=\"on\">該命令會給建構器傳遞 <code>options</code> 節中指定的一組預設選項。如果你傳入了 <code>--configuration=production</code> 標誌，它就會使用 <code>production</code> 備用配置中指定的值進行覆蓋。可以在命令列中單獨指定其它選項進行覆蓋，還可以為 <code>build</code> 目標新增更多備用配置，以定義其它環境，比如 <code>stage</code> 或 <code>qa</code>。</p><p translation-origin=\"off\">The command passes the builder the set of default options specified in the \"options\" section.\nIf you pass the <code>--configuration=production</code> flag, it uses the override values specified in the <code>production</code> alternative configuration.\nSpecify further option overrides individually on the command line.\nYou might also add more alternative configurations to the <code>build</code> target, to define other environments such as <code>stage</code> or <code>qa</code>.</p>\n\n<h4 id=\"target-strings\" translation-result=\"on\">目標字串<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-strings\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Target strings<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#target-strings\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">通用的 <code>ng run</code> CLI 命令將以下格式的目標字串作為其第一個引數。</p><p translation-origin=\"off\">The generic <code>ng run</code> CLI command takes as its first argument a target string of the following form.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nproject:target[:configuration]\n\n</code-example>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">專案（project）</nt-wrapper><nt-wrapper translation-origin=\"off\">project</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">與此目標關聯的 Angular CLI 專案的名稱。</nt-wrapper><nt-wrapper translation-origin=\"off\">The name of the Angular CLI project that the target is associated with.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">目標</nt-wrapper><nt-wrapper translation-origin=\"off\">target</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><code>angular.json</code> 檔案 <code>architect</code> 下的指定建構器配置。</nt-wrapper><nt-wrapper translation-origin=\"off\">A named builder configuration from the <code>architect</code> section of the <code>angular.json</code> file.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">配置（configuration）</nt-wrapper><nt-wrapper translation-origin=\"off\">configuration</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">（可選）用於覆蓋指定目標的具體配置名稱，如 <code>angular.json</code> 檔案中的定義。</nt-wrapper><nt-wrapper translation-origin=\"off\">(optional) The name of a specific configuration override for the given target, as defined in the <code>angular.json</code> file.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">如果你的建構器呼叫另一個建構器，它可能需要讀取一個傳入的目標字串。可以使用 <code>@angular-devkit/architect</code> 中的工具函式 <code>targetFromTargetString()</code> 把這個字串解析成一個物件。</p><p translation-origin=\"off\">If your builder calls another builder, it might need to read a passed target string.\nParse this string into an object by using the <code>targetFromTargetString()</code> utility function from <code>@angular-devkit/architect</code>.</p>\n\n<h2 id=\"schedule-and-run\" translation-result=\"on\">排程並執行<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#schedule-and-run\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Schedule and run<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#schedule-and-run\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">建築師會非同步執行建構器。要呼叫某個建構器，就要在所有配置解析完成之後安排一個要執行的任務。</p><p translation-origin=\"off\">Architect runs builders asynchronously.\nTo invoke a builder, you schedule a task to be run when all configuration resolution is complete.</p>\n\n<p translation-result=\"on\">在排程器返回 <code>BuilderRun</code> 控制項物件之前，不會執行該建構器函式。CLI 通常會透過呼叫 <code>context.scheduleTarget()</code> 函式來排程任務，然後使用 <code>angular.json</code> 檔案中的目標定義來解析輸入選項。</p><p translation-origin=\"off\">The builder function is not executed until the scheduler returns a <code>BuilderRun</code> control object.\nThe CLI typically schedules tasks by calling the <code>context.scheduleTarget()</code> function, and then resolves input options using the target definition in the <code>angular.json</code> file.</p>\n\n<p translation-result=\"on\">建築師會接受預設的選項物件來解析指定目標的輸入選項，然後覆蓋所用配置中的值（如果有的話），然後再從傳給 <code>context.scheduleTarget()</code> 的覆蓋物件中覆蓋這些值。對於 Angular CLI，覆蓋物件是從命令列引數中建構的。</p><p translation-origin=\"off\">Architect resolves input options for a given target by taking the default options object, then overwriting values from the configuration used (if any), then further overwriting values from the overrides object passed to <code>context.scheduleTarget()</code>.\nFor the Angular CLI, the overrides object is built from command line arguments.</p>\n\n<p translation-result=\"on\">建築師會根據建構器的模式對產生的選項值進行驗證。如果輸入有效，建築師會建立上下文並執行該建構器。</p><p translation-origin=\"off\">Architect validates the resulting options values against the schema of the builder.\nIf inputs are valid, Architect creates the context and executes the builder.</p>\n\n<p translation-result=\"on\">欲知詳情，參閱<a href=\"guide/workspace-config\">工作區配置</a>。</p><p translation-origin=\"off\">For more information see <a href=\"guide/workspace-config\">Workspace Configuration</a>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">你還可以透過呼叫 <code>context.scheduleBuilder()</code> 從另一個建構器或測試中呼叫某個建構器。你可以直接把 <code>options</code> 物件傳給該方法，並且這些選項值會根據這個建構器的模式進行驗證，而無需進一步調整。</p><p translation-origin=\"off\">You can also invoke a builder directly from another builder or test by calling <code>context.scheduleBuilder()</code>.\nYou pass an <code>options</code> object directly to the method, and those option values are validated against the schema of the builder without further adjustment.</p>\n\n<p translation-result=\"on\">只有 <code>context.scheduleTarget()</code> 方法來解析這些配置和並透過 <code>angular.json</code> 檔案進行覆蓋。</p><p translation-origin=\"off\">Only the  <code>context.scheduleTarget()</code> method resolves the configuration and overrides through the <code>angular.json</code> file.</p>\n\n</div>\n<h3 id=\"default-architect-configuration\" translation-result=\"on\">預設建築師配置<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#default-architect-configuration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Default architect configuration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#default-architect-configuration\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">讓我們建立一個簡單的 <code>angular.json</code> 檔案，它會把目標配置放到上下文中。</p><p translation-origin=\"off\">Let's create a simple <code>angular.json</code> file that puts target configurations into context.</p>\n\n<p translation-result=\"on\">你可以把這個建構器釋出到 npm（參閱<a href=\"guide/creating-libraries#publishing-your-library\">釋出你的函式庫</a>），並使用如下命令來安裝它：</p><p translation-origin=\"off\">You can publish the builder to npm (see <a href=\"guide/creating-libraries#publishing-your-library\">Publishing your Library</a>), and install it using the following command:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @example/copy-file\n\n</code-example>\n<p translation-result=\"on\">如果用 <code>ng new builder-test</code> 建立一個新專案，那麼產生的 <code>angular.json</code> 檔案就是這樣的，它只有預設的建構器引數。</p><p translation-origin=\"off\">If you create a new project with <code>ng new builder-test</code>, the generated <code>angular.json</code> file looks something like this, with only default builder configurations.</p>\n\n<code-example format=\"json\" header=\"angular.json\" language=\"json\">\n\n{\n  // …\n  \"projects\": {\n    // …\n    \"builder-test\": {\n      // …\n      \"architect\": {\n        // …\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            // … more options…\n            \"outputPath\": \"dist/builder-test\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": \"src/polyfills.ts\",\n            \"tsConfig\": \"src/tsconfig.app.json\"\n          },\n          \"configurations\": {\n            \"production\": {\n              // … more options…\n              \"optimization\": true,\n              \"aot\": true,\n              \"buildOptimizer\": true\n            }\n          }\n        }\n      }\n    }\n  }\n  // …\n}\n\n</code-example>\n<h3 id=\"adding-a-target\" translation-result=\"on\">新增一個目標<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#adding-a-target\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Adding a target<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#adding-a-target\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">新增一個新的目標，來執行我們的建構器以複製檔案。該目標告訴建構器，複製 <code>package.json</code> 檔案。</p><p translation-origin=\"off\">Add a new target that will run our builder to copy a file.\nThis target tells the builder to copy the <code>package.json</code> file.</p>\n\n<p translation-result=\"on\">你需要更新 <code>angular.json</code> 檔案，把這個建構器的目標新增到新專案的 <code>architect</code> 部分。</p><p translation-origin=\"off\">You need to update the <code>angular.json</code> file to add a target for this builder to the \"architect\" section of our new project.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">我們會為專案的 <code>architect</code> 物件新增一個新的目標小節</p><p translation-origin=\"off\">We'll add a new target section to the \"architect\" object for our project</p>\n\n</li>\n<li>\n<p translation-result=\"on\">名為 <code>copy-package</code> 的目標使用了我們的建構器，它釋出到了 <code>@example/copy-file</code>。（參閱<a href=\"guide/creating-libraries#publishing-your-library\">釋出你的函式庫</a>）</p><p translation-origin=\"off\">The target named \"copy-package\" uses our builder, which you published to <code>@example/copy-file</code>.\n(See <a href=\"guide/creating-libraries#publishing-your-library\">Publishing your Library</a>.)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">這個配置物件為我們定義的兩個輸入提供了預設值：<code>source</code>（你要複製的現有檔案）和 <code>destination</code>（你要複製到的路徑）</p><p translation-origin=\"off\">The options object provides default values for the two inputs that you defined; <code>source</code>, which is the existing file you are copying, and <code>destination</code>, the path you want to copy to</p>\n\n</li>\n<li>\n<p translation-result=\"on\">這些配置鍵都是可選的，但我們先不展開</p><p translation-origin=\"off\">The <code>configurations</code> key is optional, we'll leave it out for now</p>\n\n</li>\n</ul>\n<code-example format=\"json\" header=\"angular.json\" language=\"json\">\n\n{\n  \"projects\": {\n    \"builder-test\": {\n      \"architect\": {\n        \"copy-package\": {\n          \"builder\": \"@example/copy-file:copy\",\n          \"options\": {\n            \"source\": \"package.json\",\n            \"destination\": \"package-copy.json\"\n          }\n        },\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            \"outputPath\": \"dist/builder-test\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": \"src/polyfills.ts\",\n            \"tsConfig\": \"src/tsconfig.app.json\"\n          },\n          \"configurations\": {\n            \"production\": {\n              \"fileReplacements\": [\n                {\n                  \"replace\": \"src/environments/environment.ts\",\n                  \"with\": \"src/environments/environment.prod.ts\"\n                }\n              ],\n              \"optimization\": true,\n              \"aot\": true,\n              \"buildOptimizer\": true\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n</code-example>\n<h3 id=\"running-the-builder\" translation-result=\"on\">執行這個建構器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#running-the-builder\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Running the builder<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#running-the-builder\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要想使用這個新目標的預設配置執行我們的建構器，請使用以下 CLI 命令。</p><p translation-origin=\"off\">To run our builder with the new target's default configuration, use the following CLI command.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng run builder-test:copy-package\n\n</code-example>\n<p translation-result=\"on\">這將把 <code>package.json</code> 檔案複製成 <code>package-copy.json</code>。</p><p translation-origin=\"off\">This copies the <code>package.json</code> file to <code>package-copy.json</code>.</p>\n\n<p translation-result=\"on\">你可以使用命令列引數來覆蓋已配置的預設值。比如，要改用其它 <code>destination</code> 值執行，請使用以下 CLI 命令。</p><p translation-origin=\"off\">Use command-line arguments to override the configured defaults.\nFor example, to run with a different <code>destination</code> value, use the following CLI command.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng run builder-test:copy-package --destination=package-other.json\n\n</code-example>\n<p translation-result=\"on\">這將把此檔案複製為 <code>package-other.json</code> 而不再是 <code>package-copy.json</code>。因為我們沒有覆蓋 <em>source</em> 選項，所以它仍然會從 <code>package.json</code> 檔案複製（提供給該目標的預設值）。</p><p translation-origin=\"off\">This copies the file to <code>package-other.json</code> instead of <code>package-copy.json</code>.\nBecause you did not override the <em>source</em> option, it will copy from the <code>package.json</code> file (the default value provided for the target).</p>\n\n<h2 id=\"testing-a-builder\" translation-result=\"on\">測試一個建構器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#testing-a-builder\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Testing a builder<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#testing-a-builder\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">對建構器進行整合測試，以便你可以使用建築師的排程器來建立一個上下文，就像這個<a href=\"https://github.com/mgechev/cli-builders-demo\">例子</a>中一樣。</p><p translation-origin=\"off\">Use integration testing for your builder, so that you can use the Architect scheduler to create a context, as in this <a href=\"https://github.com/mgechev/cli-builders-demo\">example</a>.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">在建構器的原始碼目錄下，你建立了一個新的測試檔案 <code>my-builder.spec.ts</code>。該程式碼建立了 <code>JsonSchemaRegistry</code>（用於模式驗證）、<code>TestingArchitectHost</code>（對 <code>ArchitectHost</code> 的記憶體實現）和 <code>Architect</code> 的新例項。</p><p translation-origin=\"off\">In the builder source directory, you have created a new test file <code>my-builder.spec.ts</code>.\nThe code creates new instances of <code>JsonSchemaRegistry</code> (for schema validation), <code>TestingArchitectHost</code> (an in-memory implementation of <code>ArchitectHost</code>), and <code>Architect</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">我們緊挨著這個建構器的 <code>package.json</code> 檔案添加了一個 <code>builders.json</code> 檔案，並修改了 <code>package.json</code> 檔案以指向它。</p><p translation-origin=\"off\">We've added a <code>builders.json</code> file next to the builder's <code>package.json</code> file, and modified the package file to point to it.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">下面是執行此複製檔案建構器的測試範例。該測試使用該建構器來複制 <code>package.json</code> 檔案，並驗證複製後的檔案內容與原始檔相同。</p><p translation-origin=\"off\">Here's an example of a test that runs the copy file builder.\nThe test uses the builder to copy the <code>package.json</code> file and validates that the copied file's contents are the same as the source.</p>\n\n<code-example header=\"src/my-builder.spec.ts\" path=\"cli-builder/src/my-builder.spec.ts\">\nimport { Architect } from '@angular-devkit/architect';\nimport { TestingArchitectHost } from '@angular-devkit/architect/testing';\nimport { schema } from '@angular-devkit/core';\nimport { promises as fs } from 'fs';\n\ndescribe('Copy File Builder', () =&gt; {\n  let architect: Architect;\n  let architectHost: TestingArchitectHost;\n\n  beforeEach(async () =&gt; {\n    const registry = new schema.CoreSchemaRegistry();\n    registry.addPostTransform(schema.transforms.addUndefinedDefaults);\n\n    // TestingArchitectHost() takes workspace and current directories.\n    // Since we don't use those, both are the same in this case.\n    architectHost = new TestingArchitectHost(__dirname, __dirname);\n    architect = new Architect(architectHost, registry);\n\n    // This will either take a Node package name, or a path to the directory\n    // for the package.json file.\n    await architectHost.addBuilderFromPackage('..');\n  });\n\n  it('can copy files', async () =&gt; {\n    // A \"run\" can have <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> outputs, and contains progress information.\n    const run = await architect.scheduleBuilder('@example/copy-file:copy', {\n      source: 'package.json',\n      destination: 'package-copy.json',\n    });\n\n    // The \"result\" member (of type BuilderOutput) is the next output.\n    const output = await run.result;\n\n    // Stop the builder from running. This stops Architect from keeping\n    // the builder-associated states in memory, since builders keep waiting\n    // to be scheduled.\n    await run.stop();\n\n    // Expect that the copied file is the same as its source.\n    const sourceContent = await fs.readFile('package.json', 'utf8');\n    const destinationContent = await fs.readFile('package-copy.json', 'utf8');\n    expect(destinationContent).toBe(sourceContent);\n  });\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">在你的儲存庫中執行這個測試時，需要使用 <a href=\"https://github.com/TypeStrong/ts-node\"><code>ts-node</code></a> 套件。你可以把 <code>index.spec.ts</code> 重新命名為 <code>index.spec.js</code> 來回避它。</p><p translation-origin=\"off\">When running this test in your repo, you need the <a href=\"https://github.com/TypeStrong/ts-node\"><code>ts-node</code></a> package.\nYou can avoid this by renaming <code>my-builder.spec.ts</code> to <code>my-builder.spec.js</code>.</p>\n\n</div>\n<h3 id=\"watch-mode\" translation-result=\"on\">監視（watch）模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#watch-mode\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Watch mode<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#watch-mode\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">建築師希望建構器執行一次（預設情況下）並返回。這種行為與那些需要監視檔案更改的建構器（比如 Webpack）並不完全相容。建築師可以支援監視模式，但要注意一些問題。</p><p translation-origin=\"off\">Architect expects builders to run once (by default) and return.\nThis behavior is not entirely compatible with a builder that watches for changes (like Webpack, for example).\nArchitect can support watch mode, but there are some things to look out for.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">要在監視模式下使用，建構器處理函式應返回一個 Observable。建築師會訂閱這個 Observable，直到這個 Observable 完成（complete）為止。此外，如果使用相同的引數再次排程這個建構器，建築師還能複用這個 Observable。</p><p translation-origin=\"off\">To be used with watch mode, a builder handler function should return an Observable.\nArchitect subscribes to the Observable until it completes and might reuse it if the builder is scheduled again with the same arguments.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">這個建構器應該總是在每次執行後發出一個 <code>BuilderOutput</code> 物件。一旦它被執行，就會進入一個由外部事件觸發的監視模式。如果一個事件導致它重啟，那麼此建構器應該執行 <code>context.reportRunning()</code> 函式來告訴建築師再次執行它。如果排程器還計劃了另一次執行，就會阻止建築師停掉這個建構器。</p><p translation-origin=\"off\">The builder should always emit a <code>BuilderOutput</code> object after each execution.\nOnce it's been executed, it can enter a watch mode, to be triggered by an external event.\nIf an event triggers it to restart, the builder should execute the <code>context.reportRunning()</code> function to tell Architect that it is running again.\nThis prevents Architect from stopping the builder if another run is scheduled.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">當你的建構器透過呼叫 <code>BuilderRun.stop()</code> 來退出監視模式時，建築師會從建構器的 Observable 中取消訂閱，並呼叫建構器的退出邏輯進行清理。（這種行為也允許停止和清理執行時間過長的建構。）</p><p translation-origin=\"off\">When your builder calls <code>BuilderRun.stop()</code> to exit watch mode, Architect unsubscribes from the builder's Observable and calls the builder's teardown logic to clean up.\n(This behavior also allows for long-running builds to be stopped and cleaned up.)</p>\n\n<p translation-result=\"on\">一般來說，如果你的建構器正在監視一個外部事件，你應該把你的執行分成三個階段。</p><p translation-origin=\"off\">In general, if your builder is watching an external event, you should separate your run into three phases.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">階段</nt-wrapper><nt-wrapper translation-origin=\"off\">Phases</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">執行</nt-wrapper><nt-wrapper translation-origin=\"off\">Running</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">比如 webpack 編譯。這會在 webpack 完成並且你的建構器發出 <code>BuilderOutput</code> 物件時結束。</nt-wrapper><nt-wrapper translation-origin=\"off\">For example, webpack compiles. This ends when webpack finishes and your builder emits a <code>BuilderOutput</code> object.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">監視</nt-wrapper><nt-wrapper translation-origin=\"off\">Watching</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在兩次執行之間監視外部事件流。比如，webpack 會監視檔案系統是否發生了任何變化。這會在 webpack 重啟建構時結束，並呼叫 <code>context.reportRunning()</code>。這樣就會再回到第 1 步。</nt-wrapper><nt-wrapper translation-origin=\"off\">Between two runs, watch an external event stream. For example, webpack watches the file system for any changes. This ends when webpack restarts building, and <code>context.reportRunning()</code> is called. This goes back to step 1.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">完成</nt-wrapper><nt-wrapper translation-origin=\"off\">Completion</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">任務完全完成（比如，webpack 應執行多次），或者建構器停止執行（使用 <code>BuilderRun.stop()</code>）。你的退出邏輯被呼叫了，建築師也從你的建構器的 Observable 中取消了訂閱。</nt-wrapper><nt-wrapper translation-origin=\"off\">Either the task is fully completed (for example, webpack was supposed to run a number of times), or the builder run was stopped (using <code>BuilderRun.stop()</code>). Your teardown logic is executed, and Architect unsubscribes from your builder's Observable.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<h2 id=\"summary\" translation-result=\"on\">總結<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#summary\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Summary<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cli-builder#summary\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">CLI 建構器 API 提供了一種透過建構器執行自訂邏輯，以改變 Angular CLI 行為的新方式。</p><p translation-origin=\"off\">The CLI Builder API provides a new way of changing the behavior of the Angular CLI by using builders to execute custom logic.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">建構器既可以是同步的，也可以是非同步的，它可以只執行一次也可以監視外部事件，還可以排程其它建構器或目標</p><p translation-origin=\"off\">Builders can be synchronous or asynchronous, execute once or watch for external events, and can schedule other builders or targets</p>\n\n</li>\n<li>\n<p translation-result=\"on\">建構器在 <code>angular.json</code> 配置檔案中指定了選項的預設值，它可以被目標的備用配置覆蓋，還可以進一步被命令列標誌所覆蓋</p><p translation-origin=\"off\">Builders have option defaults specified in the <code>angular.json</code> configuration file, which can be overwritten by an alternate configuration for the target, and further overwritten by command line flags</p>\n\n</li>\n<li>\n<p translation-result=\"on\">建議你使用整合測試來測試建築師的建構器。還可以用單元測試來驗證這個建構器的執行邏輯。</p><p translation-origin=\"off\">We recommend that you use integration tests to test Architect builders.\nUse unit tests to validate the logic that the builder executes.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果你的建構器返回一個 Observable，你應該在那個 Observable 的退出邏輯中進行清理</p><p translation-origin=\"off\">If your builder returns an Observable, it should clean up in the teardown logic of that Observable</p>\n\n</li>\n</ul>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - cli/deploy\n - cli/lint\n - guide/architecture-next-steps\n - guide/deployment\n - guide/workspace-config\n-->\n<!-- links from this doc:\n - api/animations/browser\n - api/forms/SelectMultipleControlValueAccessor\n - cli/run\n - guide/cli-builder#adding-a-target\n - guide/cli-builder#angular-cli-builders\n - guide/cli-builder#angular-cli-建構器builder\n - guide/cli-builder#builder-input\n - guide/cli-builder#builder-project-structure\n - guide/cli-builder#cli-builders\n - guide/cli-builder#cli-建構器\n - guide/cli-builder#creating-a-builder\n - guide/cli-builder#default-architect-configuration\n - guide/cli-builder#handling-output\n - guide/cli-builder#input-validation\n - guide/cli-builder#progress-and-status-reporting\n - guide/cli-builder#running-the-builder\n - guide/cli-builder#schedule-and-run\n - guide/cli-builder#summary\n - guide/cli-builder#target-configuration\n - guide/cli-builder#target-strings\n - guide/cli-builder#testing-a-builder\n - guide/cli-builder#watch-mode\n - guide/cli-builder#建立建構器\n - guide/cli-builder#處理輸出\n - guide/cli-builder#對輸入的驗證\n - guide/cli-builder#總結\n - guide/cli-builder#建構器的輸入\n - guide/cli-builder#建構器的專案結構\n - guide/cli-builder#測試一個建構器\n - guide/cli-builder#新增一個目標\n - guide/cli-builder#監視watch模式\n - guide/cli-builder#目標字串\n - guide/cli-builder#目標配置\n - guide/cli-builder#排程並執行\n - guide/cli-builder#執行這個建構器\n - guide/cli-builder#進度和狀態報告\n - guide/cli-builder#預設建築師配置\n - guide/creating-libraries#publishing-your-library\n - guide/glossary#builder\n - guide/glossary#project\n - guide/glossary#schematic\n - guide/glossary#target\n - guide/workspace-config\n - http://json-schema.org\n - https://docs.npmjs.com/files/package.json\n - https://docs.npmjs.com/files/package.json%E3%80%82\n - https://electronjs.org\n - https://electronjs.org/\n - https://github.com/TypeStrong/ts-node\n - https://github.com/angular/angular-cli/blob/ba21c855c0c8b778005df01d4851b5a2176edc6f/packages/angular_devkit/build_angular/src/tslint/index.ts#L107\n - https://github.com/mgechev/cli-builders-demo\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/cli-builder.md?message=docs%3A%20請簡述你的修改...\n - https://nodejs.org/api/fs.html#fs_fspromises_copyfile_src_dest_mode\n - https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\n-->"}