{"id":"guide/security","title":"Security","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/security.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"security\" translation-result=\"on\">安全<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#security\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Security<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#security\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本主題會講述 Angular 為防範 Web 應用常見的安全漏洞和攻擊（比如跨站指令碼攻擊）內建的保護措施，但不會涉及應用級安全，比如使用者認證（<em>這個使用者是誰？</em>）和授權（<em>這個使用者能做什麼？</em>）。</p><p translation-origin=\"off\">This topic describes Angular's built-in protections against common web-application vulnerabilities and attacks such as cross-site scripting attacks.\nIt doesn't cover application-level security, such as authentication and authorization.</p>\n\n<p translation-result=\"on\">要了解更多攻防資訊，參閱<a href=\"https://www.owasp.org/index.php/Category:OWASP_Guide_Project\">開放式 Web 應用程式安全專案（OWASP）</a>。</p><p translation-origin=\"off\">For more information about the attacks and mitigations described below, see the <a href=\"https://www.owasp.org/index.php/Category:OWASP_Guide_Project\">Open Web Application Security Project (OWASP) Guide</a>.</p>\n\n<p translation-result=\"on\">你可以執行<live-example></live-example>，在 Stackblitz 中試用並下載本頁的程式碼。</p><p translation-origin=\"off\">You can run the <live-example></live-example> in Stackblitz and download the code from there.</p>\n\n<p><a id=\"report-issues\"></a></p>\n<div class=\"callout is-important\">\n<header ng-should-translate=\"\" translation-result=\"on\">舉報漏洞</header><header ng-should-translate=\"\" translation-origin=\"off\">Reporting vulnerabilities</header>\n\n<p translation-result=\"on\">Angular 是 Google 的<a href=\"https://bughunters.google.com/about/rules/6521337925468160/google-open-source-software-vulnerability-reward-program-rules\">開源軟體漏洞獎勵專案</a>的一部分，對於 Angular 中的漏洞，請把報告提交到<a href=\"https://bughunters.google.com/report\">這裡</a>。</p><p translation-origin=\"off\">Angular is part of Google <a href=\"https://bughunters.google.com/about/rules/6521337925468160/google-open-source-software-vulnerability-reward-program-rules\">Open Source Software Vulnerability Reward Program</a>, for vulnerabilities in Angular please submit your report <a href=\"https://bughunters.google.com/report\">here</a>.</p>\n\n<p translation-result=\"on\">要了解關於“谷歌如何處理安全問題”的更多資訊，參閱<a href=\"https://www.google.com/about/appsecurity/\">谷歌的安全哲學</a>。</p><p translation-origin=\"off\">For more information about how Google handles security issues, see <a href=\"https://www.google.com/about/appsecurity\">Google's security philosophy</a>.</p>\n\n</div>\n<p><a id=\"best-practices\"></a></p>\n<div class=\"callout is-helpful\">\n<header ng-should-translate=\"\" translation-result=\"on\">最佳實踐</header><header ng-should-translate=\"\" translation-origin=\"off\">Best practices</header>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">實踐</nt-wrapper><nt-wrapper translation-origin=\"off\">Practices</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">及時把 Angular 包更新到最新版本</nt-wrapper><nt-wrapper translation-origin=\"off\">Keep current with the latest Angular library releases</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">我們會頻繁的更新 Angular 庫，這些更新可能會修復之前版本中發現的安全漏洞。檢視 Angular 的<a href=\"https://github.com/angular/angular/blob/main/CHANGELOG.md\">更新記錄</a>，瞭解與安全有關的更新。</nt-wrapper><nt-wrapper translation-origin=\"off\">The Angular libraries get regular updates, and these updates might fix security defects discovered in previous versions. Check the Angular <a href=\"https://github.com/angular/angular/blob/main/CHANGELOG.md\">change log</a> for security-related updates.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">不要修改你的 Angular 副本</nt-wrapper><nt-wrapper translation-origin=\"off\">Don't alter your copy of Angular</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">私有的、客製版的 Angular 往往跟不上最新版本，這可能導致你忽略重要的安全修復與增強。反之，應該在社群共享你對 Angular 所做的改進並建立 Pull Request。.</nt-wrapper><nt-wrapper translation-origin=\"off\">Private, customized versions of Angular tend to fall behind the current version and might not include important security fixes and enhancements. Instead, share your Angular improvements with the community and make a pull request.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">避免使用本文件中帶“安全風險”標記的 Angular API</nt-wrapper><nt-wrapper translation-origin=\"off\">Avoid Angular APIs marked in the documentation as \"<em>Security Risk</em>\"</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">要了解更多資訊，請參閱本章的<a href=\"guide/security#bypass-security-apis\">信任那些安全的值</a>部分。</nt-wrapper><nt-wrapper translation-origin=\"off\">For more information, see the <a href=\"guide/security#bypass-security-apis\">Trusting safe values</a> section of this page.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n</div>\n<h2 id=\"preventing-cross-site-scripting-xss\" translation-result=\"on\">防範跨站指令碼（XSS）攻擊<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#preventing-cross-site-scripting-xss\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Preventing cross-site scripting (XSS)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#preventing-cross-site-scripting-xss\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">跨站指令碼（XSS）</a>允許攻擊者將惡意程式碼注入到頁面中。這些程式碼可以偷取使用者及其登入資料資料，還可以冒充使用者執行操作。它是 Web 上最常見的攻擊方式之一。</p><p translation-origin=\"off\"><a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">Cross-site scripting (XSS)</a> enables attackers to inject malicious code into web pages.\nSuch code can then, for example, steal user and login data, or perform actions that impersonate the user.\nThis is one of the most common attacks on the web.</p>\n\n<p translation-result=\"on\">為了防範 XSS 攻擊，你必須阻止惡意程式碼進入 DOM。比如，如果某個攻擊者能騙你把 <code>&lt;script&gt;</code> 標籤插入到 DOM，就可以在你的網站上執行任何程式碼。除了 <code>&lt;script&gt;</code>，攻擊者還可以使用很多 DOM 元素和屬性來執行程式碼，比如 <code>&lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> alt=\"\" onerror=\"...\"&gt;</code>、<code>&lt;a href=\"javascript:...\"&gt;</code>。如果攻擊者所控制的資料混進了 DOM，就會導致安全漏洞。</p><p translation-origin=\"off\">To block XSS attacks, you must prevent malicious code from entering the Document Object Model (DOM).\nFor example, if attackers can trick you into inserting a <code>&lt;script&gt;</code> tag in the DOM, they can run arbitrary code on your website.\nThe attack isn't limited to <code>&lt;script&gt;</code> tags —many elements and properties in the DOM allow code execution, for example, <code>&lt;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> alt=\"\" onerror=\"...\"&gt;</code> and <code>&lt;a href=\"javascript:...\"&gt;</code>.\nIf attacker-controlled data enters the DOM, expect security vulnerabilities.</p>\n\n<h3 id=\"angulars-cross-site-scripting-security-model\" translation-result=\"on\">Angular 的“跨站指令碼安全模型”<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#angulars-cross-site-scripting-security-model\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Angular's cross-site scripting security model<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#angulars-cross-site-scripting-security-model\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">為了系統性的防範 XSS 問題，Angular 預設把所有值都當做不可信任的。\n當值從範本中以屬性（Property）、DOM 元素屬性（Attribte）、CSS 類繫結或插值等途徑插入到 DOM 中的時候，\nAngular 將對這些值進行無害化處理（Sanitize），對不可信的值進行編碼。如果某個值已經在 Angular 之外進行過無害化處理，可以確信是安全的，可以<a href=\"guide/security#bypass-security-apis\">把這個值標記為安全的</a>來把這一點通知 Angular。</p><p translation-origin=\"off\">To systematically block XSS bugs, Angular treats all values as untrusted by default.\nWhen a value is inserted into the DOM from a template binding, or interpolation, Angular sanitizes and escapes untrusted values.\nIf a value was already sanitized outside of Angular and is considered safe, communicate this to Angular by marking the <a href=\"guide/security#bypass-security-apis\">value as trusted</a>.</p>\n\n<p translation-result=\"on\">與用於渲染的值不同，預設情況下，Angular 範本被認為是受信任的，應被視為可執行程式碼。切勿透過串聯使用者輸入和範本語法來產生範本。這樣做會使攻擊者能夠<a href=\"https://en.wikipedia.org/wiki/Code_injection\">將任意程式碼注入</a>你的應用程式。為避免這些漏洞，請始終在生產部署中<a href=\"guide/security#offline-template-compiler\">使用預設的 AOT 範本編譯器。</a>。</p><p translation-origin=\"off\">Unlike values to be used for rendering, Angular templates are considered trusted by default, and should be treated as executable code.\nNever create templates by concatenating user input and template syntax.\nDoing this would enable attackers to <a href=\"https://en.wikipedia.org/wiki/Code_injection\">inject arbitrary code</a> into your application.\nTo prevent these vulnerabilities, always use the default <a href=\"guide/security#offline-template-compiler\">Ahead-Of-Time (AOT) template compiler</a> in production deployments.</p>\n\n<p translation-result=\"on\">藉助內容安全策略和可信型別，可以提供額外的保護層。這些 Web 平台特性會在 DOM 級別執行，這是用來防範 XSS 問題的最有效位置，因為即使使用其它低階 API 也無法繞過它們。出於這個原因，我們強烈建議開發人員透過為其應用程式配置<a href=\"guide/security#content-security-policy\">內容安全策略</a>並啟用<a href=\"guide/security#trusted-types\">強制可信型別</a>來利用這些特性。</p><p translation-origin=\"off\">An extra layer of protection can be provided through the use of Content security policy and Trusted Types.\nThese web platform features operate at the DOM level which is the most effective place to prevent XSS issues. Here they can't be bypassed using other, lower-level APIs.\nFor this reason, it is strongly encouraged to take advantage of these features. To do this, configure the <a href=\"guide/security#content-security-policy\">content security policy</a> for the application and enable <a href=\"guide/security#trusted-types\">trusted types enforcement</a>.</p>\n\n<h3 id=\"sanitization-and-security-contexts\" translation-result=\"on\">無害化處理與安全環境<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#sanitization-and-security-contexts\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Sanitization and security contexts<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#sanitization-and-security-contexts\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">無害化處理會審查不可信的值，並將它們轉換成可以安全插入到 DOM 的形式。多數情況下，這些值並不會在處理過程中發生任何變化。無害化處理的方式取決於所在的環境：一個在 CSS 裡面無害的值，可能在 URL 裡很危險。</p><p translation-origin=\"off\"><em>Sanitization</em> is the inspection of an untrusted value, turning it into a value that's safe to insert into the DOM.\nIn many cases, sanitization doesn't change a value at all.\nSanitization depends on context:\nA value that's harmless in CSS is potentially dangerous in a URL.</p>\n\n<p translation-result=\"on\">Angular 定義了四個安全環境：</p><p translation-origin=\"off\">Angular defines the following security contexts:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">安全上下文</nt-wrapper><nt-wrapper translation-origin=\"off\">Security contexts</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\">HTML</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">值需要被解釋為 HTML 時使用，比如當繫結到 <code>innerHTML</code> 時。</nt-wrapper><nt-wrapper translation-origin=\"off\">Used when interpreting a value as HTML, for example, when binding to <code>innerHtml</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">樣式</nt-wrapper><nt-wrapper translation-origin=\"off\">Style</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">值需要作為 CSS 繫結到 <code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code> 屬性時使用。</nt-wrapper><nt-wrapper translation-origin=\"off\">Used when binding CSS into the <code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code> property.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\">URL</td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">值需要被用作 URL 屬性時使用，比如 <code>&lt;a href&gt;</code>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Used for URL properties, such as <code>&lt;a href&gt;</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">資源 URL</nt-wrapper><nt-wrapper translation-origin=\"off\">Resource URL</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">值需要作為程式碼進行載入並執行，比如 <code>&lt;script src&gt;</code> 中的 URL。</nt-wrapper><nt-wrapper translation-origin=\"off\">A URL that is loaded and executed as code, for example, in <code>&lt;script src&gt;</code>.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">Angular 會對前三項中種不可信的值進行無害化處理，但不能對第四種資源 URL 進行無害化，因為它們可能包含任何程式碼。在開發模式下，如果在進行無害化處理時需要被迫改變一個值，Angular 就會在控制檯上輸出一個警告。</p><p translation-origin=\"off\">Angular sanitizes untrusted values for HTML, styles, and URLs. Sanitizing resource URLs isn't possible because they contain arbitrary code.\nIn development mode, Angular prints a console warning when it has to change a value during sanitization.</p>\n\n<h3 id=\"sanitization-example\" translation-result=\"on\">無害化範例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#sanitization-example\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Sanitization example<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#sanitization-example\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">下面的例子綁定了 <code>htmlSnippet</code> 的值。一次把它放進插值裡，另一次把它繫結到元素的 <code>innerHTML</code> 屬性上。</p><p translation-origin=\"off\">The following template binds the value of <code>htmlSnippet</code>. Once by interpolating it into an element's content, and once by binding it to the <code>innerHTML</code> property of an element:</p>\n\n<code-example header=\"src/app/inner-html-binding.component.html\" path=\"security/src/app/inner-html-binding.component.html\">\n&lt;h3&gt;Binding innerHTML&lt;/h3&gt;\n&lt;p&gt;Bound value:&lt;/p&gt;\n&lt;p class=\"e2e-inner-html-interpolated\"&gt;{{htmlSnippet}}&lt;/p&gt;\n&lt;p&gt;Result of binding to innerHTML:&lt;/p&gt;\n&lt;p class=\"e2e-inner-html-bound\" [innerHTML]=\"htmlSnippet\"&gt;&lt;/p&gt;\n\n\n</code-example>\n<p translation-result=\"on\">插值的內容總會被編碼 - 其中的 HTML 不會被解釋，所以瀏覽器會在元素的文字內容中顯示尖括號。</p><p translation-origin=\"off\">Interpolated content is always escaped —the HTML isn't interpreted and the browser displays angle brackets in the element's text content.</p>\n\n<p translation-result=\"on\">如果希望這段 HTML 被正常解釋，就必須繫結到一個 HTML 屬性上，比如 <code>innerHTML</code>。但要小心如果把一個可能被攻擊者控制的值繫結到 <code>innerHTML</code> 就會導致 XSS 漏洞。比如，某些人可以用這種方式來執行惡意程式碼：</p><p translation-origin=\"off\">For the HTML to be interpreted, bind it to an HTML property such as <code>innerHTML</code>.\nBe aware that binding a value that an attacker might control into <code>innerHTML</code> normally causes an XSS vulnerability.\nFor example, one could run JavaScript in a following way:</p>\n\n<code-example header=\"src/app/inner-html-binding.component.ts (class)\" path=\"security/src/app/inner-html-binding.component.ts\" region=\"class\">\nexport class InnerHtmlBindingComponent {\n  // For example, a user/attacker-controlled value from a URL.\n  htmlSnippet = 'Template &lt;script&gt;alert(\"0wned\")&lt;/script&gt; &lt;b&gt;Syntax&lt;/b&gt;';\n}\n\n\n</code-example>\n<p translation-result=\"on\">Angular 認為這些值是不安全的，並自動進行無害化處理。它會移除 <code>script</code> 元素，但保留安全的內容，比如該片段中的 <code>&lt;b&gt;</code> 元素。</p><p translation-origin=\"off\">Angular recognizes the value as unsafe and automatically sanitizes it, which removes the <code>script</code> element but keeps safe content such as the <code>&lt;b&gt;</code> element.</p>\n\n<div class=\"lightbox\">\n<img alt=\"A screenshot showing interpolated and bound HTML values\" src=\"generated/images/guide/security/binding-inner-html.png\" width=\"400\" height=\"114\">\n</div>\n<h3 id=\"direct-use-of-the-dom-apis-and-explicit-sanitization-calls\" translation-result=\"on\">避免直接使用 DOM API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#direct-use-of-the-dom-apis-and-explicit-sanitization-calls\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Direct use of the DOM APIs and explicit sanitization calls<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#direct-use-of-the-dom-apis-and-explicit-sanitization-calls\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">除非你強制使用可信型別（Trusted Types），否則瀏覽器內建的 DOM API 不會自動保護你免受安全漏洞的侵害。比如 <code>document</code>、透過 <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code> 拿到的節點和很多第三方 API，都可能包含不安全的方法。如果你使用能操縱 DOM 的其它庫，也同樣無法藉助像 Angular 插值那樣的自動清理功能。所以，要避免直接和 DOM 打交道，而是儘可能使用 Angular 範本。</p><p translation-origin=\"off\">Unless you enforce Trusted Types, the built-in browser DOM APIs don't automatically protect you from security vulnerabilities.\nFor example, <code>document</code>, the node available through <code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>, and many third-party APIs contain unsafe methods.\nLikewise, if you interact with other libraries that manipulate the DOM, you likely won't have the same automatic sanitization as with Angular interpolations.\nAvoid directly interacting with the DOM and instead use Angular templates where possible.</p>\n\n<p translation-result=\"on\">在無法避免的情況下，使用內建的 Angular 無害化處理函式。使用 <a href=\"api/platform-browser/DomSanitizer#sanitize\">DomSanitizer.sanitize</a> 方法以及適當的 <code><a href=\"api/core/SecurityContext\" class=\"code-anchor\">SecurityContext</a></code> 來對不可信的值進行無害化處理。此函式也可以接受使用 <code>bypassSecurityTrust</code> 函式標為可信的值，而且不會對它們進行無害化處理，就像<a href=\"guide/security#bypass-security-apis\">稍後講的那樣</a>。</p><p translation-origin=\"off\">For cases where this is unavoidable, use the built-in Angular sanitization functions.\nSanitize untrusted values with the <a href=\"api/platform-browser/DomSanitizer#sanitize\">DomSanitizer.sanitize</a> method and the appropriate <code><a href=\"api/core/SecurityContext\" class=\"code-anchor\">SecurityContext</a></code>.\nThat function also accepts values that were marked as trusted using the <code>bypassSecurityTrust</code> … functions, and does not sanitize them, as <a href=\"guide/security#bypass-security-apis\">described below</a>.</p>\n\n<p><a id=\"bypass-security-apis\"></a></p>\n<h3 id=\"trusting-safe-values\" translation-result=\"on\">信任安全值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#trusting-safe-values\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Trusting safe values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#trusting-safe-values\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">有時候，應用程式確實需要包含可執行的程式碼，比如使用 URL 顯示 <code>&lt;iframe&gt;</code>，或者構造出有潛在危險的 URL。為了防止在這種情況下被自動無害化，可以告訴 Angular，你已經審查了這個值，檢查了它是怎麼產生的，並確信它總是安全的。但是<strong>千萬要小心</strong>！如果你信任了一個可能是惡意的值，就會在應用中引入一個安全漏洞。如果你有疑問，請找一個安全專家複查下。</p><p translation-origin=\"off\">Sometimes applications genuinely need to include executable code, display an <code>&lt;iframe&gt;</code> from some URL, or construct potentially dangerous URLs.\nTo prevent automatic sanitization in these situations, tell Angular that you inspected a value, checked how it was created, and made sure it is secure.\nDo <em>be careful</em>.\nIf you trust a value that might be malicious, you are introducing a security vulnerability into your application.\nIf in doubt, find a professional security reviewer.</p>\n\n<p translation-result=\"on\">注入 <code><a href=\"api/platform-browser/DomSanitizer\" class=\"code-anchor\">DomSanitizer</a></code> 服務，然後呼叫下面的方法之一，你就可以把一個值標記為可信任的。</p><p translation-origin=\"off\">To mark a value as trusted, inject <code><a href=\"api/platform-browser/DomSanitizer\" class=\"code-anchor\">DomSanitizer</a></code> and call one of the following methods:</p>\n\n<ul>\n<li>\n<p><code>bypassSecurityTrustHtml</code></p>\n</li>\n<li>\n<p><code>bypassSecurityTrustScript</code></p>\n</li>\n<li>\n<p><code>bypassSecurityTrustStyle</code></p>\n</li>\n<li>\n<p><code>bypassSecurityTrustUrl</code></p>\n</li>\n<li>\n<p><code>bypassSecurityTrustResourceUrl</code></p>\n</li>\n</ul>\n<p translation-result=\"on\">記住，一個值是否安全取決於它所在的環境，所以你要為這個值按預定的用法選擇正確的環境。假設下面的範本需要把 <code>javascript.alert(...)</code> 方法繫結到 URL。</p><p translation-origin=\"off\">Remember, whether a value is safe depends on context, so choose the right context for your intended use of the value.\nImagine that the following template needs to bind a URL to a <code>javascript:alert(...)</code> call:</p>\n\n<code-example header=\"src/app/bypass-security.component.html (URL)\" path=\"security/src/app/bypass-security.component.html\" region=\"URL\">\n&lt;h4&gt;An untrusted URL:&lt;/h4&gt;\n&lt;p&gt;&lt;a class=\"e2e-dangerous-url\" [href]=\"dangerousUrl\"&gt;Click me&lt;/a&gt;&lt;/p&gt;\n&lt;h4&gt;A trusted URL:&lt;/h4&gt;\n&lt;p&gt;&lt;a class=\"e2e-trusted-url\" [href]=\"trustedUrl\"&gt;Click me&lt;/a&gt;&lt;/p&gt;\n\n</code-example>\n<p translation-result=\"on\">通常，Angular 會自動無害化這個 URL 並禁止危險的程式碼。為了防止這種行為，可以呼叫 <code>bypassSecurityTrustUrl</code> 把這個 URL 值標記為一個可信任的 URL：</p><p translation-origin=\"off\">Normally, Angular automatically sanitizes the URL, disables the dangerous code, and in development mode, logs this action to the console.\nTo prevent this, mark the URL value as a trusted URL using the <code>bypassSecurityTrustUrl</code> call:</p>\n\n<code-example header=\"src/app/bypass-security.component.ts (trust-url)\" path=\"security/src/app/bypass-security.component.ts\" region=\"trust-url\">\nconstructor(private sanitizer: <a href=\"api/platform-browser/DomSanitizer\" class=\"code-anchor\">DomSanitizer</a>) {\n  // javascript: URLs are dangerous if attacker controlled.\n  // Angular sanitizes them in data binding, but you can\n  // explicitly tell Angular to trust this value:\n  this.dangerousUrl = 'javascript:alert(\"Hi there\")';\n  this.trustedUrl = sanitizer.bypassSecurityTrustUrl(this.dangerousUrl);\n\n</code-example>\n<div class=\"lightbox\">\n<img alt=\"A screenshot showing an alert box created from a trusted URL\" src=\"generated/images/guide/security/bypass-security-component.png\" width=\"454\" height=\"175\">\n</div>\n<p translation-result=\"on\">如果需要把使用者輸入轉換為一個可信任的值，可以在元件方法中處理。下面的範本允許使用者輸入一個 YouTube 影片的 ID，然後把相應的影片載入到 <code>&lt;iframe&gt;</code> 中。<code>&lt;iframe src&gt;</code> 是一個“資源 URL”的安全環境，因為不可信的原始碼可能作為檔案下載到本地，被毫無防備的使用者執行。所以要呼叫一個元件方法來構造一個新的、可信任的影片 URL，這樣 Angular 就會允許把它繫結到 <code>&lt;iframe src&gt;</code>。</p><p translation-origin=\"off\">If you need to convert user input into a trusted value, use a component method.\nThe following template lets users enter a YouTube video ID and load the corresponding video in an <code>&lt;iframe&gt;</code>.\nThe <code>&lt;iframe src&gt;</code> attribute is a resource URL security context, because an untrusted source can, for example, smuggle in file downloads that unsuspecting users could run.\nTo prevent this, call a method on the component to construct a trusted video URL, which causes Angular to let binding into <code>&lt;iframe src&gt;</code>:</p>\n\n<code-example header=\"src/app/bypass-security.component.html (iframe)\" path=\"security/src/app/bypass-security.component.html\" region=\"iframe\">\n&lt;h4&gt;Resource URL:&lt;/h4&gt;\n&lt;p&gt;Showing: {{dangerousVideoUrl}}&lt;/p&gt;\n&lt;p&gt;Trusted:&lt;/p&gt;\n&lt;iframe class=\"e2e-iframe-trusted-src\" width=\"640\" height=\"390\" [src]=\"videoUrl\"&gt;&lt;/iframe&gt;\n&lt;p&gt;Untrusted:&lt;/p&gt;\n&lt;iframe class=\"e2e-iframe-untrusted-src\" width=\"640\" height=\"390\" [src]=\"dangerousVideoUrl\"&gt;&lt;/iframe&gt;\n\n\n</code-example>\n<code-example header=\"src/app/bypass-security.component.ts (trust-video-url)\" path=\"security/src/app/bypass-security.component.ts\" region=\"trust-video-url\">\nupdateVideoUrl(id: string) {\n  // Appending an ID to a YouTube URL is safe.\n  // Always make sure to construct <a href=\"api/platform-browser/SafeValue\" class=\"code-anchor\">SafeValue</a> objects as\n  // close as possible to the input data so\n  // that it's easier to check if the value is safe.\n  this.dangerousVideoUrl = 'https://www.youtube.com/embed/' + id;\n  this.videoUrl =\n      this.sanitizer.bypassSecurityTrustResourceUrl(this.dangerousVideoUrl);\n}\n\n</code-example>\n<p><a id=\"content-security-policy\"></a></p>\n<h3 id=\"content-security-policy\" translation-result=\"on\">內容安全政策<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#content-security-policy\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Content security policy<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#content-security-policy\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">內容安全策略（CSP）是防止 XSS 的深度防禦技術。要啟用 CSP，請將你的 Web 伺服器配置為返回適當的 <code>Content-Security-Policy</code> HTTP 請求頭。在 Google Developers 網站上的<a href=\"https://developers.google.com/web/fundamentals/security/csp\">《網路基礎知識》指南</a>中瞭解有關內容安全政策的更多資訊。</p><p translation-origin=\"off\">Content Security Policy (CSP) is a defense-in-depth technique to prevent XSS.\nTo enable CSP, configure your web server to return an appropriate <code>Content-Security-Policy</code> HTTP header.\nRead more about content security policy at the <a href=\"https://developers.google.com/web/fundamentals/security/csp\">Web Fundamentals guide</a> on the Google Developers website.</p>\n\n<p translation-result=\"on\">新版 Angular 所需的最小化策略是：</p><p translation-origin=\"off\">The minimal policy required for a brand-new Angular application is:</p>\n\n<code-example format=\"none\" language=\"none\">\n\ndefault-src 'self'; style-src 'self' 'nonce-randomNonceGoesHere'; script-src 'self' 'nonce-randomNonceGoesHere';\n\n</code-example>\n<p translation-result=\"on\">在為 Angular 應用程式提供服務時，伺服器應在每個請求的 HTTP 標頭中包含一個隨機產生的隨機數。你必須向 Angular 提供此一次性隨機數（Nonce），以便框架可以渲染 <code>&lt;<a href=\"api/animations/style\" class=\"code-anchor\">style</a>&gt;</code> 元素。你可以透過以下兩種方式之一為 Angular 設定隨機數：</p><p translation-origin=\"off\">When serving your Angular application, the server should include a  randomly-generated nonce in the HTTP header for each request.\nYou must provide this nonce to Angular so that the framework can render <code>&lt;<a href=\"api/animations/style\" class=\"code-anchor\">style</a>&gt;</code> elements.\nYou can set the nonce for Angular in one of two ways:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">將根應用程式元素上的 <code>ngCspNonce</code> 屬性設定為 <code>&lt;app ngCspNonce=\"randomNonceGoesHere\"&gt;&lt;/app&gt;</code>。如果你可以存取伺服器端範本，並且可以在建構響應時將隨機數新增到標頭和 <code>index.html</code>，請使用此方法。</p><p translation-origin=\"off\">Set the <code>ngCspNonce</code> attribute on the root application element as <code>&lt;app ngCspNonce=\"randomNonceGoesHere\"&gt;&lt;/app&gt;</code>. Use this approach if you have access to server-side templating that can add the nonce both to the header and the <code>index.html</code> when constructing the response.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">使用 <code><a href=\"api/core/CSP_NONCE\" class=\"code-anchor\">CSP_NONCE</a></code> 注入令牌提供隨機數。如果你可以在執行時存取 nonce 並且希望快取 <code>index.html</code>，請使用此方法。</p><p translation-origin=\"off\">Provide the nonce using the <code><a href=\"api/core/CSP_NONCE\" class=\"code-anchor\">CSP_NONCE</a></code> injection token. Use this approach if you have access to the nonce at runtime and you want to be able to cache the <code>index.html</code>.</p>\n\n</li>\n</ol>\n<code-example format=\"typescript\" language=\"typescript\">\n\nimport {<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>, <a href=\"api/core/CSP_NONCE\" class=\"code-anchor\">CSP_NONCE</a>} from '@angular/core';\nimport {AppComponent} from './app/app.component';\n\n<a href=\"api/platform-browser/bootstrapApplication\" class=\"code-anchor\">bootstrapApplication</a>(AppComponent, {\n  providers: [{\n    provide: <a href=\"api/core/CSP_NONCE\" class=\"code-anchor\">CSP_NONCE</a>,\n    useValue: globalThis.myRandomNonceValue\n  }]\n});\n\n</code-example>\n<div class=\"callout is-helpful\">\n<p>Always ensure that the nonces you provide are <strong>unique per request</strong> and that they are not predictable or guessable.\nIf an attacker can predict future nonces, they can circumvent the protections offered by CSP.</p>\n</div>\n<p translation-result=\"on\">如果你無法在專案中產生隨機數，則可以透過將 <code>'unsafe-inline'</code> 新增到 CSP 標頭的 <code>style-src</code> 部分來允許內聯樣式。</p><p translation-origin=\"off\">If you cannot generate nonces in your project, you can allow inline styles by adding <code>'unsafe-inline'</code> to the <code>style-src</code> section of the CSP header.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">區段</nt-wrapper><nt-wrapper translation-origin=\"off\">Sections</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>default-src 'self';</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">允許此頁面載入所有來自同源的資源。</nt-wrapper><nt-wrapper translation-origin=\"off\">Allows the page to load all its required resources from the same origin.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>style-src 'self' 'nonce-randomNonceGoesHere';</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">允許頁面從同一個來源（ <code>'self'</code> ）載入全域樣式以及 Angular 使用 <code>nonce-randomNonceGoesHere</code> 插入的樣式。</nt-wrapper><nt-wrapper translation-origin=\"off\">Allows the page to load global styles from the same origin (<code>'self'</code>) and styles inserted by Angular with the <code>nonce-randomNonceGoesHere</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>script-src 'self' 'nonce-randomNonceGoesHere';</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">允許頁面從相同來源（ <code>'self'</code> ）載入 JavaScript 和由 Angular CLI 使用 <code>nonce-randomNonceGoesHere</code> 插入的指令碼。只有在使用關鍵 CSS 內聯時才需要這樣做。</nt-wrapper><nt-wrapper translation-origin=\"off\">Allows the page to load JavaScript from the same origin (<code>'self'</code>) and scripts inserted by the Angular CLI with the <code>nonce-randomNonceGoesHere</code>. This is only required if you're using critical CSS inlining.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">Angular 本身只需要這些設定即可正常執行。隨著專案的增長，你可能需要將 CSP 設定擴展出應用特有的一些額外特性。</p><p translation-origin=\"off\">Angular itself requires only these settings to function correctly.\nAs your project grows, you may need to expand your CSP settings to accommodate extra features specific to your application.</p>\n\n<p><a id=\"trusted-types\"></a></p>\n<!-- vale Angular.Google_Headings = NO -->\n<h3 id=\"enforcing-trusted-types\" translation-result=\"on\">強制執行可信型別<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#enforcing-trusted-types\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Enforcing Trusted Types<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#enforcing-trusted-types\"><i class=\"material-icons\">link</i></a></h3>\n\n<!-- vale Angular.Google_Headings = YES -->\n<p translation-result=\"on\">建議使用<a href=\"https://w3c.github.io/webappsec-trusted-types/dist/spec\">可信型別</a>來幫助保護你的應用程式免受跨站指令碼攻擊。可信型別是一項 <a href=\"https://en.wikipedia.org/wiki/Web_platform\">Web 平台</a>功能，可透過實施更安全的編碼實踐來幫助你防範跨站指令碼攻擊。可信型別還可以幫助簡化應用程式程式碼的審計。</p><p translation-origin=\"off\">It is recommended that you use <a href=\"https://w3c.github.io/trusted-types/dist/spec/\">Trusted Types</a> as a way to help secure your applications from cross-site scripting attacks.\nTrusted Types is a <a href=\"https://en.wikipedia.org/wiki/Web_platform\">web platform</a> feature that can help you prevent cross-site scripting attacks by enforcing safer coding practices.\nTrusted Types can also help simplify the auditing of application code.</p>\n\n<div class=\"callout is-helpful\">\n<p translation-result=\"on\">可信型別可能尚未在你的應用程式目標的所有瀏覽器中可用。如果啟用了可信型別的應用程式在不支援可信型別的瀏覽器中執行，應用程式的功能將被保留，並且你的應用程式將透過 Angular 的 DomSanitizer 防範 XSS。有關當前瀏覽器支援，請參閱 <a href=\"https://caniuse.com/trusted-types\">caniuse.com/trusted-types</a>。</p><p translation-origin=\"off\">Trusted Types might not yet be available in all browsers your application targets.\nIn the case your Trusted-Types-enabled application runs in a browser that doesn't support Trusted Types, the features of the application are preserved. Your application is guarded against XSS by way of Angular's DomSanitizer.\nSee <a href=\"https://caniuse.com/trusted-types\">caniuse.com/trusted-types</a> for the current browser support.</p>\n\n</div>\n<p translation-result=\"on\">要為你的應用程式強制實施可信型別，你必須將應用程式的 Web 伺服器配置為使用以下 Angular 策略之一發出 HTTP 請求頭：</p><p translation-origin=\"off\">To enforce Trusted Types for your application, you must configure your application's web server to emit HTTP headers with one of the following Angular policies:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">策略</nt-wrapper><nt-wrapper translation-origin=\"off\">Policies</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Detail</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>angular</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">此策略用於 Angular 內部經過安全審查的程式碼，並且當強制執行可信型別時，Angular 需要此策略才能正常執行。任何由 Angular 清理的內聯範本值或內容都被此政策視為安全的。</nt-wrapper><nt-wrapper translation-origin=\"off\">This policy is used in security-reviewed code that is internal to Angular, and is required for Angular to function when Trusted Types are enforced. Any inline template values or content sanitized by Angular is treated as safe by this policy.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>angular#unsafe-bypass</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">此策略用於要使用 Angular 的 <a href=\"api/platform-browser/DomSanitizer\">DomSanitizer</a> 的各個方法來繞過安全性的應用程式，比如 <code>bypassSecurityTrustHtml</code>。任何使用了這些方法的應用程式都必須啟用此策略。</nt-wrapper><nt-wrapper translation-origin=\"off\">This policy is used for applications that use any of the methods in Angular's <a href=\"api/platform-browser/DomSanitizer\">DomSanitizer</a> that bypass security, such as <code>bypassSecurityTrustHtml</code>. Any application that uses these methods must enable this policy.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>angular#unsafe-jit</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">此策略供<a href=\"api/core/Compiler\">Just-In-Time （JIT） 編譯器</a>使用。如果你的應用程式直接與 JIT 編譯器互動或使用<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\">平台瀏覽器動態</a>以 JIT 模式執行，你必須啟用此策略。</nt-wrapper><nt-wrapper translation-origin=\"off\">This policy is used by the <a href=\"api/core/Compiler\">Just-In-Time (JIT) compiler</a>. You must enable this policy if your application interacts directly with the JIT compiler or is running in JIT mode using the <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\">platform browser dynamic</a>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>angular#bundler</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">建立延遲載入塊檔案時，Angular CLI 打包器會使用此策略。</nt-wrapper><nt-wrapper translation-origin=\"off\">This policy is used by the Angular CLI bundler when creating lazy chunk files.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">你應該在以下位置為可信型別配置 HTTP 請求頭：</p><p translation-origin=\"off\">You should configure the HTTP headers for Trusted Types in the following locations:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">生產環境基礎設施伺服器</p><p translation-origin=\"off\">Production serving infrastructure</p>\n\n</li>\n<li>\n<p translation-result=\"on\">Angular CLI （ <code>ng serve</code> ），使用 <code>angular.json</code> 檔案中的 <code>headers</code> 屬性，用於本地開發和端到端測試</p><p translation-origin=\"off\">Angular CLI (<code>ng serve</code>), using the <code>headers</code> property in the <code>angular.json</code> file, for local development and end-to-end testing</p>\n\n</li>\n<li>\n<p translation-result=\"on\">Karma （ <code>ng test</code> ），使用 <code>karma.config.js</code> 檔案中的 <code>customHeaders</code> 屬性，進行單元測試</p><p translation-origin=\"off\">Karma (<code>ng test</code>), using the <code>customHeaders</code> property in the <code>karma.config.js</code> file, for unit testing</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">以下是為可信型別和 Angular 配置的請求頭範例：</p><p translation-origin=\"off\">The following is an example of a header specifically configured for Trusted Types and Angular:</p>\n\n<code-example format=\"html\" language=\"html\">\n\nContent-Security-Policy: trusted-types angular; require-trusted-types-for 'script';\n\n</code-example>\n<p translation-result=\"on\">以下是為可信型別和 Angular 應用程式專門配置的請求頭範例，這些應用程式使用了 Angular <a href=\"api/platform-browser/DomSanitizer\">DomSanitizer</a> 中那些可以繞過安全性的方法。</p><p translation-origin=\"off\">An example of a header specifically configured for Trusted Types and Angular applications that use any of Angular's methods in <a href=\"api/platform-browser/DomSanitizer\">DomSanitizer</a> that bypasses security:</p>\n\n<code-example format=\"html\" language=\"html\">\n\nContent-Security-Policy: trusted-types angular angular#unsafe-bypass; require-trusted-types-for 'script';\n\n</code-example>\n<p translation-result=\"on\">以下是使用 JIT，且專門為可信型別和 Angular 應用程式配置的請求頭範例：</p><p translation-origin=\"off\">The following is an example of a header specifically configured for Trusted Types and Angular applications using JIT:</p>\n\n<code-example format=\"html\" language=\"html\">\n\nContent-Security-Policy: trusted-types angular angular#unsafe-jit; require-trusted-types-for 'script';\n\n</code-example>\n<p translation-result=\"on\">以下是專門為使用延遲載入模組的受信任型別和 Angular 應用程式配置的標頭範例：</p><p translation-origin=\"off\">The following is an example of a header specifically configured for Trusted Types and Angular applications that use lazy loading of modules:</p>\n\n<code-example language=\"html\">\n\nContent-Security-Policy: trusted-types angular angular#bundler; require-trusted-types-for 'script';\n\n</code-example>\n<div class=\"callout is-helpful\">\n<header ng-should-translate=\"\" translation-result=\"on\">社群貢獻</header><header ng-should-translate=\"\" translation-origin=\"off\">Community contributions</header>\n\n<p translation-result=\"on\">要了解關於如何對可信型別配置進行故障排除的更多資訊，以下資源可能會有所幫助：</p><p translation-origin=\"off\">To learn more about troubleshooting Trusted Type configurations, the following resource might be helpful:</p>\n\n<p translation-result=\"on\"><a href=\"https://web.dev/trusted-types/#how-to-use-trusted-types\">使用可信型別防範基於 DOM 的跨站指令碼漏洞</a></p><p translation-origin=\"off\"><a href=\"https://web.dev/trusted-types/#how-to-use-trusted-types\">Prevent DOM-based cross-site scripting vulnerabilities with Trusted Types</a></p>\n\n</div>\n<p><a id=\"offline-template-compiler\"></a></p>\n<h3 id=\"use-the-aot-template-compiler\" translation-result=\"on\">使用 AOT 範本編譯器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#use-the-aot-template-compiler\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Use the AOT template compiler<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#use-the-aot-template-compiler\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">AOT 範本編譯器可防止稱為範本注入的一整類漏洞，並大大提高了應用程式效能。AOT 範本編譯器是 Angular CLI 應用程式使用的預設編譯器，你應該在所有生產部署中使用它。</p><p translation-origin=\"off\">The AOT template compiler prevents a whole class of vulnerabilities called template injection, and greatly improves application performance.\nThe AOT template compiler is the default compiler used by Angular CLI applications, and you should use it in all production deployments.</p>\n\n<p translation-result=\"on\">AOT 編譯器的替代方法是 JIT 編譯器，它可以在執行時將範本編譯為瀏覽器中的可執行範本程式碼。Angular 信任這些範本程式碼，因此動態產生範本並進行編譯（尤其是包含使用者資料的範本）可以規避 Angular 的內建保護就。這是一種安全性方面的反模式。要了解如何以安全方式動態建構表單，請參見<a href=\"guide/dynamic-form\">《動態表單》</a>指南。</p><p translation-origin=\"off\">An alternative to the AOT compiler is the JIT compiler which compiles templates to executable template code within the browser at runtime.\nAngular trusts template code, so dynamically generating templates and compiling them, in particular templates containing user data, circumvents Angular's built-in protections. This is a security anti-pattern.\nFor information about dynamically constructing forms in a safe way, see the <a href=\"guide/dynamic-form\">Dynamic Forms</a> guide.</p>\n\n<p><a id=\"server-side-xss\"></a></p>\n<h3 id=\"server-side-xss-protection\" translation-result=\"on\">伺服器端 XSS 保護<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#server-side-xss-protection\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Server-side XSS protection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#server-side-xss-protection\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在伺服器上構造的 HTML 容易受到注入攻擊。將範本程式碼注入到 Angular 應用程式中與注入可執行程式碼是一樣的：它使攻擊者可以完全控制該應用程式。為避免這種情況，請使用一種範本語言來自動轉義值以防止伺服器上的 XSS 漏洞。不要在伺服器端使用範本語言產生 Angular 範本。這樣做會帶來引入範本注入漏洞的高風險。</p><p translation-origin=\"off\">HTML constructed on the server is vulnerable to injection attacks.\nInjecting template code into an Angular application is the same as injecting executable code into the application:\nIt gives the attacker full control over the application.\nTo prevent this, use a templating language that automatically escapes values to prevent XSS vulnerabilities on the server.\nDon't create Angular templates on the server side using a templating language. This carries a high risk of introducing template-injection vulnerabilities.</p>\n\n<p><a id=\"http\"></a></p>\n<!-- vale Angular.Google_Acronyms = NO -->\n<h2 id=\"http-level-vulnerabilities\" translation-result=\"on\">HTTP 級漏洞<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#http-level-vulnerabilities\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">HTTP-level vulnerabilities<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#http-level-vulnerabilities\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 內建了一些支援來防範兩個常見的 HTTP 漏洞：跨站請求偽造（XSRF）和跨站指令碼包含（XSSI）。這兩個漏洞主要在伺服器端防範，但是 Angular 也自帶了一些輔助特性，可以讓客戶端的整合變得更容易。</p><p translation-origin=\"off\">Angular has built-in support to help prevent two common HTTP vulnerabilities, cross-site request forgery (CSRF or XSRF) and cross-site script inclusion (XSSI).\nBoth of these must be mitigated primarily on the server side, but Angular provides helpers to make integration on the client side easier.</p>\n\n<p><a id=\"xsrf\"></a></p>\n<h3 id=\"cross-site-request-forgery\" translation-result=\"on\">跨站請求偽造<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#cross-site-request-forgery\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Cross-site request forgery<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#cross-site-request-forgery\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在跨站請求偽造（XSRF 或 CSRF）中，攻擊者欺騙使用者，讓他們存取一個假冒頁面（比如 <code>evil.com</code>）。該頁面帶有惡意程式碼，秘密的向你的應用程式伺服器傳送惡意請求（比如 <code>example-bank.com</code>）。</p><p translation-origin=\"off\">In a cross-site request forgery (CSRF or XSRF), an attacker tricks the user into visiting a different web page (such as <code>evil.com</code>) with malignant code. This web page secretly sends a malicious request to the application's web server (such as <code>example-bank.com</code>).</p>\n\n<p translation-result=\"on\">假設使用者已經在 <code>example-bank.com</code> 登入。使用者開啟一個郵件，點選裡面的連結，在新頁面中開啟 <code>evil.com</code>。</p><p translation-origin=\"off\">Assume the user is logged into the application at <code>example-bank.com</code>.\nThe user opens an email and clicks a link to <code>evil.com</code>, which opens in a new tab.</p>\n\n<p translation-result=\"on\">該 <code>evil.com</code> 頁面立刻傳送惡意請求到 <code>example-bank.com</code>。這個請求可能是從使用者賬戶轉賬到攻擊者的賬戶。與該請求一起，瀏覽器自動發出 <code>example-bank.com</code> 的 cookie。</p><p translation-origin=\"off\">The <code>evil.com</code> page immediately sends a malicious request to <code>example-bank.com</code>.\nPerhaps it's a request to transfer money from the user's account to the attacker's account.\nThe browser automatically sends the <code>example-bank.com</code> cookies, including the authentication cookie, with this request.</p>\n\n<p translation-result=\"on\">如果 <code>example-bank.com</code> 伺服器缺乏 XSRF 保護，就無法辨識請求是從應用程式發來的合法請求還是從 <code>evil.com</code> 來的假請求。</p><p translation-origin=\"off\">If the <code>example-bank.com</code> server lacks XSRF protection, it can't tell the difference between a legitimate request from the application and the forged request from <code>evil.com</code>.</p>\n\n<p translation-result=\"on\">為了防止這種情況，你必須確保每個使用者的請求都是從你自己的應用中發出的，而不是從另一個網站發出的。客戶端和伺服器必須合作來抵擋這種攻擊。</p><p translation-origin=\"off\">To prevent this, the application must ensure that a user request originates from the real application, not from a different site.\nThe server and client must cooperate to thwart this attack.</p>\n\n<p translation-result=\"on\">常見的反 XSRF 技術是伺服器隨機產生一個使用者認證令牌到 cookie 中。客戶端程式碼獲取這個 cookie，並用它為接下來所有的請求新增自訂請求頁首。伺服器比較收到的 cookie 值與請求頁首的值，如果它們不匹配，便拒絕請求。</p><p translation-origin=\"off\">In a common anti-XSRF technique, the application server sends a randomly created authentication token in a cookie.\nThe client code reads the cookie and adds a custom request header with the token in all following requests.\nThe server compares the received cookie value to the request header value and rejects the request if the values are missing or don't match.</p>\n\n<p translation-result=\"on\">這個技術之所以有效，是因為所有瀏覽器都實現了<em>同源策略</em>。只有設定 cookie 的網站的程式碼可以存取該站的 cookie，併為該站的請求設定自訂頁首。這就是說，只有你的應用程式可以獲取這個 cookie 令牌和設定自訂頁首。<code>evil.com</code> 的惡意程式碼不能。</p><p translation-origin=\"off\">This technique is effective because all browsers implement the <em>same origin policy</em>.\nOnly code from the website on which cookies are set can read the cookies from that site and set custom headers on requests to that site.\nThat means only your application can read this cookie token and set the custom header.\nThe malicious code on <code>evil.com</code> can't.</p>\n\n<p translation-result=\"on\">Angular 的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 對這項技術的客戶端部分提供了內建的支援要了解更多資訊，參閱 <a href=\"guide/http#security-xsrf-protection\">HttpClient 部分</a>。</p><p translation-origin=\"off\">Angular's <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> has built-in support for the client-side half of this technique.\nRead about it more in the <a href=\"guide/http#security-xsrf-protection\">HttpClient guide</a>.</p>\n\n<p translation-result=\"on\">可到 \"開放式 Web 應用程式安全專案 （OWASP） \" 深入瞭解 CSRF，參閱<a href=\"https://owasp.org/www-community/attacks/csrf\">Cross-Site Request Forgery （CSRF）</a> 和<a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html\">Cross-Site Request Forgery （CSRF） Prevention Cheat Sheet</a>。這個斯坦福大學論文 <a href=\"https://seclab.stanford.edu/websec/csrf/csrf.pdf\">Robust Defenses for Cross-Site Request Forgery</a> 有詳盡的細節。</p><p translation-origin=\"off\">For information about CSRF at the Open Web Application Security Project (OWASP), see <a href=\"https://owasp.org/www-community/attacks/csrf\">Cross-Site Request Forgery (CSRF)</a> and <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html\">Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet</a>.\nThe Stanford University paper <a href=\"https://seclab.stanford.edu/websec/csrf/csrf.pdf\">Robust Defenses for Cross-Site Request Forgery</a> is a rich source of detail.</p>\n\n<p translation-result=\"on\">參閱 Dave Smith 在<a href=\"https://www.youtube.com/watch?v=9inczw6qtpY\" title=\"Cross Site Request Funkery Securing Your Angular Apps From Evil Doers\">AngularConnect 2016 關於 XSRF 的演講</a>。</p><p translation-origin=\"off\">See also Dave Smith's <a href=\"https://www.youtube.com/watch?v=9inczw6qtpY\" title=\"Cross Site Request Funkery Securing Your Angular Apps From Evil Doers\">talk on XSRF at AngularConnect 2016</a>.</p>\n\n<!-- vale Angular.Google_Acronyms = YES -->\n<p><a id=\"xssi\"></a></p>\n<h3 id=\"cross-site-script-inclusion-xssi\" translation-result=\"on\">跨站指令碼包含（XSSI）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#cross-site-script-inclusion-xssi\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Cross-site script inclusion (XSSI)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#cross-site-script-inclusion-xssi\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">跨站指令碼包含，也被稱為 Json 漏洞，它可以允許一個攻擊者的網站從 JSON API 讀取資料。這種攻擊發生在老的瀏覽器上，它重寫原生 JavaScript 物件的建構函式，然後使用 <code>&lt;script&gt;</code> 標籤包含一個 API 的 URL。</p><p translation-origin=\"off\">Cross-site script inclusion, also known as JSON vulnerability, can allow an attacker's website to read data from a JSON API.\nThe attack works on older browsers by overriding built-in JavaScript object constructors, and then including an API URL using a <code>&lt;script&gt;</code> tag.</p>\n\n<p translation-result=\"on\">只有在返回的 JSON 能像 JavaScript 一樣可以被執行時，這種攻擊才會生效。所以伺服器端會約定給所有 JSON 回應內文加上字首 <code>\")]}',\\n\"</code>，來把它們標記為不可執行的，以防範這種攻擊。</p><p translation-origin=\"off\">This attack is only successful if the returned JSON is executable as JavaScript.\nServers can prevent an attack by prefixing all JSON responses to make them non-executable, by convention, using the well-known string <code>\")]}',\\n\"</code>.</p>\n\n<p translation-result=\"on\">Angular 的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 庫會識別這種約定，並在進一步解析之前，自動把字串 <code>\")]}',\\n\"</code> 從所有響應中去掉。</p><p translation-origin=\"off\">Angular's <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> library recognizes this convention and automatically strips the string <code>\")]}',\\n\"</code> from all responses before further parsing.</p>\n\n<p translation-result=\"on\">要學習更多這方面的知識，請參閱<a href=\"https://security.googleblog.com/2011/05/website-security-for-webmasters.html\">谷歌 Web 安全部落格文章</a>的 XSSI 小節。</p><p translation-origin=\"off\">For more information, see the XSSI section of this <a href=\"https://security.googleblog.com/2011/05/website-security-for-webmasters.html\">Google web security blog post</a>.</p>\n\n<p><a id=\"code-review\"></a></p>\n<h2 id=\"auditing-angular-applications\" translation-result=\"on\">審計 Angular 應用程式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#auditing-angular-applications\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Auditing Angular applications<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/security#auditing-angular-applications\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 應用應該遵循和常規 Web 應用一樣的安全原則並按照這些原則進行審計。Angular 中某些應該在安全評審中被審計的 API（比如<a href=\"guide/security#bypass-security-apis\"><em>bypassSecurityTrust</em></a> API）都在文件中被明確標記為安全性敏感的。</p><p translation-origin=\"off\">Angular applications must follow the same security principles as regular web applications, and must be audited as such.\nAngular-specific APIs that should be audited in a security review, such as the <a href=\"guide/security#bypass-security-apis\"><em>bypassSecurityTrust</em></a> methods, are marked in the documentation as security sensitive.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：5/16/2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/architecture-next-steps\n - guide/example-apps-list\n - guide/template-overview\n - guide/template-syntax\n-->\n<!-- links from this doc:\n - api/animations/style\n - api/common/NgOptimizedImage\n - api/common/http/HttpClient\n - api/core/CSP_NONCE\n - api/core/Compiler\n - api/core/ElementRef\n - api/core/SecurityContext\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/DomSanitizer\n - api/platform-browser/DomSanitizer#sanitize\n - api/platform-browser/SafeValue\n - api/platform-browser/bootstrapApplication\n - guide/dynamic-form\n - guide/http#security-xsrf-protection\n - guide/security#angular-的跨站指令碼安全模型\n - guide/security#angulars-cross-site-scripting-security-model\n - guide/security#auditing-angular-applications\n - guide/security#bypass-security-apis\n - guide/security#content-security-policy\n - guide/security#cross-site-request-forgery\n - guide/security#cross-site-script-inclusion-xssi\n - guide/security#direct-use-of-the-dom-apis-and-explicit-sanitization-calls\n - guide/security#enforcing-trusted-types\n - guide/security#http-level-vulnerabilities\n - guide/security#http-級漏洞\n - guide/security#offline-template-compiler\n - guide/security#preventing-cross-site-scripting-xss\n - guide/security#sanitization-and-security-contexts\n - guide/security#sanitization-example\n - guide/security#security\n - guide/security#server-side-xss-protection\n - guide/security#trusted-types\n - guide/security#trusting-safe-values\n - guide/security#use-the-aot-template-compiler\n - guide/security#使用-aot-範本編譯器\n - guide/security#信任安全值\n - guide/security#內容安全政策\n - guide/security#安全\n - guide/security#審計-angular-應用程式\n - guide/security#強制執行可信型別\n - guide/security#無害化處理與安全環境\n - guide/security#無害化範例\n - guide/security#伺服器端-xss-保護\n - guide/security#跨站指令碼包含xssi\n - guide/security#跨站請求偽造\n - guide/security#避免直接使用-dom-api\n - guide/security#防範跨站指令碼xss攻擊\n - https://bughunters.google.com/about/rules/6521337925468160/google-open-source-software-vulnerability-reward-program-rules\n - https://bughunters.google.com/report\n - https://caniuse.com/trusted-types\n - https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html\n - https://developers.google.com/web/fundamentals/security/csp\n - https://en.wikipedia.org/wiki/Code_injection\n - https://en.wikipedia.org/wiki/Cross-site_scripting\n - https://en.wikipedia.org/wiki/Web_platform\n - https://github.com/angular/angular/blob/main/CHANGELOG.md\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/security.md?message=docs%3A%20請簡述你的修改...\n - https://owasp.org/www-community/attacks/csrf\n - https://seclab.stanford.edu/websec/csrf/csrf.pdf\n - https://security.googleblog.com/2011/05/website-security-for-webmasters.html\n - https://w3c.github.io/trusted-types/dist/spec/\n - https://w3c.github.io/webappsec-trusted-types/dist/spec\n - https://web.dev/trusted-types/#how-to-use-trusted-types\n - https://www.google.com/about/appsecurity\n - https://www.google.com/about/appsecurity/\n - https://www.owasp.org/index.php/Category:OWASP_Guide_Project\n - https://www.youtube.com/watch?v=9inczw6qtpY\n-->"}