{"id":"guide/ivy-compatibility-examples","title":"Ivy compatibility examples","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/aio/aio/content/guide/ivy-compatibility-examples.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"ivy-compatibility-examples\" translation-result=\"on\">Ivy 的相容性例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#ivy-compatibility-examples\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"ivy-compatibility-examples\">Ivy compatibility examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#ivy-compatibility-examples\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本附錄旨在為 Ivy 的變更提供更多背景資訊。其中很多例子列出了你可能會看到的錯誤資訊，所以如果你正在除錯，按錯誤資訊搜尋可能是個好主意。</p><p translation-origin=\"off\">This appendix is intended to provide more background on Ivy changes. Many of these examples list error messages you may see, so searching by error message might be a good idea if you are debugging.</p>\n\n<div class=\"alert is-critical\">\nNOTE: Most of these issues affect a small percentage of applications encountering unusual or rare edge cases.\n</div>\n<a id=\"content-children-descendants\"></a>\n<h2 id=\"contentchildren-queries-only-match-direct-children-by-default\" translation-result=\"on\">@ContentChildren 查詢預設只匹配直接子元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#contentchildren-queries-only-match-direct-children-by-default\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"contentchildren-queries-only-match-direct-children-by-default\">@ContentChildren queries only match direct children by default<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#contentchildren-queries-only-match-direct-children-by-default\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"basic-example-of-change\" translation-result=\"on\">變更的基本例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#basic-example-of-change\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"basic-example-of-change\">Basic example of change<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#basic-example-of-change\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">假設某個元件（ <code>Comp</code> ）對 <code>'foo'</code> 有 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢：</p><p translation-origin=\"off\">Let's say a component (<code>Comp</code>) has a <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> query for <code>'foo'</code>:</p>\n\n<code-example language=\"html\">\n&lt;comp&gt;\n    &lt;div&gt;\n         &lt;div #foo&gt;&lt;/div&gt;   &lt;!-- matches in old runtime, not in new runtime --&gt;\n    &lt;/div&gt;\n&lt;/comp&gt;\n</code-example>\n<p translation-result=\"on\">在之前的執行時中，帶 <code>#foo</code> 的 <code>&lt;div&gt;</code> 會匹配到。而在 Ivy 中， <code>&lt;div&gt;</code> 不能匹配，因為它不是 <code>&lt;comp&gt;</code> 的直接子節點。</p><p translation-origin=\"off\">In the previous runtime, the <code>&lt;div&gt;</code> with <code>#foo</code> would match.\nWith Ivy, that <code>&lt;div&gt;</code> does not match because it is not a direct child of <code>&lt;comp&gt;</code>.</p>\n\n<h3 id=\"background\" translation-result=\"on\">背景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#background\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"background\">Background<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#background\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">預設情況下， <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢的 <code>descendants</code> 標誌設定為 <code>false</code> 。</p><p translation-result=\"on\">在前面的渲染引擎中，“descendants” 指的是“後代指令”。只要元素和請求指令之間沒有其它指令，元素就可以匹配。這對於類似於 tabs （頁標籤組）的巢狀(Nesting)的指令是有意義的，其中巢狀(Nesting)的 tab 指令可能不適合匹配。但是，這會給使用者帶來令人驚訝的行為，因為只要在包裝器元素中新增一個不相關的指令（如 <code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code>） 就可能會讓查詢結果無效。</p><p translation-result=\"on\">比如，如果使用下面的內容查詢和範本，最後兩個 <code>Tab</code> 指令不匹配：</p><p translation-origin=\"off\">By default, <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> queries have the <code>descendants</code> flag set to <code>false</code>.</p>\n\n<p translation-origin=\"off\">In the previous rendering engine, \"descendants\" referred to \"descendant directives\".\nAn element could be a match as long as there were no other directives between the element and the requesting directive.\nThis made sense for directives with nesting like tabs, where nested tab directives might not be desirable to match.\nHowever, this caused surprising behavior for users because adding an unrelated directive like <code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code> to a wrapper element could invalidate query results.</p>\n\n<p translation-origin=\"off\">For example, with the content query and template below, the last two <code>Tab</code> directives would not be matches:</p>\n\n<code-example>\n@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>(Tab, {descendants: false}) tabs: <a href=\"api/core/QueryList\" class=\"code-anchor\">QueryList</a>&lt;Tab&gt;\n</code-example>\n<code-example>\n&lt;tab-list&gt;\n  &lt;div&gt;\n    &lt;tab&gt; One &lt;/tab&gt;     &lt;!-- match (nested in element) --&gt;\n  &lt;/div&gt;\n  &lt;tab&gt;                  &lt;!-- match (top level) --&gt;\n    &lt;tab&gt; A &lt;/tab&gt;       &lt;!-- not a match (nested in tab) --&gt;\n  &lt;/tab&gt;\n  &lt;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"classes\"&gt;\n    &lt;tab&gt; Two &lt;/tab&gt;     &lt;!-- not a match (nested in <a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>) --&gt;\n  &lt;/div&gt;\n&lt;/tab-list&gt;\n</code-example>\n<p translation-result=\"on\">另外，使用型別謂詞和使用字串謂詞之間的差異很微妙，有時甚至都分不清。比如，如果用 <code>'foo'</code> 字串謂詞替換上面的型別謂詞，匹配就會改變：</p><p translation-origin=\"off\">In addition, the differences between type and string predicates were subtle and sometimes unclear.\nFor example, if you replace the type predicate above with a <code>'foo'</code> string predicate, the matches change:</p>\n\n<code-example>\n@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>('foo', {descendants: false}) foos: <a href=\"api/core/QueryList\" class=\"code-anchor\">QueryList</a>&lt;<a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>&gt;\n</code-example>\n<code-example>\n&lt;tab-list&gt;\n  &lt;div&gt;\n    &lt;div #foo&gt; One &lt;/div&gt;     &lt;!-- match (nested in element) --&gt;\n  &lt;/div&gt;\n  &lt;tab #foo&gt;                  &lt;!-- match (top level) --&gt;\n    &lt;div #foo&gt; A &lt;/div&gt;       &lt;!-- match (nested in tab) --&gt;\n  &lt;/tab&gt;\n  &lt;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"classes\"&gt;\n    &lt;div #foo&gt; Two &lt;/div&gt;     &lt;!-- match (nested in <a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>) --&gt;\n  &lt;/div&gt;\n&lt;/tab-list&gt;\n</code-example>\n<p translation-result=\"on\">由於之前的行為對使用者來說是不一致和令人驚訝的，所以我們不打算在 Ivy 中重現它。相反，我們簡化了其心智模型，以便 “descendants” 只標識 DOM 巢狀(Nesting)。位於發出請求的元件和潛在匹配項之間的任何 DOM 元素都會使該匹配失效。型別謂詞和字串謂詞也有了相同的匹配行為。</p><p translation-result=\"on\">指令/字串謂詞的 Ivy 行為：</p><p translation-origin=\"off\">Because the previous behavior was inconsistent and surprising to users, we did not want to reproduce it in Ivy.\nInstead, we simplified the mental model so that \"descendants\" refers to DOM nesting only.\nAny DOM element between the requesting component and a potential match will invalidate that match.\nType predicates and string predicates also have identical matching behavior.</p>\n\n<p translation-origin=\"off\">Ivy behavior for directive/string predicates:</p>\n\n<code-example>\n&lt;tab-list&gt;\n  &lt;div&gt;\n    &lt;tab&gt; One &lt;/tab&gt;     &lt;!-- not a match (nested in element) --&gt;\n  &lt;/div&gt;\n  &lt;tab&gt;                  &lt;!-- match (top level) --&gt;\n    &lt;tab&gt; A &lt;/tab&gt;       &lt;!-- not a match (nested in tab) --&gt;\n  &lt;/tab&gt;\n  &lt;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"classes\"&gt;\n    &lt;tab&gt; Two &lt;/tab&gt;     &lt;!-- not a match (nested in div) --&gt;\n  &lt;/div&gt;\n&lt;/tab-list&gt;\n</code-example>\n<h3 id=\"example-of-error\" translation-result=\"on\">錯誤資訊的例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#example-of-error\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"example-of-error\">Example of error<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#example-of-error\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你看到的錯誤資訊取決於應用程式碼中特定的內容查詢的使用方式。當在內容查詢結果中參考一個屬性（這裡是 <code>undefined</code>）時，就會丟擲一個錯誤。</p><p translation-result=\"on\">比如，如果元件把內容查詢結果設定為屬性，那麼 <code>foos</code>、<code>foos.first.bar</code> 會丟擲錯誤：</p><p translation-origin=\"off\">The error message that you see will depend on how the particular content query is used in the application code.\nFrequently, an error is thrown when a property is referenced on the content query result (which is now <code>undefined</code>).</p>\n\n<p translation-origin=\"off\">For example, if the component sets the content query results to a property, <code>foos</code>, <code>foos.first.bar</code> would throw the error:</p>\n\n<code-example>\nUncaught TypeError: Cannot read property 'bar' of undefined\n</code-example>\n<p translation-result=\"on\">如果你看到這樣的錯誤，並且 <code>undefined</code> 屬性參考了 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢的結果，那麼很可能就是由於這個變化造成的。</p><p translation-origin=\"off\">If you see an error like this, and the <code>undefined</code> property refers to the result of a <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> query, it may well be caused by this change.</p>\n\n<h3 id=\"recommended-fix\" translation-result=\"on\">推薦的修復方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#recommended-fix\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"recommended-fix\">Recommended fix<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#recommended-fix\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以新增 <code>descendants: true</code> 標誌來忽略包裝元素，也可以自己刪除包裝元素。</p><p translation-result=\"on\">方案 1：</p><p translation-origin=\"off\">You can either add the <code>descendants: true</code> flag to ignore wrapper elements or remove the wrapper elements themselves.</p>\n\n<p translation-origin=\"off\">Option 1:</p>\n\n<code-example>\n@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>('foo', {descendants: true}) foos: <a href=\"api/core/QueryList\" class=\"code-anchor\">QueryList</a>&lt;<a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>&gt;;\n</code-example>\n<p translation-result=\"on\">方案 2：</p><p translation-origin=\"off\">Option 2:</p>\n\n<code-example>\n&lt;comp&gt;\n   &lt;div #foo&gt;&lt;/div&gt;   &lt;!-- matches in both old runtime and  new runtime --&gt;\n&lt;/comp&gt;\n</code-example>\n<a id=\"undecorated-classes\"></a>\n<h2 id=\"all-classes-that-use-angular-di-must-have-an-angular-class-level-decorator\" translation-result=\"on\">所有使用 Angular DI 的類都必須有一個 Angular 類級裝飾器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#all-classes-that-use-angular-di-must-have-an-angular-class-level-decorator\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"all-classes-that-use-angular-di-must-have-an-angular-class-level-decorator\">All classes that use Angular DI must have an Angular class-level decorator<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#all-classes-that-use-angular-di-must-have-an-angular-class-level-decorator\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"basic-example-of-change-1\" translation-result=\"on\">變更的基本例子：<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#basic-example-of-change-1\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"basic-example-of-change-1\">Basic example of change:<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#basic-example-of-change-1\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在以前的渲染引擎中，下列程式碼可以正常工作：</p><p translation-origin=\"off\">In the previous rendering engine, the following would work:</p>\n\n<code-example>\nexport class DataService {\n  constructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>('CONFIG') public config: DataConfig) {}\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class AppService extends DataService {...}\n</code-example>\n<p translation-result=\"on\">在 Ivy 中，它會丟擲一個錯誤，因為 <code>DataService</code> 正在使用 Angular 依賴注入，但它卻缺少一個 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 裝飾器。</p><p translation-result=\"on\">下列渲染引擎也能正常工作，但是 Ivy 需要一個 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 裝飾器，因為它使用了 DI：</p><p translation-origin=\"off\">In Ivy, it will throw an error because <code>DataService</code> is using Angular dependency injection, but is missing an <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> decorator.</p>\n\n<p translation-origin=\"off\">The following would also work in the previous rendering engine, but in Ivy would require a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> decorator because it uses DI:</p>\n\n<code-example>\nexport class BaseMenu {\n  constructor(private vcr: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) {}\n}\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[settingsMenu]'})\nexport class SettingsMenu extends BaseMenu {}\n</code-example>\n<p translation-result=\"on\">如果指令類擴充了裝飾指令，但卻沒有自己的裝飾器，那也是如此。</p><p translation-result=\"on\">如果你正在使用 CLI，那麼有兩個自動遷移應該為你轉移你的程式碼（ <a href=\"guide/migration-injectable\">本章</a>和<a href=\"guide/migration-undecorated-classes\">本章</a> ）。但是，當你在版本 9 中新增新程式碼時，可能會遇到這種不同。</p><p translation-origin=\"off\">The same is true if your directive class extends a decorated directive, but does not have a decorator of its own.</p>\n\n<p translation-origin=\"off\">If you're using the CLI, there are two automated migrations that should transition your code for you (<a href=\"guide/migration-injectable\">this one</a> and <a href=\"guide/migration-undecorated-classes\">this one</a>).\nHowever, as you're adding new code in version 9, you may run into this difference.</p>\n\n<h3 id=\"background-1\" translation-result=\"on\">背景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#background-1\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"background-1\">Background<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#background-1\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當一個類別有一個像 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 或 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 這樣的 Angular 裝飾器時，Angular 編譯器會產生額外的程式碼，以支援把依賴注入到類別的建構函式中。當使用繼承時，Ivy 既需要父類，也要讓子類別應用裝飾器來產生正確的程式碼。否則，當父類中缺少裝飾器時，該子類別將繼承一個建構函式，而這個建構函式並沒有為編譯器產生特殊的建構函式資訊，而 Angular 也沒有正確建立它所需的依賴資訊。</p><p translation-result=\"on\">在之前的渲染引擎中，編譯器具有全域知識，所以在某些情況下（比如 AOT 模式或某些注入標誌的存在），它可以查詢丟失的資料。然而，Ivy 編譯器只是孤立地處理每個類別。這意味著編譯有可能更快（併為今後的最佳化和特性開啟框架），但編譯器不能自動推斷出和以前一樣的資訊。</p><p translation-result=\"on\">新增合適的裝飾器會明確提供這些資訊。</p><p translation-origin=\"off\">When a class has an Angular decorator like <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> or <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>, the Angular compiler generates extra code to support injecting dependencies into the constructor of your class.\nWhen using inheritance, Ivy needs both the parent class and the child class to apply a decorator to generate the correct code.\nOtherwise, when the decorator is missing from the parent class, the subclass will inherit a constructor from a class for which the compiler did not generate special constructor info, and Angular won't have the dependency info it needs to create it properly.</p>\n\n<p translation-origin=\"off\">In the previous rendering engine, the compiler had global knowledge, so in some cases (such as AOT mode or the presence of certain injection flags), it could look up the missing data.\nHowever, the Ivy compiler only processes each class in isolation.\nThis means that compilation has the potential to be faster (and opens the framework up for optimizations and features going forward), but the compiler can't automatically infer the same information as before.</p>\n\n<p translation-origin=\"off\">Adding the proper decorator explicitly provides this information.</p>\n\n<h3 id=\"example-of-error-1\" translation-result=\"on\">錯誤資訊的例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#example-of-error-1\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"example-of-error-1\">Example of error<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#example-of-error-1\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 JIT 模式下，該框架會丟擲以下錯誤：</p><p translation-origin=\"off\">In JIT mode, the framework will throw the following error:</p>\n\n<code-example>\nERROR: This constructor is not compatible with Angular Dependency Injection because its dependency at index X of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index X is correct and 2) the correct Angular decorators are defined for this class and its ancestors.\n</code-example>\n<p translation-result=\"on\">在 AOT 模式下，你會看到如下內容：</p><p translation-origin=\"off\">In AOT mode, you'll see something like:</p>\n\n<code-example>\nX inherits its constructor from Y, but the latter does not have an Angular decorator of its own.\nDependency injection will not be able to resolve the parameters of Y's constructor. Either add a\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a> decorator to Y, or add an explicit constructor to X.\n</code-example>\n<p translation-result=\"on\">在某些情況下，框架可能無法檢測到丟失的裝飾器。在這種情況下，你會發現試圖對所缺的依賴項進行屬性存取時，就會丟擲一個執行時錯誤。如果依賴是 <code>foo</code> ，你在存取 <code>foo.bar</code> 這樣的東西時會看到一個錯誤：</p><p translation-origin=\"off\">In some cases, the framework may not be able to detect the missing decorator.\nIn these cases, you'll generally see a runtime error thrown when there is a property access attempted on the missing dependency.\nIf dependency was <code>foo</code>, you'd see an error when accessing something like <code>foo.bar</code>:</p>\n\n<code-example>\nUncaught TypeError: Cannot read property 'bar' of undefined\n</code-example>\n<p translation-result=\"on\">如果你看到這樣的錯誤，並且 <code>undefined</code> 值參考了應該注入的內容，那麼可能就是這種變化。</p><p translation-origin=\"off\">If you see an error like this, and the <code>undefined</code> value refers to something that should have been injected, it may be this change.</p>\n\n<h3 id=\"recommended-fix-1\" translation-result=\"on\">推薦的修復方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#recommended-fix-1\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"recommended-fix-1\">Recommended fix<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#recommended-fix-1\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\">把 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 裝飾器新增到你打算提供或注入的東西中。</p><p translation-origin=\"off\">Add an <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> decorator to anything you plan to provide or inject.</p>\n\n</li>\n</ul>\n<code-example>\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class DataService {\n  constructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>('CONFIG') public config: DataConfig) {}\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class AppService extends DataService {...}\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\">把 <a href=\"guide/migration-undecorated-classes#what-does-it-mean-to-have-a-directive-decorator-with-no-metadata-inside-of-it\">無選擇器的 <code>@Directive</code> 裝飾器</a>新增到擴充指令的類或被指令繼承的任何類中。</p><p translation-origin=\"off\">Add a <a href=\"guide/migration-undecorated-classes#what-does-it-mean-to-have-a-directive-decorator-with-no-metadata-inside-of-it\">selectorless <code>@Directive</code> decorator</a> to any class that extends a directive or any class from which a directive inherits.</p>\n\n</li>\n</ul>\n<code-example>\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()            // selectorless, so it's not usable directly\nexport class BaseMenu {\n  constructor(private vcr: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) {}\n}\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[settingsMenu]'})\nexport class SettingsMenu extends BaseMenu {}\n</code-example>\n<a id=\"select-value-binding\"></a>\n<h2 id=\"cannot-bind-to-value-property-of-select-with-ngfor\" translation-result=\"on\">無法使用 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 繫結到 <code>&lt;select&gt;</code> 的 <code>value</code> 屬性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#cannot-bind-to-value-property-of-select-with-ngfor\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"cannot-bind-to-value-property-of-select-with-ngfor\">Cannot Bind to <code>value</code> property of <code>&lt;select&gt;</code> with <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#cannot-bind-to-value-property-of-select-with-ngfor\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"basic-example-of-change-2\" translation-result=\"on\">變更的基本例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#basic-example-of-change-2\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"basic-example-of-change-2\">Basic example of change<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#basic-example-of-change-2\"><i class=\"material-icons\">link</i></a></h3>\n\n<code-example language=\"html\">\n&lt;select [value]=\"someValue\"&gt;\n  &lt;option *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let option of options\" [value]=\"option\"&gt; {{ option }} &lt;option&gt;\n&lt;/select&gt;\n</code-example>\n<p translation-result=\"on\">在 View Engine 的執行時，上面的程式碼會按照預期的那樣設定 <code>&lt;select&gt;</code> 的初始值。在 Ivy 中，在這種情況下根本不會設定初始值。</p><p translation-origin=\"off\">In the View Engine runtime, the above code would set the initial value of the <code>&lt;select&gt;</code> as expected.\nIn Ivy, the initial value would not be set at all in this case.</p>\n\n<h3 id=\"background-2\" translation-result=\"on\">背景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#background-2\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"background-2\">Background<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#background-2\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 Ivy 之前，指令輸入繫結總是在處理任何 DOM 繫結之前，先在自己的變更檢測過程中執行。下面是一個支援這個使用案例的實現細節：</p><p translation-origin=\"off\">Prior to Ivy, directive input bindings were always executed in their own change detection pass before any DOM bindings were processed.\nThis was an implementation detail that supported the use case in question:</p>\n\n<code-example language=\"html\">\n&lt;select [value]=\"someValue\"&gt;\n  &lt;option *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let option of options\" [value]=\"option\"&gt; {{ option }} &lt;option&gt;\n&lt;/select&gt;\n</code-example>\n<p translation-result=\"on\">它可以工作，因為在指令輸入繫結過程中會先檢查 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>，從而先建立選項。然後執行一輪 DOM 繫結，它會檢查 <code>value</code> 繫結。這時，它可以把這個值與其中一個現有選項進行匹配，並在 DOM 中設定 <code>&lt;select&gt;</code> 元素的值，以顯示該選項。</p><p translation-result=\"on\">在 Ivy 中，繫結會按範本中定義的順序進行檢查，不論它們是指令的輸入繫結還是 DOM 繫結。這種變化使得變更檢測更容易被除錯，因為繫結會按照範本中宣告的順序進行深度優先的檢查。</p><p translation-result=\"on\">在這種情況下，這意味著在檢查 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 之前，會先檢查 <code>value</code> 繫結，因為它是在範本的 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 上面宣告的。因此，<code>&lt;select&gt;</code> 元素的值會在建立任何選項之前設定，並且無法在 DOM 中匹配並顯示正確的選項。</p><p translation-origin=\"off\">It happened to work because the <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> would be checked first, during the directive input binding pass, and thus create the options first.\nThen the DOM binding pass would run, which would check the <code>value</code> binding.\nAt this time, it would be able to match the value against one of the existing options, and set the value of the <code>&lt;select&gt;</code> element in the DOM to display that option.</p>\n\n<p translation-origin=\"off\">In Ivy, bindings are checked in the order they are defined in the template, regardless of whether they are directive input bindings or DOM bindings.\nThis change makes change detection easier to reason about for debugging purposes, since bindings will be checked in depth-first order as declared in the template.</p>\n\n<p translation-origin=\"off\">In this case, it means that the <code>value</code> binding will be checked before the <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> is checked, as it is declared above the <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> in the template.\nConsequently, the value of the <code>&lt;select&gt;</code> element will be set before any options are created, and it won't be able to match and display the correct option in the DOM.</p>\n\n<h3 id=\"example-of-error-2\" translation-result=\"on\">錯誤資訊的例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#example-of-error-2\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"example-of-error-2\">Example of error<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#example-of-error-2\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">不會丟擲任何錯誤，但是問題中的 <code>&lt;select&gt;</code> 沒有在 DOM 中顯示正確的初始值。</p><p translation-origin=\"off\">There is no error thrown, but the <code>&lt;select&gt;</code> in question will not have the correct initial value displayed in the DOM.</p>\n\n<h3 id=\"recommended-fix-2\" translation-result=\"on\">推薦的修復方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#recommended-fix-2\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"recommended-fix-2\">Recommended fix<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#recommended-fix-2\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">為了解決這個問題，我們建議繫結 <code>&lt;option&gt;</code> 上的 <code>selected</code> 屬性，而不要繫結 <code>&lt;select&gt;</code> 上的 <code>value</code> 。</p><p translation-result=\"on\"><em>以前</em></p><p translation-origin=\"off\">To fix this problem, we recommend binding to the <code>selected</code> property on the <code>&lt;option&gt;</code> instead of the <code>value</code> on the <code>&lt;select&gt;</code>.</p>\n\n<p translation-origin=\"off\"><em>Before</em></p>\n\n<code-example language=\"html\">\n&lt;select [value]=\"someValue\"&gt;\n  &lt;option *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let option of options\" [value]=\"option\"&gt; {{ option }} &lt;option&gt;\n&lt;/select&gt;\n</code-example>\n<p translation-result=\"on\"><em>之後</em></p><p translation-origin=\"off\"><em>After</em></p>\n\n<code-example language=\"html\">\n&lt;select&gt;\n  &lt;option *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let option of options\" [value]=\"option\" [selected]=\"someValue == option\"&gt;\n    {{ option }}\n  &lt;option&gt;\n&lt;/select&gt;\n</code-example>\n<a id=\"forward-refs-directive-inputs\"></a>\n<h2 id=\"forward-references-to-directive-inputs-accessed-through-local-refs-are-no-longer-supported\" translation-result=\"on\">不再支援對透過本地參考存取的指令輸入屬性的前向參考。<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#forward-references-to-directive-inputs-accessed-through-local-refs-are-no-longer-supported\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"forward-references-to-directive-inputs-accessed-through-local-refs-are-no-longer-supported\">Forward references to directive inputs accessed through local refs are no longer supported.<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#forward-references-to-directive-inputs-accessed-through-local-refs-are-no-longer-supported\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"basic-example-of-change-3\" translation-result=\"on\">變更的基本例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#basic-example-of-change-3\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"basic-example-of-change-3\">Basic example of change<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#basic-example-of-change-3\"><i class=\"material-icons\">link</i></a></h3>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[myDir]',\n  exportAs: 'myDir'\n})\nexport class MyDir {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() message: string;\n}\n</code-example>\n<code-example language=\"html\">\n{{ myDir.name }}\n&lt;div myDir #myDir=\"myDir\" [name]=\"myName\"&gt;&lt;/div&gt;\n</code-example>\n<p translation-result=\"on\">在 View Engine 的執行時，上面的程式碼會打印出這個名字而不會出現任何錯誤。在 Ivy 中， <code>myDir.name</code> 繫結會丟擲一個 <code>ExpressionChangedAfterItHasBeenCheckedError</code> 。</p><p translation-origin=\"off\">In the View Engine runtime, the above code would print out the name without any errors.\nIn Ivy, the <code>myDir.name</code> binding will throw an <code>ExpressionChangedAfterItHasBeenCheckedError</code>.</p>\n\n<h3 id=\"background-3\" translation-result=\"on\">背景<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#background-3\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"background-3\">Background<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#background-3\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 ViewEngine 的執行時裡，指令輸入繫結和元素繫結是在不同的階段執行的。 Angular 會全域處理範本，先只檢查指令的輸入（比如 <code>[name]</code> ），然後再針對元素和文字的繫結（比如 <code>{{ myDir.name }}</code> ）處理整個範本。這意味著在 <code>myDir.name</code> 文字繫結之前會檢查 <code>name</code> 指令的輸入，儘管它們在範本中有相對的順序，但有些使用者會覺得這樣違反直覺。</p><p translation-result=\"on\">相比之下，Ivy 只會在一輪中對範本進行處理，因此會按照它們在範本中編寫的順序來檢查繫結。在這種情況下，這意味著在輸入屬性 <code>name</code> 設定該指令的屬性之前，會檢查 <code>myDir.name</code> 繫結（因此它將是 <code>undefined</code>）。<code>myDir.name</code> 屬性的值是在下一次變更檢測過程的執行時設定的，所以會丟擲一個變更檢測錯誤。</p><p translation-origin=\"off\">In the ViewEngine runtime, directive input bindings and element bindings were executed in different stages. Angular would process the template one full time to check directive inputs only (e.g. <code>[name]</code>), then process the whole template again to check element and text bindings only (e.g.<code>{{ myDir.name }}</code>). This meant that the <code>name</code> directive input would be checked before the <code>myDir.name</code> text binding despite their relative order in the template, which some users felt to be counterintuitive.</p>\n\n<p translation-origin=\"off\">In contrast, Ivy processes the template in just one pass, so that bindings are checked in the same order that they are written in the template. In this case, it means that the <code>myDir.name</code> binding will be checked before the <code>name</code> input sets the property on the directive (and thus it will be <code>undefined</code>). Since the <code>myDir.name</code> property will be set by the time the next change detection pass runs, a change detection error is thrown.</p>\n\n<h3 id=\"example-of-error-3\" translation-result=\"on\">錯誤資訊的例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#example-of-error-3\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"example-of-error-3\">Example of error<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#example-of-error-3\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">假設 <code>myName</code> 的值是 <code>Angular</code> ，你會看到一個類別似這樣的錯誤</p><p translation-origin=\"off\">Assuming that the value for <code>myName</code> is <code>Angular</code>, you should see an error that looks like</p>\n\n<code-example>\nError: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: 'undefined'. Current value: 'Angular'.\n</code-example>\n<h3 id=\"recommended-fix-3\" translation-result=\"on\">推薦的修復方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#recommended-fix-3\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"recommended-fix-3\">Recommended fix<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#recommended-fix-3\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">為了解決這個問題，我們建議你直接從宿主元件中獲取繫結的資訊（比如我們這個例子中的 <code>myName</code> 屬性），或者把資料繫結移到指令宣告之後，以便初始值在第一輪中就是可用的。</p><p translation-result=\"on\"><em>以前</em></p><p translation-origin=\"off\">To fix this problem, we recommend either getting the information for the binding directly from the host component (e.g. the <code>myName</code> property from our example) or to move the data binding after the directive has been declared so that the initial value is available on the first pass.</p>\n\n<p translation-origin=\"off\"><em>Before</em></p>\n\n<code-example language=\"html\">\n{{ myDir.name }}\n&lt;div myDir #myDir=\"myDir\" [name]=\"myName\"&gt;&lt;/div&gt;\n</code-example>\n<p translation-result=\"on\"><em>之後</em></p><p translation-origin=\"off\"><em>After</em></p>\n\n<code-example language=\"html\">\n{{ myName }}\n&lt;div myDir [name]=\"myName\"&gt;&lt;/div&gt;\n</code-example>\n<a id=\"foreign-values\"></a>\n<h2 id=\"foreign-functions-and-foreign-values-arent-statically-resolvable\">Foreign functions and foreign values aren't statically resolvable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#foreign-functions-and-foreign-values-arent-statically-resolvable\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"basic-example-of-change-4\">Basic example of change<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#basic-example-of-change-4\"><i class=\"material-icons\">link</i></a></h3>\n<p>Consider a library that defines and exports some selector string to be used in other libraries:</p>\n<code-example>\nexport let mySelector = '[my-selector]';\n</code-example>\n<p>This selector is then imported in another library or an application:</p>\n<code-example>\nimport {mySelector} from 'my-library';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: mySelector})\nexport class MyDirective {}\n</code-example>\n<p>Because the <code>mySelector</code> value is imported from an external library, it is part of a different compilation unit and therefore considered <em>foreign</em>.</p>\n<p>While this code would work correctly in the View Engine compiler, it would fail to compile in Ivy in AOT mode.</p>\n<h3 id=\"background-4\">Background<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#background-4\"><i class=\"material-icons\">link</i></a></h3>\n<p>In View Engine, the compiler would capture the source code of a library in <code>metadata.json</code> files when bundling the library, so that external consumers could \"look inside\" the source code of an external library.\nWhen AOT-compiling the application, the <code>metadata.json</code> files would be used to determine the value of <code>mySelector</code>.\nIn Ivy, the <code>metadata.json</code> files are no longer used. Instead, the compiler extracts metadata for external libraries from the <code>.d.ts</code> files that TypeScript creates.\nThis has several benefits such as better performance, much improved error reporting, and enables more build caching opportunities as there is no longer a dependency on library internals.</p>\n<p>Looking back at the previous example, the <code>mySelector</code> value would be represented in the <code>.d.ts</code> as follows:</p>\n<code-example>\nexport declare let mySelector: string;\n</code-example>\n<p>Notice that the actual value of the selector is no longer present, so that the Ivy compiler is unable to use it during AOT compilations.</p>\n<h3 id=\"example-of-error-4\">Example of error<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#example-of-error-4\"><i class=\"material-icons\">link</i></a></h3>\n<p>In the above example, a compilation error would occur when compiling <code>MyDirective</code>:</p>\n<code-example>\nerror NG1010: selector must be a string\n  Value is a reference to 'mySelector'.\n\n    1  export declare let mySelector: string;\n                          ~~~~~~~~~~\n    Reference is declared here.\n\n</code-example>\n<h3 id=\"recommended-fix-4\">Recommended fix<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility-examples#recommended-fix-4\"><i class=\"material-icons\">link</i></a></h3>\n<p>When exporting values from a library, ensure the actual value is present in the <code>.d.ts</code> file. This typically requires that the variable be declared as a constant:</p>\n<code-example>\nexport const mySelector = '[my-selector]';\n</code-example>\n<p>In classes, a field should be declared using the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> readonly</code> modifiers:</p>\n<code-example>\nexport class Selectors {\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> readonly mySelector = '[my-selector]';\n}\n</code-example>\n\n  \n</div>\n\n\n<!-- links to this doc:\n - guide/ivy-compatibility\n-->\n<!-- links from this doc:\n - api/common/NgClass\n - api/common/NgForOf\n - api/core/ContentChildren\n - api/core/Directive\n - api/core/ElementRef\n - api/core/Inject\n - api/core/Injectable\n - api/core/Input\n - api/core/QueryList\n - api/core/ViewContainerRef\n - api/upgrade/static\n - guide/ivy-compatibility-examples#all-classes-that-use-angular-di-must-have-an-angular-class-level-decorator\n - guide/ivy-compatibility-examples#background\n - guide/ivy-compatibility-examples#background-1\n - guide/ivy-compatibility-examples#background-2\n - guide/ivy-compatibility-examples#background-3\n - guide/ivy-compatibility-examples#background-4\n - guide/ivy-compatibility-examples#basic-example-of-change\n - guide/ivy-compatibility-examples#basic-example-of-change-1\n - guide/ivy-compatibility-examples#basic-example-of-change-2\n - guide/ivy-compatibility-examples#basic-example-of-change-3\n - guide/ivy-compatibility-examples#basic-example-of-change-4\n - guide/ivy-compatibility-examples#cannot-bind-to-value-property-of-select-with-ngfor\n - guide/ivy-compatibility-examples#contentchildren-queries-only-match-direct-children-by-default\n - guide/ivy-compatibility-examples#example-of-error\n - guide/ivy-compatibility-examples#example-of-error-1\n - guide/ivy-compatibility-examples#example-of-error-2\n - guide/ivy-compatibility-examples#example-of-error-3\n - guide/ivy-compatibility-examples#example-of-error-4\n - guide/ivy-compatibility-examples#foreign-functions-and-foreign-values-arent-statically-resolvable\n - guide/ivy-compatibility-examples#forward-references-to-directive-inputs-accessed-through-local-refs-are-no-longer-supported\n - guide/ivy-compatibility-examples#ivy-compatibility-examples\n - guide/ivy-compatibility-examples#recommended-fix\n - guide/ivy-compatibility-examples#recommended-fix-1\n - guide/ivy-compatibility-examples#recommended-fix-2\n - guide/ivy-compatibility-examples#recommended-fix-3\n - guide/ivy-compatibility-examples#recommended-fix-4\n - guide/migration-injectable\n - guide/migration-undecorated-classes\n - guide/migration-undecorated-classes#what-does-it-mean-to-have-a-directive-decorator-with-no-metadata-inside-of-it\n - https://github.com/ng-docs/angular-cn/edit/aio/aio/content/guide/ivy-compatibility-examples.md?message=docs%3A%20請簡述你的修改...\n-->"}