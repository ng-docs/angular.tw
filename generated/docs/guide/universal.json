{"id":"guide/universal","title":"Server-side rendering (SSR) with Angular Universal","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/universal.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"server-side-rendering-ssr-with-angular-universal\" translation-result=\"on\">Angular Universal：Angular 統一平台簡介<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#server-side-rendering-ssr-with-angular-universal\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Server-side rendering (SSR) with Angular Universal<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#server-side-rendering-ssr-with-angular-universal\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">本指南介紹 <strong>Angular Universal</strong>，一種允許 Angular 在伺服器端渲染應用程式的技術。</p><p translation-origin=\"off\">This guide describes <strong>Angular Universal</strong>, a technology that allows Angular to render applications on the server.</p>\n\n<p translation-result=\"on\">預設情況下，Angular 僅在<em>瀏覽器</em>中渲染應用程式。Angular Universal 允許 Angular 在<em>伺服器</em>上渲染應用程式，產生<em>靜態</em>HTML 內容，以表達應用程式狀態。一旦 HTML 內容在瀏覽器中渲染，Angular 就會引導應用程式並複用伺服器產生的 HTML 中可用的資訊。</p><p translation-origin=\"off\">By default, Angular renders applications only in a <em>browser</em>. Angular Universal allows Angular to render an application on the <em>server</em>, generating <em>static</em> HTML contents, which represents an application state. Once the HTML contents is rendered in a browser, Angular bootstraps an application and reuses the information available in the server-generated HTML.</p>\n\n<p translation-result=\"on\">使用伺服器端渲染，應用程式通常可以更快地在瀏覽器中渲染，讓使用者有機會在應用程式 UI 變得可完全互動之前檢視它。有關其他資訊，請參閱下面的（ <a href=\"guide/universal#why-do-it\">“為什麼使用伺服器端渲染？”部分</a>）。</p><p translation-origin=\"off\">With server-side rendering an application generally renders in a browser faster, giving users a chance to view the application UI before it becomes fully interactive. See (<a href=\"guide/universal#why-do-it\">the \"Why use Server-Side Rendering?\" section</a>) below for addition information.</p>\n\n<p translation-result=\"on\">另外，要更詳細地瞭解圍繞 SSR 的不同技術和概念，請檢視這篇<a href=\"https://developers.google.com/web/updates/2019/02/rendering-on-the-web\">文章</a>。</p><p translation-origin=\"off\">Also for a more detailed look at different techniques and concepts surrounding SSR, check out this <a href=\"https://developers.google.com/web/updates/2019/02/rendering-on-the-web\">article</a>.</p>\n\n<p translation-result=\"on\">你可以使用 <code>@nguniversal/express-engine</code> 原理圖在你的 Angular 應用程式中啟用伺服器端渲染，如下所述。</p><p translation-origin=\"off\">You can enable server-side rendering in your Angular application using the <code>@nguniversal/express-engine</code> schematic as described below.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">Angular Universal 要求使用 Node.js 的<a href=\"https://nodejs.org/about/releases\">活躍期 LTS 版本或維護期 LTS 版本</a>。有關資訊，請檢視<a href=\"guide/versions\">版本相容性</a>指南，瞭解當前支援的版本。</p><p translation-origin=\"off\">Angular Universal requires an <a href=\"https://nodejs.org/about/releases\">active LTS or maintenance LTS</a> version of Node.js.\nFor information see the <a href=\"guide/versions\">version compatibility</a> guide to learn about the currently supported versions.</p>\n\n</div>\n<p><a id=\"the-example\"></a></p>\n<h2 id=\"universal-tutorial\" translation-result=\"on\">Universal 課程<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#universal-tutorial\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Universal tutorial<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#universal-tutorial\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><a href=\"tutorial/tour-of-heroes\">英雄之旅課程</a>是本演練的基礎。</p><p translation-origin=\"off\">The <a href=\"tutorial/tour-of-heroes\">Tour of Heroes tutorial</a> is the foundation for this walkthrough.</p>\n\n<p translation-result=\"on\">在這個例子中，Angular CLI 使用 <a href=\"guide/aot-compiler\">預先（AoT）編譯器</a>編譯並打包了該應用的 Universal 版本。Node.js Express Web 伺服器則會根據客戶端的請求，利用 Universal 編譯 HTML 頁面。</p><p translation-origin=\"off\">In this example, the Angular CLI compiles and bundles the Universal version of the application with the <a href=\"guide/aot-compiler\">Ahead-of-Time (AOT) compiler</a>.\nA Node.js Express web server compiles HTML pages with Universal based on client requests.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><live-example downloadonly=\"\">下載完成的範例程式碼</live-example>，它要在一個 <a href=\"https://expressjs.com\">Node.js® Express</a> 伺服器上執行。</p><p translation-origin=\"off\"><live-example downloadonly=\"\">Download the finished sample code</live-example>, which runs in a <a href=\"https://expressjs.com\">Node.js® Express</a> server.</p>\n\n</div>\n<h3 id=\"step-1-enable-server-side-rendering\" translation-result=\"on\">步驟 1. 啟用伺服器端渲染<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#step-1-enable-server-side-rendering\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Step 1. Enable Server-Side Rendering<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#step-1-enable-server-side-rendering\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">執行以下命令為你的應用程式新增 SSR 支援：</p><p translation-origin=\"off\">Run the following command to add SSR support into your application:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng add @nguniversal/express-engine\n\n</code-example>\n<p translation-result=\"on\">該命令會更新應用程式程式碼以啟用 SSR 並將額外檔案（標有 <code>*</code> 符號的檔案）新增到專案結構中。</p><p translation-origin=\"off\">The command updates the application code to enable SSR and adds extra files to the project structure (files that are marked with the <code>*</code> symbol).</p>\n\n<div class=\"filetree\">\n    <div class=\"file\">\n        src\n    </div>\n    <div class=\"children\">\n        <div class=\"file\">\n          index.html &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt;-- app web page\n        </div>\n        <div class=\"file\">\n          main.ts &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt;-- bootstrapper for client app\n        </div>\n        <div class=\"file\">\n          main.server.ts &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt;-- * bootstrapper for server app\n        </div>\n        <div class=\"file\">\n          style.css &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt;-- styles for the app\n        </div>\n        <div class=\"file\">\n          app/ &nbsp;… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt;-- application code\n        </div>\n        <div class=\"children\">\n            <div class=\"file\">\n              app.config.ts &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt; client-side application configuration (standalone app only)\n            </div>\n            <div class=\"file\">\n              app.module.ts &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt; client-side application module (NgModule app only)\n            </div>\n        </div>\n        <div class=\"children\">\n            <div class=\"file\">\n              app.config.server.ts &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt;-- * server-side application configuration (standalone app only)\n            </div>\n            <div class=\"file\">\n              app.module.server.ts &nbsp;&nbsp;&nbsp; // &lt;-- * server-side application module (NgModule app only)\n            </div>\n        </div>\n        <div class=\"file\">\n          server.ts &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt;-- * express web server\n        </div>\n        <div class=\"file\">\n          tsconfig.json &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt;-- TypeScript base configuration\n        </div>\n        <div class=\"file\">\n          tsconfig.app.json &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt;-- TypeScript browser application configuration\n        </div>\n        <div class=\"file\">\n          tsconfig.server.json &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt;-- TypeScript server application configuration\n        </div>\n        <div class=\"file\">\n          tsconfig.spec.json &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // &lt;-- TypeScript tests configuration\n        </div>\n    </div>\n</div>\n<h3 id=\"step-2-enable-client-hydration\" translation-result=\"on\">步驟 2. 啟用客戶端水合<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#step-2-enable-client-hydration\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Step 2. Enable Client Hydration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#step-2-enable-client-hydration\"><i class=\"material-icons\">link</i></a></h3>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">水合功能已經提供了<a href=\"/guide/releases#developer-preview\">開發者預覽版</a>。你已經可以嘗試使用它了，但在穩定之前可能會發生變化。</p><p translation-origin=\"off\">The hydration feature is available for <a href=\"/guide/releases#developer-preview\">developer preview</a>. It's ready for you to try, but it might change before it is stable.</p>\n\n</div>\n<p translation-result=\"on\">水合是在客戶端還原伺服器端渲染的應用程式的過程。這包括複用伺服器端渲染的 DOM 結構、持久化應用程式狀態、傳輸伺服器已經檢索到的應用程式資料，以及另外一些過程。在<a href=\"guide/hydration\">本指南</a>中瞭解更多關於水合的資訊。</p><p translation-origin=\"off\">Hydration is the process that restores the server side rendered application on the client. This includes things like reusing the server rendered DOM structures, persisting the application state, transferring application data that was retrieved already by the server, and other processes. Learn more about hydration in <a href=\"guide/hydration\">this guide</a>.</p>\n\n<p translation-result=\"on\">你可以透過更新 <code>app.module.ts</code> 檔案來啟用水合。從 <code>@angular/platform-browser</code> 匯入 <code><a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a></code> 函式，並將函式呼叫新增到 <code>AppModule</code> 的 <code>providers</code> 部分，如下所示。</p><p translation-origin=\"off\">You can enable hydration by updating the <code>app.module.ts</code> file. Import the <code><a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a></code> function from <code>@angular/platform-browser</code> and add the function call to the <code>providers</code> section of the <code>AppModule</code> as shown below.</p>\n\n<code-example language=\"typescript\">\nimport {<a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a>} from '@angular/platform-browser';\n// ...\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  // ...\n  providers: [ <a href=\"api/platform-browser/provideClientHydration\" class=\"code-anchor\">provideClientHydration</a>() ],  // add this line\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {\n  // ...\n}\n</code-example>\n<h3 id=\"step-3-start-the-server\" translation-result=\"on\">步驟 3. 啟動伺服器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#step-3-start-the-server\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Step 3. Start the server<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#step-3-start-the-server\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">要使用 Universal 在本地系統中渲染你的應用，請使用如下命令。</p><p translation-origin=\"off\">To start rendering your application with Universal on your local system, use the following command.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nnpm run dev:ssr\n\n</code-example>\n<h3 id=\"step-4-run-your-application-in-a-browser\" translation-result=\"on\">第 4 步. 在瀏覽器中執行你的應用程式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#step-4-run-your-application-in-a-browser\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Step 4. Run your application in a browser<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#step-4-run-your-application-in-a-browser\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Web 伺服器啟動後，開啟瀏覽器並導航到 <code>http://localhost:4200</code>。你應該會看到熟悉的 Tour of Heroes 儀表板頁面。</p><p translation-origin=\"off\">Once the web server starts, open a browser and navigate to <code>http://localhost:4200</code>.\nYou should see the familiar Tour of Heroes dashboard page.</p>\n\n<p translation-result=\"on\">透過 <code>routerLinks</code> 導航時能正常工作，因為它們使用的是內建的連結元素（<code>&lt;a&gt;</code>）。你可以從儀表盤進入 英雄列表頁面，然後返回。你可以點選儀表盤頁面上的一個英雄來顯示他的詳情頁面。</p><p translation-origin=\"off\">Navigation using <code>routerLinks</code> works correctly because they use the built-in anchor (<code>&lt;a&gt;</code>) elements.\nYou can go from the Dashboard to the Heroes page and back.\nClick a hero on the Dashboard page to display its Details page.</p>\n\n<p translation-result=\"on\">如果你限制下網速（稍後會講操作步驟），讓客戶端指令碼下載時間變長，你會注意到：</p><p translation-origin=\"off\">If you throttle your network speed so that the client-side scripts take longer to download (instructions following), you'll notice:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">你無法新增或刪除英雄</p><p translation-origin=\"off\">You can't add or delete a hero</p>\n\n</li>\n<li>\n<p translation-result=\"on\">儀表盤頁面上的搜尋框會被忽略</p><p translation-origin=\"off\">The search box on the Dashboard page is ignored</p>\n\n</li>\n<li>\n<p translation-result=\"on\">“詳情”頁面上的<em>後退</em>和<em>儲存</em>按鈕不起作用</p><p translation-origin=\"off\">The <em>Back</em> and <em>Save</em> buttons on the Details page don't work</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">在開發機器上，從伺服器端渲染的應用過渡到客戶端應用的過程會很快，但是你還是應該在實際場景中測試一下你的應用。</p><p translation-origin=\"off\">The transition from the server-rendered application to the client application happens quickly on a development machine, but you should always test your applications in real-world scenarios.</p>\n\n<p translation-result=\"on\">你可以透過模擬速度較慢的網路來更清晰地看到這種轉換，如下所示：</p><p translation-origin=\"off\">You can simulate a slower network to see the transition more clearly as follows:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">開啟 Chrome 開發者工具，進入 Network 標籤頁。</p><p translation-origin=\"off\">Open the Chrome Dev Tools and go to the Network tab.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">找一下選單欄最右側的 <a href=\"https://developers.google.com/web/tools/chrome-devtools/network-performance/reference#throttling\">Network Throttling</a> 下拉選單。</p><p translation-origin=\"off\">Find the <a href=\"https://developers.google.com/web/tools/chrome-devtools/network-performance/reference#throttling\">Network Throttling</a> dropdown on the far right of the menu bar.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">嘗試一下 “3G” 的速度吧。</p><p translation-origin=\"off\">Try one of the \"3G\" speeds.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">伺服器端渲染的應用仍然可以快速啟動，但完整的客戶端應用可能需要幾秒鐘才能載入完。</p><p translation-origin=\"off\">The server-rendered application still launches quickly but the full client application might take seconds to load.</p>\n\n<p><a id=\"why-do-it\"></a></p>\n<h2 id=\"why-use-server-side-rendering\" translation-result=\"on\">為何需要伺服器端渲染？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#why-use-server-side-rendering\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Why use Server-Side Rendering?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#why-use-server-side-rendering\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">有三個主要的理由來為你的應用建立一個 Universal 版本。</p><p translation-origin=\"off\">There are three main reasons to create a Universal version of your application.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">透過<a href=\"https://static.googleusercontent.com/media/www.google.com/en//webmasters/docs/search-engine-optimization-starter-guide.pdf\">搜尋引擎最佳化（SEO）</a>來幫助網路爬蟲。</p><p translation-origin=\"off\">Facilitate web crawlers through <a href=\"https://static.googleusercontent.com/media/www.google.com/en//webmasters/docs/search-engine-optimization-starter-guide.pdf\">search engine optimization (SEO)</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\">提升手機和低功耗裝置上的效能</p><p translation-origin=\"off\">Improve performance on mobile and low-powered devices</p>\n\n</li>\n<li>\n<p translation-result=\"on\">迅速顯示出第一個支援<a href=\"https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint\">首次內容繪製（FCP）</a>的頁面</p><p translation-origin=\"off\">Show the first page quickly with a <a href=\"https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint\">first-contentful paint (FCP)</a></p>\n\n</li>\n</ul>\n<p><a id=\"seo\"></a>\n<a id=\"web-crawlers\"></a></p>\n<h3 id=\"facilitate-web-crawlers-seo\" translation-result=\"on\">幫助網路爬蟲（SEO）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#facilitate-web-crawlers-seo\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Facilitate web crawlers (SEO)<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#facilitate-web-crawlers-seo\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">Google、Bing、Facebook、Twitter 和其它社交媒體網站都依賴網路爬蟲去索引你的應用內容，並且讓它的內容可以透過網路搜尋到。這些網路爬蟲可能不會像人類那樣導航到你的具有高度互動性的 Angular 應用，併為其建立索引。</p><p translation-origin=\"off\">Google, Bing, Facebook, Twitter, and other social media sites rely on web crawlers to index your application content and make that content searchable on the web.\nThese web crawlers might be unable to navigate and index your highly interactive Angular application as a human user could do.</p>\n\n<p translation-result=\"on\">Angular Universal 可以為你產生應用的靜態版本，它易搜尋、可連結，瀏覽時也不必藉助 JavaScript。它也讓站點可以被預覽，因為每個 URL 返回的都是一個完全渲染好的頁面。</p><p translation-origin=\"off\">Angular Universal can generate a static version of your application that is easily searchable, linkable, and navigable without JavaScript.\nUniversal also makes a site preview available because each URL returns a fully rendered page.</p>\n\n<p><a id=\"no-javascript\"></a></p>\n<h3 id=\"improve-performance-on-mobile-and-low-powered-devices\" translation-result=\"on\">提升手機和低功耗裝置上的效能<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#improve-performance-on-mobile-and-low-powered-devices\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Improve performance on mobile and low-powered devices<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#improve-performance-on-mobile-and-low-powered-devices\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">有些裝置不支援 JavaScript 或 JavaScript 執行得很差，導致使用者體驗不可接受。對於這些情況，你可能會需要該應用的伺服器端渲染的、無 JavaScript 的版本。雖然有一些限制，不過這個版本可能是那些完全沒辦法使用該應用的人的唯一選擇。</p><p translation-origin=\"off\">Some devices don't support JavaScript or execute JavaScript so poorly that the user experience is unacceptable.\nFor these cases, you might require a server-rendered, no-JavaScript version of the application.\nThis version, however limited, might be the only practical alternative for people who otherwise couldn't use the application at all.</p>\n\n<p><a id=\"startup-performance\"></a></p>\n<h3 id=\"show-the-first-page-quickly\" translation-result=\"on\">快速顯示第一頁<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#show-the-first-page-quickly\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Show the first page quickly<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#show-the-first-page-quickly\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">快速顯示第一頁對於吸參考戶是至關重要的。載入速度更快的頁面效果更好，<a href=\"https://web.dev/shopping-for-speed-on-ebay/\">即使其差異只有 100 毫秒也是如此</a>。你的應用要啟動得更快一點，以便在使用者決定做別的事情之前吸引他們的注意力。</p><p translation-origin=\"off\">Displaying the first page quickly can be critical for user engagement.\nPages that load faster perform better, <a href=\"https://web.dev/shopping-for-speed-on-ebay\">even with changes as small as 100ms</a>.\nYour application might have to launch faster to engage these users before they decide to do something else.</p>\n\n<p translation-result=\"on\">使用 Angular Universal，你可以為應用產生“著陸頁”，它們看起來就和完整的應用一樣。這些著陸頁是純 HTML，並且即使 JavaScript 被禁用了也能顯示。這些頁面不會處理瀏覽器事件，不過它們<em>可以</em>用 <code>[<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>](guide/router-reference#router-link)</code> 在這個網站中導航。</p><p translation-origin=\"off\">With Angular Universal, you can generate landing pages for the application that look like the complete application.\nThe pages are pure HTML, and can display even if JavaScript is disabled.\nThe pages don't handle browser events, but they <em>do</em> support navigation through the site using <a href=\"guide/router-reference#router-link\"><code>routerLink</code></a>.</p>\n\n<p translation-result=\"on\">在實踐中，你可能要使用一個著陸頁的靜態版本來保持使用者的注意力。同時，你也會在幕後載入完整的 Angular 應用。使用者會覺得著陸頁幾乎是立即出現的，而當完整的應用載入完之後，又可以獲得完整的互動體驗。</p><p translation-origin=\"off\">In practice, you'll serve a static version of the landing page to hold the user's attention.\nAt the same time, you'll load the full Angular application behind it.\nThe user perceives near-instant performance from the landing page and gets the full interactive experience after the full application loads.</p>\n\n<p><a id=\"how-does-it-work\"></a></p>\n<h2 id=\"universal-web-servers\" translation-result=\"on\">Universal Web 伺服器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#universal-web-servers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Universal web servers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#universal-web-servers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Universal Web 伺服器使用 <a href=\"guide/universal#universal-engine\">Universal 範本引擎</a>渲染出的靜態 HTML 來響應對應用頁面的請求。伺服器接收並響應來自客戶端（通常是瀏覽器）的 HTTP 請求，並回復靜態檔案，如指令碼、CSS 和圖片。\n它可以直接響應資料請求，也可以作為獨立資料伺服器的代理進行響應。</p><p translation-origin=\"off\">A Universal web server responds to application page requests with static HTML rendered by the <a href=\"guide/universal#universal-engine\">Universal template engine</a>.\nThe server receives and responds to HTTP requests from clients (usually browsers), and serves static assets such as scripts, CSS, and images.\nIt might respond to data requests, either directly or as a proxy to a separate data server.</p>\n\n<p translation-result=\"on\">這個例子中的範例 Web 伺服器是基於常見的 <a href=\"https://expressjs.com\">Express</a> 框架的。</p><p translation-origin=\"off\">The sample web server for this guide is based on the popular <a href=\"https://expressjs.com\">Express</a> framework.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>: <br>\n只要能夠呼叫Angular <code>platform-server</code>套件的 <a href=\"api/platform-server/renderModule\"><code>renderModule</code></a>或<a href=\"api/platform-server/renderApplication\"><code>renderApplication</code></a> 函式，<em>任何</em> Web 伺服器技術都可以作為 Universal 伺服器。這裡討論的原則和決策點適用於任何 Web 伺服器技術。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\n<em>Any</em> web server technology can serve a Universal application as long as it can call Angular <code>platform-server</code> package <a href=\"api/platform-server/renderModule\"><code>renderModule</code></a> or <a href=\"api/platform-server/renderApplication\"><code>renderApplication</code></a> functions.\nThe principles and decision points discussed here apply to any web server technology.</p>\n\n</div>\n<p translation-result=\"on\">Universal 應用使用 <code>platform-server</code> 套件（而不是 <code>platform-browser</code>），它提供了 DOM 的伺服器端實現、<code>XMLHttpRequest</code> 以及其它不依賴瀏覽器的底層特性。</p><p translation-origin=\"off\">Universal applications use the Angular <code>platform-server</code> package (as opposed to <code>platform-browser</code>), which provides\nserver implementations of the DOM, <code>XMLHttpRequest</code>, and other low-level features that don't rely on a browser.</p>\n\n<p translation-result=\"on\">伺服器（這個例子中使用的是 <a href=\"https://expressjs.com\">Node.js Express</a> 伺服器）會把客戶端對應用頁面的請求傳給 NgUniversal 的 <code>ngExpressEngine</code>。在內部實現上，它會呼叫 Universal 的渲染函式，它還提供了快取等有用的工具函式。</p><p translation-origin=\"off\">The server (<a href=\"https://expressjs.com\">Node.js Express</a> in this guide's example) passes client requests for application pages to the NgUniversal <code>ngExpressEngine</code>.\nUnder the hood, the render functions, while providing caching and other helpful utilities.</p>\n\n<p translation-result=\"on\">渲染函式接受一個<em>範本</em> HTML 頁面（通常是 <code>index.html</code>）、一個包含元件的 Angular <em>模組</em>、一個能在呼叫時返回解析出 <code><a href=\"api/core/ApplicationRef\" class=\"code-anchor\">ApplicationRef</a></code> 型 <code>Promise</code> 的函式，和一個用於決定該顯示哪些元件的<em>路由</em>作為輸入。該路由會從客戶端的請求中傳給伺服器。</p><p translation-origin=\"off\">The render functions takes as inputs a <em>template</em> HTML page (usually <code>index.html</code>), and Angular <em>module</em> containing components or a function that when invoked returns a <code>Promise</code> that resolves to an <code><a href=\"api/core/ApplicationRef\" class=\"code-anchor\">ApplicationRef</a></code>, and a <em>route</em> that determines which components to display. The route comes from the client's request to the server.</p>\n\n<p translation-result=\"on\">每次請求都會給出所請求路由的一個適當的檢視。渲染函式會在範本中的 <code>&lt;app&gt;</code> 標記中渲染出這個檢視，併為客戶端建立一個完成的 HTML 頁面。</p><p translation-origin=\"off\">Each request results in the appropriate view for the requested route.\nThe render function renders the view within the <code>&lt;app&gt;</code> tag of the template, creating a finished HTML page for the client.</p>\n\n<p translation-result=\"on\">最後，伺服器就會把渲染好的頁面返回給客戶端。</p><p translation-origin=\"off\">Finally, the server returns the rendered page to the client.</p>\n\n<h3 id=\"working-around-the-browser-apis\" translation-result=\"on\">使用瀏覽器 API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#working-around-the-browser-apis\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Working around the browser APIs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#working-around-the-browser-apis\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">由於 Universal 應用並沒有執行在瀏覽器中，因此該伺服器上可能會缺少瀏覽器的某些 API 和其它能力。</p><p translation-origin=\"off\">Because a Universal application doesn't execute in the browser, some of the browser APIs and capabilities might be missing on the server.</p>\n\n<p translation-result=\"on\">比如，伺服器端應用不能參考瀏覽器獨有的全域物件，比如 <code>window</code>、<code>document</code>、<code>navigator</code> 或 <code>location</code>。</p><p translation-origin=\"off\">For example, server-side applications can't reference browser-only global objects such as <code>window</code>, <code>document</code>, <code>navigator</code>, or <code>location</code>.</p>\n\n<p translation-result=\"on\">Angular 提供了一些這些物件的可注入的抽象層，比如 <a href=\"api/common/Location\"><code>Location</code></a> 或 <a href=\"api/common/DOCUMENT\"><code>DOCUMENT</code></a>，它可以作為你所呼叫的 API 的等效替身。如果 Angular 沒有提供它，你也可以寫一個自己的抽象層，當在瀏覽器中執行時，就把它委託給瀏覽器 API，當它在伺服器中執行時，就提供一個符合要求的代用實現（也叫墊片 - shimming）。</p><p translation-origin=\"off\">Angular provides some injectable abstractions over these objects, such as <a href=\"api/common/Location\"><code>Location</code></a> or <a href=\"api/common/DOCUMENT\"><code>DOCUMENT</code></a>; it might substitute adequately for these APIs.\nIf Angular doesn't provide it, it's possible to write new abstractions that delegate to the browser APIs while in the browser and to an alternative implementation while on the server (also known as shimming).</p>\n\n<p translation-result=\"on\">同樣，由於沒有滑鼠或鍵盤事件，因此伺服器端應用也不能依賴於使用者點選某個按鈕來顯示某個元件。此應用必須僅僅根據客戶端過來的請求決定要渲染的內容。把該應用做成<a href=\"guide/router\">可路由的</a>，就是一種好方案。</p><p translation-origin=\"off\">Similarly, without mouse or keyboard events, a server-side application can't rely on a user clicking a button to show a component.\nThe application must determine what to render based solely on the incoming client request.\nThis is a good argument for making the application <a href=\"guide/router\">routable</a>.</p>\n\n<p><a id=\"service-worker\"></a></p>\n<h3 id=\"universal-and-the-angular-service-worker\" translation-result=\"on\">Universal 和 Angular Service Worker<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#universal-and-the-angular-service-worker\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Universal and the Angular Service Worker<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#universal-and-the-angular-service-worker\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你將 Universal 與 Angular Service Worker 結合使用，則其行為將不同於正常的伺服器端渲染行為。初始伺服器請求將按預期在伺服器端渲染。但是，在該初始請求之後，後續請求將交給 Service Worker 處理。對於後續請求來說，<code>index.html</code> 檔案是靜態提供的並繞過伺服器端渲染。</p><p translation-origin=\"off\">If you are using Universal in conjunction with the Angular service worker, the behavior is different than the normal server side rendering behavior. The initial server request will be rendered on the server as expected. However, after that initial request, subsequent requests are handled by the service worker. For subsequent requests, the <code>index.html</code> file is served statically and bypasses server side rendering.</p>\n\n<p><a id=\"universal-engine\"></a></p>\n<h3 id=\"universal-template-engine\" translation-result=\"on\">Universal 範本引擎<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#universal-template-engine\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Universal template engine<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#universal-template-engine\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>server.ts</code> 檔案中最重要的部分是 <code>ngExpressEngine()</code> 函式。</p><p translation-origin=\"off\">The important bit in the <code>server.ts</code> file is the <code>ngExpressEngine()</code> function.</p>\n\n<code-example header=\"server.ts\" path=\"universal/server.ts\" region=\"ngExpressEngine\">\n// Our Universal express-engine (found @ https://github.com/angular/universal/tree/main/modules/express-engine)\nserver.engine('html', ngExpressEngine({\n  bootstrap: AppServerModule,\n}));\n\n</code-example>\n<p translation-result=\"on\"><code>ngExpressEngine()</code> 函式是 Angular <code>platform-server</code> 包 <a href=\"api/platform-server/renderModule\"><code>renderModule</code></a> 和 <a href=\"api/platform-server/renderApplication\"><code>renderApplication</code></a> 函式的包裝器，它將客戶端的請求轉換為伺服器端渲染的 HTML 頁面。</p><p translation-origin=\"off\">The <code>ngExpressEngine()</code> function is a wrapper around the Angular <code>platform-server</code> package <a href=\"api/platform-server/renderModule\"><code>renderModule</code></a> and <a href=\"api/platform-server/renderApplication\"><code>renderApplication</code></a> functions which turns a client's requests into server-rendered HTML pages.</p>\n\n<p translation-result=\"on\"><code>ngExpressEngine()</code> 是對 Universal 的 <code><a href=\"api/platform-server/renderModule\" class=\"code-anchor\">renderModule</a>()</code> 函式的封裝。它會把客戶端請求轉換成伺服器端渲染的 HTML 頁面。它接受一個具有下列屬性的物件：</p><p translation-origin=\"off\">It accepts an object with the following properties:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">屬性</nt-wrapper><nt-wrapper translation-origin=\"off\">Properties</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>bootstrap</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">根 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 或函式在呼叫時會返回一個 <code>Promise</code>，該 Promise 在伺服器端渲染時解析為應用程式的 <code><a href=\"api/core/ApplicationRef\" class=\"code-anchor\">ApplicationRef</a></code>。對於範例應用程式，它是 <code>AppServerModule</code>。它是通用伺服器端渲染器和 Angular 應用程式之間的橋樑。</nt-wrapper><nt-wrapper translation-origin=\"off\">The root <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> or function that when invoked returns a <code>Promise</code> that resolves to an <code><a href=\"api/core/ApplicationRef\" class=\"code-anchor\">ApplicationRef</a></code> of the application when rendering on the server. For the example application, it is <code>AppServerModule</code>. It's the bridge between the Universal server-side renderer and the Angular application.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>extraProviders</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">這是可選的，可以讓你指定僅在伺服器端渲染應用程式時才適用的依賴提供者。當你的應用需要某些只能由當前執行的伺服器例項確定的資訊時，可以執行此操作。</nt-wrapper><nt-wrapper translation-origin=\"off\">This property is optional and lets you specify dependency providers that apply only when rendering the application on the server. Do this when your application needs information that can only be determined by the currently running server instance.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\"><code>ngExpressEngine()</code> 函式返回了一個會解析成渲染好的頁面的<em>承諾（Promise）</em>。接下來你的引擎要決定拿這個頁面做點什麼。在<em>這個引擎</em>的 <code>Promise</code> 回呼(Callback)函式中，把渲染好的頁面返回給了 Web 伺服器，然後伺服器透過 HTTP 響應把它轉發給了客戶端。</p><p translation-origin=\"off\">The <code>ngExpressEngine()</code> function returns a <code>Promise</code> callback that resolves to the rendered page.\nIt's up to the engine to decide what to do with that page.\nThis engine's <code>Promise</code> callback returns the rendered page to the web server, which then forwards it to the client in the HTTP response.</p>\n\n<h3 id=\"filtering-request-urls\" translation-result=\"on\">過濾請求的 URL<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#filtering-request-urls\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Filtering request URLs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#filtering-request-urls\"><i class=\"material-icons\">link</i></a></h3>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n當使用 NgUniversal Express 腳手架時，會自動處理基本行為。這對於嘗試理解底層行為或在不使用腳手架的情況下復現它是很有幫助的。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThe basic behavior described below is handled automatically when using the NgUniversal Express schematic.\nThis is helpful when trying to understand the underlying behavior or replicate it without using the schematic.</p>\n\n</div>\n<p translation-result=\"on\">Web 伺服器必須把<em>對應用頁面的請求</em>和其它型別的請求區分開。</p><p translation-origin=\"off\">The web server must distinguish <em>app page requests</em> from other kinds of requests.</p>\n\n<p translation-result=\"on\">這可不像攔截對根路徑 <code>/</code> 的請求那麼簡單。瀏覽器可以請求應用中的任何一個路由地址，比如 <code>/dashboard</code>、<code>/heroes</code> 或 <code>/detail:12</code>。事實上，如果應用<em>只</em>會透過伺服器端渲染，那麼應用中點選的<em>任何一個</em>連結都會發到伺服器，就像導航時的地址會發到路由器一樣。</p><p translation-origin=\"off\">It's not as simple as intercepting a request to the root address <code>/</code>.\nThe browser could ask for one of the application routes such as <code>/dashboard</code>, <code>/heroes</code>, or <code>/detail:12</code>.\nIn fact, if the application were only rendered by the server, <em>every</em> application link clicked would arrive at the server as a navigation URL intended for the router.</p>\n\n<p translation-result=\"on\">幸運的是，應用的路由具有一些共同特徵：它們的 URL 一般不帶副檔名。（資料請求也可能缺少副檔名，但是它們很容易識別出來，因為它們總是以 <code>/api</code> 開頭，所有的靜態資源的請求都會帶有一個副檔名，比如 <code>main.js</code> 或 <code>/node_modules/zone.js/bundles/zone.umd.js</code>）。</p><p translation-origin=\"off\">Fortunately, application routes have something in common: their URLs lack file extensions.\n(Data requests also lack extensions but they can be recognized because they always begin with <code>/api</code>.)\nAll static asset requests have a file extension (such as <code>main.js</code> or <code>/node_modules/zone.js/bundles/zone.umd.js</code>).</p>\n\n<p translation-result=\"on\">由於使用了路由，所以我們可以輕鬆的識別出這三種類型的請求，並分別處理它們。</p><p translation-origin=\"off\">Because you use routing, you can recognize the three types of requests and handle them differently.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">路由請求型別</nt-wrapper><nt-wrapper translation-origin=\"off\">Routing request types</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">資料請求</nt-wrapper><nt-wrapper translation-origin=\"off\">Data request</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">請求的 URL 用 <code>/api</code> 開頭。</nt-wrapper><nt-wrapper translation-origin=\"off\">Request URL that begins <code>/api</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">應用導航</nt-wrapper><nt-wrapper translation-origin=\"off\">App navigation</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">請求的 URL 不帶副檔名。</nt-wrapper><nt-wrapper translation-origin=\"off\">Request URL with no file extension.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">靜態資產</nt-wrapper><nt-wrapper translation-origin=\"off\">Static asset</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">所有其它請求。</nt-wrapper><nt-wrapper translation-origin=\"off\">All other requests.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">Node.js Express 伺服器是一系列中介軟體構成的管道，它會挨個對這些請求進行過濾和處理。你可以呼叫 <code>server.get()</code> 來配置 Express 伺服器的管道，就像下面這個資料請求一樣。</p><p translation-origin=\"off\">A Node.js Express server is a pipeline of middleware that filters and processes requests one after the other.\nYou configure the Node.js Express server pipeline with calls to <code>server.get()</code> like this one for data requests.</p>\n\n<code-example header=\"server.ts (data URL)\" path=\"universal/server.ts\" region=\"data-request\">\n// TODO: implement data requests securely\nserver.get('/api/**', (req, res) =&gt; {\n  res.status(404).send('data requests are not yet supported');\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n這個範例伺服器不能處理資料請求。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nThis sample server doesn't handle data requests.</p>\n\n<p translation-result=\"on\">本課程中的“記憶體 Web API”模組是一個示範和開發工具，它會攔截所有 HTTP 請求並模擬遠端資料伺服器的行為。在實際應用中，你要刪除該模組並在此註冊你的 Web API 中介軟體。</p><p translation-origin=\"off\">The tutorial's \"in-memory web API\" module, a demo and development tool, intercepts all HTTP calls and simulates the behavior of a remote data server.\nIn practice, you would remove that module and register your web API middleware on the server here.</p>\n\n</div>\n<p translation-result=\"on\">下列程式碼會過濾出不帶副檔名的 URL，並把它們當做導航請求進行處理。</p><p translation-origin=\"off\">The following code filters for request URLs with no extensions and treats them as navigation requests.</p>\n\n<code-example header=\"server.ts (navigation)\" path=\"universal/server.ts\" region=\"navigation-request\">\n// All regular routes use the Universal engine\nserver.get('*', (req, res) =&gt; {\n  res.render(indexHtml, { req, providers: [{ provide: <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, useValue: req.baseUrl }] });\n});\n\n</code-example>\n<h3 id=\"serving-static-files-safely\" translation-result=\"on\">安全的提供靜態檔案<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#serving-static-files-safely\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Serving static files safely<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#serving-static-files-safely\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">單獨的 <code>server.use()</code> 會處理所有其它 URL，比如對 JavaScript 、圖片和樣式表等靜態資源的請求。</p><p translation-origin=\"off\">A single <code>server.use()</code> treats all other URLs as requests for static assets such as JavaScript, image, and style files.</p>\n\n<p translation-result=\"on\">要保證客戶端只能下載那些<em>允許</em>他們存取的檔案，你應該把所有面向客戶端的資原始檔都放在 <code>/dist</code> 目錄下，並且只允許客戶端請求來自 <code>/dist</code> 目錄下的檔案。</p><p translation-origin=\"off\">To ensure that clients can only download the files that they are permitted to see, put all client-facing asset files in the <code>/dist</code> folder and only honor requests for files from the <code>/dist</code> folder.</p>\n\n<p translation-result=\"on\">下列 Node.js Express 程式碼會把剩下的所有請求都路由到 <code>/dist</code> 目錄下，如果檔案未找到，就會返回 <code>404 - NOT FOUND</code>。</p><p translation-origin=\"off\">The following Node.js Express code routes all remaining requests to <code>/dist</code>, and returns a <code>404 - NOT FOUND</code> error if the\nfile isn't found.</p>\n\n<code-example header=\"server.ts (static files)\" path=\"universal/server.ts\" region=\"static\">\n// Serve <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> files from /<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>\nserver.get('*.*', express.static(distFolder, {\n  maxAge: '1y'\n}));\n\n</code-example>\n<h3 id=\"using-absolute-urls-for-http-data-requests-on-the-server\" translation-result=\"on\">在伺服器端使用絕對 URL 進行 HTTP（資料）請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#using-absolute-urls-for-http-data-requests-on-the-server\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Using absolute URLs for HTTP (data) requests on the server<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#using-absolute-urls-for-http-data-requests-on-the-server\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">本課程的 <code>HeroService</code> 和 <code>HeroSearchService</code> 都委託 Angular 的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 模組來獲取應用資料。這些服務會向 <code>api/heroes</code> 之類別的<em>相對</em> URL 傳送請求。在伺服器端渲染的應用中，HTTP URL 必須是<em>絕對的</em>（比如，<code>https://my-server.com/api/heroes</code>）。這意味著當在伺服器上執行時，URL 必須以某種方式轉換為絕對 URL，而在瀏覽器中執行時，它們是相對 URL。</p><p translation-origin=\"off\">The tutorial's <code>HeroService</code> and <code>HeroSearchService</code> delegate to the Angular <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> module to fetch application data.\nThese services send requests to <em>relative</em> URLs such as <code>api/heroes</code>.\nIn a server-side rendered app, HTTP URLs must be <em>absolute</em> (for example, <code>https://my-server.com/api/heroes</code>).\nThis means that the URLs must be somehow converted to absolute when running on the server and be left relative when running in the browser.</p>\n\n<p translation-result=\"on\">如果你正在使用 <code>@nguniversal/*-engine</code> 包之一（比如 <code>@nguniversal/express-engine</code>），就會自動為幫你做這件事。你無需再做任何事情來讓相對 URL 能在伺服器上執行。</p><p translation-origin=\"off\">If you are using one of the <code>@nguniversal/*-engine</code> packages (such as <code>@nguniversal/express-engine</code>), this is taken care for you automatically.\nYou don't need to do anything to make relative URLs work on the server.</p>\n\n<p translation-result=\"on\">如果出於某種原因，你沒有使用 <code>@nguniversal/*-engine</code> 套件，你可能需要親自處理它。</p><p translation-origin=\"off\">If, for some reason, you are not using an <code>@nguniversal/*-engine</code> package, you might need to handle it yourself.</p>\n\n<p translation-result=\"on\">推薦的解決方案是將完整的請求 URL 傳遞給 <a href=\"api/platform-server/renderModule\">renderModule</a> 的 <code>options</code> 引數。此選項的侵入性最小，因為它不需要對應用程式進行任何更改。這裡所說的“請求 URL”指的是原始的請求 URL，把它傳給伺服器端渲染應用程式。例如，如果客戶端請求 <code>https://my-server.com/dashboard</code> 並且你正在伺服器端渲染應用程式以響應該請求，則 <code>options.url</code> 應設定為 <code>https://my-server.com/dashboard</code>。</p><p translation-origin=\"off\">The recommended solution is to pass the full request URL to the <code>options</code> argument of <a href=\"api/platform-server/renderModule\">renderModule</a>.\nThis option is the least intrusive as it does not require any changes to the application.\nHere, \"request URL\" refers to the URL of the request as a response to which the application is being rendered on the server.\nFor example, if the client requested <code>https://my-server.com/dashboard</code> and you are rendering the application on the server to respond to that request, <code>options.url</code> should be set to <code>https://my-server.com/dashboard</code>.</p>\n\n<p translation-result=\"on\">現在，作為在伺服器端渲染應用的一部分，每次傳送 HTTP 請求時，Angular 都可以使用這裡提供的 <code>options.url</code> 正確地將請求 URL 解析為絕對 URL。</p><p translation-origin=\"off\">Now, on every HTTP request made as part of rendering the application on the server, Angular can correctly resolve the request URL to an absolute URL, using the provided <code>options.url</code>.</p>\n\n<h3 id=\"useful-scripts\" translation-result=\"on\">實用指令碼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#useful-scripts\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Useful scripts<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/universal#useful-scripts\"><i class=\"material-icons\">link</i></a></h3>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">指令碼</nt-wrapper><nt-wrapper translation-origin=\"off\">Scripts</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code-example format=\"shell\" language=\"shell\"> npm run dev:ssr </code-example></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">此命令類似於 <a href=\"cli/serve\"><code>ng serve</code></a>，它在開發期間提供即時重新載入，但使用伺服器端渲染。該應用程式以監視模式執行並在每次更改後重新整理瀏覽器。這個命令要比實際的 <code>ng serve</code> 命令慢。</nt-wrapper><nt-wrapper translation-origin=\"off\">Similar to <a href=\"cli/serve\"><code>ng serve</code></a>, which offers live reload during development, but uses server-side rendering. The application runs in watch mode and refreshes the browser after every change. This command is slower than the actual <code>ng serve</code> command.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code-example format=\"shell\" language=\"shell\"> ng build &amp;&amp; ng run app-name:server </code-example></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">此命令會在生產模式下建構伺服器指令碼和應用程式。當你要建構用於部署的專案時，請使用此命令。</nt-wrapper><nt-wrapper translation-origin=\"off\">Builds both the server script and the application in production mode. Use this command when you want to build the project for deployment.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code-example format=\"shell\" language=\"shell\"> npm run serve:ssr </code-example></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">此命令啟動伺服器指令碼，用於透過伺服器端渲染在本地為應用程式提供服務。它使用由 <code>ng run build:ssr</code> 建立的建構工件，因此請確保你也運行了該命令。<div class=\"alert is-helpful\"><strong>注意</strong>：<br><code>serve:ssr</code> 不能用於在生產環境為你的應用程式提供服務，而僅用於在本地測試伺服器端渲染的應用程式。</div></nt-wrapper><nt-wrapper translation-origin=\"off\">Starts the server script for serving the application locally with server-side rendering. It uses the build artifacts created by <code>ng run build:ssr</code>, so make sure you have run that command as well. <div class=\"alert is-helpful\"> <strong>NOTE</strong>: <br> <code>serve:ssr</code> is not intended to be used to serve your application in production, but only for testing the server-side rendered application locally. </div></nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code-example format=\"shell\" language=\"shell\"> npm run prerender </code-example></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">此指令碼可用於預先渲染應用程式的頁面。<a href=\"guide/prerendering\">在此處</a>閱讀有關預先渲染的更多資訊。</nt-wrapper><nt-wrapper translation-origin=\"off\">Used to prerender an application's pages. Read more about prerendering <a href=\"guide/prerendering\">here</a>.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：4/25/2023</div>\n</div>\n\n\n<!-- links to this doc:\n - api/platform-server\n - api/router/ExtraOptions\n - api/router/InitialNavigation\n - api/router/withEnabledBlockingInitialNavigation\n - errors/NG0912\n - guide/architecture-next-steps\n - guide/developer-guide-overview\n - guide/glossary\n - guide/prerendering\n - guide/web-worker\n-->\n<!-- links from this doc:\n - /guide/releases#developer-preview\n - api/animations/browser\n - api/common/APP_BASE_HREF\n - api/common/DOCUMENT\n - api/common/Location\n - api/common/http/HttpClient\n - api/core/ApplicationRef\n - api/core/NgModule\n - api/platform-browser/provideClientHydration\n - api/platform-server/renderApplication\n - api/platform-server/renderModule\n - api/router/RouterLink\n - api/upgrade/static\n - cli/serve\n - guide/aot-compiler\n - guide/hydration\n - guide/prerendering\n - guide/router\n - guide/router-reference#router-link\n - guide/universal#angular-universalangular-統一平台簡介\n - guide/universal#facilitate-web-crawlers-seo\n - guide/universal#filtering-request-urls\n - guide/universal#improve-performance-on-mobile-and-low-powered-devices\n - guide/universal#server-side-rendering-ssr-with-angular-universal\n - guide/universal#serving-static-files-safely\n - guide/universal#show-the-first-page-quickly\n - guide/universal#step-1-enable-server-side-rendering\n - guide/universal#step-2-enable-client-hydration\n - guide/universal#step-3-start-the-server\n - guide/universal#step-4-run-your-application-in-a-browser\n - guide/universal#universal-and-the-angular-service-worker\n - guide/universal#universal-engine\n - guide/universal#universal-template-engine\n - guide/universal#universal-tutorial\n - guide/universal#universal-web-servers\n - guide/universal#universal-web-伺服器\n - guide/universal#universal-和-angular-service-worker\n - guide/universal#universal-課程\n - guide/universal#universal-範本引擎\n - guide/universal#useful-scripts\n - guide/universal#using-absolute-urls-for-http-data-requests-on-the-server\n - guide/universal#why-do-it\n - guide/universal#why-use-server-side-rendering\n - guide/universal#working-around-the-browser-apis\n - guide/universal#為何需要伺服器端渲染\n - guide/universal#使用瀏覽器-api\n - guide/universal#在伺服器端使用絕對-url-進行-http資料請求\n - guide/universal#安全的提供靜態檔案\n - guide/universal#實用指令碼\n - guide/universal#幫助網路爬蟲seo\n - guide/universal#快速顯示第一頁\n - guide/universal#提升手機和低功耗裝置上的效能\n - guide/universal#步驟-1-啟用伺服器端渲染\n - guide/universal#步驟-2-啟用客戶端水合\n - guide/universal#步驟-3-啟動伺服器\n - guide/universal#第-4-步-在瀏覽器中執行你的應用程式\n - guide/universal#過濾請求的-url\n - guide/versions\n - tutorial/tour-of-heroes\n - https://developers.google.com/web/tools/chrome-devtools/network-performance/reference#throttling\n - https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint\n - https://developers.google.com/web/updates/2019/02/rendering-on-the-web\n - https://expressjs.com\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/universal.md?message=docs%3A%20請簡述你的修改...\n - https://nodejs.org/about/releases\n - https://static.googleusercontent.com/media/www.google.com/en//webmasters/docs/search-engine-optimization-starter-guide.pdf\n - https://web.dev/shopping-for-speed-on-ebay\n - https://web.dev/shopping-for-speed-on-ebay/\n-->"}