{"id":"guide/migration-undecorated-classes","title":"Missing @Directive()/@Component() decorator migration","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/migration-undecorated-classes.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"missing-directivecomponent-decorator-migration\" translation-result=\"on\">缺少 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> / <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 裝飾器的遷移<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#缺少-directive--component-裝飾器的遷移\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Missing <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code>/<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator migration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#missing-directivecomponent-decorator-migration\"><i class=\"material-icons\">link</i></a></h1>\n\n<h2 id=\"what-does-this-migration-do\" translation-result=\"on\">這種遷移是做什麼的？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#what-does-this-migration-do\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What does this migration do?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#what-does-this-migration-do\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">此遷移會把一個空的 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 裝飾器新增到一些不帶裝飾器的基底類別中：</p><p translation-origin=\"off\">This migration adds an empty <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> decorator to undecorated\nbase classes that:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">使用了 Angular 的特性</p><p translation-origin=\"off\">Use Angular features</p>\n\n</li>\n<li>\n<p translation-result=\"on\">被指令或元件繼承（extend）</p><p translation-origin=\"off\">Are extended by directives or components</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">比如，在下面的對比中，把一個 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 裝飾器加到了 <code>BaseMenu</code> 上是因為 <code>BaseMenu</code> 使用了依賴性注入。</p><p translation-origin=\"off\">For example, in the diff below, a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> decorator is added to <code>BaseMenu</code> because <code>BaseMenu</code> uses dependency injection.</p>\n\n<p translation-result=\"on\"><strong>之前</strong>：</p><p translation-origin=\"off\"><strong>Before</strong>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nexport class BaseMenu {\n  constructor(private vcr: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) {}\n}\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[settingsMenu]'})\nexport class SettingsMenu extends BaseMenu {}\n\n</code-example>\n<p translation-result=\"on\"><strong>之後</strong>：</p><p translation-origin=\"off\"><strong>After</strong>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()\nexport class BaseMenu {\n  constructor(private vcr: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) {}\n}\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[settingsMenu]'})\nexport class SettingsMenu extends BaseMenu {}\n\n</code-example>\n<p translation-result=\"on\">如果指令或元件是在沒有裝飾器的情況下被類擴充的，那麼該原理圖就會把任何繼承來的指令或元件元資料複製到派生類中。</p><p translation-origin=\"off\">In the event that a directive or component is extended by a class without a decorator, the schematic copies any inherited directive or component metadata to the derived class.</p>\n\n<p translation-result=\"on\"><strong>之前</strong>：</p><p translation-origin=\"off\"><strong>Before</strong>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'base-menu',\n  template: '&lt;div&gt;&lt;/div&gt;'\n})\nclass BaseMenu {}\n\nexport class SettingsMenu extends BaseMenu {}\n\n</code-example>\n<p translation-result=\"on\"><strong>之後</strong>：</p><p translation-origin=\"off\"><strong>After</strong>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'base-menu',\n  template: '&lt;div&gt;&lt;/div&gt;'\n})\nclass BaseMenu {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'base-menu',\n  template: '&lt;div&gt;&lt;/div&gt;'\n})\nexport class SettingsMenu extends BaseMenu {}\n\n</code-example>\n<p translation-result=\"on\">這個原理圖還裝飾了使用 Angular 欄位裝飾器的類，包括：</p><p translation-origin=\"off\">This schematic also decorates classes that use Angular field decorators, including:</p>\n\n<ul>\n<li>\n<p><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code></p>\n</li>\n<li>\n<p><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code></p>\n</li>\n<li>\n<p><code>@<a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a>()</code></p>\n</li>\n<li>\n<p><code>@<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>()</code></p>\n</li>\n<li>\n<p><code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>()</code> / <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a>()</code></p>\n</li>\n<li>\n<p><code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> / <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>()</code></p>\n</li>\n</ul>\n<p translation-result=\"on\"><strong>之前</strong>：</p><p translation-origin=\"off\"><strong>Before</strong>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass Base {\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()\n  countChanged = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;number&gt;();\n}\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[myDir]'\n})\nclass Dir extends Base {\n}\n\n</code-example>\n<p translation-result=\"on\"><strong>之後</strong>：</p><p translation-origin=\"off\"><strong>After</strong>:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>() // schematic adds @<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()\nclass Base {\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()\n  countChanged = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;number&gt;();\n}\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[myDir]'\n})\nclass Dir extends Base {\n}\n\n</code-example>\n<h2 id=\"why-is-this-migration-necessary\" translation-result=\"on\">為何這次遷移必不可少？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#why-is-this-migration-necessary\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Why is this migration necessary?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#why-is-this-migration-necessary\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"migrating-classes-that-use-di\" translation-result=\"on\">遷移使用了 DI 的類<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#migrating-classes-that-use-di\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Migrating classes that use DI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#migrating-classes-that-use-di\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當一個類別有 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 或者 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 裝飾器時，Angular 編譯器會產生一些額外的程式碼來把這些依賴注入到建構函式中。當使用繼承時，Ivy 既要讓父類、也要讓子類別應用裝飾器來產生正確的程式碼。</p><p translation-origin=\"off\">When a class has a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator, the Angular compiler generates extra code to inject dependencies into the constructor.\nWhen using inheritance, Ivy needs both the parent class and the child class to apply a decorator to generate the correct code.</p>\n\n<p translation-result=\"on\">你可以把這種變化看作兩種情況：父類缺少裝飾器，或者子類別缺少裝飾器。在這兩種場景中，Angular 的執行時都需要得到來自編譯器的額外資訊。這些額外資訊來自所新增的裝飾器。</p><p translation-origin=\"off\">You can think of this change as two cases: a parent class is missing a decorator or a child class is missing a decorator.\nIn both scenarios, Angular's runtime needs additional information from the compiler.\nThis additional information comes from adding decorators.</p>\n\n<h4 id=\"decorator-missing-from-parent-class\" translation-result=\"on\">父類缺少了裝飾器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#decorator-missing-from-parent-class\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Decorator missing from parent class<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#decorator-missing-from-parent-class\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">當父類中缺少裝飾器時，該子類別會繼承一個建構函式，而這個建構函式並沒有為編譯器產生特殊的建構函式資訊（因為它沒有指令裝飾器）。當 Angular 嘗試建立子類別時，它沒有正確的資訊來建立它。</p><p translation-origin=\"off\">When the decorator is missing from the parent class, the subclass will inherit a constructor from a class for which the compiler did not generate special constructor info (because it was not decorated as a directive).\nWhen Angular then tries to create the subclass, it doesn't have the correct info to create it.</p>\n\n<p translation-result=\"on\">在 View Engine 中，編譯器具有全域知識，可以查詢丟失的資料。然而，Ivy 編譯器只是孤立地處理每個指令。這意味著編譯可以更快，但編譯器無法自動推斷出和以前一樣的資訊。新增 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 可以明確提供這些資訊。</p><p translation-origin=\"off\">In View Engine, the compiler has global knowledge, so it can look up the missing data.\nHowever, the Ivy compiler only processes each directive in isolation.\nThis means that compilation can be faster, but the compiler can't automatically infer the same information as before.\nAdding the <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> explicitly provides this information.</p>\n\n<p translation-result=\"on\">未來，會把 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 新增到那些還沒有裝飾器而且被指令擴充的基底類別中。</p><p translation-origin=\"off\">In the future, add <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> to base classes that do not already have decorators and are extended by directives.</p>\n\n<h4 id=\"decorator-missing-from-child-class\" translation-result=\"on\">子類別缺少裝飾器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#decorator-missing-from-child-class\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Decorator missing from child class<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#decorator-missing-from-child-class\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">當子類別缺少裝飾器時，子類別繼承自父類，但卻沒有自己的裝飾器。如果沒有裝飾器，編譯器就無法知道該類是 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 還是 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>，所以它無法為該指令產生正確的程式碼。</p><p translation-origin=\"off\">When the child class is missing the decorator, the child class inherits from the parent class yet has no decorators of its own.\nWithout a decorator, the compiler has no way of knowing that the class is a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>, so it doesn't generate the proper instructions for the directive.</p>\n\n<h3 id=\"migrating-classes-that-use-field-decorators\" translation-result=\"on\">遷移使用了欄位裝飾器的類<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#migrating-classes-that-use-field-decorators\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Migrating classes that use field decorators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#migrating-classes-that-use-field-decorators\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 ViewEngine 中，包含 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 等欄位裝飾器的基底類別在元件沒有 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 或者 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 裝飾器時也能正常工作。比如：</p><p translation-origin=\"off\">In ViewEngine, base classes with field decorators like <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> worked even when the class did not have a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator.\nFor example:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nclass Base {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  foo: string;\n}\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>(…)\nclass Dir extends Base {\n  ngOnChanges(): void {\n    // notified when bindings to [foo] are updated\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">但是，這個例子無法用 Ivy 編譯，因為 <code>Base</code> 類<em>需要</em>一個 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 或者 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 裝飾器來為輸入、輸出、查詢和宿主繫結產生程式碼。</p><p translation-origin=\"off\">However, this example won't compile with Ivy because the <code>Base</code> class <em>requires</em> either a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator to generate code for inputs, outputs, queries, and host bindings.</p>\n\n<p translation-result=\"on\">所以始終都需要一個類別裝飾器，這會給 Angular 帶來兩大好處：</p><p translation-origin=\"off\">Always requiring a class decorator leads to two main benefits for Angular:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">以前的行為是不一致的。一些 Angular 特性需要裝飾器（依賴注入），但其它的則不需要。現在，所有的 Angular 特性都需要一個類別裝飾器。</p><p translation-origin=\"off\">The previous behavior was inconsistent.\nSome Angular features required a decorator (dependency injection), but others did not.\nNow, all Angular features consistently require a class decorator.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">支援不帶裝飾器的類會增加 Angular 的程式碼大小和複雜性。如果總是要求類裝飾器，對於所有使用者來說框架都會變得更小、更簡單。</p><p translation-origin=\"off\">Supporting undecorated classes increases the code size and complexity of Angular.\nAlways requiring class decorators allows the framework to become smaller and simpler for all users.</p>\n\n</li>\n</ol>\n<h2 id=\"what-does-it-mean-to-have-a-directive-decorator-with-no-metadata-inside-of-it\" translation-result=\"on\"><code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 裝飾器裡面沒有元資料是怎麼回事？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#directive-裝飾器裡面沒有元資料是怎麼回事\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What does it mean to have a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> decorator with no metadata inside of it?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#what-does-it-mean-to-have-a-directive-decorator-with-no-metadata-inside-of-it\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 裝飾器的出現讓 Angular 為受其影響的類生成了額外的程式碼。如果該裝飾器不包含任何屬性（元資料），該指令就不會與任何元素匹配或者被直接例項化，但<em>擴充</em>該指令類別的其它類也會繼承這些產生的程式碼。你可以把它看作一個“抽象”的指令。</p><p translation-origin=\"off\">The presence of the <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> decorator causes Angular to generate extra code for the affected class.\nIf that decorator includes no properties (metadata), the directive won't be matched to elements or instantiated directly, but other classes that <em>extend</em> the directive class will inherit this generated code.\nYou can think of this as an \"abstract\" directive.</p>\n\n<p translation-result=\"on\">把一個抽象指令新增到 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中會導致錯誤。非抽象指令必須定義一個 <code>selector</code> 屬性，才能匹配範本中的某些元素。</p><p translation-origin=\"off\">Adding an abstract directive to an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> will cause an error.\nA directive must have a <code>selector</code> property defined in order to match some element in a template.</p>\n\n<h2 id=\"when-do-i-need-a-directive-decorator-without-a-selector\" translation-result=\"on\">我什麼時候需要一個沒有選擇器的 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 裝飾器？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#我什麼時候需要一個沒有選擇器的-directive-裝飾器\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">When do I need a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> decorator without a selector?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#when-do-i-need-a-directive-decorator-without-a-selector\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果你正在使用依賴注入或任何 Angular 特有的特性，比如 <code>@<a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a>()</code>，<code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>()</code> 或者 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>，你就需要一個 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 或者 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 裝飾器。裝飾器能讓編譯器知道如何產生正確的指令來建立該類以及那些擴充了它的類別。如果你不想直接把那個基底類別用作指令，那就不寫這個選擇器。如果你確實希望它可以獨立使用，那就像往常一樣填寫元資料。</p><p translation-origin=\"off\">If you're using dependency injection, or any Angular-specific feature, such as <code>@<a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a>()</code>, <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>()</code>, or <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, you need a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator.\nThe decorator lets the compiler know to generate the correct instructions to create that class and any classes that extend it.\nIf you don't want to use that base class as a directive directly, leave the selector blank.\nIf you do want it to be usable independently, fill in the metadata as usual.</p>\n\n<p translation-result=\"on\">那些沒有使用 Angular 特性的類不需要 Angular 裝飾器。</p><p translation-origin=\"off\">Classes that don't use Angular features don't need an Angular decorator.</p>\n\n<h2 id=\"im-a-library-author-should-i-add-the-directive-decorator-to-base-classes\" translation-result=\"on\">我是庫作者。我應該把 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 裝飾器新增到基底類別中嗎？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#我是庫作者我應該把-directive-裝飾器新增到基底類別中嗎\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">I'm a library author. Should I add the <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> decorator to base classes?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#im-a-library-author-should-i-add-the-directive-decorator-to-base-classes\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">由於 Angular 9 中引入了對無選擇器裝飾器的支援，如果你想支援 Angular 8 及更早版本，就不應該新增一個無選擇器的 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 裝飾器。你可以新增帶選擇器的 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code>，或者把 Angular 特有的特性移動到受影響的子類別中。</p><p translation-origin=\"off\">As support for selectorless decorators is introduced in Angular version 9, if you want to support Angular version 8 and earlier, you shouldn't add a selectorless <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> decorator.\nYou can either add <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> with a selector or move the Angular-specific features to affected subclasses.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/16/2023</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Directive\n - api/core/EventEmitter\n - api/core/HostBinding\n - api/core/HostListener\n - api/core/Input\n - api/core/NgModule\n - api/core/Output\n - api/core/ViewChild\n - api/core/ViewChildren\n - api/core/ViewContainerRef\n - guide/migration-undecorated-classes#decorator-missing-from-child-class\n - guide/migration-undecorated-classes#decorator-missing-from-parent-class\n - guide/migration-undecorated-classes#directive-裝飾器裡面沒有元資料是怎麼回事\n - guide/migration-undecorated-classes#im-a-library-author-should-i-add-the-directive-decorator-to-base-classes\n - guide/migration-undecorated-classes#migrating-classes-that-use-di\n - guide/migration-undecorated-classes#migrating-classes-that-use-field-decorators\n - guide/migration-undecorated-classes#missing-directivecomponent-decorator-migration\n - guide/migration-undecorated-classes#what-does-it-mean-to-have-a-directive-decorator-with-no-metadata-inside-of-it\n - guide/migration-undecorated-classes#what-does-this-migration-do\n - guide/migration-undecorated-classes#when-do-i-need-a-directive-decorator-without-a-selector\n - guide/migration-undecorated-classes#why-is-this-migration-necessary\n - guide/migration-undecorated-classes#為何這次遷移必不可少\n - guide/migration-undecorated-classes#子類別缺少裝飾器\n - guide/migration-undecorated-classes#我什麼時候需要一個沒有選擇器的-directive-裝飾器\n - guide/migration-undecorated-classes#我是庫作者我應該把-directive-裝飾器新增到基底類別中嗎\n - guide/migration-undecorated-classes#父類缺少了裝飾器\n - guide/migration-undecorated-classes#缺少-directive--component-裝飾器的遷移\n - guide/migration-undecorated-classes#遷移使用了-di-的類\n - guide/migration-undecorated-classes#遷移使用了欄位裝飾器的類\n - guide/migration-undecorated-classes#這種遷移是做什麼的\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/migration-undecorated-classes.md?message=docs%3A%20請簡述你的修改...\n-->"}