{"id":"guide/ivy-compatibility","title":"Ivy compatibility guide","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/aio/aio/content/guide/ivy-compatibility.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"ivy-compatibility-guide\" translation-result=\"on\">Ivy 相容性指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility#ivy-compatibility-guide\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"ivy-compatibility-guide\">Ivy compatibility guide<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility#ivy-compatibility-guide\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">Angular 團隊一直在努力確保 Ivy 與之前的渲染引擎（“View Engine”）儘可能向後相容。但是，在極少數情況下，需要做一些小改動才能確保 Angular 的行為是可預測和一致的，以糾正 View Engine 實現中的問題。為了順利過渡，我們儘可能提供了自動遷移功能，以便 CLI 可以自動遷移你的應用和庫程式碼。也就是說，某些應用可能需要做一些手動更新。</p><p translation-origin=\"off\">The Angular team has worked hard to ensure Ivy is as backwards-compatible with the previous rendering engine (\"View Engine\") as possible.\nHowever, in rare cases, minor changes were necessary to ensure that the Angular's behavior was predictable and consistent, correcting issues in the View Engine implementation.\nIn order to smooth the transition, we have provided automated migrations wherever possible so your application and library code is migrated automatically by the CLI.\nThat said, some applications will likely need to apply some manual updates.</p>\n\n<a id=\"debugging\"></a>\n<h2 id=\"how-to-debug-errors-with-ivy\" translation-result=\"on\">如何用 Ivy 除錯錯誤<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility#how-to-debug-errors-with-ivy\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"how-to-debug-errors-with-ivy\">How to debug errors with Ivy<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility#how-to-debug-errors-with-ivy\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果發現了錯誤，請先在 <code>tsconfig.json</code> 中<a href=\"guide/ivy#opting-out-of-angular-ivy\">暫時關閉 Ivy</a> ，然後重新啟動你的應用程式。</p><p translation-result=\"on\">如果仍然有錯，說要這些錯誤不是 Ivy 特有的。在這種情況下，你可能需要查閱<a href=\"guide/updating-to-version-12\">常規更新指南</a>。如果你選擇了任何新的、更嚴格的型別檢查設定，則可能還需要檢視<a href=\"guide/template-typecheck\">範本型別檢查指南</a>。</p><p translation-result=\"on\">如果錯誤消失了，可以刪除對 <code>tsconfig.base.json</code> 的更改，切換回 Ivy，並檢視下面的預期更改列表。</p><p translation-origin=\"off\">If you're seeing errors, first temporarily <a href=\"guide/ivy#opting-out-of-angular-ivy\">turn off Ivy</a> in your <code>tsconfig.json</code> and re-start your application.</p>\n\n<p translation-origin=\"off\">If you're still seeing the errors, they are not specific to Ivy. In this case, you may want to consult the <a href=\"guide/updating-to-version-12\">general update guide</a>. If you've opted into any of the new, stricter type-checking settings, you may also want to check out the <a href=\"guide/template-typecheck\">template type-checking guide</a>.</p>\n\n<p translation-origin=\"off\">If the errors are gone, switch back to Ivy by removing the changes to the <code>tsconfig.json</code> and review the list of expected changes below.</p>\n\n<a id=\"payload-size-debugging\"></a>\n<h3 id=\"payload-size-debugging\" translation-result=\"on\">有效載荷大小除錯<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility#payload-size-debugging\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"payload-size-debugging\">Payload size debugging<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility#payload-size-debugging\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你注意到應用的主服務套件的大小隨著 Ivy 的增加而增加了，你可能需要檢查如下內容：</p><p translation-origin=\"off\">If you notice that the size of your application's main bundle has increased with Ivy, you may want to check the following:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">   驗證你想要延遲載入的元件和 <code>NgModules</code> 是否只在惰性模組中才匯入過。你在惰性模組之外匯入的東西最終都會出現在主釋出套件中。原始問題請<a href=\"https://github.com/angular/angular-cli/issues/16146#issuecomment-557559287\">點選此處</a>檢視詳情。</p><p translation-origin=\"off\">Verify that the components and <code>NgModules</code> that you want to be lazy loaded are only imported in lazy modules.\nAnything that you import outside lazy modules can end up in the main bundle.\nSee more details in the original issue <a href=\"https://github.com/angular/angular-cli/issues/16146#issuecomment-557559287\">here</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">   檢查匯入的函式庫是否已標記為無副作用。如果你的應用匯入過那些沒有副作用的共享庫，就把“sideEffects”：false 新增到他們的 <code>package.json</code>。如果這些庫被匯入過但沒有被直接參考，那麼這將確保這些庫被正確搖樹優化了。原始問題請<a href=\"https://github.com/angular/angular-cli/issues/16799#issuecomment-580912090\">點選此處</a>檢視詳情。</p><p translation-origin=\"off\">Check that imported libraries have been marked side-effect-free.\nIf your application imports from shared libraries that are meant to be free from side effects, add \"sideEffects\": false to their <code>package.json</code>.\nThis will ensure that the libraries will be properly tree-shaken if they are imported but not directly referenced.\nSee more details in the original issue <a href=\"https://github.com/angular/angular-cli/issues/16799#issuecomment-580912090\">here</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">   未使用 Angular CLI 的專案會看到一個顯著的大小回歸，除非他們更新了最小化工具的設定，並把編譯時常量 <code>ngDevMode</code>，<code>ngI18nClosureMode</code> 和 <code>ngJitMode</code> 設為了 <code>false</code> （對於 Terser，請透過<a href=\"https://terser.org/docs/api-reference.html#conditional-compilation\"><code>global_defs</code> 配置選項</a>把它們設為 <code>false</code> ）。注意，這些常量不能給第三方庫或應用程式碼使用，因為它們不是我們公共 API 的一部分，可能會在將來發生變化。</p><p translation-origin=\"off\">Projects not using Angular CLI will see a significant size regression unless they update their minifier settings and set compile-time constants <code>ngDevMode</code>, <code>ngI18nClosureMode</code> and <code>ngJitMode</code> to <code>false</code> (for Terser, set these to <code>false</code> using <a href=\"https://terser.org/docs/api-reference.html#conditional-compilation\"><code>global_defs</code> config option</a>).\nNote that these constants are not meant to be used by 3rd party library or application code as they are not part of our public api surface and might change in the future.</p>\n\n</li>\n</ol>\n<a id=\"common-changes\"></a>\n<h3 id=\"changes-you-may-see\" translation-result=\"on\">你可能會看到變化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility#changes-you-may-see\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"changes-you-may-see\">Changes you may see<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility#changes-you-may-see\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\">預設情況下，<code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢只搜尋 DOM 層次結構中的直接子節點（以前，只要它沒有匹配到另一個指令，它們就會搜尋 DOM 中的任何巢狀(Nesting)級別）。詳情<a href=\"guide/ivy-compatibility-examples#content-children-descendants\">參閱這裡</a>。</p><p translation-origin=\"off\">By default, <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> queries will only search direct child nodes in the DOM hierarchy (previously, they would search any nesting level in the DOM as long as another directive wasn't matched above it). See further <a href=\"guide/ivy-compatibility-examples#content-children-descendants\">details</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">所有使用 Angular DI 的類都必須有一個 Angular 裝飾器，比如 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 或者 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code>（以前，只有在 AOT 模式下或者帶有注入標誌時才能使用未修飾的類）。詳情<a href=\"guide/ivy-compatibility-examples#undecorated-classes\">參閱這裡</a>。</p><p translation-origin=\"off\">All classes that use Angular DI must have an Angular decorator like <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> or <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> (previously, undecorated classes were allowed in AOT mode only or if injection flags were used). See further <a href=\"guide/ivy-compatibility-examples#undecorated-classes\">details</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">指令的未繫結輸入（比如 <code>&lt;my-comp name=\"\"&gt;</code> ）現在是在建立檢視時設定的，位於執行變更檢測之前（以前所有輸入都是在變更檢測過程中設定的）。</p><p translation-origin=\"off\">Unbound inputs for directives (for example, name in <code>&lt;my-comp name=\"\"&gt;</code>) are now set upon creation of the view, before change detection runs (previously, all inputs were set during change detection).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">直接在範本的 HTML 中設定的靜態屬性會覆蓋指令或元件中設定的任何與之衝突的宿主屬性（以前，如果有衝突，指令/元件設定的靜態宿主屬性會覆蓋靜態的範本屬性）。</p><p translation-origin=\"off\">Static attributes set directly in the HTML of a template will override any conflicting host attributes set by directives or components (previously, static host attributes set by directives / components would override static template attributes if conflicting).</p>\n\n</li>\n</ul>\n<a id=\"less-common-changes\"></a>\n<h3 id=\"less-common-changes\" translation-result=\"on\">不太常見的變化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility#less-common-changes\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"less-common-changes\">Less common changes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ivy-compatibility#less-common-changes\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\">像 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 和 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 裝飾器裡面的 <code>host</code> 這樣的屬性可以被繼承（之前，只有具有顯式欄位裝飾器的屬性，比如 <code>@<a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a></code> 才會被繼承）。</p><p translation-origin=\"off\">Properties like <code>host</code> inside <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> and <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> decorators can be inherited (previously, only properties with explicit field decorators like <code>@<a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a></code> would be inherited).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">HammerJS 支援是可選的，如果需要則匯入 <code><a href=\"api/platform-browser/HammerModule\" class=\"code-anchor\">HammerModule</a></code> （以前，它總是包含在生產套件中，而不管應用是否使用了 HammerJS）。</p><p translation-origin=\"off\">HammerJS support is opt-in through importing the <code><a href=\"api/platform-browser/HammerModule\" class=\"code-anchor\">HammerModule</a></code> (previously, it was always included in production bundles regardless of whether the application used HammerJS).</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> 和 <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 查詢將無法匹配指令自己的宿主節點（以前，這些查詢除了內容子節點外，還會匹配宿主節點）。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code> and <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> queries will no longer be able to match their directive's own host node (previously, these queries would match the host node in addition to its content children).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果一個令牌是使用 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 或 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> 標誌注入的，則不會在模組注入器中搜索該令牌（以前，有這些標誌的令牌仍會在模組級別進行搜尋）。</p><p translation-origin=\"off\">If a token is injected with the <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> or <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code> flag, the module injector is not searched for that token (previously, tokens marked with these flags would still search at the module level).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">當在範本繫結中存取同名的多個本地參考時，匹配上的總是第一個參考（以前匹配的是最後一個參考）。</p><p translation-origin=\"off\">When accessing multiple local refs with the same name in template bindings, the first is matched (previously, the last instance was matched).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">從本模組匯出的其它模組中使用的指令（但這些模組自己沒有主動匯出過）會被公開匯出（之前，編譯器會自動編寫一個私有的、使用別名的匯出，以便利用其中的全域知識解析下游模組）。</p><p translation-origin=\"off\">Directives that are used in an exported module (but not exported themselves) are exported publicly (previously, the compiler would automatically write a private, aliased export that it could use its global knowledge to resolve downstream).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">裝飾器元資料中的外部函式或外部常量不能再用靜態解析的（之前，你可以從其它編譯單元（比如庫）中匯入一個常量或函式，並在你的 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 定義中使用該常量/函式）。</p><p translation-origin=\"off\">Foreign functions or foreign constants in decorator metadata aren't statically resolvable (previously, you could import a constant or function from another compilation unit, like a library, and use that constant/function in your <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> definition).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">預設情況下，不再支援透過本地參考來存取指令輸入的前向參考。<a href=\"guide/ivy-compatibility-examples#forward-refs-directive-inputs\">詳情在此</a></p><p translation-origin=\"off\">Forward references to directive inputs accessed through local refs are no longer supported by default. <a href=\"guide/ivy-compatibility-examples#forward-refs-directive-inputs\">details</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\">  如果同時存在一個未繫結的 class 屬性和一個 <code>[class]</code> 繫結，那麼未繫結的屬性中的類也會被新增進去（以前，類繫結會覆蓋未繫結屬性中的類）。</p><p translation-origin=\"off\">If there is both an unbound class attribute and a <code>[class]</code> binding, the classes in the unbound attribute will also be added (previously, the class binding would overwrite classes in the unbound attribute).\nFor more information about the updated style precedence in Ivy, refer to the <a href=\"guide/style-precedence\">style precedence guide</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">現在賦值給一個僅用在範本中的變數會出錯，比如 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let item of items\"</code> 中的 <code>item</code>（以前，編譯器會忽略這些賦值）。</p><p translation-origin=\"off\">It is now an error to assign values to template-only variables like <code>item</code> in <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let item of items\"</code> (previously, the compiler would ignore these assignments).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">不能再在指令例項上使用 Mock 方式來覆蓋生命週期鉤子（而應該修改指令型別本身的生命週期鉤子）。</p><p translation-origin=\"off\">It's no longer possible to overwrite lifecycle hooks with mocks on directive instances for testing (instead, modify the lifecycle hook on the directive type itself).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">特殊注入令牌（比如 <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> 或 <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code> ）每次都會返回一個新的例項（之前，如果它們在同一個節點上被請求過，就會共享這些特殊令牌的同一個例項）。這主要會影響到那些比較這些物件標識的測試。</p><p translation-origin=\"off\">Special injection tokens (such as <code><a href=\"api/core/TemplateRef\" class=\"code-anchor\">TemplateRef</a></code> or <code><a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a></code>) return a new instance whenever they are requested (previously, instances of special tokens were shared if requested on the same node). This primarily affects tests that do identity comparison of these objects.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">ICU 解析是在執行時發生的，因此在 ICU 案例中只允許使用文字、HTML 標籤和文字繫結（以前，ICU 中也允許使用指令）。</p><p translation-origin=\"off\">ICU parsing happens at runtime, so only text, HTML tags and text bindings are allowed inside ICU cases (previously, directives were also permitted inside ICUs).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把文字繫結新增到源範本中不存在的 i18n 會丟擲一個執行時錯誤（以前，允許在翻譯中包含額外繫結）。</p><p translation-origin=\"off\">Adding text bindings into i18n translations that are not present in the source template itself will throw a runtime error (previously, including extra bindings in translations was permitted).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">i18n 翻譯中的額外 HTML 標籤（源範本中不存在的）將渲染為純文字（以前，這些標籤會渲染為 HTML 格式）。</p><p translation-origin=\"off\">Extra HTML tags in i18n translations that are not present in the source template itself will be rendered as plain text (previously, these tags would render as HTML).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">格式為 <code>{provide: X}</code> 且不帶 <code>useValue</code>，<code>useFactory</code>，<code>useExisting</code> 或 <code>useClass</code> 屬性的服務提供者將被視為 <code>{provide: X, useClass: X}</code> （以前被視為 <code>{provide: X, useValue: undefined}</code> ）。</p><p translation-origin=\"off\">Providers formatted as <code>{provide: X}</code> without a <code>useValue</code>, <code>useFactory</code>, <code>useExisting</code>, or <code>useClass</code> property are treated like <code>{provide: X, useClass: X}</code> (previously, it defaulted to <code>{provide: X, useValue: undefined}</code>).</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/core/DebugElement#attributes\" class=\"code-anchor\">DebugElement.attributes</a></code> 為那些已新增過的屬性返回 <code>undefined</code>，並導致它們被移除（以前，表示新增後再刪除的屬性的值為 <code>null</code> ）。</p><p translation-origin=\"off\"><code><a href=\"api/core/DebugElement#attributes\" class=\"code-anchor\">DebugElement.attributes</a></code> returns <code>undefined</code> for attributes that were added and then subsequently removed (previously, attributes added and later removed would have a value of <code>null</code>).</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/core/DebugElement#classes\" class=\"code-anchor\">DebugElement.classes</a></code> 為那些已新增過再刪除的類返回 <code>undefined</code> （以前，表示新增後再刪除的類別的值為 <code>false</code> ）。</p><p translation-origin=\"off\"><code><a href=\"api/core/DebugElement#classes\" class=\"code-anchor\">DebugElement.classes</a></code> returns <code>undefined</code> for classes that were added and then subsequently removed (previously, classes added and later removed would have a value of <code>false</code>).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果在 <code>&lt;select&gt;</code> 中選擇原生的 <code>&lt;option&gt;</code> 元素，而這個 <code>&lt;option&gt;</code> 元素是透過 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 建立的，就使用 <code>&lt;option&gt;</code> 的 <code>[selected]</code> 屬性，而不是繫結到 <code>&lt;select&gt;</code> 元素上的 <code>[value]</code> 屬性（以前，你可以繫結到任何一個。）<a href=\"guide/ivy-compatibility-examples#select-value-binding\">詳情在此</a></p><p translation-origin=\"off\">If selecting the native <code>&lt;option&gt;</code> element in a <code>&lt;select&gt;</code> where the <code>&lt;option&gt;</code>s are created using <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>, use the <code>[selected]</code> property of an <code>&lt;option&gt;</code> instead of binding to the <code>[value]</code> property of the <code>&lt;select&gt;</code> element (previously, you could bind to either.) <a href=\"guide/ivy-compatibility-examples#select-value-binding\">details</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\">嵌入式檢視（比如 <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 建立的嵌入式檢視）現在會插入到錨點註釋節點（比如 <code>&lt;!--ng-for-of--&gt;</code> ）的前面，而不是像之前一樣插入到後面。在大多數情況下，這對渲染的 DOM 沒有任何影響。</p><p translation-result=\"on\"> 動畫會推遲刪除嵌入式檢視的時機，任何新的嵌入式檢視都會插入到這個嵌入式檢視的後面，並在這些動畫完成時被刪除。這種差異只會在動畫處於活動狀態時存在，並可能會改變動畫的視覺外觀。當動畫完成後，渲染出的 DOM 與使用 View Engine 渲染的 DOM 完全相同。</p><p translation-result=\"on\">但帶有 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 渲染出來的 <code>&lt;option&gt;</code> 的 <code>&lt;select&gt;</code> 是一個例外。如果沒有提供 <a href=\"api/common/NgForOf#ngForTrackBy\"><code>trackBy</code></a> 函式，則當 <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 使用的可迭代物件發生變化時，選中的 <code>&lt;option&gt;</code> 不會被保留。\n對於 View Engine，這種程式錯誤被掩蓋了，一般不會被看見。要避免此問題，請提供 <code>trackBy</code> 函式，以便正確關聯模型和渲染出來的元素。</p><p translation-origin=\"off\">Embedded views (such as ones created by <code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code>) are now inserted in front of anchor DOM comment node (for example, <code>&lt;!--ng-for-of--&gt;</code>) rather than behind it as was the case previously.\nIn most cases this has no impact on rendered DOM.</p>\n\n<p translation-origin=\"off\">When animations delay the removal of an embedded view, any new embedded views will be inserted after the embedded view that will be removed once the animation completes.\nThis difference only lasts while the animation is active, and might alter the visual appearance of the animation.\nWhen the animation is finished, the resulting rendered DOM is identical to that rendered with View Engine.</p>\n\n<p translation-origin=\"off\">One additional exception is the <code>&lt;select&gt;</code> element with <code>&lt;option&gt;</code> elements dynamically rendered using <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code>. If a <a href=\"api/common/NgForOf#ngForTrackBy\"><code>trackBy</code></a> function is not provided, the selected <code>&lt;option&gt;</code> will not be preserved when the iterable used by the <code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> changes.\nWith View Engine, this programming error was obscured, and often not visible.\nTo avoid this problem, provide the <code>trackBy</code> function to correctly associate the model with the rendered DOM elements.</p>\n\n</li>\n</ul>\n\n  \n</div>\n\n\n<!-- links to this doc:\n - guide/ivy\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/common/NgForOf#ngForTrackBy\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/DebugElement#attributes\n - api/core/DebugElement#classes\n - api/core/Directive\n - api/core/Host\n - api/core/HostBinding\n - api/core/Injectable\n - api/core/NgModule\n - api/core/Self\n - api/core/TemplateRef\n - api/core/ViewContainerRef\n - api/platform-browser/HammerModule\n - guide/ivy#opting-out-of-angular-ivy\n - guide/ivy-compatibility#changes-you-may-see\n - guide/ivy-compatibility#how-to-debug-errors-with-ivy\n - guide/ivy-compatibility#ivy-compatibility-guide\n - guide/ivy-compatibility#less-common-changes\n - guide/ivy-compatibility#payload-size-debugging\n - guide/ivy-compatibility-examples#content-children-descendants\n - guide/ivy-compatibility-examples#forward-refs-directive-inputs\n - guide/ivy-compatibility-examples#select-value-binding\n - guide/ivy-compatibility-examples#undecorated-classes\n - guide/style-precedence\n - guide/template-typecheck\n - guide/updating-to-version-12\n - https://github.com/angular/angular-cli/issues/16146#issuecomment-557559287\n - https://github.com/angular/angular-cli/issues/16799#issuecomment-580912090\n - https://github.com/ng-docs/angular-cn/edit/aio/aio/content/guide/ivy-compatibility.md?message=docs%3A%20請簡述你的修改...\n - https://terser.org/docs/api-reference.html#conditional-compilation\n-->"}