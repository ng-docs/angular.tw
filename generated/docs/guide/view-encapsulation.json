{"id":"guide/view-encapsulation","title":"View encapsulation","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/view-encapsulation.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"view-encapsulation\" translation-result=\"on\">檢視封裝<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#view-encapsulation\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">View encapsulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#view-encapsulation\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">在 Angular 中，元件的樣式可以封裝在元件的宿主元素中，這樣它們就不會影響應用程式的其餘部分。</p><p translation-origin=\"off\">In Angular, a component's styles can be encapsulated within the component's host element so that they don't affect the rest of the application.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 的裝飾器提供了 <a href=\"api/core/Component#encapsulation\"><code>encapsulation</code></a> 選項，可用來控制如何基於<em>每個元件</em>應用檢視封裝。</p><p translation-origin=\"off\">The <code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> decorator provides the <a href=\"api/core/Component#encapsulation\"><code>encapsulation</code></a> option which can be used to control how the encapsulation is applied on a <em>per component</em> basis.</p>\n\n<p translation-result=\"on\">從以下模式中選擇：</p><p translation-origin=\"off\">Choose from the following modes:</p>\n\n<!-- vale off -->\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">模式</nt-wrapper><nt-wrapper translation-origin=\"off\">Modes</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">Angular 使用瀏覽器內建的 <a href=\"https://developer.mozilla.org/docs/Web/Web_Components/Shadow_DOM\">Shadow DOM API</a> 將元件的檢視包含在 ShadowRoot（用作元件的宿主元素）中，並以隔離的方式應用所提供的樣式。</nt-wrapper><nt-wrapper translation-origin=\"off\">Angular uses the browser's built-in <a href=\"https://developer.mozilla.org/docs/Web/Web_Components/Shadow_DOM\">Shadow DOM API</a> to enclose the component's view inside a ShadowRoot, used as the component's host element, and apply the provided styles in an isolated manner.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">Angular 會修改元件的 CSS 選擇器，使它們只應用於元件的檢視，不影響應用程式中的其他元素（<em>模擬 </em>Shadow DOM 行為）。有關更多詳細資訊，請參閱<a href=\"guide/view-encapsulation#inspect-generated-css\">檢視產生的 CSS</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Angular modifies the component's CSS selectors so that they are only applied to the component's view and do not affect other elements in the application, <em>emulating</em> Shadow DOM behavior. For more details, see <a href=\"guide/view-encapsulation#inspect-generated-css\">Inspecting generated CSS</a>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">Angular 不應用任何形式的檢視封裝，這意味著為元件指定的任何樣式實際上都是全域應用的，並且可以影響應用程式中存在的任何 HTML 元素。這種模式本質上與將樣式包含在 HTML 本身中是一樣的。</nt-wrapper><nt-wrapper translation-origin=\"off\">Angular does not apply any sort of view encapsulation meaning that any styles specified for the component are actually globally applied and can affect any HTML element present within the application. This mode is essentially the same as including the styles into the HTML itself.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p><a id=\"inspect-generated-css\"></a></p>\n<h2 id=\"inspecting-generated-css\" translation-result=\"on\">檢視產生的 CSS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#inspecting-generated-css\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Inspecting generated CSS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#inspecting-generated-css\"><i class=\"material-icons\">link</i></a></h2>\n\n<!-- vale on -->\n<p translation-result=\"on\">使用模擬檢視封裝時，Angular 會預處理所有元件的樣式，以便它們僅應用於元件的檢視。</p><p translation-origin=\"off\">When using the emulated view encapsulation, Angular pre-processes all the component's styles so that they are only applied to the component's view.</p>\n\n<p translation-result=\"on\">在正執行的 Angular 應用程式的 DOM 中，使用模擬檢視封裝模式的元件所在的元素附加了一些額外的屬性：</p><p translation-origin=\"off\">In the DOM of a running Angular application, elements belonging to components using emulated view encapsulation have some extra attributes attached to them:</p>\n\n<code-example language=\"html\">\n\n&lt;hero-details _nghost-pmm-5&gt;\n  &lt;h2 _ngcontent-pmm-5&gt;Mister Fantastic&lt;/h2&gt;\n  &lt;hero-team _ngcontent-pmm-5 _nghost-pmm-6&gt;\n    &lt;h3 _ngcontent-pmm-6&gt;Team&lt;/h3&gt;\n  &lt;/hero-team&gt;\n&lt;/hero-details&gt;\n\n</code-example>\n<p translation-result=\"on\">有兩種這樣的屬性：</p><p translation-origin=\"off\">Two kinds of these attributes exist:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">屬性</nt-wrapper><nt-wrapper translation-origin=\"off\">Attributes</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>_nghost</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">被新增到包裹元件檢視的元素中，這將是原生 Shadow DOM 封裝中的 ShadowRoots。元件的宿主元素通常就是這種情況。</nt-wrapper><nt-wrapper translation-origin=\"off\">Are added to elements that enclose a component's view and that would be ShadowRoots in a native Shadow DOM encapsulation. This is typically the case for components' host elements.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>_ngcontent</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">被新增到元件檢視中的子元素上，這些屬性用於將元素與其各自模擬的 ShadowRoots（具有匹配 <code>_nghost</code> 屬性的宿主元素）相匹配。</nt-wrapper><nt-wrapper translation-origin=\"off\">Are added to child element within a component's view, those are used to match the elements with their respective emulated ShadowRoots (host elements with a matching <code>_nghost</code> attribute).</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">這些屬性的確切值是 Angular 的私有實現細節。它們是自動產生的，你不應在應用程式程式碼中參考它們。</p><p translation-origin=\"off\">The exact values of these attributes are a private implementation detail of Angular.\nThey are automatically created and you should never refer to them in application code.</p>\n\n<p translation-result=\"on\">它們以產生的元件樣式為目標，這些樣式會被注入到 DOM 的 <code>&lt;head&gt;</code> 部分：</p><p translation-origin=\"off\">They are targeted by the created component styles, which are injected in the <code>&lt;head&gt;</code> section of the DOM:</p>\n\n<code-example format=\"css\" language=\"css\">\n\n[_nghost-pmm-5] {\n  display: block;\n  border: 1px solid black;\n}\nh3[_ngcontent-pmm-6] {\n  background-color: white;\n  border: 1px solid #777;\n}\n\n</code-example>\n<p translation-result=\"on\">這些樣式經過後期處理，以便每個 CSS 選擇器都使用適當的 <code>_nghost</code> 或 <code>_ngcontent</code> 屬性進行擴充。這些修改後的選擇器可以確保樣式以隔離和有針對性的方式應用於元件的檢視。</p><p translation-origin=\"off\">These styles are post-processed so that each CSS selector is augmented with the appropriate <code>_nghost</code> or <code>_ngcontent</code> attribute.\nThese modified selectors make sure the styles to be applied to components' views in an isolated and targeted fashion.</p>\n\n<h2 id=\"mixing-encapsulation-modes\" translation-result=\"on\">混合封裝模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#mixing-encapsulation-modes\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Mixing encapsulation modes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#mixing-encapsulation-modes\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如前所述，你可以在元件的裝飾器中針對<em>每個元件</em>指定封裝模式，這意味著在你的應用程式中，不同的元件可以使用不同的封裝策略。</p><p translation-origin=\"off\">As mentioned earlier, you specify the encapsulation mode in the Component's decorator on a <em>per component</em> basis. This means that within your application you can have different components using different encapsulation strategies.</p>\n\n<p translation-result=\"on\">儘管可能，但不建議這樣做。如果真的需要，你應該知道使用不同封裝模式的元件的樣式會如何彼此互動：</p><p translation-origin=\"off\">Although possible, this is not recommended.\nIf it is really needed, you should be aware of how the styles of components using different encapsulation modes interact with each other:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">模式</nt-wrapper><nt-wrapper translation-origin=\"off\">Modes</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元件的樣式會新增到文件的 <code>&lt;head&gt;</code> 中，使它們在整個應用程式中可用，但它們的選擇器只會影響它們各自元件範本中的元素。</nt-wrapper><nt-wrapper translation-origin=\"off\">The styles of components are added to the <code>&lt;head&gt;</code> of the document, making them available throughout the application, but their selectors only affect elements within their respective components' templates.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元件的樣式會新增到文件的 <code>&lt;head&gt;</code> 中，使它們在整個應用程式中可用，因此是完全全域的，會影響文件中的任何匹配元素。</nt-wrapper><nt-wrapper translation-origin=\"off\">The styles of components are added to the <code>&lt;head&gt;</code> of the document, making them available throughout the application, so are completely global and affect any matching elements within the document.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元件樣式僅新增到 shadow DOM 宿主中，確保它們僅影響各自元件檢視中的元素。</nt-wrapper><nt-wrapper translation-origin=\"off\">The styles of components are only added to the shadow DOM host, ensuring that they only affect elements within their respective components' views.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> 和 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 元件的樣式也會新增到每個 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 元件的 shadow DOM 宿主中。</p><p translation-origin=\"off\">Styles of <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> and <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> components are also added to the shadow DOM host of each <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> component.</p>\n\n<p translation-result=\"on\">這意味著帶有 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的元件的樣式將影響 shadow DOM 中的匹配元素。</p><p translation-origin=\"off\">This means that styles for components with <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> affect matching elements within the shadow DOM.</p>\n\n<p translation-result=\"on\">這種方法乍一看似乎有違直覺，但如果沒有它，帶有 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的元件將在使用 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 的元件內渲染不同的效果，因為其樣式將不可用。</p><p translation-origin=\"off\">This approach may seem counter-intuitive at first. But without it a component with <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> would be rendered differently within a component using <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code>, since its styles would not be available.</p>\n\n</div>\n<h3 id=\"examples\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#examples\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#examples\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">本節展示了具有不同 <code><a href=\"api/core/ViewEncapsulation\" class=\"code-anchor\">ViewEncapsulation</a></code> 的元件的樣式如何互動的範例。</p><p translation-origin=\"off\">This section shows examples of how the styling of components with different <code><a href=\"api/core/ViewEncapsulation\" class=\"code-anchor\">ViewEncapsulation</a></code> interact.</p>\n\n<p translation-result=\"on\">請參閱 <live-example nodownload=\"\"></live-example> 以自己嘗試這些元件。</p><p translation-origin=\"off\">See the <live-example nodownload=\"\"></live-example> to try out these components yourself.</p>\n\n<h4 id=\"no-encapsulation\" translation-result=\"on\">無封裝<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#no-encapsulation\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">No encapsulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#no-encapsulation\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">第一個範例顯示了一個具有 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 的元件。此元件將其範本元素著色為紅色。</p><p translation-origin=\"off\">The first example shows a component that has <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code>.\nThis component colors its template elements red.</p>\n\n<code-example header=\"src/app/no-encapsulation.component.ts\" path=\"view-encapsulation/src/app/no-encapsulation.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-no-encapsulation',\n  template: `\n    &lt;h2&gt;None&lt;/h2&gt;\n    &lt;div class=\"none-message\"&gt;No encapsulation&lt;/div&gt;\n  `,\n  styles: ['h2, .none-message { color: red; }'],\n  encapsulation: <a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a>,\n})\nexport class NoEncapsulationComponent { }\n\n\n</code-example>\n<p translation-result=\"on\">Angular 將此元件的樣式作為全域樣式新增到文件的 <code>&lt;head&gt;</code> 中。</p><p translation-origin=\"off\">Angular adds the styles for this component as global styles to the <code>&lt;head&gt;</code> of the document.</p>\n\n<p translation-result=\"on\">如前所述，Angular 還會將這些樣式新增到所有 shadow DOM 宿主。因此，樣式在整個應用程式中都可用。</p><p translation-origin=\"off\">As already mentioned, Angular also adds the styles to all shadow DOM hosts, making the styles available throughout the whole application.</p>\n\n<div class=\"lightbox\">\n<img alt=\"component with no encapsulation\" src=\"generated/images/guide/view-encapsulation/no-encapsulation.png\" width=\"500\" height=\"101\">\n</div>\n<h4 id=\"emulated-encapsulation\" translation-result=\"on\">模擬封裝<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#emulated-encapsulation\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Emulated encapsulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#emulated-encapsulation\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">第二個範例顯示了一個具有 <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code> 的元件。此元件將其範本元素著色為綠色。</p><p translation-origin=\"off\">The second example shows a component that has <code><a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a></code>.\nThis component colors its template elements green.</p>\n\n<code-example header=\"src/app/emulated-encapsulation.component.ts\" path=\"view-encapsulation/src/app/emulated-encapsulation.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-emulated-encapsulation',\n  template: `\n    &lt;h2&gt;Emulated&lt;/h2&gt;\n    &lt;div class=\"emulated-message\"&gt;Emulated encapsulation&lt;/div&gt;\n    &lt;app-no-encapsulation&gt;&lt;/app-no-encapsulation&gt;\n  `,\n  styles: ['h2, .emulated-message { color: green; }'],\n  encapsulation: <a href=\"api/core/ViewEncapsulation#Emulated\" class=\"code-anchor\">ViewEncapsulation.Emulated</a>,\n})\nexport class EmulatedEncapsulationComponent { }\n\n\n</code-example>\n<p translation-result=\"on\">與 <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code> 類似，Angular 會將此元件的樣式新增到文件的 <code>&lt;head&gt;</code> 中，但它們是帶有“作用域”的樣式。</p><p translation-origin=\"off\">Comparable to <code><a href=\"api/core/ViewEncapsulation#None\" class=\"code-anchor\">ViewEncapsulation.None</a></code>, Angular adds the styles for this component to the <code>&lt;head&gt;</code> of the document, but with \"scoped\" styles.</p>\n\n<p translation-result=\"on\">只有直接在該元件範本中的元素才會匹配其樣式。由於來自 <code>EmulatedEncapsulationComponent</code> 的樣式是特化的，因此它們會覆蓋來自 <code>NoEncapsulationComponent</code> 的全域樣式。</p><p translation-origin=\"off\">Only the elements directly within this component's template are going to match its styles.\nSince the \"scoped\" styles from the <code>EmulatedEncapsulationComponent</code> are specific, they override the global styles from the <code>NoEncapsulationComponent</code>.</p>\n\n<p translation-result=\"on\">在此範例中，<code>EmulatedEncapsulationComponent</code> 包含著 <code>NoEncapsulationComponent</code>，但 <code>NoEncapsulationComponent</code> 仍然如預期般生效了，因為 <code>EmulatedEncapsulationComponent</code> 的“範圍化”樣式與其範本中的元素並不匹配。</p><p translation-origin=\"off\">In this example, the <code>EmulatedEncapsulationComponent</code> contains a <code>NoEncapsulationComponent</code>, but <code>NoEncapsulationComponent</code> is still styled as expected since the <code>EmulatedEncapsulationComponent</code> 's \"scoped\" styles do not match elements in its template.</p>\n\n<div class=\"lightbox\">\n<img alt=\"component with no encapsulation\" src=\"generated/images/guide/view-encapsulation/emulated-encapsulation.png\" width=\"500\" height=\"207\">\n</div>\n<h4 id=\"shadow-dom-encapsulation\" translation-result=\"on\">Shadow DOM 封裝<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#shadow-dom-encapsulation\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Shadow DOM encapsulation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/view-encapsulation#shadow-dom-encapsulation\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">第三個範例顯示了一個具有 <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code> 的元件。此元件會將其範本元素著色為藍色。</p><p translation-origin=\"off\">The third example shows a component that has <code><a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a></code>.\nThis component colors its template elements blue.</p>\n\n<code-example header=\"src/app/shadow-dom-encapsulation.component.ts\" path=\"view-encapsulation/src/app/shadow-dom-encapsulation.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-shadow-dom-encapsulation',\n  template: `\n    &lt;h2&gt;ShadowDom&lt;/h2&gt;\n    &lt;div class=\"shadow-message\"&gt;Shadow DOM encapsulation&lt;/div&gt;\n    &lt;app-emulated-encapsulation&gt;&lt;/app-emulated-encapsulation&gt;\n    &lt;app-no-encapsulation&gt;&lt;/app-no-encapsulation&gt;\n  `,\n  styles: ['h2, .shadow-message { color: blue; }'],\n  encapsulation: <a href=\"api/core/ViewEncapsulation#ShadowDom\" class=\"code-anchor\">ViewEncapsulation.ShadowDom</a>,\n})\nexport class ShadowDomEncapsulationComponent { }\n\n\n</code-example>\n<p translation-result=\"on\">Angular 僅將此元件的樣式新增到 shadow DOM 宿主，因此它們在 shadow DOM 之外是不可見的。</p><p translation-origin=\"off\">Angular adds styles for this component only to the shadow DOM host, so they are not visible outside the shadow DOM.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\nAngular 還將 <code>NoEncapsulationComponent</code> 和 <code>EmulatedEncapsulationComponent</code> 的全域樣式新增到了 shadow DOM 宿主中，因此這些樣式仍然可用於該元件的範本中的元素。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nAngular also adds the global styles from the <code>NoEncapsulationComponent</code> and <code>EmulatedEncapsulationComponent</code> to the shadow DOM host. Those styles are still available to the elements in the template of this component.</p>\n\n</div>\n<p translation-result=\"on\">在這個例子中，<code>ShadowDomEncapsulationComponent</code> 包含一個 <code>NoEncapsulationComponent</code> 和 <code>EmulatedEncapsulationComponent</code>。</p><p translation-origin=\"off\">In this example, the <code>ShadowDomEncapsulationComponent</code> contains both a <code>NoEncapsulationComponent</code> and <code>EmulatedEncapsulationComponent</code>.</p>\n\n<p translation-result=\"on\"><code>ShadowDomEncapsulationComponent</code> 元件新增的樣式在該元件的整個 shadow DOM 中都可用，在 <code>NoEncapsulationComponent</code> 和 <code>EmulatedEncapsulationComponent</code> 中也是如此。</p><p translation-origin=\"off\">The styles added by the <code>ShadowDomEncapsulationComponent</code> component are available throughout the shadow DOM of this component, and so to both the <code>NoEncapsulationComponent</code> and <code>EmulatedEncapsulationComponent</code>.</p>\n\n<p translation-result=\"on\"><code>EmulatedEncapsulationComponent</code> 具有特化的“範圍化”樣式，因此該元件範本的樣式不受影響。</p><p translation-origin=\"off\">The <code>EmulatedEncapsulationComponent</code> has specific \"scoped\" styles, so the styling of this component's template is unaffected.</p>\n\n<p translation-result=\"on\">由於 <code>ShadowDomEncapsulationComponent</code> 中的樣式是在全域樣式之後新增到 Shadow Host 中的，因此 <code>h2</code> 樣式會覆蓋 <code>NoEncapsulationComponent</code> 中的樣式。結果是 <code>NoEncapsulationComponent</code> 中的 <code>&lt;h2&gt;</code> 元素被著色為藍色而不是紅色，這可能不是元件作者的本意。</p><p translation-origin=\"off\">Since styles from <code>ShadowDomEncapsulationComponent</code> are added to the shadow host after the global styles, the <code>h2</code> style overrides the style from the <code>NoEncapsulationComponent</code>.\nThe result is that the <code>&lt;h2&gt;</code> element in the <code>NoEncapsulationComponent</code> is colored blue rather than red, which may not be what the component's author intended.</p>\n\n<div class=\"lightbox\">\n<img alt=\"component with no encapsulation\" src=\"generated/images/guide/view-encapsulation/shadow-dom-encapsulation.png\" width=\"500\" height=\"413\">\n</div>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：4/21/2023</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/component-styles\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/Component#encapsulation\n - api/core/ViewEncapsulation\n - api/core/ViewEncapsulation#Emulated\n - api/core/ViewEncapsulation#None\n - api/core/ViewEncapsulation#ShadowDom\n - guide/view-encapsulation#emulated-encapsulation\n - guide/view-encapsulation#examples\n - guide/view-encapsulation#inspect-generated-css\n - guide/view-encapsulation#inspecting-generated-css\n - guide/view-encapsulation#mixing-encapsulation-modes\n - guide/view-encapsulation#no-encapsulation\n - guide/view-encapsulation#shadow-dom-encapsulation\n - guide/view-encapsulation#shadow-dom-封裝\n - guide/view-encapsulation#view-encapsulation\n - guide/view-encapsulation#例子\n - guide/view-encapsulation#無封裝\n - guide/view-encapsulation#檢視產生的-css\n - guide/view-encapsulation#模擬封裝\n - guide/view-encapsulation#混合封裝模式\n - guide/view-encapsulation#檢視封裝\n - https://developer.mozilla.org/docs/Web/Web_Components/Shadow_DOM\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/view-encapsulation.md?message=docs%3A%20請簡述你的修改...\n-->"}