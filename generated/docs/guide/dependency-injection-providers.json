{"id":"guide/dependency-injection-providers","title":"Configuring dependency providers","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/dependency-injection-providers.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"configuring-dependency-providers\" translation-result=\"on\">配置依賴提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#configuring-dependency-providers\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Configuring dependency providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#configuring-dependency-providers\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">“建立與注入服務”這個主題介紹的是如何使用類作為依賴項。除了類之外，你還可以用其他值作為依賴項，例如 Boolean、字串、日期和物件。Angular DI 提供了一些必要的 API 來讓依賴的配置方式更加靈活，以便你可以把這些值在 DI 中可用。</p><p translation-origin=\"off\">The Creating and injecting services topic describes how to use classes as dependencies. Besides classes, you can also use other values such as Boolean, string, date, and objects as dependencies. Angular DI provides the necessary APIs to make the dependency configuration flexible, so you can make those values available in DI.</p>\n\n<h2 id=\"specifying-a-provider-token\" translation-result=\"on\">指定提供者令牌<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#specifying-a-provider-token\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Specifying a provider token<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#specifying-a-provider-token\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果你用服務類作為提供者令牌，則其預設行為是注入器使用 <code>new</code> 運算子例項化該類別。</p><p translation-origin=\"off\">If you specify the service class as the provider token, the default behavior is for the injector to instantiate that class using the <code>new</code> operator.</p>\n\n<p translation-result=\"on\">在下面這個例子中，<code>Logger</code> 類提供了 <code>Logger</code> 的例項。</p><p translation-origin=\"off\">In the following example, the <code>Logger</code> class provides a <code>Logger</code> instance.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<p translation-result=\"on\">但是，你可以將 DI 配置為使用不同的類或任何其他不同的值來與 <code>Logger</code> 類關聯。因此，當注入 <code>Logger</code> 時，會改為使用這個新值。</p><p translation-origin=\"off\">You can, however, configure a DI to use a different class or any other different value to associate with the <code>Logger</code> class. So when the <code>Logger</code> is injected, this new value is used instead.</p>\n\n<p translation-result=\"on\">實際上，類提供者語法是一個簡寫表示式，可以擴充為由 <code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code> 介面定義的提供者配置資訊。</p><p translation-origin=\"off\">In fact, the class provider syntax is a shorthand expression that expands into a provider configuration, defined by the <code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code> interface.</p>\n\n<p translation-result=\"on\">在這種情況下，Angular 將 <code>providers</code> 值展開為完整的提供者物件，如下所示：</p><p translation-origin=\"off\">Angular expands the <code>providers</code> value in this case into a full provider object as follows:</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-3\">\n[{ provide: Logger, useClass: Logger }]\n\n</code-example>\n<p translation-result=\"on\">展開後的提供者配置是一個具有兩個屬性的物件字面量：</p><p translation-origin=\"off\">The expanded provider configuration is an object literal with two properties:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>provide</code> 屬性包含一個令牌，該令牌會作為定位依賴值和配置注入器時的鍵。</p><p translation-origin=\"off\">The <code>provide</code> property holds the token that serves as the key for both locating a dependency value and configuring the injector.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">第二個屬性是一個提供者定義物件，它會告訴注入器如何建立依賴值。提供者定義物件中的鍵可以是以下值之一：</p><p translation-origin=\"off\">The second property is a provider definition object, which tells the injector how to create the dependency value. The provider-definition key can be one of the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">useClass - 此選項告訴 Angular DI 在注入依賴項時要例項化這裡提供的類</p><p translation-origin=\"off\">useClass - this option tells Angular DI to instantiate a provided class when a dependency is injected</p>\n\n</li>\n<li>\n<p translation-result=\"on\">useExisting - 允許你為令牌起一個別名，並參考任意一個現有令牌。</p><p translation-origin=\"off\">useExisting - allows you to alias a token and reference any existing one.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">useFactory - 允許你定義一個用來構造依賴項的函式。</p><p translation-origin=\"off\">useFactory - allows you to define a function that constructs a dependency.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">useValue - 提供了一個應該作為依賴項使用的靜態值。</p><p translation-origin=\"off\">useValue - provides a static value that should be used as a dependency.</p>\n\n</li>\n</ul>\n</li>\n</ul>\n<p translation-result=\"on\">下面的部分介紹如何使用這裡所說的“提供者定義”鍵。</p><p translation-origin=\"off\">The section below describes how to use the mentioned provider definition keys.</p>\n\n<p><a id=\"token\"></a>\n<a id=\"injection-token\"></a></p>\n<h3 id=\"class-providers-useclass\" translation-result=\"on\">類提供者：useClass<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#class-providers-useclass\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Class providers: useClass<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#class-providers-useclass\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>useClass</code> 這個提供者鍵名能讓你建立並返回指定類別的新例項。你可以用這種型別的提供者來作為通用類或預設類別的替代實現。例如，替代實現可以實現不同的策略、擴充預設類或模擬測試使用案例中真實類別的行為。在以下範例中，當在元件或任何其他類中請求 <code>Logger</code> 依賴項時，將轉而例項化 <code>BetterLogger</code> 類別。</p><p translation-origin=\"off\">The <code>useClass</code> provider key lets you create and return a new instance of the specified class.\nYou can use this type of provider to substitute an alternative implementation for a common or default class. The alternative implementation can, for example, implement a different strategy, extend the default class, or emulate the behavior of the real class in a test case.\nIn the following example, the <code>BetterLogger</code> class would be instantiated when the <code>Logger</code> dependency is requested in a component or any other class.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-4\">\n[{ provide: Logger, useClass: BetterLogger }]\n\n</code-example>\n<p><a id=\"class-provider-dependencies\"></a></p>\n<p translation-result=\"on\">如果替代類提供者有自己的依賴項，請在父模組或元件的 <code>providers</code> 元資料屬性中指定這兩個提供者。</p><p translation-origin=\"off\">If the alternative class providers have their own dependencies, specify both providers in the providers metadata property of the parent module or component.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-5\">\n[ UserService,\n  { provide: Logger, useClass: EvenBetterLogger }]\n\n</code-example>\n<p translation-result=\"on\">在這個例子中，<code>EvenBetterLogger</code> 會在日誌資訊裡顯示使用者名稱。這個 logger 要從注入的 <code>UserService</code> 例項中來獲取該使用者。</p><p translation-origin=\"off\">In this example, <code>EvenBetterLogger</code> displays the user name in the log message. This logger gets the user from an injected <code>UserService</code> instance.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"EvenBetterLogger\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class EvenBetterLogger extends Logger {\n  constructor(private userService: UserService) { super(); }\n\n  override log(message: string) {\n    const name = this.userService.user.name;\n    super.log(`Message to ${name}: ${message}`);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">Angular DI 知道如何建構 <code>UserService</code> 依賴項，因為它已經在上面進行配置並且在注入器中可用。</p><p translation-origin=\"off\">Angular DI knows how to construct the <code>UserService</code> dependency, since it has been configured above and is available in the injector.</p>\n\n<h3 id=\"alias-providers-useexisting\" translation-result=\"on\">別名提供者：useExisting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#alias-providers-useexisting\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Alias providers: useExisting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#alias-providers-useexisting\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>useExisting</code> 提供者鍵允許你將一個令牌對映到另一個。實際上，第一個令牌是與第二個令牌關聯的服務的別名，建立了兩種存取同一個服務物件的方式。</p><p translation-origin=\"off\">The <code>useExisting</code> provider key lets you map one token to another. In effect, the first token is an alias for the service associated with the second token, creating two ways to access the same service object.</p>\n\n<p translation-result=\"on\">在下面的例子中，當元件請求新的或舊的記錄器時，注入器都會注入一個 <code>NewLogger</code> 的例項。透過這種方式，<code>OldLogger</code> 就成了 <code>NewLogger</code> 的別名。</p><p translation-origin=\"off\">In the following example, the injector injects the singleton instance of <code>NewLogger</code> when the component asks for either the new or the old logger. In this way, <code>OldLogger</code> is an alias for <code>NewLogger</code>.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6b\">\n[ NewLogger,\n  // Alias OldLogger w/ reference to NewLogger\n  { provide: OldLogger, useExisting: NewLogger}]\n\n</code-example>\n<p translation-result=\"on\">確保你沒有使用 <code>OldLogger</code> 將 <code>NewLogger</code> 別名為 <code>useClass</code>，因為這會建立兩個不同 <code>NewLogger</code> 例項。</p><p translation-origin=\"off\">Ensure you do not alias <code>OldLogger</code> to <code>NewLogger</code> with <code>useClass</code>, as this creates two different <code>NewLogger</code> instances.</p>\n\n<h3 id=\"factory-providers-usefactory\" translation-result=\"on\">工廠提供者：useFactory<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#factory-providers-usefactory\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Factory providers: useFactory<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#factory-providers-usefactory\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>useFactory</code> 提供者鍵允許你透過呼叫工廠函式來建立依賴物件。使用這種方法，你可以根據 DI 和應用程式中其他地方的可用資訊建立動態值。</p><p translation-origin=\"off\">The <code>useFactory</code> provider key lets you create a dependency object by calling a factory function. With this approach you can create a dynamic value based on information available in the DI and elsewhere in the app.</p>\n\n<p translation-result=\"on\">在下面的例子中，只有授權使用者才能看到 <code>HeroService</code> 中的秘密英雄。授權可能在單個應用會話期間發生變化，比如改用其他使用者登入。</p><p translation-origin=\"off\">In the following example, only authorized users should see secret heroes in the <code>HeroService</code>.\nAuthorization can change during the course of a single application session, as when a different user logs in .</p>\n\n<p translation-result=\"on\">要想在 <code>UserService</code> 和 <code>HeroService</code> 中儲存敏感資訊，就要給 <code>HeroService</code> 的建構函式傳一個邏輯標誌來控制秘密英雄的顯示。</p><p translation-origin=\"off\">To keep security-sensitive information in <code>UserService</code> and out of <code>HeroService</code>, give the <code>HeroService</code> constructor a boolean flag to control display of secret heroes.</p>\n\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.ts\" region=\"internals\" header=\"src/app/heroes/hero.service.ts (excerpt)\">\nconstructor(\n  private logger: Logger,\n  private isAuthorized: boolean) { }\n\ngetHeroes() {\n  const auth = this.isAuthorized ? 'authorized ' : 'unauthorized';\n  this.logger.log(`Getting heroes for ${auth} user.`);\n  return HEROES.filter(hero =&gt; this.isAuthorized || !hero.isSecret);\n}\n\n</code-example>\n<p translation-result=\"on\">要實現 <code>isAuthorized</code> 標誌，可以用工廠提供者來為 <code>HeroService</code> 建立一個新的 logger 例項。</p><p translation-origin=\"off\">To implement the <code>isAuthorized</code> flag, use a factory provider to create a new logger instance for <code>HeroService</code>.</p>\n\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"factory\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\">\nconst heroServiceFactory = (logger: Logger, userService: UserService) =&gt;\n  new HeroService(logger, userService.user.isAuthorized);\n\n</code-example>\n<p translation-result=\"on\">這個工廠函式可以存取 <code>UserService</code>。你可以同時把 <code>Logger</code> 和 <code>UserService</code> 注入到工廠提供者中，這樣注入器就可以把它們傳給工廠函數了。</p><p translation-origin=\"off\">The factory function has access to <code>UserService</code>.\nYou inject both <code>Logger</code> and <code>UserService</code> into the factory provider so the injector can pass them along to the factory function.</p>\n\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"provider\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\">\nexport const heroServiceProvider =\n  { provide: HeroService,\n    useFactory: heroServiceFactory,\n    deps: [Logger, UserService]\n  };\n\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\"><code>useFactory</code> 欄位指定該提供者是一個工廠函式，其實現程式碼是 <code>heroServiceFactory</code>。</p><p translation-origin=\"off\">The <code>useFactory</code> field specifies that the provider is a factory function whose implementation is <code>heroServiceFactory</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>deps</code> 屬性是一個提供者令牌的陣列。<code>Logger</code> 和 <code>UserService</code> 類作為它們自己的類提供者的令牌。注入器會解析這些令牌，並將相應的服務注入到匹配的 <code>heroServiceFactory</code> 工廠函式引數中。</p><p translation-origin=\"off\">The <code>deps</code> property is an array of provider tokens.\nThe <code>Logger</code> and <code>UserService</code> classes serve as tokens for their own class providers.\nThe injector resolves these tokens and injects the corresponding services into the matching <code>heroServiceFactory</code> factory function parameters.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">透過把工廠提供者匯出為變數 <code>heroServiceProvider</code>，就能讓工廠提供者變得可複用。</p><p translation-origin=\"off\">Capturing the factory provider in the exported variable, <code>heroServiceProvider</code>, makes the factory provider reusable.</p>\n\n<h3 id=\"value-providers-usevalue\" translation-result=\"on\">值提供者：useValue<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#value-providers-usevalue\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Value providers: useValue<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#value-providers-usevalue\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>useValue</code> 鍵允許你將固定值與某個 DI 令牌相關聯。可以用此技術提供執行時配置常量，例如網站基址和特性標誌。你還可以在單元測試中使用值提供者來提供模擬資料以代替生產級資料服務。下一節提供有關 <code>useValue</code> 鍵的更多資訊。</p><p translation-origin=\"off\">The <code>useValue</code> key lets you associate a fixed value with a DI token. Use this technique to provide runtime configuration constants such as website base addresses and feature flags. You can also use a value provider in a unit test to provide mock data in place of a production data service. The next section provides more information about the <code>useValue</code> key.</p>\n\n<h2 id=\"using-an-injectiontoken-object\" translation-result=\"on\">使用 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#使用-injectiontoken-物件\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Using an <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> object<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#using-an-injectiontoken-object\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">可以定義和使用一個 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 物件來為非類別的依賴選擇一個提供者令牌。下列例子定義了一個類別型為 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 的 <code>APP_CONFIG</code>。</p><p translation-origin=\"off\">Define and use an <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> object for choosing a provider token for non-class dependencies. The following example defines a token, <code>APP_CONFIG</code> of the type <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code>.</p>\n\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"token\" header=\"src/app/app.config.ts\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const APP_CONFIG = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&lt;AppConfig&gt;('app.config');\n\n</code-example>\n<p translation-result=\"on\">可選的引數 <code>&lt;AppConfig&gt;</code> 和令牌描述 <code>app.config</code> 指明瞭此令牌的用途。</p><p translation-origin=\"off\">The optional type parameter, <code>&lt;AppConfig&gt;</code>, and the token description, <code>app.config</code>, specify the token's purpose.</p>\n\n<p translation-result=\"on\">接著，用 <code>APP_CONFIG</code> 這個 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 物件在元件中註冊依賴提供者。</p><p translation-origin=\"off\">Next, register the dependency provider in the component using the <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> object of <code>APP_CONFIG</code>.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" header=\"src/app/providers.component.ts\" region=\"providers-9\">\nproviders: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }]\n\n</code-example>\n<p translation-result=\"on\">現在，藉助引數裝飾器 <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>()</code>，你可以把這個配置物件注入到建構函式中。</p><p translation-origin=\"off\">Now, inject the configuration object into the constructor with <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>()</code> parameter decorator.</p>\n\n<code-example path=\"dependency-injection/src/app/app.component.2.ts\" region=\"ctor\" header=\"src/app/app.component.ts\">\nconstructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(APP_CONFIG) config: AppConfig) {\n  this.title = config.title;\n}\n\n</code-example>\n<h3 id=\"interfaces-and-di\" translation-result=\"on\">介面和 DI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#interfaces-and-di\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Interfaces and DI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#interfaces-and-di\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">儘管 TypeScript 的 <code>AppConfig</code> 介面可以充當類別的型別，但 <code>AppConfig</code> 介面在 DI 中無法使用。在 TypeScript 中，介面是設計時工件，它沒有可供 DI 框架使用的執行時表示或令牌。</p><p translation-origin=\"off\">Though the TypeScript <code>AppConfig</code> interface supports typing within the class, the <code>AppConfig</code> interface plays no role in DI.\nIn TypeScript, an interface is a design-time artifact, and does not have a runtime representation, or token, that the DI framework can use.</p>\n\n<p translation-result=\"on\">當轉譯器把 TypeScript 轉換成 JavaScript 時，介面就會消失，因為 JavaScript 沒有介面。</p><p translation-origin=\"off\">When the transpiler changes TypeScript to JavaScript, the interface disappears because JavaScript doesn't have interfaces.</p>\n\n<p translation-result=\"on\">由於 Angular 在執行期沒有介面，所以該介面不能作為令牌，也不能注入它。</p><p translation-origin=\"off\">Because there is no interface for Angular to find at runtime, the interface cannot be a token, nor can you inject it.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9-interface\">\n// Can't use interface as provider token\n[{ provide: AppConfig, useValue: HERO_DI_CONFIG })]\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-9-ctor-interface\">\n// Can't inject using the interface as the parameter type\nconstructor(private config: AppConfig){ }\n\n</code-example>\n<h2 id=\"whats-next\" translation-result=\"on\">下一步呢？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#whats-next\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">What's next<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#whats-next\"><i class=\"material-icons\">link</i></a></h2>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"guide/dependency-injection-in-action\">依賴注入實戰</a></p><p translation-origin=\"off\"><a href=\"guide/dependency-injection-in-action\">Dependency Injection in Action</a></p>\n\n</li>\n</ul>\n\n  <div class=\"reviewed\">最後複查時間：8/2/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/Injector\n - api/core/StaticProvider\n - guide/creating-injectable-service\n - guide/dependency-injection\n - guide/dependency-injection-in-action\n - guide/dependency-injection-overview\n - guide/hierarchical-dependency-injection\n - guide/providers\n - guide/router\n-->\n<!-- links from this doc:\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Provider\n - guide/dependency-injection-in-action\n - guide/dependency-injection-providers#alias-providers-useexisting\n - guide/dependency-injection-providers#class-providers-useclass\n - guide/dependency-injection-providers#configuring-dependency-providers\n - guide/dependency-injection-providers#factory-providers-usefactory\n - guide/dependency-injection-providers#interfaces-and-di\n - guide/dependency-injection-providers#specifying-a-provider-token\n - guide/dependency-injection-providers#using-an-injectiontoken-object\n - guide/dependency-injection-providers#value-providers-usevalue\n - guide/dependency-injection-providers#whats-next\n - guide/dependency-injection-providers#下一步呢\n - guide/dependency-injection-providers#使用-injectiontoken-物件\n - guide/dependency-injection-providers#值提供者usevalue\n - guide/dependency-injection-providers#別名提供者useexisting\n - guide/dependency-injection-providers#工廠提供者usefactory\n - guide/dependency-injection-providers#指定提供者令牌\n - guide/dependency-injection-providers#介面和-di\n - guide/dependency-injection-providers#類提供者useclass\n - guide/dependency-injection-providers#配置依賴提供者\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/dependency-injection-providers.md?message=docs%3A%20請簡述你的修改...\n-->"}