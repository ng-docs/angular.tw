{"id":"guide/http-interceptor-use-cases","title":"HTTP -  interceptor use-cases","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-interceptor-use-cases.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"http----interceptor-use-cases\" translation-result=\"on\">HTTP 攔截器使用案例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#http----interceptor-use-cases\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">HTTP -  interceptor use-cases<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#http----interceptor-use-cases\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">以下是攔截器的一些常見用法。</p><p translation-origin=\"off\">Following are a number of common uses for interceptors.</p>\n\n<h2 id=\"set-default-headers\" translation-result=\"on\">設定預設標題<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#set-default-headers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Set default headers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#set-default-headers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">應用通常會使用攔截器來設定外發請求的預設請求頭。</p><p translation-origin=\"off\">Apps often use an interceptor to set default headers on outgoing requests.</p>\n\n<p translation-result=\"on\">該範例應用具有一個 <code>AuthService</code>，它會產生一個認證令牌。在這裡，<code>AuthInterceptor</code> 會注入該服務以獲取令牌，並對每一個外發的請求新增一個帶有該令牌的認證頭：</p><p translation-origin=\"off\">The sample app has an <code>AuthService</code> that produces an authorization token.\nHere is its <code>AuthInterceptor</code> that injects that service to get the token and adds an authorization header with that token to every outgoing request:</p>\n\n<code-example header=\"app/http-interceptors/auth-interceptor.ts\" path=\"http/src/app/http-interceptors/auth-interceptor.ts\">\nimport { AuthService } from '../auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class AuthInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n\n  constructor(private auth: AuthService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // Get the auth token from the service.\n    const authToken = this.auth.getAuthorizationToken();\n\n    // Clone the request and replace the original headers with\n    // cloned headers, updated with the authorization.\n    const authReq = req.clone({\n      headers: req.headers.set('Authorization', authToken)\n    });\n\n    // send cloned request with header to the next handler.\n    return next.handle(authReq);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">這種在複製請求的同時設定新請求頭的操作太常見了，因此它還有一個快捷方式 <code>setHeaders</code>：</p><p translation-origin=\"off\">The practice of cloning a request to set new headers is so common that there's a <code>setHeaders</code> shortcut for it:</p>\n\n<code-example path=\"http/src/app/http-interceptors/auth-interceptor.ts\" region=\"set-header-shortcut\">\n// Clone the request and set the new header in one step.\nconst authReq = req.clone({ setHeaders: { Authorization: authToken } });\n\n</code-example>\n<p translation-result=\"on\">這種可以修改頭的攔截器可以用於很多不同的操作，比如：</p><p translation-origin=\"off\">An interceptor that alters headers can be used for a number of different operations, including:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">認證 / 授權</p><p translation-origin=\"off\">Authentication/authorization</p>\n\n</li>\n<li>\n<p translation-result=\"on\">控制快取行為。比如 <code>If-Modified-Since</code></p><p translation-origin=\"off\">Caching behavior; for example, <code>If-Modified-Since</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">XSRF 防護</p><p translation-origin=\"off\">XSRF protection</p>\n\n</li>\n</ul>\n<h2 id=\"log-request-and-response-pairs\" translation-result=\"on\">記錄請求和響應對<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#log-request-and-response-pairs\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Log request and response pairs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#log-request-and-response-pairs\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">因為攔截器可以<em>同時</em>處理請求和響應，所以它們也可以對整個 HTTP 操作執行計時和記錄日誌等任務。</p><p translation-origin=\"off\">Because interceptors can process the request and response <em>together</em>, they can perform tasks such as timing and logging an entire HTTP operation.</p>\n\n<p translation-result=\"on\">考慮下面這個 <code>LoggingInterceptor</code>，它捕獲請求的發起時間、響應的接收時間，並使用注入的 <code>MessageService</code> 來發送總共花費的時間。</p><p translation-origin=\"off\">Consider the following <code>LoggingInterceptor</code>, which captures the time of the request,\nthe time of the response, and logs the outcome with the elapsed time\nwith the injected <code>MessageService</code>.</p>\n\n<code-example header=\"app/http-interceptors/logging-interceptor.ts)\" path=\"http/src/app/http-interceptors/logging-interceptor.ts\" region=\"excerpt\">\nimport { finalize, tap } from 'rxjs/operators';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class LoggingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private messenger: MessageService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    const started = Date.now();\n    let ok: string;\n\n    // extend server response observable with logging\n    return next.handle(req)\n      .pipe(\n        tap({\n          // Succeeds when there is a response; ignore other events\n          next: (event) =&gt; (ok = event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a> ? 'succeeded' : ''),\n          // Operation failed; error is an <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>\n          error: (error) =&gt; (ok = 'failed')\n        }),\n        // Log when response observable either completes or errors\n        finalize(() =&gt; {\n          const elapsed = Date.now() - started;\n          const msg = `${req.method} \"${req.urlWithParams}\"\n             ${ok} in ${elapsed} ms.`;\n          this.messenger.add(msg);\n        })\n      );\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">RxJS 的 <code>tap</code> 運運算元會捕獲請求成功了還是失敗了。RxJS 的 <code>finalize</code> 運運算元無論在返回成功還是失敗時都會呼叫，然後把結果彙報給 <code>MessageService</code>。</p><p translation-origin=\"off\">The RxJS <code>tap</code> operator captures whether the request succeeded or failed.\nThe RxJS <code>finalize</code> operator is called when the response observable either returns an error or completes and reports the outcome to the <code>MessageService</code>.</p>\n\n<p translation-result=\"on\">在這個可觀察物件的流中，無論是 <code>tap</code> 還是 <code>finalize</code> 接觸過的值，都會照常傳送給呼叫者。</p><p translation-origin=\"off\">Neither <code>tap</code> nor <code>finalize</code> touch the values of the observable stream returned to the caller.</p>\n\n<p><a id=\"custom-json-parser\"></a></p>\n<h2 id=\"custom-json-parsing\" translation-result=\"on\">自訂 JSON 解析<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#custom-json-parsing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Custom JSON parsing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#custom-json-parsing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">攔截器可用來以自訂實現替換內建的 JSON 解析。</p><p translation-origin=\"off\">Interceptors can be used to replace the built-in JSON parsing with a custom implementation.</p>\n\n<p translation-result=\"on\">以下範例中的 <code>CustomJsonInterceptor</code> 示範瞭如何實現此目的。如果截獲的請求期望一個 <code>'json'</code> 響應，則將 <code>responseType</code> 更改為 <code>'text'</code> 以禁用內建的 JSON 解析。然後，透過注入的 <code>JsonParser</code> 解析響應。</p><p translation-origin=\"off\">The <code>CustomJsonInterceptor</code> in the following example demonstrates how to achieve this.\nIf the intercepted request expects a <code>'json'</code> response, the <code>responseType</code> is changed to <code>'text'</code> to disable the built-in JSON parsing.\nThen the response is parsed via the injected <code>JsonParser</code>.</p>\n\n<code-example header=\"app/http-interceptors/custom-json-interceptor.ts\" path=\"http/src/app/http-interceptors/custom-json-interceptor.ts\" region=\"custom-json-interceptor\">\n// The JsonParser class acts as a base class for custom parsers and as the DI token.\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport abstract class JsonParser {\n  abstract parse(text: string): any;\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CustomJsonInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private jsonParser: JsonParser) {}\n\n  intercept(httpRequest: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    if (httpRequest.responseType === 'json') {\n      // If the expected response type is JSON then handle it here.\n      return this.handleJsonResponse(httpRequest, next);\n    } else {\n      return next.handle(httpRequest);\n    }\n  }\n\n  private handleJsonResponse(httpRequest: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // Override the responseType to disable the default JSON parsing.\n    httpRequest = httpRequest.clone({responseType: 'text'});\n    // Handle the response using the custom parser.\n    return next.handle(httpRequest).pipe(map(event =&gt; this.parseJsonResponse(event)));\n  }\n\n  private parseJsonResponse(event: <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;) {\n    if (event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a> &amp;&amp; typeof event.body === 'string') {\n      return event.clone({body: this.jsonParser.parse(event.body)});\n    } else {\n      return event;\n    }\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">然後，你可以實現自己的自訂 <code>JsonParser</code>。這是一個具有特殊日期接收器的自訂 JsonParser。</p><p translation-origin=\"off\">You can then implement your own custom <code>JsonParser</code>.\nHere is a custom JsonParser that has a special date reviver.</p>\n\n<code-example header=\"app/http-interceptors/custom-json-interceptor.ts\" path=\"http/src/app/http-interceptors/custom-json-interceptor.ts\" region=\"custom-json-parser\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CustomJsonParser implements JsonParser {\n  parse(text: string): any {\n    return JSON.parse(text, dateReviver);\n  }\n}\n\nfunction dateReviver(key: string, value: any) {\n  /* . . . */\n}\n\n</code-example>\n<p translation-result=\"on\">你提供 <code>CustomParser</code> 以及 <code>CustomJsonInterceptor</code>。</p><p translation-origin=\"off\">You provide the <code>CustomParser</code> along with the <code>CustomJsonInterceptor</code>.</p>\n\n<code-example header=\"app/http-interceptors/index.ts\" path=\"http/src/app/http-interceptors/index.ts\" region=\"custom-json-interceptor\">\n{ provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: CustomJsonInterceptor, multi: true },\n{ provide: JsonParser, useClass: CustomJsonParser },\n\n</code-example>\n<p><a id=\"caching\"></a></p>\n<h2 id=\"cache-requests\" translation-result=\"on\">快取請求<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#cache-requests\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Cache requests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#cache-requests\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">攔截器還可以自行處理這些請求，而不用轉發給 <code>next.handle()</code>。</p><p translation-origin=\"off\">Interceptors can handle requests by themselves, without forwarding to <code>next.handle()</code>.</p>\n\n<p translation-result=\"on\">比如，你可能會想快取某些請求和響應，以便提升效能。你可以把這種快取操作委託給某個攔截器，而不破壞你現有的各個資料服務。</p><p translation-origin=\"off\">For example, you might decide to cache certain requests and responses to improve performance.\nYou can delegate caching to an interceptor without disturbing your existing data services.</p>\n\n<p translation-result=\"on\">下例中的 <code>CachingInterceptor</code> 示範了這種方法。</p><p translation-origin=\"off\">The <code>CachingInterceptor</code> in the following example demonstrates this approach.</p>\n\n<code-example header=\"app/http-interceptors/caching-interceptor.ts)\" path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"v1\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CachingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private cache: RequestCache) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // continue if not cacheable.\n    if (!isCacheable(req)) { return next.handle(req); }\n\n    const cachedResponse = this.cache.get(req);\n    return cachedResponse ?\n      of(cachedResponse) : sendRequest(req, next, this.cache);\n  }\n}\n\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\"><code>isCacheable()</code> 函式用於決定該請求是否允許快取。在這個例子中，只有發到包搜尋 API 的 GET 請求才是可以快取的。</p><p translation-origin=\"off\">The <code>isCacheable()</code> function determines if the request is cacheable.\nIn this sample, only GET requests to the package search API are cacheable.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果該請求是不可快取的，該攔截器會把該請求轉發給連結串列中的下一個處理器</p><p translation-origin=\"off\">If the request is not cacheable, the interceptor forwards the request to the next handler in the chain</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果可快取的請求在快取中找到了，該攔截器就會透過 <code>of()</code> 函式返回一個已快取的回應內文的<em>可觀察物件</em>，然後繞過 <code>next</code> 處理器（以及所有其它下游攔截器）</p><p translation-origin=\"off\">If a cacheable request is found in the cache, the interceptor returns an <code>of()</code> <em>observable</em> with the cached response, by-passing the <code>next</code> handler and all other interceptors downstream</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果可快取的請求不在快取中，程式碼會呼叫 <code>sendRequest()</code>。這個函式會把請求轉發給 <code>next.handle()</code>，它會最終呼叫伺服器並返回來自伺服器的響應物件。</p><p translation-origin=\"off\">If a cacheable request is not in cache, the code calls <code>sendRequest()</code>.\nThis function forwards the request to <code>next.handle()</code> which ultimately calls the server and returns the server's response.</p>\n\n</li>\n</ul>\n<p><a id=\"send-request\"></a></p>\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"send-request\">\n/**\n * Get server response observable by sending request to `next()`.\n * Will add the response to the cache on the way out.\n */\nfunction sendRequest(\n  req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;,\n  next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>,\n  cache: RequestCache): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n  return next.handle(req).pipe(\n    tap(event =&gt; {\n      // There may be other events besides the response.\n      if (event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>) {\n        cache.put(req, event); // Update the cache.\n      }\n    })\n  );\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">請注意 <code>sendRequest()</code> 是如何在響應返回應用程式時攔截它的。此方法透過 <code>tap()</code> 運運算元將響應聯入管道，其回呼(Callback)會將響應新增到快取中。</p><p translation-origin=\"off\">Notice how <code>sendRequest()</code> intercepts the response on its way back to the application.\nThis method pipes the response through the <code>tap()</code> operator, whose callback adds the response to the cache.</p>\n\n<p translation-result=\"on\">原始響應會不經過修改地沿著攔截器鏈回到應用程式的呼叫者處。</p><p translation-origin=\"off\">The original response continues untouched back up through the chain of interceptors to the application caller.</p>\n\n<p translation-result=\"on\">資料服務（例如 <code>PackageSearchService</code>）並不知道它們的某些 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 請求實際上返回的是已快取的響應。</p><p translation-origin=\"off\">Data services, such as <code>PackageSearchService</code>, are unaware that some of their <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> requests actually return cached responses.</p>\n\n</div>\n<p><a id=\"cache-refresh\"></a></p>\n<h2 id=\"use-interceptors-to-request-multiple-values\" translation-result=\"on\">使用攔截器請求多個值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#use-interceptors-to-request-multiple-values\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Use interceptors to request multiple values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-interceptor-use-cases#use-interceptors-to-request-multiple-values\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 方法通常會返回一個可觀察物件，它會發出一個值（資料或錯誤）。攔截器可以把它改成一個可以發出<a href=\"guide/observables\">多個值</a>的可觀察物件。</p><p translation-origin=\"off\">The <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> method normally returns an observable that emits a single value, either the data or an error.\nAn interceptor can change this to an observable that emits <a href=\"guide/observables\">multiple values</a>.</p>\n\n<p translation-result=\"on\">修改後的 <code>CachingInterceptor</code> 版本可以返回一個立即發出所快取響應的可觀察物件，然後把請求傳送到包搜尋 API，然後把修改過的搜尋結果重新發出一次。</p><p translation-origin=\"off\">The following revised version of the <code>CachingInterceptor</code> optionally returns an observable that immediately emits the cached response, sends the request on to the package search API, and emits again later with the updated search results.</p>\n\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"intercept-refresh\">\n// cache-then-refresh\nif (req.headers.get('x-refresh')) {\n  const results$ = sendRequest(req, next, this.cache);\n  return cachedResponse ?\n    results$.pipe( startWith(cachedResponse) ) :\n    results$;\n}\n// cache-or-fetch\nreturn cachedResponse ?\n  of(cachedResponse) : sendRequest(req, next, this.cache);\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><em>cache-then-refresh</em> 選項是透過自訂標頭 <code>x-refresh</code> 來觸發的。</p><p translation-origin=\"off\">The <em>cache-then-refresh</em> option is triggered by the presence of a custom <code>x-refresh</code> header.</p>\n\n<p translation-result=\"on\"><code>PackageSearchComponent</code> 上的複選框切換了 <code>withRefresh</code> 標誌，這是 <code>PackageSearchService.search()</code> 的引數之一。<code>search()</code> 方法建立了自訂標頭 <code>x-refresh</code>，並在呼叫 <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code> 之前將其新增到請求中。</p><p translation-origin=\"off\">A checkbox on the <code>PackageSearchComponent</code> toggles a <code>withRefresh</code> flag, which is one of the arguments to <code>PackageSearchService.search()</code>.\nThat <code>search()</code> method creates the custom <code>x-refresh</code> header and adds it to the request before calling <code><a href=\"api/common/http/HttpClient#get\" class=\"code-anchor\">HttpClient.get()</a></code>.</p>\n\n</div>\n<p translation-result=\"on\">修改後的 <code>CachingInterceptor</code> 會發起一個伺服器請求，而不管有沒有快取的值。\n就像 <a href=\"guide/http-interceptor-use-cases#send-request\">前面</a> 的 <code>sendRequest()</code> 方法一樣進行訂閱。\n在訂閱 <code>results$</code> 可觀察物件時，就會發起這個請求。</p><p translation-origin=\"off\">The revised <code>CachingInterceptor</code> sets up a server request whether there's a cached value or not, using the same <code>sendRequest()</code> method described <a href=\"guide/http-interceptor-use-cases#send-request\">above</a>.\nThe <code>results$</code> observable makes the request when subscribed.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">如果沒有快取值，攔截器直接返回 <code>results$</code>。</p><p translation-origin=\"off\">If there's no cached value, the interceptor returns <code>results$</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果有快取的值，這些程式碼就會把快取的響應加入到 <code>result$</code> 的<em>管道</em>中。這會產生一個重組後的 Observable，它會發出兩次響應，故此訂閱者將會看到一個包含這兩個響應的序列。</p><p translation-origin=\"off\">If there is a cached value, the code <em>pipes</em> the cached response onto <code>results$</code>. This produces a recomposed observable that emits two responses, so subscribers will see a sequence of these two responses:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">立即發出的已快取的響應</p><p translation-origin=\"off\">The cached response that's emitted immediately</p>\n\n</li>\n<li>\n<p translation-result=\"on\">稍後發出來自伺服器的響應</p><p translation-origin=\"off\">The response from the server, that's emitted later</p>\n\n</li>\n</ul>\n</li>\n</ul>\n<p><a id=\"report-progress\"></a></p>\n\n  <div class=\"reviewed\">最後複查時間：11/8/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/http-intercept-requests-and-responses\n - guide/http-optimize-server-interaction\n-->\n<!-- links from this doc:\n - api/common/http/HTTP_INTERCEPTORS\n - api/common/http/HttpClient\n - api/common/http/HttpClient#get\n - api/common/http/HttpErrorResponse\n - api/common/http/HttpEvent\n - api/common/http/HttpHandler\n - api/common/http/HttpInterceptor\n - api/common/http/HttpRequest\n - api/common/http/HttpResponse\n - api/core/Injectable\n - guide/http-interceptor-use-cases#cache-requests\n - guide/http-interceptor-use-cases#custom-json-parsing\n - guide/http-interceptor-use-cases#http----interceptor-use-cases\n - guide/http-interceptor-use-cases#http-攔截器使用案例\n - guide/http-interceptor-use-cases#log-request-and-response-pairs\n - guide/http-interceptor-use-cases#send-request\n - guide/http-interceptor-use-cases#set-default-headers\n - guide/http-interceptor-use-cases#use-interceptors-to-request-multiple-values\n - guide/http-interceptor-use-cases#使用攔截器請求多個值\n - guide/http-interceptor-use-cases#快取請求\n - guide/http-interceptor-use-cases#自訂-json-解析\n - guide/http-interceptor-use-cases#記錄請求和響應對\n - guide/http-interceptor-use-cases#設定預設標題\n - guide/observables\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-interceptor-use-cases.md?message=docs%3A%20請簡述你的修改...\n-->"}