{"id":"guide/observables","title":"Using observables to pass values","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/observables.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"using-observables-to-pass-values\" translation-result=\"on\">使用可觀察物件（Observable）來傳遞值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#using-observables-to-pass-values\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Using observables to pass values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#using-observables-to-pass-values\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">可觀察物件對在應用的各個部分之間傳遞訊息提供了支援。它們在 Angular 中頻繁使用，並且推薦把它們用於事件處理、非同步程式設計以及處理多個值等場景。</p><p translation-origin=\"off\">Observables provide support for passing messages between parts of your application.\nThey are used frequently in Angular and are a technique for event handling, asynchronous programming, and handling multiple values.</p>\n\n<p translation-result=\"on\">觀察者（Observer）模式是一個軟體設計模式，它有一個物件，稱之為<em>主體 Subject</em>，負責維護一個依賴項（稱之為觀察者 Observer）的列表，並且在狀態變化時自動通知它們。該模式和<a href=\"https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\">釋出/訂閱</a>模式非常相似（但不完全一樣）。</p><p translation-origin=\"off\">The observer pattern is a software design pattern in which an object, called the <em>subject</em>, maintains a list of its dependents, called <em>observers</em>, and notifies them automatically of state changes.\nThis pattern is similar (but not identical) to the <a href=\"https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\">publish/subscribe</a> design pattern.</p>\n\n<p translation-result=\"on\">可觀察物件是宣告式的 —— 也就是說，雖然你定義了一個用於釋出值的函式，但是在有消費者訂閱它之前，這個函式並不會實際執行。訂閱之後，當這個函式執行完或取消訂閱時，訂閱者就會收到通知。</p><p translation-origin=\"off\">Observables are declarative —that is, you define a function for publishing values, but it is not executed until a consumer subscribes to it.\nThe subscribed consumer then receives notifications until the function completes, or until they unsubscribe.</p>\n\n<p translation-result=\"on\">可觀察物件可以傳送多個任意類別型的值 —— 字面量、訊息、事件。無論這些值是同步傳送的還是非同步傳送的，接收這些值的 API 都是一樣的。由於準備（setup）和清場（teardown）的邏輯都是由可觀察物件自己處理的，因此你的應用程式碼只管訂閱並消費這些值就可以了，做完之後，取消訂閱。無論這個流是按鍵流、HTTP 響應流還是定時器，對這些值進行監聽和停止監聽的介面都是一樣的。</p><p translation-origin=\"off\">An observable can deliver multiple values of any type —literals, messages, or events, depending on the context.\nThe API for receiving values is the same whether the values are delivered synchronously or asynchronously.\nBecause setup and teardown logic are both handled by the observable, your application code only needs to worry about subscribing to consume values, and when done, unsubscribing.\nWhether the stream was keystrokes, an HTTP response, or an interval timer, the interface for listening to values and stopping listening is the same.</p>\n\n<p translation-result=\"on\">由於這些優點，可觀察物件在 Angular 中得到廣泛使用，應用開發者也同樣如此。</p><p translation-origin=\"off\">Because of these advantages, observables are used extensively within Angular, and for application development as well.</p>\n\n<h2 id=\"basic-usage-and-terms\" translation-result=\"on\">基本用法和詞彙<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#basic-usage-and-terms\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Basic usage and terms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#basic-usage-and-terms\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">作為釋出者，你建立一個 <code>Observable</code> 的例項，其中定義了一個<em>訂閱者（subscriber）</em>函式。當有消費者呼叫 <code>subscribe()</code> 方法時，這個函式就會執行。訂閱者函式用於定義“如何獲取或產生那些要釋出的值或訊息”。</p><p translation-origin=\"off\">As a publisher, you create an <code>Observable</code> instance that defines a <em>subscriber</em> function.\nThis is the function that is executed when a consumer calls the <code>subscribe()</code> method.\nThe subscriber function defines how to obtain or generate values or messages to be published.</p>\n\n<p translation-result=\"on\">要執行所建立的可觀察物件，並開始從中接收通知，你就要呼叫它的 <code>subscribe()</code> 方法，並傳入一個<em>觀察者（observer）</em>。這是一個 JavaScript 物件，它定義了你收到的這些訊息的處理器（handler）。<code>subscribe()</code> 呼叫會返回一個 <code>Subscription</code> 物件，該物件具有一個 <code>unsubscribe()</code> 方法。當呼叫該方法時，你就會停止接收通知。</p><p translation-origin=\"off\">To execute the observable you have created and begin receiving notifications, you call its <code>subscribe()</code> method, passing an <em>observer</em>.\nThis is a JavaScript object that defines the handlers for the notifications you receive.\nThe <code>subscribe()</code> call returns a <code>Subscription</code> object that has an <code>unsubscribe()</code> method, which you call to stop receiving notifications.</p>\n\n<p translation-result=\"on\">下面這個例子中示範了這種基本用法，它展示瞭如何使用可觀察物件來對當前地理位置進行更新。</p><p translation-origin=\"off\">Here's an example that demonstrates the basic usage model by showing how an observable could be used to provide geolocation updates.</p>\n\n<code-example header=\"Observe geolocation updates\" class=\"no-auto-link\" path=\"observables/src/geolocation.ts\">\n\n// Create an Observable that will start listening to geolocation updates\n// when a consumer subscribes.\nconst locations = new Observable((observer) =&gt; {\n  let watchId: number;\n\n  // Simple geolocation API check provides values to publish\n  if ('geolocation' in navigator) {\n    watchId = navigator.geolocation.watchPosition((position: GeolocationPosition) =&gt; {\n      observer.next(position);\n    }, (error: GeolocationPositionError) =&gt; {\n      observer.error(error);\n    });\n  } else {\n    observer.error('Geolocation not available');\n  }\n\n  // When the consumer unsubscribes, clean up data ready for next subscription.\n  return {\n    unsubscribe() {\n      navigator.geolocation.clearWatch(watchId);\n    }\n  };\n});\n\n// Call subscribe() to start listening for updates.\nconst locationsSubscription = locations.subscribe({\n  next(position) {\n    console.log('Current Position: ', position);\n  },\n  error(msg) {\n    console.log('Error Getting Location: ', msg);\n  }\n});\n\n// Stop listening for location after 10 seconds\nsetTimeout(() =&gt; {\n  locationsSubscription.unsubscribe();\n}, 10000);\n\n</code-example>\n<h2 id=\"defining-observers\" translation-result=\"on\">定義觀察者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#defining-observers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Defining observers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#defining-observers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">用於接收可觀察物件通知的處理器要實現 <code>Observer</code> 介面。這個物件定義了一些回呼(Callback)函式來處理可觀察物件可能會發來的三種通知：</p><p translation-origin=\"off\">A handler for receiving observable notifications implements the <code>Observer</code> interface.\nIt is an object that defines callback methods to handle the three types of notifications that an observable can send:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">通知型別</nt-wrapper><nt-wrapper translation-origin=\"off\">Notification type</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>next</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">必要。用來處理每個送達值。在開始執行後可能執行零次或多次。</nt-wrapper><nt-wrapper translation-origin=\"off\">Required. A handler for each delivered value. Called zero or more times after execution starts.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>error</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">可選。用來處理錯誤通知。錯誤會中斷這個可觀察物件例項的執行過程。</nt-wrapper><nt-wrapper translation-origin=\"off\">Optional. A handler for an error notification. An error halts execution of the observable instance.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>complete</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">可選。用來處理執行完畢（complete）通知。當執行完畢後，這些值就會繼續傳給下一個處理器。</nt-wrapper><nt-wrapper translation-origin=\"off\">Optional. A handler for the execution-complete notification. Delayed values can continue to be delivered to the next handler after execution is complete.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">觀察者物件可以定義這三種處理器的任意組合。如果你不為某種通知型別提供處理器，這個觀察者就會忽略相應型別的通知。</p><p translation-origin=\"off\">An observer object can define any combination of these handlers.\nIf you don't supply a handler for a notification type, the observer ignores notifications of that type.</p>\n\n<h2 id=\"subscribing\" translation-result=\"on\">訂閱<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#subscribing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Subscribing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#subscribing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">只有當有人訂閱 <code>Observable</code> 的例項時，它才會開始釋出值。訂閱時要先呼叫該例項的 <code>subscribe()</code> 方法，並把一個觀察者物件傳給它，用來接收通知。</p><p translation-origin=\"off\">An <code>Observable</code> instance begins publishing values only when someone subscribes to it.\nYou subscribe by calling the <code>subscribe()</code> method of the instance, passing an observer object to receive the notifications.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">為了展示訂閱的原理，我們需要建立新的可觀察物件。它有一個建構函式可以用來建立新例項，但是為了更簡明，也可以使用 <code>Observable</code> 上定義的一些靜態方法來建立一些常用的簡單可觀察物件：</p><p translation-origin=\"off\">In order to show how subscribing works, we need to create a new observable.\nThere is a constructor that you use to create new instances, but for illustration, we can use some methods from the RxJS library that create simple observables of frequently used types:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">RxJS 方法</nt-wrapper><nt-wrapper translation-origin=\"off\">RxJS methods</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>of(...items)</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">返回一個 <code>Observable</code> 例項，它用同步的方式把引數中提供的這些值傳送出來。</nt-wrapper><nt-wrapper translation-origin=\"off\">Returns an <code>Observable</code> instance that synchronously delivers the values provided as arguments.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>from(iterable)</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">把它的引數轉換成一個 <code>Observable</code> 例項。該方法通常用於把一個數組轉換成一個（傳送多個值的）可觀察物件。</nt-wrapper><nt-wrapper translation-origin=\"off\">Converts its argument to an <code>Observable</code> instance. This method is commonly used to convert an array to an observable.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n</div>\n<p translation-result=\"on\">下面的例子會建立並訂閱一個簡單的可觀察物件，它的觀察者會把接收到的訊息記錄到控制檯中：</p><p translation-origin=\"off\">Here's an example of creating and subscribing to a simple observable, with an observer that logs the received message to the console:</p>\n\n<code-example header=\"Subscribe using observer\" path=\"observables/src/subscribing.ts\" region=\"observer\">\n\n// Create simple observable that emits three values\nconst myObservable = of(1, 2, 3);\n\n// Create observer object\nconst myObserver = {\n  next: (x: number) =&gt; console.log('Observer got a next value: ' + x),\n  error: (err: Error) =&gt; console.error('Observer got an error: ' + err),\n  complete: () =&gt; console.log('Observer got a complete notification'),\n};\n\n// Execute with the observer object\nmyObservable.subscribe(myObserver);\n\n// Logs:\n// Observer got a next value: 1\n// Observer got a next value: 2\n// Observer got a next value: 3\n// Observer got a complete notification\n\n\n</code-example>\n<p translation-result=\"on\">另外，<code>subscribe()</code> 方法還可以接收定義在同一行中的回呼(Callback)函式，無論 <code>next</code>、<code>error</code> 還是 <code>complete</code> 處理器。比如，下面的 <code>subscribe()</code> 呼叫和前面指定預定義觀察者的例子是等價的。</p><p translation-origin=\"off\">Alternatively, the <code>subscribe()</code> method can accept callback function definitions in line, for <code>next</code>, <code>error</code>, and <code>complete</code> handlers.\nFor example, the following <code>subscribe()</code> call is the same as the one that specifies the predefined observer:</p>\n\n<code-example header=\"Subscribe with positional arguments\" path=\"observables/src/subscribing.ts\" region=\"sub_fn\">\nmyObservable.subscribe(\n  x =&gt; console.log('Observer got a next value: ' + x),\n  err =&gt; console.error('Observer got an error: ' + err),\n  () =&gt; console.log('Observer got a complete notification')\n);\n\n</code-example>\n<p translation-result=\"on\">無論哪種情況，<code>next</code> 處理器都是必要的，而 <code>error</code> 和 <code>complete</code> 處理器是可選的。</p><p translation-origin=\"off\">In either case, a <code>next</code> handler is required.\nThe <code>error</code> and <code>complete</code> handlers are optional.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n<code>next()</code> 函式可以接受訊息字串、事件物件、數字值或各種結構，具體型別取決於上下文。\n為了更通用一點，我們把由可觀察物件釋出出來的資料統稱為<em>流</em>。任何型別的值都可以表示為可觀察物件，而這些值會被髮布為一個流。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nA <code>next()</code> function could receive, for instance, message strings, or event objects, numeric values, or structures, depending on context.\nAs a general term, we refer to data published by an observable as a <em>stream</em>.\nAny type of value can be represented with an observable, and the values are published as a stream.</p>\n\n</div>\n<h2 id=\"creating-observables\" translation-result=\"on\">建立可觀察物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#creating-observables\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Creating observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#creating-observables\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用 <code>Observable</code> 建構函式可以建立任何型別的可觀察流。當執行可觀察物件的 <code>subscribe()</code> 方法時，這個建構函式就會把它接收到的引數作為訂閱函式來執行。訂閱函式會接收一個 <code>Observer</code> 物件，並把值釋出給觀察者的 <code>next()</code> 方法。</p><p translation-origin=\"off\">Use the <code>Observable</code> constructor to create an observable stream of any type.\nThe constructor takes as its argument the subscriber function to run when the observable's <code>subscribe()</code> method executes.\nA subscriber function receives an <code>Observer</code> object, and can publish values to the observer's <code>next()</code> method.</p>\n\n<p translation-result=\"on\">比如，要建立一個與前面的 <code>of(1, 2, 3)</code> 等價的可觀察物件，你可以這樣做：</p><p translation-origin=\"off\">For example, to create an observable equivalent to the <code>of(1, 2, 3)</code> above, you could do something like this:</p>\n\n<code-example header=\"Create observable with constructor\" path=\"observables/src/creating.ts\" region=\"subscriber\">\n// This function runs when subscribe() is called\nfunction sequenceSubscriber(observer: Observer&lt;number&gt;) {\n  // synchronously deliver 1, 2, and 3, then complete\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.complete();\n\n  // unsubscribe function doesn't need to do anything in this\n  // because values are delivered synchronously\n  return {unsubscribe() {}};\n}\n\n// Create a new Observable that will deliver the above <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\nconst <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> = new Observable(sequenceSubscriber);\n\n// execute the Observable and print the result of each notification\nsequence.subscribe({\n  next(num) { console.log(num); },\n  complete() { console.log('Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>'); }\n});\n\n// Logs:\n// 1\n// 2\n// 3\n// Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\n\n</code-example>\n<p translation-result=\"on\">如果要略微加強這個例子，我們可以建立一個用來發布事件的可觀察物件。在這個例子中，訂閱函式是用內聯方式定義的。</p><p translation-origin=\"off\">To take this example a little further, we can create an observable that publishes events.\nIn this example, the subscriber function is defined inline.</p>\n\n<code-example header=\"Create with custom fromEvent function\" path=\"observables/src/creating.ts\" region=\"fromevent\">\n\nfunction fromEvent&lt;T extends keyof HTMLElementEventMap&gt;(target: HTMLElement, eventName: T) {\n  return new Observable&lt;HTMLElementEventMap[T]&gt;((observer) =&gt; {\n    const handler = (e: HTMLElementEventMap[T]) =&gt; observer.next(e);\n\n    // Add the event handler to the target\n    target.addEventListener(eventName, handler);\n\n    return () =&gt; {\n      // Detach the event handler from the target\n      target.removeEventListener(eventName, handler);\n    };\n  });\n}\n\n\n</code-example>\n<p translation-result=\"on\">現在，你就可以使用這個函式來建立可釋出 <code>keydown</code> 事件的可觀察物件了：</p><p translation-origin=\"off\">Now you can use this function to create an observable that publishes keydown events:</p>\n\n<code-example header=\"Use custom fromEvent function\" path=\"observables/src/creating.ts\" region=\"fromevent_use\">\n\nconst ESC_CODE = 'Escape';\nconst nameInput = document.getElementById('name') as HTMLInputElement;\n\nconst subscription = fromEvent(nameInput, 'keydown').subscribe((e: KeyboardEvent) =&gt; {\n  if (e.code === ESC_CODE) {\n    nameInput.value = '';\n  }\n});\n\n</code-example>\n<h2 id=\"multicasting\" translation-result=\"on\">多播<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#multicasting\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Multicasting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#multicasting\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">典型的可觀察物件會為每一個觀察者建立一次新的、獨立的執行。當觀察者進行訂閱時，該可觀察物件會連上一個事件處理器，並且向那個觀察者傳送一些值。當第二個觀察者訂閱時，這個可觀察物件就會連上一個新的事件處理器，並獨立執行一次，把這些值傳送給第二個可觀察物件。</p><p translation-origin=\"off\">A typical observable creates a new, independent execution for each subscribed observer.\nWhen an observer subscribes, the observable wires up an event handler and delivers values to that observer.\nWhen a second observer subscribes, the observable then wires up a new event handler and delivers values to that second observer in a separate execution.</p>\n\n<p translation-result=\"on\">有時候，不應該對每一個訂閱者都獨立執行一次，你可能會希望每次訂閱都得到同一批值 —— 即使是那些你已經發送過的。這在某些情況下有用，比如用來發送 <code>document</code> 上的點選事件的可觀察物件。</p><p translation-origin=\"off\">Sometimes, instead of starting an independent execution for each subscriber, you want each subscription to get the same values —even if values have already started emitting.\nThis might be the case with something like an observable of clicks on the document object.</p>\n\n<p translation-result=\"on\"><em>多播</em>用來讓可觀察物件在一次執行中同時廣播給多個訂閱者。藉助支援多播的可觀察物件，你不必註冊多個監聽器，而是複用第一個（<code>next</code>）監聽器，並且把值傳送給各個訂閱者。</p><p translation-origin=\"off\"><em>Multicasting</em> is the practice of broadcasting to a list of multiple subscribers in a single execution.\nWith a multicasting observable, you don't register multiple listeners on the document, but instead re-use the first listener and send values out to each subscriber.</p>\n\n<p translation-result=\"on\">當建立可觀察物件時，你要決定你希望別人怎麼用這個物件以及是否對它的值進行多播。</p><p translation-origin=\"off\">When creating an observable you should determine how you want that observable to be used and whether or not you want to multicast its values.</p>\n\n<p translation-result=\"on\">來看一個從 1 到 3 進行計數的例子，它每發出一個數字就會等待 1 秒。</p><p translation-origin=\"off\">Let's look at an example that counts from 1 to 3, with a one-second delay after each number emitted.</p>\n\n<code-example header=\"Create a delayed sequence\" path=\"observables/src/multicasting.ts\" region=\"delay_sequence\">\nfunction sequenceSubscriber(observer: Observer&lt;number&gt;) {\n  const seq = [1, 2, 3];\n  let clearTimer: VoidFunction | undefined;\n\n  // Will run through an array of numbers, emitting one value\n  // per second until it gets to the end of the array.\n  function doInSequence(arr: number[], idx: number) {\n    const timeout = setTimeout(() =&gt; {\n      observer.next(arr[idx]);\n      if (idx === arr.length - 1) {\n        observer.complete();\n      } else {\n        doInSequence(arr, ++idx);\n      }\n    }, 1000);\n    clearTimer = () =&gt; clearTimeout(timeout);\n  }\n\n  doInSequence(seq, 0);\n\n  // Unsubscribe should clear the timeout to stop execution\n  return {\n    unsubscribe() {\n      clearTimer?.();\n    }\n  };\n}\n\n// Create a new Observable that will deliver the above <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\nconst <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> = new Observable(sequenceSubscriber);\n\nsequence.subscribe({\n  next(num) { console.log(num); },\n  complete() { console.log('Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>'); }\n});\n\n// Logs:\n// (at 1 second): 1\n// (at 2 seconds): 2\n// (at 3 seconds): 3\n// (at 3 seconds): Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\n\n\n</code-example>\n<p translation-result=\"on\">注意，如果你訂閱了兩次，就會有兩個獨立的流，每個流都會每秒發出一個數字。程式碼如下：</p><p translation-origin=\"off\">Notice that if you subscribe twice, there will be two separate streams, each emitting values every second.\nIt looks something like this:</p>\n\n<code-example header=\"Two subscriptions\" path=\"observables/src/multicasting.ts\" region=\"subscribe_twice\">\n\n// Subscribe starts the clock, and will emit after 1 second\nsequence.subscribe({\n  next(num) { console.log('1st subscribe: ' + num); },\n  complete() { console.log('1st <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished.'); }\n});\n\n// After 1/2 second, subscribe again.\nsetTimeout(() =&gt; {\n  sequence.subscribe({\n    next(num) { console.log('2nd subscribe: ' + num); },\n    complete() { console.log('2nd <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished.'); }\n  });\n}, 500);\n\n// Logs:\n// (at 1 second): 1st subscribe: 1\n// (at 1.5 seconds): 2nd subscribe: 1\n// (at 2 seconds): 1st subscribe: 2\n// (at 2.5 seconds): 2nd subscribe: 2\n// (at 3 seconds): 1st subscribe: 3\n// (at 3 seconds): 1st <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished\n// (at 3.5 seconds): 2nd subscribe: 3\n// (at 3.5 seconds): 2nd <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished\n\n\n</code-example>\n<p translation-result=\"on\">修改這個可觀察物件以支援多播，程式碼如下：</p><p translation-origin=\"off\"> Changing the observable to be multicasting could look something like this:</p>\n\n<code-example header=\"Create a multicast subscriber\" path=\"observables/src/multicasting.ts\" region=\"multicast_sequence\">\nfunction multicastSequenceSubscriber() {\n  const seq = [1, 2, 3];\n  // Keep track of each observer (one for every active subscription)\n  const observers: Observer&lt;unknown&gt;[] = [];\n  // Still a single timer because there will only ever be one\n  // set of values being generated, multicasted to each subscriber\n  let clearTimer: VoidFunction | undefined;\n\n  // Return the subscriber function (runs when subscribe()\n  // function is invoked)\n  return (observer: Observer&lt;unknown&gt;) =&gt; {\n    observers.push(observer);\n    // When this is the first subscription, start the <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\n    if (observers.length === 1) {\n      const multicastObserver: Observer&lt;number&gt; = {\n        next(val) {\n          // Iterate through observers and notify all subscriptions\n          observers.forEach(obs =&gt; obs.next(val));\n        },\n        error() { /* Handle the error... */ },\n        complete() {\n          // Notify all complete callbacks\n          observers.slice(0).forEach(obs =&gt; obs.complete());\n        }\n      };\n      doSequence(multicastObserver, seq, 0);\n    }\n\n    return {\n      unsubscribe() {\n        // Remove from the observers array so it's no longer notified\n        observers.splice(observers.indexOf(observer), 1);\n        // If there's no more listeners, do cleanup\n        if (observers.length === 0) {\n          clearTimer?.();\n        }\n      }\n    };\n\n    // Run through an array of numbers, emitting one value\n    // per second until it gets to the end of the array.\n    function doSequence(sequenceObserver: Observer&lt;number&gt;, arr: number[], idx: number) {\n      const timeout = setTimeout(() =&gt; {\n        console.log('Emitting ' + arr[idx]);\n        sequenceObserver.next(arr[idx]);\n        if (idx === arr.length - 1) {\n          sequenceObserver.complete();\n        } else {\n          doSequence(sequenceObserver, arr, ++idx);\n        }\n      }, 1000);\n      clearTimer = () =&gt; clearTimeout(timeout);\n    }\n  };\n}\n\n// Create a new Observable that will deliver the above <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\nconst multicastSequence = new Observable(multicastSequenceSubscriber());\n\n// Subscribe starts the clock, and begins to emit after 1 second\nmulticastSequence.subscribe({\n  next(num) { console.log('1st subscribe: ' + num); },\n  complete() { console.log('1st <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished.'); }\n});\n\n// After 1 1/2 seconds, subscribe again (should \"miss\" the first value).\nsetTimeout(() =&gt; {\n  multicastSequence.subscribe({\n    next(num) { console.log('2nd subscribe: ' + num); },\n    complete() { console.log('2nd <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished.'); }\n  });\n}, 1500);\n\n// Logs:\n// (at 1 second): Emitting 1\n// (at 1 second): 1st subscribe: 1\n// (at 2 seconds): Emitting 2\n// (at 2 seconds): 1st subscribe: 2\n// (at 2 seconds): 2nd subscribe: 2\n// (at 3 seconds): Emitting 3\n// (at 3 seconds): 1st subscribe: 3\n// (at 3 seconds): 2nd subscribe: 3\n// (at 3 seconds): 1st <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished\n// (at 3 seconds): 2nd <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">雖然支援多播的可觀察物件需要做更多的準備工作，但對某些應用來說，這非常有用。稍後我們會介紹一些簡化多播的工具，它們讓你能接收任何可觀察物件，並把它變成支援多播的。</p><p translation-origin=\"off\">Multicasting observables take a bit more setup, but they can be useful for certain applications.\nLater we will look at tools that simplify the process of multicasting, allowing you to take any observable and make it multicasting.</p>\n\n</div>\n<h2 id=\"error-handling\" translation-result=\"on\">錯誤處理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#error-handling\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Error handling<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observables#error-handling\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">由於可觀察物件會非同步產生值，所以用 <code>try/catch</code> 是無法捕獲錯誤的。你應該在觀察者中指定一個 <code>error</code> 回呼(Callback)來處理錯誤。發生錯誤時還會導致可觀察物件清理現有的訂閱，並且停止產生值。可觀察物件可以產生值（呼叫 <code>next</code> 回呼(Callback)），也可以呼叫 <code>complete</code> 或 <code>error</code> 回呼(Callback)來主動結束。</p><p translation-origin=\"off\">Because observables produce values asynchronously, try/catch will not effectively catch errors.\nInstead, you handle errors by specifying an <code>error</code> callback on the observer.\nProducing an error also causes the observable to clean up subscriptions and stop producing values.\nAn observable can either produce values (calling the <code>next</code> callback), or it can complete, calling either the <code>complete</code> or <code>error</code> callback.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nmyObservable.subscribe({\n  next(num) { console.log('Next num: ' + num)},\n  error(err) { console.log('Received an error: ' + err)}\n});\n\n</code-example>\n<p translation-result=\"on\">在稍後的小節中會對錯誤處理（特別是從錯誤中的恢復）做更詳細的講解。</p><p translation-origin=\"off\">Error handling (and specifically recovering from an error) is covered in more detail in a later section.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/service-worker/SwRegistrationOptions\n - guide/architecture-next-steps\n - guide/glossary\n - guide/http\n - guide/http-interceptor-use-cases\n - guide/pipes\n - guide/understanding-communicating-with-http\n-->\n<!-- links from this doc:\n - api/animations/sequence\n - guide/observables#basic-usage-and-terms\n - guide/observables#creating-observables\n - guide/observables#defining-observers\n - guide/observables#error-handling\n - guide/observables#multicasting\n - guide/observables#subscribing\n - guide/observables#using-observables-to-pass-values\n - guide/observables#使用可觀察物件observable來傳遞值\n - guide/observables#建立可觀察物件\n - guide/observables#基本用法和詞彙\n - guide/observables#多播\n - guide/observables#定義觀察者\n - guide/observables#訂閱\n - guide/observables#錯誤處理\n - https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/observables.md?message=docs%3A%20請簡述你的修改...\n-->"}