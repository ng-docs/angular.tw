{"id":"guide/forms-overview","title":"Introduction to forms in Angular","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/forms-overview.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"introduction-to-forms-in-angular\" translation-result=\"on\">Angular 表單簡介<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#introduction-to-forms-in-angular\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Introduction to forms in Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#introduction-to-forms-in-angular\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">用表單處理使用者輸入是許多常見應用的基礎功能。\n應用透過表單來讓使用者登入、修改個人檔案、輸入敏感資訊以及執行各種資料輸入任務。</p><p translation-origin=\"off\">Handling user input with forms is the cornerstone of many common applications.\nApplications use forms to enable users to log in, to update a profile, to enter sensitive information, and to perform many other data-entry tasks.</p>\n\n<p translation-result=\"on\">Angular 提供了兩種不同的方法來透過表單處理使用者輸入：響應式表單和範本驅動表單。\n兩者都從檢視中捕獲使用者輸入事件、驗證使用者輸入、建立表單模型、修改資料模型，並提供追蹤這些更改的途徑。</p><p translation-origin=\"off\">Angular provides two different approaches to handling user input through forms: reactive and template-driven.\nBoth capture user input events from the view, validate the user input, create a form model and data model to update, and provide a way to track changes.</p>\n\n<p translation-result=\"on\">本指南提供的資訊可以幫你確定哪種方式最適合你的情況。它介紹了這兩種方法所用的公共構成要素，還總結了兩種方式之間的關鍵區別，並在建立、資料流和測試等不同的情境下展示了這些差異。</p><p translation-origin=\"off\">This guide provides information to help you decide which type of form works best for your situation.\nIt introduces the common building blocks used by both approaches.\nIt also summarizes the key differences between the two approaches, and demonstrates those differences in the context of setup, data flow, and testing.</p>\n\n<h2 id=\"prerequisites\" translation-result=\"on\">前提條件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#prerequisites\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Prerequisites<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本指南假設你對以下內容有基本的瞭解。</p><p translation-origin=\"off\">This guide assumes that you have a basic understanding of the following.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"https://www.typescriptlang.org\" title=\"TypeScript 語言\">TypeScript</a>和 HTML5 程式設計</p><p translation-origin=\"off\"><a href=\"https://www.typescriptlang.org/\" title=\"The TypeScript language\">TypeScript</a> and HTML5 programming</p>\n\n</li>\n<li>\n<p translation-result=\"on\">Angular 的應用設計基礎，就像<a href=\"guide/architecture\" title=\"Angular 概念簡介。\">Angular Concepts 中</a>描述的那樣</p><p translation-origin=\"off\">Angular app-design fundamentals, as described in <a href=\"guide/architecture\" title=\"Introduction to Angular concepts\">Angular Concepts</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/architecture-components#template-syntax\" title=\"範本語法簡介\">Angular 範本語法</a>的基礎知識</p><p translation-origin=\"off\">The basics of <a href=\"guide/architecture-components#template-syntax\" title=\"Template syntax intro\">Angular template syntax</a></p>\n\n</li>\n</ul>\n<h2 id=\"choosing-an-approach\" translation-result=\"on\">選擇一種方法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#choosing-an-approach\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Choosing an approach<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#choosing-an-approach\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">響應式表單和範本驅動表單以不同的方式處理和管理表單資料。每種方法都有各自的優點。</p><p translation-origin=\"off\">Reactive forms and template-driven forms process and manage form data differently.\nEach approach offers different advantages.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">表單</nt-wrapper><nt-wrapper translation-origin=\"off\">Forms</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">響應式表單</nt-wrapper><nt-wrapper translation-origin=\"off\">Reactive forms</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">提供對底層表單物件模型直接、顯式的存取。它們與範本驅動表單相比，更加健壯：它們的可擴充性、可複用性和可測試性都更高。如果表單是你的應用程式的關鍵部分，或者你已經在使用響應式表單來建構應用，那就使用響應式表單。</nt-wrapper><nt-wrapper translation-origin=\"off\">Provide direct, explicit access to the underlying form's object model. Compared to template-driven forms, they are more robust: they're more scalable, reusable, and testable. If forms are a key part of your application, or you're already using reactive patterns for building your application, use reactive forms.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">範本驅動表單</nt-wrapper><nt-wrapper translation-origin=\"off\">Template-driven forms</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">依賴<strong>範本中的</strong>指令來建立和操作底層的物件模型。它們對於嚮應用新增一個簡單的表單非常有用，比如電子郵件列表登錄檔單。它們很容易新增到應用中，但在擴充性方面不如響應式表單。如果你有可以只在範本中管理的非常基本的表單需求和邏輯，那麼範本驅動表單就很合適。</nt-wrapper><nt-wrapper translation-origin=\"off\">Rely on directives in the template to create and manipulate the underlying object model. They are useful for adding a simple form to an app, such as an email list signup form. They're straightforward to add to an app, but they don't scale as well as reactive forms. If you have very basic form requirements and logic that can be managed solely in the template, template-driven forms could be a good fit.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<h3 id=\"key-differences\" translation-result=\"on\">關鍵差異<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#key-differences\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Key differences<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#key-differences\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">下表總結了響應式表單和範本驅動表單之間的一些關鍵差異。</p><p translation-origin=\"off\">The following table summarizes the key differences between reactive and template-driven forms.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">響應式</nt-wrapper><nt-wrapper translation-origin=\"off\">Reactive</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">範本驅動</nt-wrapper><nt-wrapper translation-origin=\"off\">Template-driven</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><a href=\"guide/forms-overview#setup\">建立表單模型</a></nt-wrapper><nt-wrapper translation-origin=\"off\"><a href=\"guide/forms-overview#setup\">Setup of form model</a></nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">顯式的，在元件類中建立</nt-wrapper><nt-wrapper translation-origin=\"off\">Explicit, created in component class</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">隱含的，由指令建立</nt-wrapper><nt-wrapper translation-origin=\"off\">Implicit, created by directives</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><a href=\"guide/forms-overview#mutability-of-the-data-model\">資料模型</a></nt-wrapper><nt-wrapper translation-origin=\"off\"><a href=\"guide/forms-overview#mutability-of-the-data-model\">Data model</a></nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">結構化和不可變的</nt-wrapper><nt-wrapper translation-origin=\"off\">Structured and immutable</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">非結構化和可變的</nt-wrapper><nt-wrapper translation-origin=\"off\">Unstructured and mutable</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><a href=\"guide/forms-overview#data-flow-in-forms\">資料流</a></nt-wrapper><nt-wrapper translation-origin=\"off\"><a href=\"guide/forms-overview#data-flow-in-forms\">Data flow</a></nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">同步</nt-wrapper><nt-wrapper translation-origin=\"off\">Synchronous</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">非同步</nt-wrapper><nt-wrapper translation-origin=\"off\">Asynchronous</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><a href=\"guide/forms-overview#validation\">表單驗證</a></nt-wrapper><nt-wrapper translation-origin=\"off\"><a href=\"guide/forms-overview#validation\">Form validation</a></nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">函式</nt-wrapper><nt-wrapper translation-origin=\"off\">Functions</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">指令</nt-wrapper><nt-wrapper translation-origin=\"off\">Directives</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<h3 id=\"scalability\" translation-result=\"on\">可延展性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#scalability\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Scalability<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#scalability\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果表單是應用程式的核心部分，那麼可延展性就非常重要。能夠跨元件複用表單模型是至關重要的。</p><p translation-origin=\"off\">If forms are a central part of your application, scalability is very important.\nBeing able to reuse form models across components is critical.</p>\n\n<p translation-result=\"on\">響應式表單比範本驅動表單更有可延展性。它們提供對底層表單 API 的直接存取，並且在檢視和資料模型之間使用<a href=\"guide/forms-overview#data-flow-in-reactive-forms\">同步資料流</a>，從而可以更輕鬆地建立大型表單。響應式表單需要較少的測試設定，測試時不需要深入理解變更檢測，就能正確測試表單更新和驗證。</p><p translation-origin=\"off\">Reactive forms are more scalable than template-driven forms.\nThey provide direct access to the underlying form API, and use <a href=\"guide/forms-overview#data-flow-in-reactive-forms\">synchronous data flow</a> between the view and the data model, which makes creating large-scale forms easier.\nReactive forms require less setup for testing, and testing does not require deep understanding of change detection to properly test form updates and validation.</p>\n\n<p translation-result=\"on\">範本驅動表單專注於簡單的場景，可複用性沒那麼高。它們抽象出了底層表單 API，並且在檢視和資料模型之間使用<a href=\"guide/forms-overview#data-flow-in-template-driven-forms\">非同步資料流</a>。對範本驅動表單的這種抽象也會影響測試。測試程式非常依賴於手動觸發變更檢測才能正常執行，並且需要進行更多設定工作。</p><p translation-origin=\"off\">Template-driven forms focus on simple scenarios and are not as reusable.\nThey abstract away the underlying form API, and use <a href=\"guide/forms-overview#data-flow-in-template-driven-forms\">asynchronous data flow</a> between the view and the data model.\nThe abstraction of template-driven forms also affects testing.\nTests are deeply reliant on manual change detection execution to run properly, and require more setup.</p>\n\n<p><a id=\"setup\"></a></p>\n<h2 id=\"setting-up-the-form-model\" translation-result=\"on\">建立表單模型<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setting-up-the-form-model\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Setting up the form model<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setting-up-the-form-model\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">響應式表單和範本驅動型表單都會追蹤使用者與之互動的表單輸入元素和元件模型中的表單資料之間的值變更。這兩種方法共享同一套底層建構塊，只在如何建立和管理常用表單控制項例項方面有所不同。</p><p translation-origin=\"off\">Both reactive and template-driven forms track value changes between the form input elements that users interact with and the form data in your component model.\nThe two approaches share underlying building blocks, but differ in how you create and manage the common form-control instances.</p>\n\n<h3 id=\"common-form-foundation-classes\" translation-result=\"on\">常用表單基礎類<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#common-form-foundation-classes\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Common form foundation classes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#common-form-foundation-classes\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">響應式表單和範本驅動表單都建立在下列基礎類之上。</p><p translation-origin=\"off\">Both reactive and template-driven forms are built on the following base classes.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">基底類別</nt-wrapper><nt-wrapper translation-origin=\"off\">Base classes</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">追蹤單個表單控制項的值和驗證狀態。</nt-wrapper><nt-wrapper translation-origin=\"off\">Tracks the value and validation status of an individual form control.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">追蹤一個表單控制項組的值和狀態。</nt-wrapper><nt-wrapper translation-origin=\"off\">Tracks the same values and status for a collection of form controls.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/forms/FormArray\" class=\"code-anchor\">FormArray</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">追蹤表單控制項陣列的值和狀態。</nt-wrapper><nt-wrapper translation-origin=\"off\">Tracks the same values and status for an array of form controls.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code><a href=\"api/forms/ControlValueAccessor\" class=\"code-anchor\">ControlValueAccessor</a></code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在 Angular 的 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項和內建 DOM 元素之間建立一個橋樑</nt-wrapper><nt-wrapper translation-origin=\"off\">Creates a bridge between Angular <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instances and built-in DOM elements.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p><a id=\"setup-the-form-model\"></a></p>\n<h3 id=\"setup-in-reactive-forms\" translation-result=\"on\">建立響應式表單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setup-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Setup in reactive forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setup-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">對於響應式表單，你可以直接在元件類中定義表單模型。<code>[formControl]</code> 指令會透過內部值存取器來把顯式建立的 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項與檢視中的特定表單元素聯絡起來。</p><p translation-origin=\"off\">With reactive forms, you define the form model directly in the component class.\nThe <code>[formControl]</code> directive links the explicitly created <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance to a specific form element in the view, using an internal value accessor.</p>\n\n<p translation-result=\"on\">下面的元件使用響應式表單為單個控制項實現了一個輸入欄位。在這個例子中，表單模型是 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項。</p><p translation-origin=\"off\">The following component implements an input field for a single control, using reactive forms.\nIn this example, the form model is the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance.</p>\n\n<code-example path=\"forms-overview/src/app/reactive/favorite-color/favorite-color.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a> } from '@angular/forms';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-reactive-favorite-color',\n  template: `\n    Favorite Color: &lt;input type=\"text\" [formControl]=\"favoriteColorControl\"&gt;\n  `\n})\nexport class FavoriteColorComponent {\n  favoriteColorControl = new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>('');\n}\n\n\n</code-example>\n<p translation-result=\"on\">圖 1 展示了在響應式表單中，表單模型是如何成為事實之源（source of truth）的。它透過輸入元素上的 <code>[formControl]</code> 指令，在任何給定的時間點提供表單元素的值和狀態。</p><p translation-origin=\"off\">Figure 1 shows how, in reactive forms, the form model is the source of truth; it provides the value and status of the form element at any given point in time, through the <code>[formControl]</code> directive on the input element.</p>\n\n<!--todo: make consistent with other topics -->\n<p translation-result=\"on\"><strong>圖 1.</strong> <em>在響應式表單中直接存取表單模型</em></p><p translation-origin=\"off\"><strong>Figure 1.</strong> <em>Direct access to forms model in a reactive form.</em></p>\n\n<div class=\"lightbox\">\n<img alt=\"Reactive forms key differences\" src=\"generated/images/guide/forms-overview/key-diff-reactive-forms.png\" width=\"635\" height=\"335\">\n</div>\n<h3 id=\"setup-in-template-driven-forms\" translation-result=\"on\">建立範本驅動表單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setup-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Setup in template-driven forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#setup-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在範本驅動表單中，表單模型是隱含的，而不是顯式的。指令 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 為指定的表單元素建立並管理一個 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項。</p><p translation-origin=\"off\">In template-driven forms, the form model is implicit, rather than explicit.\nThe directive <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> creates and manages a <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance for a given form element.</p>\n\n<p translation-result=\"on\">下面的元件使用範本驅動表單為單個控制項實現了同樣的輸入欄位。</p><p translation-origin=\"off\">The following component implements the same input field for a single control, using template-driven forms.</p>\n\n<code-example path=\"forms-overview/src/app/template/favorite-color/favorite-color.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-template-favorite-color',\n  template: `\n    Favorite Color: &lt;input type=\"text\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"favoriteColor\"&gt;\n  `\n})\nexport class FavoriteColorComponent {\n  favoriteColor = '';\n}\n\n\n</code-example>\n<p translation-result=\"on\">在範本驅動表單中，其事實之源就是範本。你沒有對 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項的直接程式設計存取，如圖 2 所示。</p><p translation-origin=\"off\">In a template-driven form the source of truth is the template.\nYou do not have direct programmatic access to the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance, as shown in Figure 2.</p>\n\n<!--todo: make consistent with other topics -->\n<p translation-result=\"on\"><strong>圖 2.</strong> <em>範本驅動表單中對表單模型的間接存取。</em></p><p translation-origin=\"off\"><strong>Figure 2.</strong> <em>Indirect access to forms model in a template-driven form.</em></p>\n\n<div class=\"lightbox\">\n<img alt=\"Template-driven forms key differences\" src=\"generated/images/guide/forms-overview/key-diff-td-forms.png\" width=\"607\" height=\"387\">\n</div>\n<p><a id=\"data-flow-in-forms\"></a></p>\n<h2 id=\"data-flow-in-forms\" translation-result=\"on\">表單中的資料流<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-forms\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Data flow in forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-forms\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">當應用包含一個表單時，Angular 必須讓該檢視與元件模型保持同步，並讓元件模型與檢視保持同步。當用戶透過檢視更改值並進行選擇時，新值必須反映在資料模型中。同樣，當程式邏輯改變資料模型中的值時，這些值也必須反映到檢視中。</p><p translation-origin=\"off\">When an application contains a form, Angular must keep the view in sync with the component model and the component model in sync with the view.\nAs users change values and make selections through the view, the new values must be reflected in the data model.\nSimilarly, when the program logic changes values in the data model, those values must be reflected in the view.</p>\n\n<p translation-result=\"on\">響應式表單和範本驅動表單在處理來自使用者或程式化變更時的資料處理方式上有所不同。下面的這些原理圖會以上面定義的 <code>favorite-color</code> 輸入欄位為例，分別說明兩種表單各自的資料流。</p><p translation-origin=\"off\">Reactive and template-driven forms differ in how they handle data flowing from the user or from programmatic changes.\nThe following diagrams illustrate both kinds of data flow for each type of form, using the favorite-color input field defined above.</p>\n\n<p><a id=\"data-flow-in-reactive-forms\"></a></p>\n<h3 id=\"data-flow-in-reactive-forms\" translation-result=\"on\">響應式表單中的資料流<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Data flow in reactive forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在響應式表單中，檢視中的每個表單元素都直接連結到一個表單模型（<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項）。\n從檢視到模型的修改以及從模型到檢視的修改都是同步的，而且不依賴於 UI 的渲染方式。</p><p translation-origin=\"off\">In reactive forms each form element in the view is directly linked to the form model (a <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance).\nUpdates from the view to the model and from the model to the view are synchronous and do not depend on how the UI is rendered.</p>\n\n<p translation-result=\"on\">這個檢視到模型的圖表展示了當輸入欄位的值發生變化時，資料流是如何從檢視開始經過下列步驟進行流動的。</p><p translation-origin=\"off\">The view-to-model diagram shows how data flows when an input field's value is changed from the view through the following steps.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">終端使用者在輸入框元素中鍵入了一個值，這裡是 \"Blue\"。</p><p translation-origin=\"off\">The user types a value into the input element, in this case the favorite color <em>Blue</em>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">這個輸入框元素會發出一個帶有最新值的 \"input\" 事件。</p><p translation-origin=\"off\">The form input element emits an \"input\" event with the latest value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">這個控制項值存取器 <code><a href=\"api/forms/ControlValueAccessor\" class=\"code-anchor\">ControlValueAccessor</a></code> 會監聽表單輸入框元素上的事件，並立即把新值傳給 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項。</p><p translation-origin=\"off\">The control value accessor listening for events on the form input element immediately relays the new value to the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項會透過 <code>valueChanges</code> 這個可觀察物件發出這個新值。</p><p translation-origin=\"off\">The <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance emits the new value through the <code>valueChanges</code> observable.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>valueChanges</code> 的任何一個訂閱者都會收到這個新值。</p><p translation-origin=\"off\">Any subscribers to the <code>valueChanges</code> observable receive the new value.</p>\n\n</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"Reactive forms data flow - view to model\" src=\"generated/images/guide/forms-overview/dataflow-reactive-forms-vtm.png\" width=\"600\" height=\"592\">\n</div>\n<p translation-result=\"on\">這個模型到檢視的原理圖體現了程式中對模型的修改是如何透過下列步驟傳播到檢視中的。</p><p translation-origin=\"off\">The model-to-view diagram shows how a programmatic change to the model is propagated to the view through the following steps.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\"><code>favoriteColorControl.setValue()</code> 方法被呼叫，它會更新這個 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 的值。</p><p translation-origin=\"off\">The user calls the <code>favoriteColorControl.setValue()</code> method, which updates the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項會透過 <code>valueChanges</code> 這個可觀察物件發出新值。</p><p translation-origin=\"off\">The <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance emits the new value through the <code>valueChanges</code> observable.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>valueChanges</code> 的任何訂閱者都會收到這個新值。</p><p translation-origin=\"off\">Any subscribers to the <code>valueChanges</code> observable receive the new value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">該表單輸入框元素上的控制項值存取器會把控制項更新為這個新值。</p><p translation-origin=\"off\">The control value accessor on the form input element updates the element with the new value.</p>\n\n</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"Reactive forms data flow - model to view\" src=\"generated/images/guide/forms-overview/dataflow-reactive-forms-mtv.png\" width=\"600\" height=\"611\">\n</div>\n<p><a id=\"data-flow-in-template-driven-forms\"></a></p>\n<h3 id=\"data-flow-in-template-driven-forms\" translation-result=\"on\">範本驅動表單中的資料流<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Data flow in template-driven forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#data-flow-in-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在範本驅動表單中，每一個表單元素都是和一個負責管理內部表單模型的指令關聯起來的。</p><p translation-origin=\"off\">In template-driven forms, each form element is linked to a directive that manages the form model internally.</p>\n\n<p translation-result=\"on\">這個檢視到模型的圖表展示了當輸入欄位的值發生變化時，資料流是如何從檢視開始經過下列步驟進行流動的。</p><p translation-origin=\"off\">The view-to-model diagram shows how data flows when an input field's value is changed from the view through the following steps.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">終端使用者在輸入框元素中敲 \"Blue\"。</p><p translation-origin=\"off\">The user types <em>Blue</em> into the input element.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">該輸入框元素會發出一個 \"input\" 事件，帶著值 \"Blue\"。</p><p translation-origin=\"off\">The input element emits an \"input\" event with the value <em>Blue</em>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">附著在該輸入框上的控制項值存取器會觸發 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項上的 <code>setValue()</code> 方法。</p><p translation-origin=\"off\">The control value accessor attached to the input triggers the <code>setValue()</code> method on the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項透過 <code>valueChanges</code> 這個可觀察物件發出新值。</p><p translation-origin=\"off\">The <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance emits the new value through the <code>valueChanges</code> observable.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>valueChanges</code> 的任何訂閱者都會收到新值。</p><p translation-origin=\"off\">Any subscribers to the <code>valueChanges</code> observable receive the new value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">控制項值存取器 <code>ControlValueAccessory</code> 還會呼叫 <code><a href=\"api/forms/NgModel#viewToModelUpdate\" class=\"code-anchor\">NgModel.viewToModelUpdate()</a></code> 方法，它會發出一個 <code>ngModelChange</code> 事件。</p><p translation-origin=\"off\">The control value accessor also calls the <code><a href=\"api/forms/NgModel#viewToModelUpdate\" class=\"code-anchor\">NgModel.viewToModelUpdate()</a></code> method which emits an <code>ngModelChange</code> event.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">由於該元件範本雙向資料繫結到了 <code>favoriteColor</code>，元件中的 <code>favoriteColor</code> 屬性就會修改為 <code>ngModelChange</code> 事件所發出的值（\"Blue\"）。</p><p translation-origin=\"off\">Because the component template uses two-way data binding for the <code>favoriteColor</code> property, the <code>favoriteColor</code> property in the component is updated to the value emitted by the <code>ngModelChange</code> event (<em>Blue</em>).</p>\n\n</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"Template-driven forms data flow - view to model\" width=\"100%\" src=\"generated/images/guide/forms-overview/dataflow-td-forms-vtm.png\">\n</div>\n<p translation-result=\"on\">這個模型到檢視的原理圖展示了當 <code>favoriteColor</code> 從<em>藍</em>變到<em>紅</em>時，資料是如何經過如下步驟從模型流動到檢視的。</p><p translation-origin=\"off\">The model-to-view diagram shows how data flows from model to view when the <code>favoriteColor</code> changes from <em>Blue</em> to <em>Red</em>, through the following steps</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">元件中修改了 <code>favoriteColor</code> 的值。</p><p translation-origin=\"off\">The <code>favoriteColor</code> value is updated in the component.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">變更檢測開始。</p><p translation-origin=\"off\">Change detection begins.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在變更檢測期間，由於這些輸入框之一的值發生了變化，Angular 就會呼叫 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 指令上的 <code>ngOnChanges</code> 生命週期鉤子。</p><p translation-origin=\"off\">During change detection, the <code>ngOnChanges</code> lifecycle hook is called on the <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> directive instance because the value of one of its inputs has changed.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>ngOnChanges()</code> 方法會把一個非同步任務排入佇列，以設定內部 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項的值。</p><p translation-origin=\"off\">The <code>ngOnChanges()</code> method queues an async task to set the value for the internal <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">變更檢測完成。</p><p translation-origin=\"off\">Change detection completes.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在下一個檢測週期，用來為 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項賦值的任務就會執行。</p><p translation-origin=\"off\">On the next tick, the task to set the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance value is executed.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項透過可觀察物件 <code>valueChanges</code> 發出最新值。</p><p translation-origin=\"off\">The <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance emits the latest value through the <code>valueChanges</code> observable.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>valueChanges</code> 的任何訂閱者都會收到這個新值。</p><p translation-origin=\"off\">Any subscribers to the <code>valueChanges</code> observable receive the new value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">控制項值存取器 <code><a href=\"api/forms/ControlValueAccessor\" class=\"code-anchor\">ControlValueAccessor</a></code> 會使用 <code>favoriteColor</code> 的最新值來修改表單的輸入框元素。</p><p translation-origin=\"off\">The control value accessor updates the form input element in the view with the latest <code>favoriteColor</code> value.</p>\n\n</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"Template-driven forms data flow - model to view\" width=\"100%\" src=\"generated/images/guide/forms-overview/dataflow-td-forms-mtv.png\">\n</div>\n<p><a id=\"mutability-of-the-data-model\"></a></p>\n<h3 id=\"mutability-of-the-data-model\" translation-result=\"on\">資料模型的可變性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#mutability-of-the-data-model\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Mutability of the data model<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#mutability-of-the-data-model\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">變更追蹤的方法對應用的效率有著重要影響。</p><p translation-origin=\"off\">The change-tracking method plays a role in the efficiency of your application.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">表格</nt-wrapper><nt-wrapper translation-origin=\"off\">Forms</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳細資訊</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">響應式表單</nt-wrapper><nt-wrapper translation-origin=\"off\">Reactive forms</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">透過以不可變的資料結構提供資料模型，來保持資料模型的純粹性。每當在資料模型上觸發更改時，<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項都會返回一個新的資料模型，而不會更新現有的資料模型。這使你能夠透過該控制項的可觀察物件追蹤對資料模型的唯一更改。這讓變更檢測更有效率，因為它只需在唯一性更改（譯註：也就是物件參考發生變化）時進行更新。由於資料更新遵循響應式模式，因此你可以把它和可觀察物件的各種運算子整合起來以轉換資料。</nt-wrapper><nt-wrapper translation-origin=\"off\">Keep the data model pure by providing it as an immutable data structure. Each time a change is triggered on the data model, the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance returns a new data model rather than updating the existing data model. This gives you the ability to track unique changes to the data model through the control's observable. Change detection is more efficient because it only needs to update on unique changes. Because data updates follow reactive patterns, you can integrate with observable operators to transform data.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">範本驅動表單</nt-wrapper><nt-wrapper translation-origin=\"off\">Template-driven forms</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">依賴於可變性和雙向資料繫結，可以在範本中做出更改時更新元件中的資料模型。由於使用雙向資料繫結時沒有用來對資料模型進行追蹤的唯一性更改，因此變更檢測在需要確定何時更新時效率較低。</nt-wrapper><nt-wrapper translation-origin=\"off\">Rely on mutability with two-way data binding to update the data model in the component as changes are made in the template. Because there are no unique changes to track on the data model when using two-way data binding, change detection is less efficient at determining when updates are required.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">前面那些使用 <code>favorite-color</code> 輸入元素的例子就示範了這種差異。</p><p translation-origin=\"off\">The difference is demonstrated in the previous examples that use the favorite-color input element.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">對於響應式表單，當控制項值更新時，<strong><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 的例項</strong>總會返回一個新值</p><p translation-origin=\"off\">With reactive forms, the <strong><code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance</strong> always returns a new value when the control's value is updated</p>\n\n</li>\n<li>\n<p translation-result=\"on\">對於範本驅動表單，<strong><code>favorite-color</code> 屬性</strong>總會被修改為新值</p><p translation-origin=\"off\">With template-driven forms, the <strong>favorite color property</strong> is always modified to its new value</p>\n\n</li>\n</ul>\n<p><a id=\"validation\"></a></p>\n<h2 id=\"form-validation\" translation-result=\"on\">表單驗證<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#form-validation\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Form validation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#form-validation\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">驗證是管理任何表單時必備的一部分。無論你是要檢查必填項，還是查詢外部 API 來檢查使用者名稱是否已存在，Angular 都會提供一組內建的驗證器，以及建立自訂驗證器所需的能力。</p><p translation-origin=\"off\">Validation is an integral part of managing any set of forms.\nWhether you're checking for required fields or querying an external API for an existing username, Angular provides a set of built-in validators as well as the ability to create custom validators.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">表格</nt-wrapper><nt-wrapper translation-origin=\"off\">Forms</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳細資訊</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">響應式表單</nt-wrapper><nt-wrapper translation-origin=\"off\">Reactive forms</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">把自訂驗證器定義成<strong>函式</strong>，它以要驗證的控制項作為引數</nt-wrapper><nt-wrapper translation-origin=\"off\">Define custom validators as <strong>functions</strong> that receive a control to validate</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">範本驅動表單</nt-wrapper><nt-wrapper translation-origin=\"off\">Template-driven forms</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">和範本<strong>指令</strong>緊密相關，並且必須提供包裝了驗證函式的自訂驗證器指令</nt-wrapper><nt-wrapper translation-origin=\"off\">Tied to template <strong>directives</strong>, and must provide custom validator directives that wrap validation functions</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">要了解驗證器的更多知識，參閱<a href=\"guide/form-validation\">表單驗證</a>。</p><p translation-origin=\"off\">For more information, see <a href=\"guide/form-validation\">Form Validation</a>.</p>\n\n<h2 id=\"testing\" translation-result=\"on\">測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">測試在複雜的應用程式中也起著重要的作用。當驗證你的表單功能是否正確時，更簡單的測試策略往往也更有用。測試響應式表單和範本驅動表單的差別之一在於它們是否需要渲染 UI 才能基於表單控制項和表單欄位變化來執行斷言。下面的例子示範了使用響應式表單和範本驅動表單時表單的測試過程。</p><p translation-origin=\"off\">Testing plays a large part in complex applications.\nA simpler testing strategy is useful when validating that your forms function correctly.\nReactive forms and template-driven forms have different levels of reliance on rendering the UI to perform assertions based on form control and form field changes.\nThe following examples demonstrate the process of testing forms with reactive and template-driven forms.</p>\n\n<h3 id=\"testing-reactive-forms\" translation-result=\"on\">測試響應式表單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing-reactive-forms\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Testing reactive forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing-reactive-forms\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">響應式表單提供了相對簡單的測試策略，因為它們能提供對表單和資料模型的同步存取，而且不必渲染 UI 就能測試它們。在這些測試中，控制項和資料是透過控制項進行查詢和操縱的，不需要和變更檢測週期打交道。</p><p translation-origin=\"off\">Reactive forms provide a relatively straightforward testing strategy because they provide synchronous access to the form and data models, and they can be tested without rendering the UI.\nIn these tests, status and data are queried and manipulated through the control without interacting with the change detection cycle.</p>\n\n<p translation-result=\"on\">下面的測試利用前面例子中的 \"喜歡的顏色\" 元件來驗證響應式表單中的 \"從檢視到模型\" 和 \"從模型到檢視\" 資料流。</p><p translation-origin=\"off\">The following tests use the favorite-color components from previous examples to verify the view-to-model and model-to-view data flows for a reactive form.</p>\n\n<!--todo: make consistent with other topics -->\n<p translation-result=\"on\"><strong>驗證“從檢視到模型”的資料流</strong></p><p translation-origin=\"off\"><strong>Verifying view-to-model data flow</strong></p>\n\n<p translation-result=\"on\">第一個例子執行了下列步驟來驗證“從檢視到模型”資料流。</p><p translation-origin=\"off\">The first example performs the following steps to verify the view-to-model data flow.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">查詢表單輸入框元素的檢視，併為測試建立自訂的 \"input\" 事件</p><p translation-origin=\"off\">Query the view for the form input element, and create a custom \"input\" event for the test.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把輸入的新值設定為 <em>Red</em>，並在表單輸入元素上排程 \"input\" 事件。</p><p translation-origin=\"off\">Set the new value for the input to <em>Red</em>, and dispatch the \"input\" event on the form input element.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">斷言該元件的 <code>favoriteColorControl</code> 的值與來自輸入框的值是匹配的。</p><p translation-origin=\"off\">Assert that the component's <code>favoriteColorControl</code> value matches the value from the input.</p>\n\n</li>\n</ol>\n<code-example header=\"Favorite color test - view to model\" path=\"forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts\" region=\"view-to-model\">\nit('should update the value of the input field', () =&gt; {\n  const input = fixture.nativeElement.querySelector('input');\n  const event = createNewEvent('input');\n\n  input.value = 'Red';\n  input.dispatchEvent(event);\n\n  expect(fixture.componentInstance.favoriteColorControl.value).toEqual('Red');\n});\n\n</code-example>\n<p translation-result=\"on\">下一個例子執行了下列步驟來驗證“從模型到檢視”資料流。</p><p translation-origin=\"off\">The next example performs the following steps to verify the model-to-view data flow.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">使用 <code>favoriteColorControl</code> 這個 <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 例項來設定新值。</p><p translation-origin=\"off\">Use the <code>favoriteColorControl</code>, a <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance, to set the new value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">查詢表單中輸入框的檢視。</p><p translation-origin=\"off\">Query the view for the form input element.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">斷言控制項上設定的新值與輸入中的值是匹配的。</p><p translation-origin=\"off\">Assert that the new value set on the control matches the value in the input.</p>\n\n</li>\n</ol>\n<code-example header=\"Favorite color test - model to view\" path=\"forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts\" region=\"model-to-view\">\nit('should update the value in the control', () =&gt; {\n  component.favoriteColorControl.setValue('Blue');\n\n  const input = fixture.nativeElement.querySelector('input');\n\n  expect(input.value).toBe('Blue');\n});\n\n</code-example>\n<h3 id=\"testing-template-driven-forms\" translation-result=\"on\">測試範本驅動表單<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Testing template-driven forms<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#testing-template-driven-forms\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">使用範本驅動表單編寫測試就需要詳細瞭解變更檢測過程，以及指令在每個變更檢測週期中如何執行，以確保在正確的時間查詢、測試或更改元素。</p><p translation-origin=\"off\">Writing tests with template-driven forms requires a detailed knowledge of the change detection process and an understanding of how directives run on each cycle to ensure that elements are queried, tested, or changed at the correct time.</p>\n\n<p translation-result=\"on\">下面的測試使用了以前的 \"喜歡的顏色\" 元件，來驗證範本驅動表單的 \"從檢視到模型\" 和 \"從模型到檢視\" 資料流。</p><p translation-origin=\"off\">The following tests use the favorite color components mentioned earlier to verify the data flows from view to model and model to view for a template-driven form.</p>\n\n<p translation-result=\"on\">下面的測試驗證了 \"從檢視到模型\" 資料流：</p><p translation-origin=\"off\">The following test verifies the data flow from view to model.</p>\n\n<code-example header=\"Favorite color test - view to model\" path=\"forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts\" region=\"view-to-model\">\nit('should update the favorite color in the component', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n     const input = fixture.nativeElement.querySelector('input');\n     const event = createNewEvent('input');\n\n     input.value = 'Red';\n     input.dispatchEvent(event);\n\n     fixture.detectChanges();\n\n     expect(component.favoriteColor).toEqual('Red');\n   }));\n\n</code-example>\n<p translation-result=\"on\">這個 \"檢視到模型\" 測試的執行步驟如下：</p><p translation-origin=\"off\">Here are the steps performed in the view to model test.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">查詢表單輸入元素中的檢視，併為測試建立自訂 \"input\" 事件。</p><p translation-origin=\"off\">Query the view for the form input element, and create a custom \"input\" event for the test.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把輸入框的新值設定為 <em>Red</em>，並在表單輸入框元素上派發 \"input\" 事件。</p><p translation-origin=\"off\">Set the new value for the input to <em>Red</em>, and dispatch the \"input\" event on the form input element.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">透過測試夾具（Fixture）來執行變更檢測。</p><p translation-origin=\"off\">Run change detection through the test fixture.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">斷言該元件 <code>favoriteColor</code> 屬性的值與來自輸入框的值是匹配的。</p><p translation-origin=\"off\">Assert that the component <code>favoriteColor</code> property value matches the value from the input.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">下面的測試驗證了 \"從模型到檢視\" 的資料流：</p><p translation-origin=\"off\">The following test verifies the data flow from model to view.</p>\n\n<code-example header=\"Favorite color test - model to view\" path=\"forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts\" region=\"model-to-view\">\nit('should update the favorite color on the input field', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n     component.favoriteColor = 'Blue';\n\n     fixture.detectChanges();\n\n     <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();\n\n     const input = fixture.nativeElement.querySelector('input');\n\n     expect(input.value).toBe('Blue');\n   }));\n\n</code-example>\n<p translation-result=\"on\">這個 \"模型到檢視\" 測試的執行步驟如下：</p><p translation-origin=\"off\">Here are the steps performed in the model to view test.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">使用元件例項來設定 <code>favoriteColor</code> 的值。</p><p translation-origin=\"off\">Use the component instance to set the value of the <code>favoriteColor</code> property.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">透過測試夾具（Fixture）來執行變更檢測。</p><p translation-origin=\"off\">Run change detection through the test fixture.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在 <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 任務中使用 <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code> 方法來模擬時間的流逝。</p><p translation-origin=\"off\">Use the <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code> method to simulate the passage of time within the <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> task.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">查詢表單輸入框元素的檢視。</p><p translation-origin=\"off\">Query the view for the form input element.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">斷言輸入框的值與該元件例項的 <code>favoriteColor</code> 屬性值是匹配的。</p><p translation-origin=\"off\">Assert that the input value matches the value of the <code>favoriteColor</code> property in the component instance.</p>\n\n</li>\n</ol>\n<h2 id=\"next-steps\" translation-result=\"on\">後續步驟<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#next-steps\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Next steps<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/forms-overview#next-steps\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要進一步瞭解響應式表單，參閱下列章節：</p><p translation-origin=\"off\">To learn more about reactive forms, see the following guides:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"guide/reactive-forms\">響應式表單</a></p><p translation-origin=\"off\"><a href=\"guide/reactive-forms\">Reactive forms</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/form-validation#reactive-form-validation\">表單驗證</a></p><p translation-origin=\"off\"><a href=\"guide/form-validation#reactive-form-validation\">Form validation</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/dynamic-form\">動態表單</a></p><p translation-origin=\"off\"><a href=\"guide/dynamic-form\">Dynamic forms</a></p>\n\n</li>\n</ul>\n<p translation-result=\"on\">要進一步瞭解範本驅動表單，參閱下列章節：</p><p translation-origin=\"off\">To learn more about template-driven forms, see the following guides:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"guide/forms\">建構範本驅動表單</a>課程</p><p translation-origin=\"off\"><a href=\"guide/forms\">Building a template-driven form</a> tutorial</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/form-validation#template-driven-validation\">表單驗證</a></p><p translation-origin=\"off\"><a href=\"guide/form-validation#template-driven-validation\">Form validation</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code> 指令 API 參考手冊</p><p translation-origin=\"off\"><code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code> directive API reference</p>\n\n</li>\n</ul>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/forms\n - api/forms/ReactiveFormsModule\n - features\n - guide/architecture-next-steps\n - guide/developer-guide-overview\n - guide/docs-style-guide\n - guide/example-apps-list\n - guide/form-validation\n - guide/forms\n - guide/glossary\n - guide/npm-packages\n - guide/reactive-forms\n - guide/user-input\n - guide/what-is-angular\n - scaling\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/testing/fakeAsync\n - api/core/testing/tick\n - api/forms/ControlValueAccessor\n - api/forms/FormArray\n - api/forms/FormControl\n - api/forms/FormGroup\n - api/forms/NgForm\n - api/forms/NgModel\n - api/forms/NgModel#viewToModelUpdate\n - guide/architecture\n - guide/architecture-components#template-syntax\n - guide/dynamic-form\n - guide/form-validation\n - guide/form-validation#reactive-form-validation\n - guide/form-validation#template-driven-validation\n - guide/forms\n - guide/forms-overview#angular-表單簡介\n - guide/forms-overview#choosing-an-approach\n - guide/forms-overview#common-form-foundation-classes\n - guide/forms-overview#data-flow-in-forms\n - guide/forms-overview#data-flow-in-reactive-forms\n - guide/forms-overview#data-flow-in-template-driven-forms\n - guide/forms-overview#form-validation\n - guide/forms-overview#introduction-to-forms-in-angular\n - guide/forms-overview#key-differences\n - guide/forms-overview#mutability-of-the-data-model\n - guide/forms-overview#next-steps\n - guide/forms-overview#prerequisites\n - guide/forms-overview#scalability\n - guide/forms-overview#setting-up-the-form-model\n - guide/forms-overview#setup\n - guide/forms-overview#setup-in-reactive-forms\n - guide/forms-overview#setup-in-template-driven-forms\n - guide/forms-overview#testing\n - guide/forms-overview#testing-reactive-forms\n - guide/forms-overview#testing-template-driven-forms\n - guide/forms-overview#validation\n - guide/forms-overview#關鍵差異\n - guide/forms-overview#前提條件\n - guide/forms-overview#可延展性\n - guide/forms-overview#後續步驟\n - guide/forms-overview#響應式表單中的資料流\n - guide/forms-overview#常用表單基礎類\n - guide/forms-overview#建立響應式表單\n - guide/forms-overview#建立範本驅動表單\n - guide/forms-overview#建立表單模型\n - guide/forms-overview#資料模型的可變性\n - guide/forms-overview#範本驅動表單中的資料流\n - guide/forms-overview#測試\n - guide/forms-overview#測試響應式表單\n - guide/forms-overview#測試範本驅動表單\n - guide/forms-overview#表單中的資料流\n - guide/forms-overview#表單驗證\n - guide/forms-overview#選擇一種方法\n - guide/reactive-forms\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/forms-overview.md?message=docs%3A%20請簡述你的修改...\n - https://www.typescriptlang.org\n - https://www.typescriptlang.org/\n-->"}