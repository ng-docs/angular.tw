{"id":"guide/http-security-xsrf-protection","title":"HTTP client - Security: Cross-Site Request Forgery (XSRF) protection","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-security-xsrf-protection.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"http-client---security-cross-site-request-forgery-xsrf-protection\" translation-result=\"on\">HTTP 客戶端 - 安全性：跨站點請求偽造（XSRF）保護<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-security-xsrf-protection#http-client---security-cross-site-request-forgery-xsrf-protection\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">HTTP client - Security: Cross-Site Request Forgery (XSRF) protection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-security-xsrf-protection#http-client---security-cross-site-request-forgery-xsrf-protection\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\"><a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery\">跨站請求偽造（XSRF 或 CSRF）</a>是一種攻擊技術，攻擊者可以透過這種技術誘使已完成身份驗證的使用者在你的網站上不知不覺地執行某些操作。</p><p translation-origin=\"off\"><a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery\">Cross-Site Request Forgery (XSRF or CSRF)</a> is an attack technique by which the attacker can trick an authenticated user into unknowingly executing actions on your website.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 支援用於防止 XSRF 攻擊的<a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token\">通用機制</a>。當執行 HTTP 請求時，攔截器從 cookie 中讀取令牌，預設為 <code>XSRF-TOKEN</code>，並將其設定為 HTTP 標頭 <code>X-XSRF-TOKEN</code>。因為只有在你的域上執行的程式碼才能讀取 cookie，這樣後端就可以確定 HTTP 請求來自你的客戶端程式而不是攻擊者。</p><p translation-origin=\"off\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> supports a <a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token\">common mechanism</a> used to prevent XSRF attacks.\nWhen performing HTTP requests, an interceptor reads a token from a cookie, by default <code>XSRF-TOKEN</code>, and sets it as an HTTP header, <code>X-XSRF-TOKEN</code>.\nBecause only code that runs on your domain could read the cookie, the backend can be certain that the HTTP request came from your client application and not an attacker.</p>\n\n<p translation-result=\"on\">預設情況下，攔截器會在所有的修改型請求中（比如 POST 等）把這個請求頭髮送給使用相對 URL 的請求。但不會在 GET/HEAD 請求中傳送，也不會發送給使用絕對 URL 的請求。</p><p translation-origin=\"off\">By default, an interceptor sends this header on all mutating requests (such as POST)\nto relative URLs, but not on GET/HEAD requests or on requests with an absolute URL.</p>\n\n<p translation-result=\"on\">要獲得這種優點，你的伺服器需要在頁面載入或首個 GET 請求中把一個名叫 <code>XSRF-TOKEN</code> 的標記寫入可被 JavaScript 讀到的會話 cookie 中。而在後續的請求中，伺服器可以驗證這個 cookie 是否與 HTTP 頭 <code>X-XSRF-TOKEN</code> 的值一致，以確保只有執行在你自己域名下的程式碼才能發起這個請求。這個標記必須對每個使用者都是唯一的，並且必須能被伺服器驗證，因此不能由客戶端自己產生標記。把這個標記設定為你的站點認證資訊並且加了鹽（salt）的摘要，以提升安全性。</p><p translation-origin=\"off\">To take advantage of this, your server needs to set a token in a JavaScript readable session cookie called <code>XSRF-TOKEN</code> on either the page load or the first GET request.\nOn subsequent requests the server can verify that the cookie matches the <code>X-XSRF-TOKEN</code> HTTP header, and therefore be sure that only code running on your domain could have sent the request.\nThe token must be unique for each user and must be verifiable by the server; this prevents the client from making up its own tokens.\nSet the token to a digest of your site's authentication cookie with a salt for added security.</p>\n\n<p translation-result=\"on\">為了防止多個 Angular 應用共享同一個域名或子域時出現衝突，要給每個應用分配一個唯一的 cookie 名稱。</p><p translation-origin=\"off\">To prevent collisions in environments where multiple Angular apps share the same domain or subdomain, give each application a unique cookie name.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><em><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 僅支援受 XSRF 保護的客戶端部分</em>。後端服務必須配置為能夠為頁面設定 cookie，並驗證在所有符合條件的請求中是否存在該標頭。如果後端服務未能正確設定它們，則會讓 Angular 的預設保護失效。</p><p translation-origin=\"off\"><em><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> supports only the client half of the XSRF protection scheme.</em>\nYour backend service must be configured to set the cookie for your page, and to verify that the header is present on all eligible requests.\nFailing to do so renders Angular's default protection ineffective.</p>\n\n</div>\n<h2 id=\"configure-custom-cookieheader-names\" translation-result=\"on\">配置自訂 cookie/標頭名稱<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-security-xsrf-protection#configure-custom-cookieheader-names\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Configure custom cookie/header names<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http-security-xsrf-protection#configure-custom-cookieheader-names\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果你的後端服務中對 XSRF 標記的 cookie 或頭使用了不一樣的名字，就要使用 <code><a href=\"api/common/http/HttpClientXsrfModule#withOptions\" class=\"code-anchor\">HttpClientXsrfModule.withOptions()</a></code> 來覆蓋掉預設值。</p><p translation-origin=\"off\">If your backend service uses different names for the XSRF token cookie or header, use <code><a href=\"api/common/http/HttpClientXsrfModule#withOptions\" class=\"code-anchor\">HttpClientXsrfModule.withOptions()</a></code> to override the defaults.</p>\n\n<code-example path=\"http/src/app/app.module.ts\" region=\"xsrf\">\nimports: [\n  <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  HttpClientXsrfModule.withOptions({\n    cookieName: 'My-Xsrf-Cookie',\n    headerName: 'My-Xsrf-Header',\n  }),\n],\n\n</code-example>\n<p><a id=\"testing-requests\"></a></p>\n\n  <div class=\"reviewed\">最後複查時間：11/14/2022</div>\n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/common/http/HttpClientModule\n - api/common/http/HttpClientXsrfModule#withOptions\n - guide/http-security-xsrf-protection#configure-custom-cookieheader-names\n - guide/http-security-xsrf-protection#http-client---security-cross-site-request-forgery-xsrf-protection\n - guide/http-security-xsrf-protection#http-客戶端---安全性跨站點請求偽造xsrf保護\n - guide/http-security-xsrf-protection#配置自訂-cookie標頭名稱\n - https://en.wikipedia.org/wiki/Cross-site_request_forgery\n - https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/http-security-xsrf-protection.md?message=docs%3A%20請簡述你的修改...\n-->"}