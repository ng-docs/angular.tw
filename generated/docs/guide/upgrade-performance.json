{"id":"guide/upgrade-performance","title":"Upgrading for performance","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/upgrade-performance.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"upgrading-for-performance\" translation-result=\"on\">更關注效能的升級方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#upgrading-for-performance\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Upgrading for performance<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#upgrading-for-performance\"><i class=\"material-icons\">link</i></a></h1>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><em>Angular</em>是現在和未來的 Angular 名稱。</p><p translation-origin=\"off\"><em>Angular</em> is the name for the Angular of today and tomorrow.</p>\n\n<p translation-result=\"on\"><em>AngularJS</em>是所有 1.x 版本的 Angular 的名稱。</p><p translation-origin=\"off\"><em>AngularJS</em> is the name for all 1.x versions of Angular.</p>\n\n</div>\n<p translation-result=\"on\">本指南介紹了一些用來將 AngularJS 專案高效地逐塊遷移到 Angular 平臺上的工具。本章和<a href=\"guide/upgrade\">從 AngularJS 升級</a>很像，但是這裡會用輔助函式 <a href=\"api/upgrade/static/downgradeModule\"><code>downgradeModule()</code></a> 取代 <a href=\"api/upgrade/static/UpgradeModule\"><code>UpgradeModule</code></a>。這會影響到應用如何啟動，以及變更檢測事件如何在兩個框架之間傳播。它能讓你逐步升級，並提高混合式應用的執行速度，並讓你能在升級過程中儘早用上 Angular 中的最新特性。</p><p translation-origin=\"off\">This guide describes some of the built-in tools for efficiently migrating AngularJS projects over to the Angular platform, one piece at a time.\nIt is very similar to <a href=\"guide/upgrade\">Upgrading from AngularJS</a> with the exception that this one uses the <a href=\"api/upgrade/static/downgradeModule\"><code>downgradeModule()</code></a> helper function instead of the <a href=\"api/upgrade/static/UpgradeModule\"><code>UpgradeModule</code></a> class.\nThis affects how the application is bootstrapped and how change detection is propagated between the two frameworks.\nIt allows you to upgrade incrementally while improving the speed of your hybrid applications and leveraging the latest of Angular in AngularJS applications early in the process of upgrading.</p>\n\n<h2 id=\"preparation\" translation-result=\"on\">準備工作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#preparation\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Preparation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#preparation\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在討論你應該如何用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 來建立混合式應用之前，你可以先採取一些措施來簡化升級過程，甚至在開始升級之前就可以做。無論你用哪種方式升級，這些步驟都是一樣的，請參考<a href=\"guide/upgrade\">從 AngularJS 升級</a>的<a href=\"guide/upgrade#preparation\">準備工作</a>部分。</p><p translation-origin=\"off\">Before discussing how you can use <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> to create hybrid apps, there are things that you can do to ease the upgrade process even before you begin upgrading.\nBecause the steps are the same regardless of how you upgrade, refer to the <a href=\"guide/upgrade#preparation\">Preparation</a> section of <a href=\"guide/upgrade\">Upgrading from AngularJS</a>.</p>\n\n<h2 id=\"upgrading-with-ngupgrade\" translation-result=\"on\">使用 <code>ngUpgrade</code> 升級<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#upgrading-with-ngupgrade\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Upgrading with <code>ngUpgrade</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#upgrading-with-ngupgrade\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用 Angular 中的 <code>ngUpgrade</code> 函式庫，你可以透過建構混合式應用來逐步升級現有的 AngularJS 應用。在這些混合式應用中，你可以混用 AngularJS 和 Angular 的元件與服務，並讓它們天衣無縫地進行互操作。這意味著你不用一次性完成遷移工作，因為在過渡階段兩個框架可以自然共存。</p><p translation-origin=\"off\">With the <code>ngUpgrade</code> library in Angular you can upgrade an existing AngularJS application incrementally by building a hybrid app where you can run both frameworks side-by-side.\nIn these hybrid applications you can mix and match AngularJS and Angular components and services and have them interoperate seamlessly.\nThat means you don't have to do the upgrade work all at once as there is a natural coexistence between the two frameworks during the transition period.</p>\n\n<h3 id=\"how-ngupgrade-works\" translation-result=\"on\"><code>ngUpgrade</code> 的工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#how-ngupgrade-works\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">How <code>ngUpgrade</code> Works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#how-ngupgrade-works\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">無論選擇 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 還是 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，升級的基本原則都是一樣的：無論是混合式應用背後的心智模型，還是 <a href=\"api/upgrade/static\">upgrade/static</a> 的用法。要了解更多，參閱<a href=\"guide/upgrade\">從 AngularJS 升級</a>的 <a href=\"guide/upgrade#how-ngupgrade-works\"><code>ngUpgrade</code> 工作原理</a>部分。</p><p translation-origin=\"off\">Regardless of whether you choose <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> or <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>, the basic principles of upgrading, the mental model behind hybrid apps, and how you use the <a href=\"api/upgrade/static\">upgrade/static</a> utilities remain the same.\nFor more information, see the <a href=\"guide/upgrade#how-ngupgrade-works\">How <code>ngUpgrade</code> Works</a> section of <a href=\"guide/upgrade\">Upgrading from AngularJS</a>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><a href=\"guide/upgrade\">從 AngularJS 升級</a>中的<a href=\"guide/upgrade#change-detection\">變更檢測</a>部分僅僅適用於使用 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 的應用。雖然你處理變更檢測的方式和 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>（本章的重點）不同，不過讀一下<a href=\"guide/upgrade#change-detection\">變更檢測</a>部分還是能為後續內容提供一些有用的上下文知識。</p><p translation-origin=\"off\">The <a href=\"guide/upgrade#change-detection\">Change Detection</a> section of <a href=\"guide/upgrade\">Upgrading from AngularJS</a> only applies to applications that use <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>.\nThough you handle change detection differently with <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>, which is the focus of this guide, reading the <a href=\"guide/upgrade#change-detection\">Change Detection</a> section provides helpful context for what follows.</p>\n\n</div>\n<h4 id=\"change-detection-with-downgrademodule\" translation-result=\"on\">使用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 進行變更檢測<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#使用-downgrademodule-進行變更檢測\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Change Detection with <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#change-detection-with-downgrademodule\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">如前所述，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 和 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 之間的一個關鍵區別，就是如何進行變更檢測，以及檢測結果如何在兩個框架之間傳播。</p><p translation-origin=\"off\">As mentioned before, one of the key differences between <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> and <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> has to do with change detection and how it is propagated between the two frameworks.</p>\n\n<p translation-result=\"on\">使用 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，兩套變更檢測系統綁得更緊密一些。一旦應用中的 AngularJS 部分發生了某些變化，變更檢測就會自動在 Angular 部分觸發它，反之亦然。這很方便，因為它保證了任何一個框架都不會丟失重要的變更。不過，其實大多數情況下並不需要執行這些額外的變更檢測。</p><p translation-origin=\"off\">With <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>, the two change detection systems are tied together more tightly.\nWhenever something happens in the AngularJS part of the app, change detection is automatically triggered on the Angular part and vice versa.\nThis is convenient as it ensures that neither framework misses an important change.\nMost of the time, though, these extra change detection runs are unnecessary.</p>\n\n<p translation-result=\"on\">而 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 會避免顯式觸發變更檢測，除非它確信應用的其它部分對此感興趣。比如，如果被降級的元件定義了 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>，當那個值發生變化時，應用就可能需要知道。因此，<code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 就會自動在該元件上觸發變更檢測。</p><p translation-origin=\"off\"><code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>, on the other side, avoids explicitly triggering change detection unless it knows the other part of the application is interested in the changes.\nFor example, if a downgraded component defines an <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, chances are that the application needs to be aware when that value changes.\nThus, <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> automatically triggers change detection on that component.</p>\n\n<p translation-result=\"on\">但是，大多數情況下，應用的其它地方並不會關心某個元件中進行的區域性更改。比如，如果使用者點選了某個表單的提交按鈕，通常會由元件自行處理這個操作的結果。話雖如此，但在某些情況下，你可能希望把這些變化傳播到應用中由另一個框架控制的部分。這時候，你就有責任透過手動觸發變更檢測來通知相關方。</p><p translation-origin=\"off\">In most cases, though, the changes made locally in a particular component are of no interest to the rest of the application.\nFor example, if the user clicks a button that submits a form, the component usually handles the result of this action.\nThat being said, there <em>are</em> cases where you want to propagate changes to some other part of the application that may be controlled by the other framework.\nIn such cases, you are responsible for notifying the interested parties by manually triggering change detection.</p>\n\n<p translation-result=\"on\">如果你希望某些程式碼片段在應用的 AngularJS 部分觸發變更檢測，就要把它包在 <a href=\"https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply\"><code>scope.$apply()</code></a> 中。同樣，要想在 Angular 中觸發變更檢測，就要呼叫 <a href=\"api/core/NgZone#run\"><code>ngZone.run()</code></a>。</p><p translation-origin=\"off\">If you want a particular piece of code to trigger change detection in the AngularJS part of the app, you need to wrap it in <a href=\"https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply\"><code>scope.$apply()</code></a>.\nSimilarly, for triggering change detection in Angular you would use <a href=\"api/core/NgZone#run\"><code>ngZone.run()</code></a>.</p>\n\n<p translation-result=\"on\">很多情況下，是否執行額外的變更檢測可能並不重要。不過，在較大或變更檢測較多的應用中，它們可能會產生顯著地影響。透過讓你更精細的控制變更檢測的傳播方式，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 可以讓你的混合式應用達到更好地效能。</p><p translation-origin=\"off\">In many cases, a few extra change detection runs may not matter much.\nHowever, on larger or change-detection-heavy applications they can have a noticeable impact.\nBy giving you more fine-grained control over the change detection propagation, <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> allows you to achieve better performance for your hybrid applications.</p>\n\n<h2 id=\"using-downgrademodule\" translation-result=\"on\">使用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#使用-downgrademodule\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Using <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-downgrademodule\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">AngularJS 和 Angular 都有自己的模組概念，來幫你把應用按功能組織成內聚的程式碼塊。</p><p translation-origin=\"off\">Both AngularJS and Angular have their own concept of modules to help organize an application into cohesive blocks of functionality.</p>\n\n<p translation-result=\"on\">它們在架構和實現方面的細節有很大不同。在 AngularJS 中，你可以用 <a href=\"https://docs.angularjs.org/api/ng/function/angular.module\"><code>angular.module()</code></a> 指定名字和依賴，以建立一個模組。然後，你可以使用它的各種方法新增資產。在 Angular 中，你要建立一個帶有 <a href=\"api/core/NgModule\">NgModule</a> 裝飾器的類，靠這個裝飾器的元資料來描述這些資產。</p><p translation-origin=\"off\">Their details are quite different in architecture and implementation.\nIn AngularJS, you create a module by specifying its name and dependencies with <a href=\"https://docs.angularjs.org/api/ng/function/angular.module\"><code>angular.module()</code></a>.\nThen you can add assets using its various methods.\nIn Angular, you create a class adorned with an <a href=\"api/core/NgModule\">NgModule</a> decorator that describes assets in metadata.</p>\n\n<p translation-result=\"on\">在混合式應用中，你同時執行著兩個框架。這意味著你至少需要一個來自 AngularJS 的模組和一個來自 Angular 的模組。</p><p translation-origin=\"off\">In a hybrid application you run both frameworks at the same time.\nThis means that you need at least one module each from both AngularJS and Angular.</p>\n\n<p translation-result=\"on\">大多數情況下，你可以使用與常規應用程式相同的方式來指定模組。然後，使用 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 輔助函式來讓兩個框架了解對方使用的資產。這叫做\"升級（upgrading）\"和\"降級（downgrading）\"。</p><p translation-origin=\"off\">For the most part, you specify the modules in the same way you would for a regular application.\nThen, you use the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> helpers to let the two frameworks know about assets they can use from each other.\nThis is known as \"upgrading\" and \"downgrading\".</p>\n\n<div class=\"callout is-helpful\">\n<header ng-should-translate=\"\" translation-result=\"on\">定義：</header><header ng-should-translate=\"\" translation-origin=\"off\">Definitions:</header>\n\n<ul>\n<li>\n<p translation-result=\"on\"><em>升級</em>：讓 AngularJS 中的資產，比如元件或服務，可用於應用中的 Angular 部分。</p><p translation-origin=\"off\"><em>Upgrading</em>:\nThe act of making an AngularJS asset, such as a component or service, available to the Angular part of the application.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><em>降級</em>：讓 Angular 中的資產，比如元件或服務，可用於應用中的 AngularJS 部分。</p><p translation-origin=\"off\"><em>Downgrading</em>:\nThe act of making an Angular asset, such as a component or service, available to the AngularJS part of the application.</p>\n\n</li>\n</ul>\n</div>\n<p translation-result=\"on\">依賴互聯中最重要的部分之一是把兩個主模組聯結在一起。這就是 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 的用武之地。使用它來建立 AngularJS 模組（你可以在 AngularJS 主模組中把這個模組用作依賴項），該模組將引導你的 Angular 主模組，並啟動混合式應用中的 Angular 部分。從某種意義上說，它把 NgModule \"降級\"成了 AngularJS 模組。</p><p translation-origin=\"off\">An important part of inter-linking dependencies is linking the two main modules together.\nThis is where <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> comes in.\nUse it to create an AngularJS module —one that you can use as a dependency in your main AngularJS module— that will bootstrap your main Angular module and kick off the Angular part of the hybrid application.\nIn a sense, it \"downgrades\" an Angular module to an AngularJS module.</p>\n\n<p translation-result=\"on\">要記住如下幾點：</p><p translation-origin=\"off\">There are a few things to remember, though:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">你不必把 Angular 模組直接傳給 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>。<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 所需要的只是一個用來建立模組例項 \"配方\"（比如工廠函式）。</p><p translation-origin=\"off\">You don't pass the Angular module directly to <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>.\nAll <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> needs is a \"recipe\", for example, a factory function, to create an instance for your module.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">除非應用實際用到了，否則不會初始化這個 Angular 模組。</p><p translation-origin=\"off\">The Angular module is not instantiated until the application actually needs it.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">下面是如何使用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 來聯結兩個模組的例子。</p><p translation-origin=\"off\">The following is an example of how you can use <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> to link the two modules.</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\n// Import `<a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()`.\nimport { <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n// Use it to downgrade the Angular module to an AngularJS module.\nconst downgradedModule = <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>(MainAngularModuleFactory);\n\n// Use the downgraded module as a dependency to the main AngularJS module.\nangular.module('mainAngularJsModule', [\n  downgradedModule\n]);\n\n</code-example>\n<h4 id=\"specifying-a-factory-for-the-angular-module\" translation-result=\"on\">為 Angular 模組指定一個工廠<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#specifying-a-factory-for-the-angular-module\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Specifying a factory for the Angular module<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#specifying-a-factory-for-the-angular-module\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">如前所述，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 需要知道如何例項化 Angular 模組。你可以透過提供可以建立 Angular 模組例項的工廠函式來定義該配方。<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 接受兩種型別的工廠函式：</p><p translation-origin=\"off\">As mentioned earlier, <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> needs to know how to instantiate the Angular module.\nIt needs a recipe.\nYou define that recipe by providing a factory function that can create an instance of the Angular module.\n<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> accepts two types of factory functions:</p>\n\n<ul>\n<li>\n<p><code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code></p>\n</li>\n<li>\n<p><code>(extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) =&gt; Promise&lt;<a href=\"api/core/NgModuleRef\" class=\"code-anchor\">NgModuleRef</a>&gt;</code></p>\n</li>\n</ul>\n<p translation-result=\"on\">當傳入 <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code> 時，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 會把它傳給 <a href=\"api/platform-browser/platformBrowser\"><code>platformBrowser</code></a> 的 <a href=\"api/core/PlatformRef#bootstrapModuleFactory\"><code>bootstrapModuleFactory()</code></a> 來例項化模組。它與預先（AOT）編譯模式相容。預先編譯能讓你的應用載入更快。要了解預先編譯的更多知識，以及如何建立 <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code>，參閱 <a href=\"guide/aot-compiler\">預先編譯</a> 章。</p><p translation-origin=\"off\">When you pass an <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code>, <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> uses it to instantiate the module using <a href=\"api/platform-browser/platformBrowser\"><code>platformBrowser</code></a>'s <a href=\"api/core/PlatformRef#bootstrapModuleFactory\"><code>bootstrapModuleFactory()</code></a>, which is compatible with ahead-of-time (AOT) compilation.\nAOT compilation helps make your applications load faster\nFor more about AOT and how to create an <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code>, see the <a href=\"guide/aot-compiler\">Ahead-of-Time Compilation</a> guide.</p>\n\n<p translation-result=\"on\">另外，你還可以傳入一個普通函式，它要返回一個解析為 <a href=\"api/core/NgModuleRef\">NgModuleRef</a>（比如你的 Angular 模組）的 Promise。該函式接收一個額外 <a href=\"api/core/StaticProvider\">Providers</a> 的陣列，這個陣列可以在所返回 <code><a href=\"api/core/NgModuleRef\" class=\"code-anchor\">NgModuleRef</a></code> 的 <a href=\"api/core/Injector\">Injector</a> 中可用。比如，如果你在使用 <a href=\"api/platform-browser/platformBrowser\">platformBrowser</a> 或 <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\">platformBrowserDynamic</a>，就可以把 <code>extraProviders</code> 陣列傳給它們：</p><p translation-origin=\"off\">Alternatively, you can pass a plain function, which is expected to return a promise resolving to an <a href=\"api/core/NgModuleRef\">NgModuleRef</a> (that is, an instance of your Angular module).\nThe function is called with an array of extra <a href=\"api/core/StaticProvider\">Providers</a> that are expected to be available on the returned <code><a href=\"api/core/NgModuleRef\" class=\"code-anchor\">NgModuleRef</a></code>'s <a href=\"api/core/Injector\">Injector</a>.\nFor example, if you are using <a href=\"api/platform-browser/platformBrowser\">platformBrowser</a> or <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\">platformBrowserDynamic</a>, you can pass the <code>extraProviders</code> array to them:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nconst bootstrapFn = (extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) =&gt; {\n  const platformRef = <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>(extraProviders);\n  return platformRef.bootstrapModule(MainAngularModule);\n};\n// or\nconst bootstrapFn = (extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) =&gt; {\n  const platformRef = <a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>(extraProviders);\n  return platformRef.bootstrapModuleFactory(MainAngularModuleFactory);\n};\n\n</code-example>\n<p translation-result=\"on\">使用 <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code> 需要更少的樣板程式碼，並且是一個很好的預設選項，因為它支援 AOT 開箱即用。使用自訂函式需要稍多的程式碼，但是給你提供了更大的靈活性。</p><p translation-origin=\"off\">Using an <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code> requires less boilerplate and is a good default option as it supports AOT out-of-the-box.\nUsing a custom function requires slightly more code, but gives you greater flexibility.</p>\n\n<h4 id=\"instantiating-the-angular-module-on-demand\" translation-result=\"on\">按需例項化 Angular 模組<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#instantiating-the-angular-module-on-demand\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Instantiating the Angular module on-demand<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#instantiating-the-angular-module-on-demand\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 和 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 之間的另一個關鍵區別，就是後者要求你預先例項化 AngularJS 和 Angular 的模組。這意味著你必須為例項化應用中的 Angular 而付出代價 —— 即使你以後不會用到任何 Angular 資產。<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 則不那麼激進。它只會在第一次用到時才例項化 Angular 部分，也就是說，當它需要例項化一個降級後的元件時。</p><p translation-origin=\"off\">Another key difference between <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> and <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> is that the latter requires you to instantiate both the AngularJS and Angular modules up-front.\nThis means that you have to pay the cost of instantiating the Angular part of the app, even if you don't use any Angular assets until later.\n<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> is again less aggressive.\nIt will only instantiate the Angular part when it is required for the first time; that is, as soon as it needs to create a downgraded component.</p>\n\n<p translation-result=\"on\">你還可以更進一步，甚至不必將應用程式中 Angular 部分的程式碼下載到使用者的瀏覽器中 —— 直到需要它的那一刻。當不需要初始渲染或使用者尚未存取到混合式應用中的 Angular 部分時，這特別有用。</p><p translation-origin=\"off\">You could go a step further and not even download the code for the Angular part of the application to the user's browser until it is needed.\nThis is especially useful when you use Angular on parts of the hybrid application that are not necessary for the initial rendering or that the user doesn't reach.</p>\n\n<p translation-result=\"on\">舉一些例子：</p><p translation-origin=\"off\">A few examples are:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">你只想在特定的路由上使用 Angular，除非使用者存取此路由，否則你不需要它。</p><p translation-origin=\"off\">You use Angular on specific routes only and you don't need it until/if a user visits such a route.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你可以將 Angular 用於僅對特定型別的使用者可見的特性，比如：登入使用者、管理員或 VIP 成員。這樣在使用者通過了身份驗證之前，你都無需載入 Angular。</p><p translation-origin=\"off\">You use Angular for features that are only visible to specific types of users; for example, logged-in users, administrators, or VIP members.\nYou don't need to load Angular until a user is authenticated.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你可以把 Angular 用於應用中那些在初始渲染時不太重要的特性，並且願意為了更好地初始載入效能，而忍受載入該特性時的一點延遲。</p><p translation-origin=\"off\">You use Angular for a feature that is not critical for the initial rendering of the application and you can afford a small delay in favor of better initial load performance.</p>\n\n</li>\n</ul>\n<h3 id=\"bootstrapping-with-downgrademodule\" translation-result=\"on\">透過 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 啟動<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#透過-downgrademodule-啟動\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Bootstrapping with <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#bootstrapping-with-downgrademodule\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可能已經猜到了，你不需要修改引導現有 AngularJS 應用的方式。<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 需要一些額外的步驟，但 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 能自行引導 Angular 模組，你只要為它提供配方即可。</p><p translation-origin=\"off\">As you might have guessed, you don't need to change anything in the way you bootstrap your existing AngularJS application.\nUnlike <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>—which requires some extra steps— <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> is able to take care of bootstrapping the Angular module, as long as you provide the recipe.</p>\n\n<p translation-result=\"on\">要開始使用任何 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> API，你仍然要像在普通 Angular 應用中一樣載入 Angular 框架。要想用 SystemJS 做到這一點，你可以遵循<a href=\"guide/upgrade-setup\" title=\"Setup for Upgrading from AngularJS\">升級的準備工作</a>中的指導，有選擇的從<a href=\"https://github.com/angular/quickstart\">快速上手專案的 GitHub 儲存庫</a>中複製程式碼。</p><p translation-origin=\"off\">In order to start using any <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> APIs, you still need to load the Angular framework as you would in a normal Angular application.\nYou can see how this can be done with SystemJS by following the instructions in the <a href=\"guide/upgrade-setup\" title=\"Setup for Upgrading from AngularJS\">Upgrade Setup</a> guide, selectively copying code from the <a href=\"https://github.com/angular/quickstart\">QuickStart GitHub repository</a>.</p>\n\n<p translation-result=\"on\">你還需要用 <code>npm install @angular/upgrade --save</code> 安裝 <code>@angular/upgrade</code> 套件，並新增一個指向 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 套件的對映：</p><p translation-origin=\"off\">You also need to install the <code>@angular/upgrade</code> package using <code>npm install @angular/upgrade --save</code> and add a mapping for the <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> package:</p>\n\n<code-example header=\"systemjs.config.js (map)\" path=\"upgrade-module/src/systemjs.config.1.js\" region=\"upgrade-static-package\">\n'@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/fesm2022/static.mjs',\n\n</code-example>\n<p translation-result=\"on\">接下來，建立一個 <code>app.module.ts</code> 檔案，並新增如下 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 類：</p><p translation-origin=\"off\">Next, create an <code>app.module.ts</code> file and add the following <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> class:</p>\n\n<code-example header=\"app.module.ts\">\n\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>\n  ]\n})\nexport class MainAngularModule {\n  // Empty placeholder method to satisfy the `<a href=\"api/core/Compiler\" class=\"code-anchor\">Compiler</a>`.\n  ngDoBootstrap() {}\n}\n\n</code-example>\n<p translation-result=\"on\">這個最小的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 匯入了 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>，Angular 每個基於瀏覽器的應用都會匯入該模組。它還定義了一個空的 <code>ngDoBootstrap()</code> 方法，來防止 <a href=\"api/core/Compiler\">Compiler</a> 返回錯誤。在這裡它是必要的，因為 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 裝飾器上還沒有宣告 <code>bootstrap</code>。</p><p translation-origin=\"off\">This bare minimum <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> imports <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>, the module every Angular browser-based app must have.\nIt also defines an empty <code>ngDoBootstrap()</code> method, to prevent the <a href=\"api/core/Compiler\">Compiler</a> from returning errors.\nThis is necessary because the module will not have a <code>bootstrap</code> declaration on its <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">你不用把 <code>bootstrap</code> 宣告加到 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 裝飾器上，因為 AngularJS 擁有應用的根元件，並且 <code>ngUpgrade</code> 會負責啟動必要的元件。</p><p translation-origin=\"off\">You do not add a <code>bootstrap</code> declaration to the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator since AngularJS owns the root template of the application and <code>ngUpgrade</code> bootstraps the necessary components.</p>\n\n</div>\n<p translation-result=\"on\">現在你可以用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 把 AngularJS 和 Angular 的模組聯結在一起。</p><p translation-origin=\"off\">You can now link the AngularJS and Angular modules together using <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>.</p>\n\n<code-example header=\"app.module.ts\">\n\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\nimport { <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nconst bootstrapFn = (extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) =&gt; {\n  const platformRef = <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>(extraProviders);\n  return platformRef.bootstrapModule(MainAngularModule);\n};\nconst downgradedModule = <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>(bootstrapFn);\n\nangular.module('mainAngularJsModule', [\n  downgradedModule\n]);\n\n</code-example>\n<p translation-result=\"on\">現有的 AngularJS 程式碼仍然在和以前一樣正常工作，但你已經可以開始新增新的 Angular 程式碼了。</p><p translation-origin=\"off\">The existing AngularJS code works as before <em>and</em> you are ready to start adding Angular code.</p>\n\n<h3 id=\"using-components-and-injectables\" translation-result=\"on\">使用元件與可注入物件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-components-and-injectables\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Using Components and Injectables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-components-and-injectables\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 和 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 之間的區別就是這些。其餘的 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> API 和概念的工作方式在不同的混合式應用中都完全一樣了。欲知詳情，參閱<a href=\"guide/upgrade\">從 AngularJS 升級</a>。</p><p translation-origin=\"off\">The differences between <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> and <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> end here.\nThe rest of the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> APIs and concepts work in the exact same way for both types of hybrid applications.\nSee <a href=\"guide/upgrade\">Upgrading from AngularJS</a> to learn about:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"guide/upgrade#using-angular-components-from-angularjs-code\">從 AngularJS 程式碼中使用 Angular 元件</a>.</p><p translation-origin=\"off\"><a href=\"guide/upgrade#using-angular-components-from-angularjs-code\">Using Angular Components from AngularJS Code</a>.</p>\n\n<div class=\"callout is-important\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n如果你要降級多個模組，就要在呼叫 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 時為每個元件所屬的降級後模組指定一個模組名。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nIf you are downgrading multiple modules, you need to specify the name of the downgraded module each component belongs to, when calling <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code>.</p>\n\n</div>\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/upgrade#using-angularjs-component-directives-from-angular-code\">如何從 Angular 程式碼中使用 AngularJS 元件和指令</a>。</p><p translation-origin=\"off\"><a href=\"guide/upgrade#using-angularjs-component-directives-from-angular-code\">Using AngularJS Component Directives from Angular Code</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/upgrade#projecting-angularjs-content-into-angular-components\">把 AngularJS 的內容投影進 Angular 元件中</a>。</p><p translation-origin=\"off\"><a href=\"guide/upgrade#projecting-angularjs-content-into-angular-components\">Projecting AngularJS Content into Angular Components</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\">把 Angular 的內容透傳進 AngularJS 元件和指令中</a>。</p><p translation-origin=\"off\"><a href=\"guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\">Transcluding Angular Content into AngularJS Component Directives</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">讓 AngularJS 的依賴可注入到 Angular 中</a>。</p><p translation-origin=\"off\"><a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">Making AngularJS Dependencies Injectable to Angular</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/upgrade#making-angular-dependencies-injectable-to-angularjs\">讓 Angular 的依賴可注入到 AngularJS 中</a>.</p><p translation-origin=\"off\"><a href=\"guide/upgrade#making-angular-dependencies-injectable-to-angularjs\">Making Angular Dependencies Injectable to AngularJS</a>.</p>\n\n<div class=\"callout is-important\">\n<p translation-result=\"on\"><strong>注意</strong>：<br>\n如果你正在降級多個模組，就要在呼叫 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> 時為每個包含可注入物件的模組指定降級後的模組名。</p><p translation-origin=\"off\"><strong>NOTE</strong>: <br>\nIf you are downgrading multiple modules, you need to specify the name of the downgraded module each injectable belongs to, when calling <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code>.</p>\n\n</div>\n</li>\n</ul>\n<div class=\"alert is-important\">\n<p translation-result=\"on\">雖然可以降級可注入物件，但在例項化 Angular 模組之前，無法使用降級後的可注入物件。安全起見，你需要確保降級後的可注入物件不會用於應用中<em>不受</em> Angular 控制的任何地方。</p><p translation-origin=\"off\">While it is possible to downgrade injectables, downgraded injectables will not be available until the Angular module that provides them is instantiated.\nIn order to be safe, you need to ensure that the downgraded injectables are not used anywhere <em>outside</em> the part of the application where it is guaranteed that their module has been instantiated.</p>\n\n<p translation-result=\"on\">比如，在只使用 Angular 元件的已升級元件中<em>可以</em>使用降級後的服務，但是，<em>不能</em>在那些不依賴 Angular 的 AngularJS 元件中使用它，也不能從其它模組中使用降級過的 Angular 元件。</p><p translation-origin=\"off\">For example, it is <em>OK</em> to use a downgraded service in an upgraded component that is only used from a downgraded Angular component provided by the same Angular module as the injectable, but it is <em>not OK</em> to use it in an AngularJS component that may be used independently of Angular or use it in a downgraded Angular component from a different module.</p>\n\n</div>\n<h2 id=\"using-ahead-of-time-compilation-with-hybrid-apps\" translation-result=\"on\">使用混合式應用進行預先編譯<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-ahead-of-time-compilation-with-hybrid-apps\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Using ahead-of-time compilation with hybrid apps<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-ahead-of-time-compilation-with-hybrid-apps\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以像在任何其它 Angular 應用中一樣，利用混合式應用的預先（AOT）編譯功能。混合式應用的設定與<a href=\"guide/aot-compiler\">預先（AOT）編譯</a>一章所講的大致相同，但 <code>index.html</code> 和 <code>main-aot.ts</code> 略有差異。</p><p translation-origin=\"off\">You can take advantage of ahead-of-time (AOT) compilation in hybrid applications just like in any other Angular application.\nThe setup for a hybrid application is mostly the same as described in the <a href=\"guide/aot-compiler\">Ahead-of-Time Compilation</a> guide save for differences in <code>index.html</code> and <code>main-aot.ts</code>.</p>\n\n<p translation-result=\"on\">AOT 需要在 AngularJS 的 <code>index.html</code> 中的 <code>&lt;script&gt;</code> 標籤中載入所有 AngularJS 檔案。</p><p translation-origin=\"off\">AOT needs to load any AngularJS files that are in the <code>&lt;script&gt;</code> tags in the AngularJS <code>index.html</code>.\nAn easy way to copy them is to add each to the <code>copy-dist-files.js</code> file.</p>\n\n<p translation-result=\"on\">你還要將所產生的 <code>MainAngularModuleFactory</code> 傳給 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 函式，而不是自訂引導函式。</p><p translation-origin=\"off\">You also need to pass the generated <code>MainAngularModuleFactory</code> to <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> instead of the custom bootstrap function:</p>\n\n<code-example header=\"app/main-aot.ts\">\n\nimport { <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\nimport { MainAngularModuleNgFactory } from '../aot/app/app.module.ngfactory';\n\nconst downgradedModule = <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>(MainAngularModuleNgFactory);\n\nangular.module('mainAngularJsModule', [\n  downgradedModule\n]);\n\n</code-example>\n<p translation-result=\"on\">這就是當你想讓混合式應用受益於 AOT 時所要做的一切。</p><p translation-origin=\"off\">And that is all you need to do to get the full benefit of AOT for hybrid Angular applications.</p>\n\n<h2 id=\"conclusion\" translation-result=\"on\">總結<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#conclusion\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Conclusion<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#conclusion\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">該頁面介紹瞭如何藉助 <a href=\"api/upgrade/static\">upgrade/static</a> 套件，來按照你自己的節奏逐步升級現有的 AngularJS 應用。並且升級過程中不會方案此應用的進一步開發。</p><p translation-origin=\"off\">This page covered how to use the <a href=\"api/upgrade/static\">upgrade/static</a> package to incrementally upgrade existing AngularJS applications at your own pace and without impeding further development of the app for the duration of the upgrade process.</p>\n\n<p translation-result=\"on\">具體來說，本章介紹瞭如何使用 <a href=\"api/upgrade/static/downgradeModule\"><code>downgradeModule()</code></a> 來代替 <a href=\"api/upgrade/static/UpgradeModule\"><code>UpgradeModule</code></a>，為混合式應用提供更好的效能和更大的靈活性。</p><p translation-origin=\"off\">Specifically, this guide showed how you can achieve better performance and greater flexibility in your hybrid applications by using <a href=\"api/upgrade/static/downgradeModule\"><code>downgradeModule()</code></a> instead of <a href=\"api/upgrade/static/UpgradeModule\"><code>UpgradeModule</code></a>.</p>\n\n<p translation-result=\"on\">總結，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 中的關鍵差異性因素是：</p><p translation-origin=\"off\">To summarize, the key differentiating factors of <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> are:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">它允許例項化甚至延遲載入 Angular 部分，這能改善初始載入時間。某些情況下，這可能會完全免除啟動第二個框架的成本。</p><p translation-origin=\"off\">It allows instantiating or even loading the Angular part lazily, which improves the initial loading time.\nIn some cases this may waive the cost of running a second framework altogether.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">透過避免執行不必要的變更檢測，它提高了效能，給開發人員提供了更大的自訂能力。</p><p translation-origin=\"off\">It improves performance by avoiding unnecessary change detection runs while giving the developer greater ability to customize.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它不需要你更改引導 AngularJS 應用的方式。</p><p translation-origin=\"off\">It does not require you to change how you bootstrap your AngularJS application.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">當你希望混合式應用的 AngularJS 部分和 Angular 部分保持松耦合時，使用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 是個很好的選擇。你仍然可以混用並匹配兩個框架中的元件和服務。作為回報，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 為你提供了更大的控制權和更好的效能。</p><p translation-origin=\"off\">Using <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> is a good option for hybrid applications when you want to keep the AngularJS and Angular parts less coupled.\nYou can still mix and match components and services from both frameworks, but you might need to manually propagate change detection.\nIn return, <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> offers more control and better performance.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/upgrade/static/downgradeModule\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/core/Compiler\n - api/core/Injector\n - api/core/Input\n - api/core/NgModule\n - api/core/NgModuleFactory\n - api/core/NgModuleRef\n - api/core/NgZone#run\n - api/core/PlatformRef#bootstrapModuleFactory\n - api/core/StaticProvider\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/BrowserModule\n - api/platform-browser/platformBrowser\n - api/upgrade/static\n - api/upgrade/static/UpgradeModule\n - api/upgrade/static/downgradeComponent\n - api/upgrade/static/downgradeInjectable\n - api/upgrade/static/downgradeModule\n - guide/aot-compiler\n - guide/upgrade\n - guide/upgrade#change-detection\n - guide/upgrade#how-ngupgrade-works\n - guide/upgrade#making-angular-dependencies-injectable-to-angularjs\n - guide/upgrade#making-angularjs-dependencies-injectable-to-angular\n - guide/upgrade#preparation\n - guide/upgrade#projecting-angularjs-content-into-angular-components\n - guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\n - guide/upgrade#using-angular-components-from-angularjs-code\n - guide/upgrade#using-angularjs-component-directives-from-angular-code\n - guide/upgrade-performance#bootstrapping-with-downgrademodule\n - guide/upgrade-performance#change-detection-with-downgrademodule\n - guide/upgrade-performance#conclusion\n - guide/upgrade-performance#how-ngupgrade-works\n - guide/upgrade-performance#instantiating-the-angular-module-on-demand\n - guide/upgrade-performance#ngupgrade-的工作原理\n - guide/upgrade-performance#preparation\n - guide/upgrade-performance#specifying-a-factory-for-the-angular-module\n - guide/upgrade-performance#upgrading-for-performance\n - guide/upgrade-performance#upgrading-with-ngupgrade\n - guide/upgrade-performance#using-ahead-of-time-compilation-with-hybrid-apps\n - guide/upgrade-performance#using-components-and-injectables\n - guide/upgrade-performance#using-downgrademodule\n - guide/upgrade-performance#為-angular-模組指定一個工廠\n - guide/upgrade-performance#使用-downgrademodule\n - guide/upgrade-performance#使用-downgrademodule-進行變更檢測\n - guide/upgrade-performance#使用-ngupgrade-升級\n - guide/upgrade-performance#使用混合式應用進行預先編譯\n - guide/upgrade-performance#使用元件與可注入物件\n - guide/upgrade-performance#準備工作\n - guide/upgrade-performance#總結\n - guide/upgrade-performance#按需例項化-angular-模組\n - guide/upgrade-performance#更關注效能的升級方式\n - guide/upgrade-performance#透過-downgrademodule-啟動\n - guide/upgrade-setup\n - https://docs.angularjs.org/api/ng/function/angular.module\n - https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply\n - https://github.com/angular/quickstart\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/upgrade-performance.md?message=docs%3A%20請簡述你的修改...\n-->"}