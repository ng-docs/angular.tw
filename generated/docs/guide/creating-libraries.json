{"id":"guide/creating-libraries","title":"Creating libraries","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/creating-libraries.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"creating-libraries\" translation-result=\"on\">建立函式庫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#creating-libraries\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Creating libraries<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#creating-libraries\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">對於如何建立和釋出新函式庫，以擴充 Angular 的功能，本頁面提供了一個概念性的總覽</p><p translation-origin=\"off\">This page provides a conceptual overview of how to create and publish new libraries to extend Angular functionality.</p>\n\n<p translation-result=\"on\">如果你發現自己要在多個應用中解決同樣的問題（或者要把你的解決方案分享給其它開發者），你就有了一個潛在的函式庫。簡單的例子就是一個用來把使用者帶到你公司網站上的按鈕，該按鈕會包含在你公司建構的所有應用中。</p><p translation-origin=\"off\">If you find that you need to solve the same problem in more than one application (or want to share your solution with other developers), you have a candidate for a library.\nA simple example might be a button that sends users to your company website, that would be included in all applications that your company builds.</p>\n\n<h2 id=\"getting-started\" translation-result=\"on\">快速上手<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#getting-started\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Getting started<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#getting-started\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用 Angular CLI，用以下命令在新的工作區中產生一個新函式庫的骨架：</p><p translation-origin=\"off\">Use the Angular CLI to generate a new library skeleton in a new workspace with the following commands.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng new my-workspace --no-create-application\ncd my-workspace\nng generate library my-lib\n\n</code-example>\n<div class=\"callout is-important\">\n<header ng-should-translate=\"\" translation-result=\"on\">命名你的函式庫</header><header ng-should-translate=\"\" translation-origin=\"off\">Naming your library</header>\n\n<p translation-result=\"on\">如果你想稍後在公共包登錄檔（比如 npm）中釋出它，則在選擇函式庫名稱時應該非常小心。參閱<a href=\"guide/creating-libraries#publishing-your-library\">釋出你的函式庫</a>。</p><p translation-origin=\"off\">You should be very careful when choosing the name of your library if you want to publish it later in a public package registry such as npm.\nSee <a href=\"guide/creating-libraries#publishing-your-library\">Publishing your library</a>.</p>\n\n<p translation-result=\"on\">避免使用以 <code>ng-</code> 為字首的名稱，比如 <code>ng-library</code>。<code>ng-</code> 字首是 Angular 框架及其函式庫中使用的保留字。首選 <code>ngx-</code> 字首作為用於表示該函式庫適合與 Angular 一起使用的約定。這也是登錄檔的使用者區分不同 JavaScript 框架函式庫的優秀指示器。</p><p translation-origin=\"off\">Avoid using a name that is prefixed with <code>ng-</code>, such as <code>ng-library</code>.\nThe <code>ng-</code> prefix is a reserved keyword used from the Angular framework and its libraries.\nThe <code>ngx-</code> prefix is preferred as a convention used to denote that the library is suitable for use with Angular.\nIt is also an excellent indication to consumers of the registry to differentiate between libraries of different JavaScript frameworks.</p>\n\n</div>\n<p translation-result=\"on\"><code>ng generate</code> 命令會在你的工作區中建立 <code>projects/my-lib</code> 資料夾，其中包含帶有一個元件和一個服務的 NgModule。</p><p translation-origin=\"off\">The <code>ng generate</code> command creates the <code>projects/my-lib</code> folder in your workspace, which contains a component and a service inside an NgModule.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">要了解關於函式庫專案的目錄結構的詳細資訊，參閱<a href=\"guide/file-structure\">專案檔案結構</a>中的<a href=\"guide/file-structure#library-project-files\">函式庫專案檔案</a>部分。</p><p translation-origin=\"off\">For more details on how a library project is structured, refer to the <a href=\"guide/file-structure#library-project-files\">Library project files</a> section of the <a href=\"guide/file-structure\">Project File Structure guide</a>.</p>\n\n<p translation-result=\"on\">可以使用單一儲存庫（monorepo）模式將同一個工作區用於多個專案。參閱<a href=\"guide/file-structure#multiple-projects\">建立多專案型工作區</a>。</p><p translation-origin=\"off\">Use the monorepo model to use the same workspace for multiple projects.\nSee <a href=\"guide/file-structure#multiple-projects\">Setting up for a multi-project workspace</a>.</p>\n\n</div>\n<p translation-result=\"on\">當你產生一個新函式庫時，該工作區的配置檔案 <code>angular.json</code> 中也增加了一個 'library' 型別的專案。</p><p translation-origin=\"off\">When you generate a new library, the workspace configuration file, <code>angular.json</code>, is updated with a project of type <code>library</code>.</p>\n\n<code-example format=\"json\">\n\n\"projects\": {\n  …\n  \"my-lib\": {\n    \"root\": \"projects/my-lib\",\n    \"sourceRoot\": \"projects/my-lib/src\",\n    \"projectType\": \"library\",\n    \"prefix\": \"lib\",\n    \"architect\": {\n      \"build\": {\n        \"builder\": \"@angular-devkit/build-angular:ng-packagr\",\n        …\n\n</code-example>\n<p translation-result=\"on\">可以使用 CLI 命令來建構、測試和 lint 這個專案：</p><p translation-origin=\"off\">Build, test, and lint the project with CLI commands:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng build my-lib --configuration development\nng test my-lib\nng lint my-lib\n\n</code-example>\n<p translation-result=\"on\">注意，該專案配置的建構器與應用類專案的預設建構器不同。此建構器可以確保函式庫永遠使用 <a href=\"guide/aot-compiler\">AoT 編譯器</a>建構。</p><p translation-origin=\"off\">Notice that the configured builder for the project is different from the default builder for application projects.\nThis builder, among other things, ensures that the library is always built with the <a href=\"guide/aot-compiler\">AOT compiler</a>.</p>\n\n<p translation-result=\"on\">要讓函式庫程式碼可以複用，你必須為它定義一個公共的 API。這個“使用者層”定義了函式庫中消費者的可用內容。該函式庫的使用者應該可以透過單個的匯入路徑來存取公共功能（如 NgModules、服務提供者和工具函式）。</p><p translation-origin=\"off\">To make library code reusable you must define a public API for it.\nThis \"user layer\" defines what is available to consumers of your library.\nA user of your library should be able to access public functionality (such as NgModules, service providers and general utility functions) through a single import path.</p>\n\n<p translation-result=\"on\">函式庫的公共 API 是在函式庫資料夾下的 <code>public-api.ts</code> 檔案中維護的。當你的函式庫被匯入應用時，從該檔案匯出的所有內容都會公開。請使用 NgModule 來暴露這些服務和元件。</p><p translation-origin=\"off\">The public API for your library is maintained in the <code>public-api.ts</code> file in your library folder.\nAnything exported from this file is made public when your library is imported into an application.\nUse an NgModule to expose services and components.</p>\n\n<p translation-result=\"on\">你的函式庫裡應該提供一些文件（通常是 README 檔案）來指導別人安裝和維護。</p><p translation-origin=\"off\">Your library should supply documentation (typically a README file) for installation and maintenance.</p>\n\n<h2 id=\"refactoring-parts-of-an-application-into-a-library\" translation-result=\"on\">把應用中的部分內容重構成一個函式庫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#refactoring-parts-of-an-application-into-a-library\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Refactoring parts of an application into a library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#refactoring-parts-of-an-application-into-a-library\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">為了讓你的解決方案可供複用，你需要對它進行調整，以免它依賴應用特有的程式碼。在將應用的功能遷移到函式庫中時，需要注意以下幾點。</p><p translation-origin=\"off\">To make your solution reusable, you need to adjust it so that it does not depend on application-specific code.\nHere are some things to consider in migrating application functionality to a library.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">元件和管道之類別的可宣告物件應該設計成無狀態的，這意味著它們不依賴或修改外部變數。如果確實依賴於狀態，就需要對每種情況進行評估，以決定它是應用的狀態還是函式庫要管理的狀態。</p><p translation-origin=\"off\">Declarations such as components and pipes should be designed as stateless, meaning they don't rely on or alter external variables.\nIf you do rely on state, you need to evaluate every case and decide whether it is application state or state that the library would manage.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">元件內部訂閱的所有可觀察物件都應該在這些元件的生命週期內進行清理和釋放</p><p translation-origin=\"off\">Any observables that the components subscribe to internally should be cleaned up and disposed of during the lifecycle of those components</p>\n\n</li>\n<li>\n<p translation-result=\"on\">元件對外暴露互動方式時，應該透過輸入引數來提供上下文，透過輸出引數來將事件傳給其它元件</p><p translation-origin=\"off\">Components should expose their interactions through inputs for providing context, and outputs for communicating events to other components</p>\n\n</li>\n<li>\n<p translation-result=\"on\">檢查所有內部依賴。</p><p translation-origin=\"off\">Check all internal dependencies.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">對於在元件或服務中使用的自訂類或介面，檢查它們是否依賴於其它類或介面，它們也需要一起遷移</p><p translation-origin=\"off\">For custom classes or interfaces used in components or service, check whether they depend on additional classes or interfaces that also need to be migrated</p>\n\n</li>\n<li>\n<p translation-result=\"on\">同樣，如果你的函式庫程式碼依賴於某個服務，則需要遷移該服務</p><p translation-origin=\"off\">Similarly, if your library code depends on a service, that service needs to be migrated</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果你的函式庫程式碼或其範本依賴於其它函式庫（比如 Angular Material），你就必須把它們配置為該函式庫的依賴</p><p translation-origin=\"off\">If your library code or its templates depend on other libraries (such as Angular Material, for instance), you must configure your library with those dependencies</p>\n\n</li>\n</ul>\n</li>\n<li>\n<p translation-result=\"on\">考慮如何為客戶端應用提供服務。</p><p translation-origin=\"off\">Consider how you provide services to client applications.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">服務應該自己宣告提供者（而不是在 NgModule 或元件中宣告提供者），以便它們是<em>可搖樹最佳化的</em>。這樣，如果伺服器從未被注入到匯入該函式庫的應用中，編譯器就會把該服務從該 bundle 中刪除。關於這方面的更多資訊，參閱<a href=\"guide/architecture-services#providing-services\">Tree-shakable 提供者</a>。</p><p translation-origin=\"off\">Services should declare their own providers, rather than declaring providers in the NgModule or a component.\nDeclaring a provider makes that service <em>tree-shakable</em>.\nThis practice lets the compiler leave the service out of the bundle if it never gets injected into the application that imports the library.\nFor more about this, see <a href=\"guide/architecture-services#providing-services\">Tree-shakable providers</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果你在多個 NgModules 註冊全域服務提供者或提供者共享，使用<a href=\"guide/singleton-services\"><code>forRoot()</code> 和 <code>forChild()</code> 設計模式</a>由提供<a href=\"api/router/RouterModule\">RouterModule</a></p><p translation-origin=\"off\">If you register global service providers or share providers across multiple NgModules, use the <a href=\"guide/singleton-services\"><code>forRoot()</code> and <code>forChild()</code> design patterns</a> provided by the <a href=\"api/router/RouterModule\">RouterModule</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果你的函式庫中提供的可選服務可能並沒有被所有的客戶端應用所使用，那麼就可以透過<a href=\"guide/lightweight-injection-tokens\">輕量級令牌設計模式</a>為這種情況支援正確的樹狀<a href=\"guide/lightweight-injection-tokens\">結構了</a></p><p translation-origin=\"off\">If your library provides optional services that might not be used by all client applications, support proper tree-shaking for that case by using the <a href=\"guide/lightweight-injection-tokens\">lightweight token design pattern</a></p>\n\n</li>\n</ul>\n</li>\n</ul>\n<p><a id=\"integrating-with-the-cli\"></a></p>\n<h2 id=\"integrating-with-the-cli-using-code-generation-schematics\" translation-result=\"on\">使用程式碼產生器原理圖與 CLI 整合<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#integrating-with-the-cli-using-code-generation-schematics\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Integrating with the CLI using code-generation schematics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#integrating-with-the-cli-using-code-generation-schematics\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">一個函式庫通常都包含<em>可複用的程式碼</em>，用於定義元件，服務，以及你剛才匯入到專案中的其他 Angular 工件（管道，指令等等）。函式庫被打包成一個 npm 套件，用於釋出和共享。這個套件還可以包含一些<a href=\"guide/glossary#schematic\">原理圖</a>，它提供直接在專案中產生或轉換程式碼的指令，就像 CLI 用 <code>ng generate component</code> 建立一個通用的新 <code>ng generate component</code>。比如，用函式庫打套件的原理圖可以為 Angular CLI 提供產生元件所需的資訊，該元件用於配置和使用該函式庫中定義的特定特性或一組特性。這方面的一個例子是 <a href=\"https://material.angular.cn/guide/schematics#navigation-schematic\">Angular Material 的導航原理圖</a>，它用來配置 CDK 的 <a href=\"https://material.angular.cn/cdk/layout/overview#breakpointobserver\"><code>BreakpointObserver</code></a> 並把它與 Material 的 <a href=\"https://material.angular.cn/components/sidenav/overview\">MatSideNav</a> 和 <a href=\"https://material.angular.cn/components/toolbar/overview\">MatToolbar</a> 元件一起使用。</p><p translation-origin=\"off\">A library typically includes <em>reusable code</em> that defines components, services, and other Angular artifacts (pipes, directives) that you import into a project.\nA library is packaged into an npm package for publishing and sharing.\nThis package can also include <a href=\"guide/glossary#schematic\">schematics</a> that provide instructions for generating or transforming code directly in your project, in the same way that the CLI creates a generic new component with <code>ng generate component</code>.\nA schematic that is packaged with a library can, for example, provide the Angular CLI with the information it needs to generate a component that configures and uses a particular feature, or set of features, defined in that library.\nOne example of this is <a href=\"https://material.angular.io/guide/schematics#navigation-schematic\">Angular Material's navigation schematic</a> which configures the CDK's <a href=\"https://material.angular.io/cdk/layout/overview#breakpointobserver\">BreakpointObserver</a> and uses it with Material's <a href=\"https://material.angular.io/components/sidenav/overview\">MatSideNav</a> and <a href=\"https://material.angular.io/components/toolbar/overview\">MatToolbar</a> components.</p>\n\n<p translation-result=\"on\">建立幷包含以下幾種原理圖。</p><p translation-origin=\"off\">Create and include the following kinds of schematics:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">包含一個安裝原理圖，以便 <code>ng add</code> 可以把你的函式庫新增到專案中。</p><p translation-origin=\"off\">Include an installation schematic so that <code>ng add</code> can add your library to a project</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在函式庫中包含了產生原理圖，以便 <code>ng generate</code> 可以為專案中的已定義工件（元件，服務，測試等）提供支援。</p><p translation-origin=\"off\">Include generation schematics in your library so that <code>ng generate</code> can scaffold your defined artifacts (components, services, tests) in a project</p>\n\n</li>\n<li>\n<p translation-result=\"on\">包含一個更新的原理圖，以便 <code>ng update</code> 可以更新你的函式庫的依賴，並提供一些遷移來破壞新版本中的更改。</p><p translation-origin=\"off\">Include an update schematic so that <code>ng update</code> can update your library's dependencies and provide migrations for breaking changes in new releases</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">你的函式庫中所包含的內容取決於你的任務。比如，你可以定義一個原理圖來建立一個預先填充了固定資料的下拉列表，以展示如何把它新增到一個應用中。如果你想要一個每次包含不同傳入值的下拉列表，那麼你的函式庫可以定義一個原理圖來用指定的配置建立它。然後，開發人員可以使用 <code>ng generate</code> 為自己的應用配置一個例項。</p><p translation-origin=\"off\">What you include in your library depends on your task.\nFor example, you could define a schematic to create a dropdown that is pre-populated with canned data to show how to add it to an application.\nIf you want a dropdown that would contain different passed-in values each time, your library could define a schematic to create it with a given configuration.\nDevelopers could then use <code>ng generate</code> to configure an instance for their own application.</p>\n\n<p translation-result=\"on\">假設你要讀取配置檔案，然後根據該配置產生表單。如果該表單需要函式庫的使用者進行額外的自訂，它可能最適合用作 schematic。但是，如果這些表單總是一樣的，開發人員不需要做太多自訂工作，那麼你就可以建立一個動態的元件來獲取配置並產生表單。通常，自訂越複雜，schematic 方式就越有用。</p><p translation-origin=\"off\">Suppose you want to read a configuration file and then generate a form based on that configuration.\nIf that form needs additional customization by the developer who is using your library, it might work best as a schematic.\nHowever, if the form will always be the same and not need much customization by developers, then you could create a dynamic component that takes the configuration and generates the form.\nIn general, the more complex the customization, the more useful the schematic approach.</p>\n\n<p translation-result=\"on\">欲知詳情，參閱 <a href=\"guide/schematics\">原理圖概覽</a> 和 <a href=\"guide/schematics-for-libraries\">供函式庫使用的原理圖</a>。</p><p translation-origin=\"off\">For more information, see <a href=\"guide/schematics\">Schematics Overview</a> and <a href=\"guide/schematics-for-libraries\">Schematics for Libraries</a>.</p>\n\n<h2 id=\"publishing-your-library\" translation-result=\"on\">釋出你的函式庫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#publishing-your-library\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Publishing your library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#publishing-your-library\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用 Angular CLI 和 npm 套件管理器來建構你的函式庫併發布為 npm 套件。</p><p translation-origin=\"off\">Use the Angular CLI and the npm package manager to build and publish your library as an npm package.</p>\n\n<p translation-result=\"on\">Angular CLI 使用一個名為 <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/README.md\">ng-packagr</a> 的工具從已編譯的程式碼中建立可以釋出到 npm 的軟體套件。<code>ng-packagr</code> 支援的發行格式的資訊以及有關如何為函式庫選擇正確格式的指南，參閱<a href=\"guide/creating-libraries#ivy-libraries\">使用 Ivy 建構庫</a>。</p><p translation-origin=\"off\">Angular CLI uses a tool called <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/README.md\">ng-packagr</a> to create packages from your compiled code that can be published to npm.\nSee <a href=\"guide/creating-libraries#ivy-libraries\">Building libraries with Ivy</a> for information on the distribution formats supported by <code>ng-packagr</code> and guidance on how\nto choose the right format for your library.</p>\n\n<p translation-result=\"on\">你應該總是使用 <code>production</code> 配置來建構用於分發的函式庫。這樣可以確保所產生的輸出對 npm 使用了適當的最佳化和正確的軟體套件格式。</p><p translation-origin=\"off\">You should always build libraries for distribution using the <code>production</code> configuration.\nThis ensures that generated output uses the appropriate optimizations and the correct package format for npm.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng build my-lib\ncd dist/my-lib\nnpm publish\n\n</code-example>\n<p><a id=\"lib-assets\"></a></p>\n<h2 id=\"managing-assets-in-a-library\" translation-result=\"on\">管理函式庫中的資產（assets）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#managing-assets-in-a-library\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Managing assets in a library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#managing-assets-in-a-library\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">對於 Angular 函式庫，可分發檔案中可包含一些額外的資產，如主題檔案、Sass mixins 或文件（如變更日誌）。欲知詳情，請參見<a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md\">在建構時將資產複製到函式庫中</a>和<a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md\">將資產嵌入到元件樣式中</a>。</p><p translation-origin=\"off\">In your Angular library, the distributable can include additional assets like theming files, Sass mixins, or documentation (like a changelog).\nFor more information <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md\">copy assets into your library as part of the build</a> and <a href=\"https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md\">embed assets in component styles</a>.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">當包含額外的資產（如 Sass mixins 或預編譯的 CSS）時，你需要將這些手動新增到主入口點的 <code>package.json</code> 中的條件化 <a href=\"guide/angular-package-format/#exports\">“exports”</a> 部分。</p><p translation-origin=\"off\">When including additional assets like Sass mixins or pre-compiled CSS.\nYou need to add these manually to the conditional <a href=\"guide/angular-package-format/#exports\">\"exports\"</a> in the <code>package.json</code> of the primary entrypoint.</p>\n\n<p translation-result=\"on\"><code>ng-packagr</code> 會將手寫的 <code>\"exports\"</code> 與自動產生的 <code>\"exports\"</code> 合併，以便讓函式庫作者配置額外的匯出子路徑或自訂條件。</p><p translation-origin=\"off\"><code>ng-packagr</code> will merge handwritten <code>\"exports\"</code> with the auto-generated ones, allowing for library authors to configure additional export subpaths, or custom conditions.</p>\n\n<code-example language=\"json\">\n\n\"exports\": {\n  \".\": {\n    \"sass\": \"./_index.scss\",\n  },\n  \"./theming\": {\n    \"sass\": \"./_theming.scss\"\n  },\n  \"./prebuilt-themes/indigo-pink.css\": {\n    \"style\": \"./prebuilt-themes/indigo-pink.css\"\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">以上是 <a href=\"https://unpkg.com/browse/@angular/material/package.json\">@angular/material</a> 可分發檔案的摘錄。</p><p translation-origin=\"off\">The above is an extract from the <a href=\"https://unpkg.com/browse/@angular/material/package.json\">@angular/material</a> distributable.</p>\n\n</div>\n<h2 id=\"peer-dependencies\" translation-result=\"on\">同級依賴<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#peer-dependencies\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Peer dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#peer-dependencies\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">各種 Angular 函式庫應該把自己依賴的所有 <code>@angular/*</code> 都列為同級依賴。這確保了當各個模組請求 Angular 時，都會得到完全相同的模組。如果某個函式庫在 <code>dependencies</code> 列出 <code>@angular/core</code> 而不是用 <code>peerDependencies</code>，它可能會得到一個不同的 Angular 模組，這會破壞你的應用。</p><p translation-origin=\"off\">Angular libraries should list any <code>@angular/*</code> dependencies the library depends on as peer dependencies.\nThis ensures that when modules ask for Angular, they all get the exact same module.\nIf a library lists <code>@angular/core</code> in <code>dependencies</code> instead of <code>peerDependencies</code>, it might get a different Angular module instead, which would cause your application to break.</p>\n\n<h2 id=\"using-your-own-library-in-applications\" translation-result=\"on\">在應用中使用你自己的函式庫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#using-your-own-library-in-applications\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Using your own library in applications<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#using-your-own-library-in-applications\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果要在同一個工作空間中使用某個函式庫，你不必把它釋出到 npm 套件管理器，但你還是得先建構它。</p><p translation-origin=\"off\">You don't have to publish your library to the npm package manager to use it in the same workspace, but you do have to build it first.</p>\n\n<p translation-result=\"on\">要想在應用中使用你自己的函式庫：</p><p translation-origin=\"off\">To use your own library in an application:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">建構該函式庫。在建構之前，無法使用函式庫。</p><p translation-origin=\"off\">Build the library.\nYou cannot use a library before it is built.</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng build my-lib\n\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\">在你的應用中，按名字從函式庫中匯入：</p><p translation-origin=\"off\">In your applications, import from the library by name:</p>\n\n<code-example format=\"typescript\" language=\"typescript\">\n\nimport { myExport } from 'my-lib';\n\n</code-example>\n</li>\n</ul>\n<h3 id=\"building-and-rebuilding-your-library\" translation-result=\"on\">建構和重建你的函式庫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#building-and-rebuilding-your-library\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Building and rebuilding your library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#building-and-rebuilding-your-library\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你沒有把函式庫釋出為 npm 套件，然後把它從 npm 安裝到你的應用中，那麼建構步驟就是必要的。比如，如果你複製了 git 儲存庫並運行了 <code>npm install</code>，編輯器就會把 <code>my-lib</code> 的匯入顯示為缺失狀態（如果你還沒有建構過該函式庫）。</p><p translation-origin=\"off\">The build step is important if you haven't published your library as an npm package and then installed the package back into your application from npm.\nFor instance, if you clone your git repository and run <code>npm install</code>, your editor shows the <code>my-lib</code> imports as missing if you haven't yet built your library.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">當你在 Angular 應用中從某個函式庫匯入一些東西時，Angular 就會尋找函式庫名和磁碟上某個位置之間的對映關係。當你用 npm 套件安裝該函式庫時，它就對映到 <code>node_modules</code> 目錄下。當你自己建構函式庫時，它就會在 <code>tsconfig</code> 路徑中查詢這個對映。</p><p translation-origin=\"off\">When you import something from a library in an Angular application, Angular looks for a mapping between the library name and a location on disk.\nWhen you install a library package, the mapping is in the <code>node_modules</code> folder.\nWhen you build your own library, it has to find the mapping in your <code>tsconfig</code> paths.</p>\n\n<p translation-result=\"on\">用 Angular CLI 產生函式庫時，會自動把它的路徑新增到 <code>tsconfig</code> 檔案中。Angular CLI 使用 <code>tsconfig</code> 路徑告訴建構系統在哪裡尋找這個函式庫。</p><p translation-origin=\"off\">Generating a library with the Angular CLI automatically adds its path to the <code>tsconfig</code> file.\nThe Angular CLI uses the <code>tsconfig</code> paths to tell the build system where to find the library.</p>\n\n<p translation-result=\"on\">欲知詳情，參見<a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\">路徑對映概覽</a>。</p><p translation-origin=\"off\">For more information, see <a href=\"https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\">Path mapping overview</a>.</p>\n\n</div>\n<p translation-result=\"on\">如果你發現函式庫中的更改沒有反映到應用中，那麼你的應用很可能正在使用這個函式庫的舊版本。</p><p translation-origin=\"off\">If you find that changes to your library are not reflected in your application, your application is probably using an old build of the library.</p>\n\n<p translation-result=\"on\">每當你對它進行修改時，都可以重建你的函式庫，但這個額外的步驟需要時間。<em>增量建構</em>功能可以改善函式庫的開發體驗。每當檔案發生變化時，都會執行區域性建構，並修補一些檔案。</p><p translation-origin=\"off\">You can rebuild your library whenever you make changes to it, but this extra step takes time.\n<em>Incremental builds</em> functionality improves the library-development experience.\nEvery time a file is changed a partial build is performed that emits the amended files.</p>\n\n<p translation-result=\"on\">增量建構可以作為開發環境中的後臺處理序執行。要啟用這個特性，可以在建構命令中加入 <code>--watch</code> 標誌：</p><p translation-origin=\"off\">Incremental builds can be run as a background process in your development environment.\nTo take advantage of this feature add the <code>--watch</code> flag to the build command:</p>\n\n<code-example format=\"shell\" language=\"shell\">\n\nng build my-lib --watch\n\n</code-example>\n<div class=\"alert is-important\">\n<p translation-result=\"on\">CLI 的 <code>build</code> 命令為函式庫使用與應用不同的建構器，並呼叫不同的建構工具。</p><p translation-origin=\"off\">The CLI <code>build</code> command uses a different builder and invokes a different build tool for libraries than it does for applications.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">應用的建構體系（<code>@angular-devkit/build-angular</code>）基於 <code>webpack</code>，並被包含在所有新的 Angular CLI 專案中。</p><p translation-origin=\"off\">The build system for applications, <code>@angular-devkit/build-angular</code>, is based on <code>webpack</code>, and is included in all new Angular CLI projects</p>\n\n</li>\n<li>\n<p translation-result=\"on\">函式庫的建構體系基於 <code>ng-packagr</code>。只有在使用 <code>ng generate library my-lib</code> 新增函式庫時，它才會新增到依賴項中。</p><p translation-origin=\"off\">The build system for libraries is based on <code>ng-packagr</code>.\nIt is only added to your dependencies when you add a library using <code>ng generate library my-lib</code>.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">這兩種建構體系支援不同的東西，即使它們支援相同的東西，它們的執行方式也不同。這意味著同一套 TypeScript 原始碼在產生函式庫時產生的 JavaScript 程式碼可能與產生應用時產生的 JavaScript 程式碼也不同。</p><p translation-origin=\"off\">The two build systems support different things, and even where they support the same things, they do those things differently.\nThis means that the TypeScript source can result in different JavaScript code in a built library than it would in a built application.</p>\n\n<p translation-result=\"on\">因此，依賴於函式庫的應用應該只使用指向<em>內建函式庫</em>的 TypeScript 路徑對映。TypeScript 的路徑對映<em>不應該</em>指向函式庫的 <code>.ts</code> 原始檔。</p><p translation-origin=\"off\">For this reason, an application that depends on a library should only use TypeScript path mappings that point to the <em>built library</em>.\nTypeScript path mappings should <em>not</em> point to the library source <code>.ts</code> files.</p>\n\n</div>\n<p><a id=\"ivy-libraries\"></a></p>\n<h2 id=\"publishing-libraries\" translation-result=\"on\">釋出函式庫<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#publishing-libraries\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Publishing libraries<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#publishing-libraries\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">釋出函式庫時可以使用兩種分發格式：</p><p translation-origin=\"off\">There are two distribution formats to use when publishing a library:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">分發格式</nt-wrapper><nt-wrapper translation-origin=\"off\">Distribution formats</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">部分 Ivy（推薦）</nt-wrapper><nt-wrapper translation-origin=\"off\">Partial-Ivy (recommended)</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">包含可移植程式碼，從 v12 開始，使用任何版本的 Angular 建構的 Ivy 應用都可以使用這些可移植程式碼。</nt-wrapper><nt-wrapper translation-origin=\"off\">Contains portable code that can be consumed by Ivy applications built with any version of Angular from v12 onwards.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">完全 Ivy</nt-wrapper><nt-wrapper translation-origin=\"off\">Full-Ivy</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">包含專用的 Angular Ivy 指令，不能保證它們可在 Angular 的不同版本中使用。這種格式要求函式庫和應用使用<em>完全相同</em>的 Angular 版本建構。這種格式對於直接從原始碼建構所有函式庫和應用程式碼的環境很有用。</nt-wrapper><nt-wrapper translation-origin=\"off\">Contains private Angular Ivy instructions, which are not guaranteed to work across different versions of Angular. This format requires that the library and application are built with the <em>exact</em> same version of Angular. This format is useful for environments where all library and application code is built directly from source.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\">對於釋出到 npm 的函式庫，請使用 partial-Ivy 格式，因為它在 Angular 的各個補丁版本之間是穩定的。</p><p translation-origin=\"off\">For publishing to npm use the partial-Ivy format as it is stable between patch versions of Angular.</p>\n\n<p translation-result=\"on\">如果要釋出到 npm，請避免使用完全 Ivy 的方式編譯函式庫，因為產生的 Ivy 指令不屬於 Angular 公共 API 的一部分，因此在補丁版本之間可能會有所不同。</p><p translation-origin=\"off\">Avoid compiling libraries with full-Ivy code if you are publishing to npm because the generated Ivy instructions are not part of Angular's public API, and so might change between patch versions.</p>\n\n<h2 id=\"ensuring-library-version-compatibility\" translation-result=\"on\">確保函式庫版本相容性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#ensuring-library-version-compatibility\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Ensuring library version compatibility<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#ensuring-library-version-compatibility\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">用於建構應用的 Angular 版本應始終與用於建構其任何依賴函式庫的 Angular 版本相同或更大。比如，如果你有一個使用 Angular 13 版的函式庫，則依賴於該函式庫的應用應該使用 Angular 13 版或更高版本。Angular 不支援為該應用使用早期版本。</p><p translation-origin=\"off\">The Angular version used to build an application should always be the same or greater than the Angular versions used to build any of its dependent libraries.\nFor example, if you had a library using Angular version 13, the application that depends on that library should use Angular version 13 or later.\nAngular does not support using an earlier version for the application.</p>\n\n<p translation-result=\"on\">如果打算將函式庫釋出到 npm，請透過在 <code>tsconfig.prod.json</code> 的 <code>\"compilationMode\": \"partial\"</code> 來使用部分 Ivy 程式碼進行編譯。這種部分格式在不同版本的 Angular 之間是穩定的，因此可以安全地釋出到 npm。這種格式的程式碼在應用程式建構期間會使用相同版本的 Angular 編譯器進行處理，以確保應用程式及其所有函式庫使用的是同一個版本的 Angular。</p><p translation-origin=\"off\">If you intend to publish your library to npm, compile with partial-Ivy code by setting <code>\"compilationMode\": \"partial\"</code> in <code>tsconfig.prod.json</code>.\nThis partial format is stable between different versions of Angular, so is safe to publish to npm.\nCode with this format is processed during the application build using the same version of the Angular compiler, ensuring that the application and all of its libraries use a single version of Angular.</p>\n\n<p translation-result=\"on\">如果要釋出到 npm，請避免使用完全 Ivy 程式碼來編譯函式庫，因為產生的 Ivy 指令不屬於 Angular 公共 API 的一部分，因此在補丁版本之間可能會有所不同。</p><p translation-origin=\"off\">Avoid compiling libraries with full-Ivy code if you are publishing to npm because the generated Ivy instructions are not part of Angular's public API, and so might change between patch versions.</p>\n\n<p translation-result=\"on\">如果你以前從未在 npm 中釋出過軟體套件，則必須建立一個使用者帳戶。在<a href=\"https://docs.npmjs.com/getting-started/publishing-npm-packages\">釋出 npm 程式套件</a>中瞭解更多資訊。</p><p translation-origin=\"off\">If you've never published a package in npm before, you must create a user account.\nRead more in <a href=\"https://docs.npmjs.com/getting-started/publishing-npm-packages\">Publishing npm Packages</a>.</p>\n\n<h2 id=\"consuming-partial-ivy-code-outside-the-angular-cli\" translation-result=\"on\">在 Angular CLI 之外使用部分 Ivy 程式碼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Consuming partial-Ivy code outside the Angular CLI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">應用將 npm 中的許多 Angular 函式庫安裝到其 <code>node_modules</code> 目錄中。但是，這些函式庫中的程式碼不能與已編譯的應用直接捆綁在一起，因為它尚未完全編譯。要完成編譯，可以使用 Angular 連結器。</p><p translation-origin=\"off\">An application installs many Angular libraries from npm into its <code>node_modules</code> directory.\nHowever, the code in these libraries cannot be bundled directly along with the built application as it is not fully compiled.\nTo finish compilation, use the Angular linker.</p>\n\n<p translation-result=\"on\">對於不使用 Angular CLI 的應用程式，此連結器可用作 <a href=\"https://babeljs.io\">Babel</a> 外掛。該外掛要從 <code>@angular/compiler-cli/linker/babel</code> 匯入。</p><p translation-origin=\"off\">For applications that don't use the Angular CLI, the linker is available as a <a href=\"https://babeljs.io\">Babel</a> plugin.\nThe plugin is to be imported from <code>@angular/compiler-cli/linker/babel</code>.</p>\n\n<p translation-result=\"on\">Angular 連結器的 Babel 外掛支援建構快取，這意味著連結器只需一次處理函式庫，而與其他 npm 操作無關。</p><p translation-origin=\"off\">The Angular linker Babel plugin supports build caching, meaning that libraries only need to be processed by the linker a single time, regardless of other npm operations.</p>\n\n<p translation-result=\"on\">下面的例子藉助 <a href=\"https://webpack.js.org/loaders/babel-loader/#options\">babel-loader</a> 把此連結器註冊為 <a href=\"https://babeljs.io\">Babel</a> 外掛，從而將此外掛整合到自訂 <a href=\"https://webpack.js.org\">Webpack</a> 建構中。</p><p translation-origin=\"off\">Example of integrating the plugin into a custom <a href=\"https://webpack.js.org\">Webpack</a> build by registering the linker as a <a href=\"https://babeljs.io\">Babel</a> plugin using <a href=\"https://webpack.js.org/loaders/babel-loader/#options\">babel-loader</a>.</p>\n\n<code-example header=\"webpack.config.mjs\" path=\"angular-linker-plugin/webpack.config.mjs\" region=\"webpack-config\">\nimport linkerPlugin from '@angular/compiler-cli/linker/babel';\n\nexport default {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.m?js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            plugins: [linkerPlugin],\n            compact: false,\n            cacheDirectory: true,\n          }\n        }\n      }\n    ]\n  }\n  // ...\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">Angular CLI 自動集成了連結器外掛，因此，如果你這個函式庫的使用方也在使用 CLI，則他們可以從 npm 安裝 Ivy 原生函式庫，而無需任何其他配置。</p><p translation-origin=\"off\">The Angular CLI integrates the linker plugin automatically, so if consumers of your library are using the CLI, they can install Ivy-native libraries from npm without any additional configuration.</p>\n\n</div>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/angular-package-format\n - guide/cli-builder\n - guide/file-structure\n - guide/glossary\n - guide/libraries\n - guide/npm-packages\n-->\n<!-- links from this doc:\n - api/router/RouterModule\n - guide/angular-package-format/#exports\n - guide/aot-compiler\n - guide/architecture-services#providing-services\n - guide/creating-libraries#building-and-rebuilding-your-library\n - guide/creating-libraries#consuming-partial-ivy-code-outside-the-angular-cli\n - guide/creating-libraries#creating-libraries\n - guide/creating-libraries#ensuring-library-version-compatibility\n - guide/creating-libraries#getting-started\n - guide/creating-libraries#integrating-with-the-cli-using-code-generation-schematics\n - guide/creating-libraries#ivy-libraries\n - guide/creating-libraries#managing-assets-in-a-library\n - guide/creating-libraries#peer-dependencies\n - guide/creating-libraries#publishing-libraries\n - guide/creating-libraries#publishing-your-library\n - guide/creating-libraries#refactoring-parts-of-an-application-into-a-library\n - guide/creating-libraries#using-your-own-library-in-applications\n - guide/creating-libraries#使用程式碼產生器原理圖與-cli-整合\n - guide/creating-libraries#建立函式庫\n - guide/creating-libraries#釋出你的函式庫\n - guide/creating-libraries#釋出庫\n - guide/creating-libraries#同級依賴\n - guide/creating-libraries#在-angular-cli-之外使用部分-ivy-程式碼\n - guide/creating-libraries#在應用中使用你自己的函式庫\n - guide/creating-libraries#快速上手\n - guide/creating-libraries#把應用中的部分內容重構成一個函式庫\n - guide/creating-libraries#建構和重建你的函式庫\n - guide/creating-libraries#確保函式庫版本相容性\n - guide/creating-libraries#管理函式庫中的資產assets\n - guide/file-structure\n - guide/file-structure#library-project-files\n - guide/file-structure#multiple-projects\n - guide/glossary#schematic\n - guide/lightweight-injection-tokens\n - guide/schematics\n - guide/schematics-for-libraries\n - guide/singleton-services\n - https://babeljs.io\n - https://docs.npmjs.com/getting-started/publishing-npm-packages\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/creating-libraries.md?message=docs%3A%20請簡述你的修改...\n - https://github.com/ng-packagr/ng-packagr/blob/master/README.md\n - https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md\n - https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md\n - https://material.angular.cn/cdk/layout/overview#breakpointobserver\n - https://material.angular.cn/components/sidenav/overview\n - https://material.angular.cn/components/toolbar/overview\n - https://material.angular.cn/guide/schematics#navigation-schematic\n - https://material.angular.io/cdk/layout/overview#breakpointobserver\n - https://material.angular.io/components/sidenav/overview\n - https://material.angular.io/components/toolbar/overview\n - https://material.angular.io/guide/schematics#navigation-schematic\n - https://unpkg.com/browse/@angular/material/package.json\n - https://webpack.js.org\n - https://webpack.js.org/loaders/babel-loader/#options\n - https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping\n-->"}