{"id":"guide/dependency-injection-navtree","title":"Navigate the component tree with DI","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/dependency-injection-navtree.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"navigate-the-component-tree-with-di\" translation-result=\"on\">使用 DI 瀏覽元件樹<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#navigate-the-component-tree-with-di\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Navigate the component tree with DI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#navigate-the-component-tree-with-di\"><i class=\"material-icons\">link</i></a></h1>\n\n<div class=\"callout is-critical\">\n<header ng-should-translate=\"\" translation-result=\"on\">已標記為歸檔</header><header ng-should-translate=\"\" translation-origin=\"off\">Marked for archiving</header>\n\n<p translation-result=\"on\">為確保你擁有最佳的體驗，本主題已標記為歸檔，直到我們確定其清楚地傳達了最準確的資訊為止。</p><p translation-origin=\"off\">To ensure that you have the best experience possible, this topic is marked for archiving until we determine that it clearly conveys the most accurate information possible.</p>\n\n<p translation-result=\"on\">同時，下列主題可能會有所幫助：<a href=\"guide/hierarchical-dependency-injection\">多級注入器</a>。</p><p translation-origin=\"off\">In the meantime, this topic might be helpful: <a href=\"guide/hierarchical-dependency-injection\">Hierarchical injectors</a>.</p>\n\n<p translation-result=\"on\">如果你認為不應將此內容歸檔，請提交 <a href=\"https://github.com/angular/angular/issues/new?template=3-docs-bug.md\">GitHub 問題</a>。</p><p translation-origin=\"off\">If you think this content should not be archived, please file a <a href=\"https://github.com/angular/angular/issues/new?template=3-docs-bug.md\">GitHub issue</a>.</p>\n\n</div>\n<p translation-result=\"on\">應用的元件之間經常需要共享資訊。你通常要用松耦合的技術來共享資訊，比如資料繫結和服務共享。但是有時候讓一個元件直接參考另一個元件還是很有意義的。比如，你需要透過另一個元件的直接參考來存取其屬性或呼叫其方法。</p><p translation-origin=\"off\">Application components often need to share information.\nYou can often use loosely coupled techniques for sharing information, such as data binding and service sharing, but sometimes it makes sense for one component to have a direct reference to another component.\nYou need a direct reference, for instance, to access values or call methods on that component.</p>\n\n<p translation-result=\"on\">在 Angular 中獲取元件參考略微有些棘手。Angular 元件本身並沒有一棵可以用程式設計方式檢查或瀏覽的樹。其父子關係是透過元件的<a href=\"guide/glossary#view\">檢視物件</a>間接建立的。</p><p translation-origin=\"off\">Obtaining a component reference is a bit tricky in Angular.\nAngular components themselves do not have a tree that you can inspect or navigate programmatically.\nThe parent-child relationship is indirect, established through the components' <a href=\"guide/glossary#view\">view objects</a>.</p>\n\n<p translation-result=\"on\">每個元件都有一個<em>宿主檢視</em>和一些<em>內嵌檢視</em>。元件 A 的內嵌檢視可以是元件 B 的宿主檢視，而元件 B 還可以有它自己的內嵌檢視。這意味著每個元件都有一棵以該元件的宿主檢視為根節點的<a href=\"guide/glossary#view-hierarchy\">檢視樹</a>。</p><p translation-origin=\"off\">Each component has a <em>host view</em>, and can have additional <em>embedded views</em>.\nAn embedded view in component A is the host view of component B, which can in turn have embedded view.\nThis means that there is a <a href=\"guide/glossary#view-hierarchy\">view hierarchy</a> for each component, of which that component's host view is the root.</p>\n\n<p translation-result=\"on\">有一些用於在檢視樹中<em>向下</em>導航的 API。請到 <a href=\"api\">API 參考手冊</a>中檢視 <code><a href=\"api/core/Query\" class=\"code-anchor\">Query</a></code>、<code><a href=\"api/core/QueryList\" class=\"code-anchor\">QueryList</a></code>、<code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>。</p><p translation-origin=\"off\">There is an API for navigating <em>down</em> the view hierarchy.\nCheck out <code><a href=\"api/core/Query\" class=\"code-anchor\">Query</a></code>, <code><a href=\"api/core/QueryList\" class=\"code-anchor\">QueryList</a></code>, <code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code>, and <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> in the <a href=\"api\">API Reference</a>.</p>\n\n<p translation-result=\"on\">不存在用於獲取父參考的公共 API。不過，由於每個元件的例項都會新增到注入器的容器中，因此你可以透過 Angular 的依賴注入來存取父元件。</p><p translation-origin=\"off\">There is no public API for acquiring a parent reference.\nHowever, because every component instance is added to an injector's container, you can use Angular dependency injection to reach a parent component.</p>\n\n<p translation-result=\"on\">本節描述的就是關於這種做法的一些技巧。</p><p translation-origin=\"off\">This section describes some techniques for doing that.</p>\n\n<p><a id=\"find-parent\"></a>\n<a id=\"known-parent\"></a></p>\n<h3 id=\"find-a-parent-component-of-known-type\" translation-result=\"on\">查詢已知型別的父元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-component-of-known-type\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Find a parent component of known type<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-component-of-known-type\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以使用標準的類注入形式來獲取型別已知的父元件。</p><p translation-origin=\"off\">You use standard class injection to acquire a parent component whose type you know.</p>\n\n<p translation-result=\"on\">在下面的例子中，父元件 <code>AlexComponent</code> 具有一些子元件，包括 <code>CathyComponent</code>：</p><p translation-origin=\"off\">In the following example, the parent <code>AlexComponent</code> has several children including a <code>CathyComponent</code>:</p>\n\n<p><a id=\"alex\"></a></p>\n<code-example header=\"parent-finder.component.ts (AlexComponent v.1)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-1\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'alex',\n  template: `\n    &lt;div class=\"a\"&gt;\n      &lt;h3&gt;{{name}}&lt;/h3&gt;\n      &lt;cathy&gt;&lt;/cathy&gt;\n      &lt;craig&gt;&lt;/craig&gt;\n      &lt;carol&gt;&lt;/carol&gt;\n    &lt;/div&gt;`,\n})\nexport class AlexComponent extends Base\n{\n  override name = 'Alex';\n}\n\n</code-example>\n<p translation-result=\"on\">在把 <code>AlexComponent</code> 注入到 <code>CathyComponent</code> 的建構函式中之後，<em>Cathy</em> 可以報告她是否能存取 <em>Alex</em>：</p><p translation-origin=\"off\"><em>Cathy</em> reports whether or not she has access to <em>Alex</em> after injecting an <code>AlexComponent</code> into her constructor:</p>\n\n<code-example header=\"parent-finder.component.ts (CathyComponent)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"cathy\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'cathy',\n  template: `\n  &lt;div class=\"c\"&gt;\n    &lt;h3&gt;Cathy&lt;/h3&gt;\n    {{alex ? 'Found' : 'Did not find'}} Alex via the component class.&lt;br&gt;\n  &lt;/div&gt;`\n})\nexport class CathyComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex?: AlexComponent ) { }\n}\n\n</code-example>\n<p translation-result=\"on\">注意，雖然為了安全起見我們用了 <a href=\"guide/dependency-injection-in-action#optional\"><code>@Optional</code></a> 限定符，但是<live-example name=\"dependency-injection-in-action\"></live-example>中仍然會確認 <code>alex</code> 引數是否有值。</p><p translation-origin=\"off\">Notice that even though the <a href=\"guide/dependency-injection-in-action#optional\"><code>@Optional</code></a> qualifier is there for safety, the <live-example name=\"dependency-injection-in-action\"></live-example> confirms that the <code>alex</code> parameter is set.</p>\n\n<p><a id=\"base-parent\"></a></p>\n<h3 id=\"unable-to-find-a-parent-by-its-base-class\" translation-result=\"on\">不能根據父元件的基底類別存取父元件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#unable-to-find-a-parent-by-its-base-class\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Unable to find a parent by its base class<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#unable-to-find-a-parent-by-its-base-class\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你<em>不知道</em>具體的父元件類怎麼辦？</p><p translation-origin=\"off\">What if you <em>don't</em> know the concrete parent component class?</p>\n\n<p translation-result=\"on\">可複用元件可能是多個元件的子元件。想象一個用於渲染相關金融工具的突發新聞的元件。出於商業原因，當市場上的資料流發生變化時，這些新元件會頻繁呼叫其父元件。</p><p translation-origin=\"off\">A re-usable component might be a child of multiple components.\nImagine a component for rendering breaking news about a financial instrument.\nFor business reasons, this news component makes frequent calls directly into its parent instrument as changing market data streams by.</p>\n\n<p translation-result=\"on\">該應用可能定義了十幾個金融工具元件。理想情況下，它們全都實現了同一個基底類別，你的 <code>NewsComponent</code> 也能理解其 API。</p><p translation-origin=\"off\">The app probably defines more than a dozen financial instrument components.\nIf you're lucky, they all implement the same base class whose API your <code>NewsComponent</code> understands.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果能查詢實現了某個介面的元件當然更好。但那是不可能的。因為 TypeScript 介面在轉譯後的 JavaScript 中不存在，而 JavaScript 不支援介面。因此，找無可找。</p><p translation-origin=\"off\">Looking for components that implement an interface would be better.\nThat's not possible because TypeScript interfaces disappear from the transpiled JavaScript, which doesn't support interfaces.\nThere's no artifact to look for.</p>\n\n</div>\n<p translation-result=\"on\">這個設計並不怎麼好。該例子是為了驗證<em>元件是否能透過其父元件的基底類別來注入父元件</em>。</p><p translation-origin=\"off\">This isn't necessarily good design.\nThis example is examining <em>whether a component can inject its parent via the parent's base class</em>.</p>\n\n<p translation-result=\"on\">這個例子中的 <code>CraigComponent</code> 體現了此問題。<a href=\"guide/dependency-injection-navtree#alex\">往回看</a>，你可以看到 <code>Alex</code> 元件<em>擴充</em>（<em>繼承</em>）了基底類別 <code>Base</code>。</p><p translation-origin=\"off\">The sample's <code>CraigComponent</code> explores this question.\n<a href=\"guide/dependency-injection-navtree#alex\">Looking back</a>, you see that the <code>Alex</code> component <em>extends</em> (<em>inherits</em>) from a class named <code>Base</code>.</p>\n\n<code-example header=\"parent-finder.component.ts (Alex class signature)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\">\nexport class AlexComponent extends Base\n\n</code-example>\n<p translation-result=\"on\"><code>CraigComponent</code> 試圖把 <code>Base</code> 注入到它的建構函式引數 <code>alex</code> 中，並彙報這次注入是否成功了。</p><p translation-origin=\"off\">The <code>CraigComponent</code> tries to inject <code>Base</code> into its <code>alex</code> constructor parameter and reports if it succeeded.</p>\n\n<code-example header=\"parent-finder.component.ts (CraigComponent)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"craig\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'craig',\n  template: `\n  &lt;div class=\"c\"&gt;\n    &lt;h3&gt;Craig&lt;/h3&gt;\n    {{alex ? 'Found' : 'Did not find'}} Alex via the base class.\n  &lt;/div&gt;`\n})\nexport class CraigComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex?: Base ) { }\n}\n\n</code-example>\n<p translation-result=\"on\">不幸的是，這不行！\n<live-example name=\"dependency-injection-in-action\"></live-example> 確認了 <code>alex</code> 引數為空。\n因此，<em>你不能透過父元件的基底類別注入它</em>。</p><p translation-origin=\"off\">Unfortunately, this doesn't work.\nThe <live-example name=\"dependency-injection-in-action\"></live-example> confirms that the <code>alex</code> parameter is null.\n<em>You cannot inject a parent by its base class.</em></p>\n\n<p><a id=\"class-interface-parent\"></a></p>\n<h3 id=\"find-a-parent-by-its-class-interface\" translation-result=\"on\">根據父元件的類介面查詢它<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-by-its-class-interface\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Find a parent by its class interface<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-by-its-class-interface\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可以透過父元件的<a href=\"guide/dependency-injection-in-action#class-interface\">類介面</a>來查詢它。</p><p translation-origin=\"off\">You can find a parent component with a <a href=\"guide/dependency-injection-in-action#class-interface\">class interface</a>.</p>\n\n<p translation-result=\"on\">該父元件必須合作，以類介面令牌為名，為自己定義一個<em>別名提供者</em>。</p><p translation-origin=\"off\">The parent must cooperate by providing an <em>alias</em> to itself in the name of a class interface token.</p>\n\n<p translation-result=\"on\">回憶一下，Angular 總是會把元件例項新增到它自己的注入器中，因此<a href=\"guide/dependency-injection-navtree#known-parent\">以前</a>你才能把 <em>Alex</em> 注入到 <em>Cathy</em> 中。</p><p translation-origin=\"off\">Recall that Angular always adds a component instance to its own injector; that's why you could inject <em>Alex</em> into <em>Cathy</em> <a href=\"guide/dependency-injection-navtree#known-parent\">earlier</a>.</p>\n\n<p translation-result=\"on\">編寫一個 <a href=\"guide/dependency-injection-in-action#useexisting\"><em>別名提供者</em></a>（一個 <code>provide</code> 物件字面量，其中有一個 <code>useExisting</code> 定義），創造了另一種方式來注入同一個元件例項，並把那個提供者新增到 <code>AlexComponent</code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 元資料的 <code>providers</code> 陣列中。</p><p translation-origin=\"off\">Write an <a href=\"guide/dependency-injection-in-action#useexisting\"><em>alias provider</em></a> —a <code>provide</code> object literal with a <code>useExisting</code> definition— that creates an <em>alternative</em> way to inject the same component instance and add that provider to the <code>providers</code> array of the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> metadata for the <code>AlexComponent</code>.</p>\n\n<p><a id=\"alex-providers\"></a></p>\n<code-example header=\"parent-finder.component.ts (AlexComponent providers)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; AlexComponent) }],\n\n</code-example>\n<p translation-result=\"on\"><a href=\"guide/dependency-injection-navtree#parent-token\">Parent</a> 是該提供者的類介面。\n<a href=\"guide/dependency-injection-in-action#forwardref\"><em>forwardRef</em></a> 用於打破迴圈參考，因為在你剛才這個定義中 <code>AlexComponent</code> 參考了自身。</p><p translation-origin=\"off\"><a href=\"guide/dependency-injection-navtree#parent-token\">Parent</a> is the provider's class interface token.\nThe <a href=\"guide/dependency-injection-in-action#forwardref\"><em>forwardRef</em></a> breaks the circular reference you just created by having the <code>AlexComponent</code> refer to itself.</p>\n\n<p translation-result=\"on\"><em>Alex</em> 的第三個子元件 <em>Carol</em>，把其父元件注入到了自己的 <code>parent</code> 引數中 —— 和你以前做過的一樣。</p><p translation-origin=\"off\"><em>Carol</em>, the third of <em>Alex</em>'s child components, injects the parent into its <code>parent</code> parameter, the same way you've done it before.</p>\n\n<code-example header=\"parent-finder.component.ts (CarolComponent class)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-class\">\nexport class CarolComponent {\n  name = 'Carol';\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n}\n\n</code-example>\n<p translation-result=\"on\">下面是 <em>Alex</em> 及其家人的執行效果。</p><p translation-origin=\"off\">Here's <em>Alex</em> and family in action.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Alex in action\" src=\"generated/images/guide/dependency-injection-in-action/alex.png\" width=\"302\" height=\"374\">\n</div>\n<p><a id=\"parent-tree\"></a></p>\n<h3 id=\"find-a-parent-in-a-tree-with-skipself\" translation-result=\"on\">使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 在樹中查詢父級<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#使用-skipself-在樹中查詢父級\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Find a parent in a tree with <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#find-a-parent-in-a-tree-with-skipself\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">想象一下元件樹的一個分支：<em>Alice</em> -&gt; <em>Barry</em> -&gt; <em>Carol</em>。無論 <em>Alice</em> 還是 <em>Barry</em> 都實現了類介面 <code>Parent</code>。</p><p translation-origin=\"off\">Imagine one branch of a component hierarchy: <em>Alice</em> -&gt; <em>Barry</em> -&gt; <em>Carol</em>.\nBoth <em>Alice</em> and <em>Barry</em> implement the <code>Parent</code> class interface.</p>\n\n<p translation-result=\"on\"><em>Barry</em> 很為難。他需要存取他的母親 <em>Alice</em>，同時他自己還是 <em>Carol</em> 的父親。這意味著他必須同時<em>注入</em> <code>Parent</code> 類介面來找到 <em>Alice</em>，同時還要<em>提供</em>一個 <code>Parent</code> 來滿足 <em>Carol</em> 的要求。</p><p translation-origin=\"off\"><em>Barry</em> is the problem.\nHe needs to reach his parent, <em>Alice</em>, and also be a parent to <em>Carol</em>.\nThat means he must both <em>inject</em> the <code>Parent</code> class interface to get <em>Alice</em> and <em>provide</em> a <code>Parent</code> to satisfy <em>Carol</em>.</p>\n\n<p translation-result=\"on\"><em>Barry</em> 的程式碼如下。</p><p translation-origin=\"off\">Here's <em>Barry</em>.</p>\n\n<code-example header=\"parent-finder.component.ts (BarryComponent)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry\">\nconst templateB = `\n  &lt;div class=\"b\"&gt;\n    &lt;div&gt;\n      &lt;h3&gt;{{name}}&lt;/h3&gt;\n      &lt;p&gt;My parent is {{parent?.name}}&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;carol&gt;&lt;/carol&gt;\n    &lt;chris&gt;&lt;/chris&gt;\n  &lt;/div&gt;`;\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector:   'barry',\n  template:   templateB,\n  providers:  [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; BarryComponent) }]\n})\nexport class BarryComponent implements Parent {\n  name = 'Barry';\n  constructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n}\n\n</code-example>\n<p translation-result=\"on\"><em>Barry</em> 的 <code>providers</code> 陣列看起來和 <a href=\"guide/dependency-injection-navtree#alex-providers\"><em>Alex</em></a> 的一樣。\n如果你準備繼續像這樣編寫<a href=\"guide/dependency-injection-in-action#useexisting\"><em>別名提供者</em></a>，就應該建立一個輔助函式。</p><p translation-origin=\"off\"><em>Barry</em>'s <code>providers</code> array looks just like <a href=\"guide/dependency-injection-navtree#alex-providers\"><em>Alex</em>'s</a>.\nIf you're going to keep writing <a href=\"guide/dependency-injection-in-action#useexisting\"><em>alias providers</em></a> like this you should create a helper function.</p>\n\n<p translation-result=\"on\">現在，注意看 <em>Barry</em> 的建構函式。</p><p translation-origin=\"off\">For now, focus on <em>Barry</em>'s constructor.</p>\n\n<code-tabs>\n    <code-pane header=\"Barry's constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry-ctor\">\nconstructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n\n</code-pane>\n    <code-pane header=\"Carol's constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-ctor\">\nconstructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent?: Parent ) { }\n\n</code-pane>\n</code-tabs>\n<p translation-result=\"on\">除增加了 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 裝飾器之外，它和 <em>Carol</em> 的建構函式相同。</p><p translation-origin=\"off\">It's identical to <em>Carol</em>'s constructor except for the additional <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> decorator.</p>\n\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 有兩個重要原因：</p><p translation-origin=\"off\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> is essential for two reasons:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">它告訴注入器開始從元件樹中<em>高於</em>自己的位置（也就是父元件）開始搜尋 <code>Parent</code> 依賴。</p><p translation-origin=\"off\">It tells the injector to start its search for a <code>Parent</code> dependency in a component <em>above</em> itself, which <em>is</em> what parent means.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果你省略了 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 裝飾器，Angular 就會丟擲迴圈依賴錯誤。</p><p translation-origin=\"off\">Angular throws a cyclic dependency error if you omit the <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> decorator.</p>\n\n<code-example format=\"output\" hidecopy=\"\" language=\"shell\">\n\nNG0200: Circular dependency in DI detected for BethComponent. Dependency path: BethComponent -&gt; Parent -&gt; BethComponent\n\n</code-example>\n</li>\n</ol>\n<p translation-result=\"on\">下面是 <em>Alice</em>、<em>Barry</em> 及其家人的執行效果。</p><p translation-origin=\"off\">Here's <em>Alice</em>, <em>Barry</em>, and family in action.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Alice in action\" src=\"generated/images/guide/dependency-injection-in-action/alice.png\" width=\"298\" height=\"631\">\n</div>\n<p><a id=\"parent-token\"></a></p>\n<h3 id=\"parent-class-interface\" translation-result=\"on\">父類介面<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#parent-class-interface\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Parent class interface<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-navtree#parent-class-interface\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你<a href=\"guide/dependency-injection-in-action#class-interface\">已經學過</a>，類介面是一個抽象類別，它實際上用做介面而不是基底類別。</p><p translation-origin=\"off\">You <a href=\"guide/dependency-injection-in-action#class-interface\">learned earlier</a> that a class interface is an abstract class used as an interface rather than as a base class.</p>\n\n<p translation-result=\"on\">下面的例子定義了一個類別介面 <code>Parent</code>。</p><p translation-origin=\"off\">The example defines a <code>Parent</code> class interface.</p>\n\n<code-example header=\"parent-finder.component.ts (Parent class-interface)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"parent\">\nexport abstract class Parent { abstract name: string; }\n\n</code-example>\n<p translation-result=\"on\"><code>Parent</code> 類介面定義了一個帶型別的 <code>name</code> 屬性，但沒有實現它。這個 <code>name</code> 屬性是父元件中唯一可供子元件呼叫的成員。這樣的窄化介面幫助把子元件從它的父元件中解耦出來。</p><p translation-origin=\"off\">The <code>Parent</code> class interface defines a <code>name</code> property with a type declaration but <em>no implementation</em>.\nThe <code>name</code> property is the only member of a parent component that a child component can call.\nSuch a narrow interface helps decouple the child component class from its parent components.</p>\n\n<p translation-result=\"on\">一個元件想要作為父元件使用，就<em>應該</em>像 <code>AliceComponent</code> 那樣實現這個類介面。</p><p translation-origin=\"off\">A component that could serve as a parent <em>should</em> implement the class interface as the <code>AliceComponent</code> does.</p>\n\n<code-example header=\"parent-finder.component.ts (AliceComponent class signature)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alice-class-signature\">\nexport class AliceComponent implements Parent\n\n</code-example>\n<p translation-result=\"on\">這樣做可以增加程式碼的清晰度，但在技術上並不是必要的。雖然 <code>AlexComponent</code> 像 <code>Base</code> 類所要求的一樣具有 <code>name</code> 屬性，但它的類簽名中並沒有提及 <code>Parent</code>。</p><p translation-origin=\"off\">Doing so adds clarity to the code.\nBut it's not technically necessary.\nAlthough <code>AlexComponent</code> has a <code>name</code> property, as required by its <code>Base</code> class,\nits class signature doesn't mention <code>Parent</code>.</p>\n\n<code-example header=\"parent-finder.component.ts (AlexComponent class signature)\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\">\nexport class AlexComponent extends Base\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><code>AlexComponent</code> <em>應該</em>實現 <code>Parent</code> 才是一種正確的風格。這個例子中之所以沒這樣做，<em>只是</em>為了證明即使沒有宣告介面，程式碼也可以編譯和執行。</p><p translation-origin=\"off\"><code>AlexComponent</code> <em>should</em> implement <code>Parent</code> as a matter of proper style.\nIt doesn't in this example <em>only</em> to demonstrate that the code will compile and run without the interface.</p>\n\n</div>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/TemplateRef\n-->\n<!-- links from this doc:\n - api\n - api/core/Component\n - api/core/ContentChildren\n - api/core/Optional\n - api/core/Query\n - api/core/QueryList\n - api/core/SkipSelf\n - api/core/ViewChildren\n - api/core/forwardRef\n - guide/dependency-injection-in-action#class-interface\n - guide/dependency-injection-in-action#forwardref\n - guide/dependency-injection-in-action#optional\n - guide/dependency-injection-in-action#useexisting\n - guide/dependency-injection-navtree#alex\n - guide/dependency-injection-navtree#alex-providers\n - guide/dependency-injection-navtree#find-a-parent-by-its-class-interface\n - guide/dependency-injection-navtree#find-a-parent-component-of-known-type\n - guide/dependency-injection-navtree#find-a-parent-in-a-tree-with-skipself\n - guide/dependency-injection-navtree#known-parent\n - guide/dependency-injection-navtree#navigate-the-component-tree-with-di\n - guide/dependency-injection-navtree#parent-class-interface\n - guide/dependency-injection-navtree#parent-token\n - guide/dependency-injection-navtree#unable-to-find-a-parent-by-its-base-class\n - guide/dependency-injection-navtree#不能根據父元件的基底類別存取父元件\n - guide/dependency-injection-navtree#使用-di-瀏覽元件樹\n - guide/dependency-injection-navtree#使用-skipself-在樹中查詢父級\n - guide/dependency-injection-navtree#查詢已知型別的父元件\n - guide/dependency-injection-navtree#根據父元件的類介面查詢它\n - guide/dependency-injection-navtree#父類介面\n - guide/glossary#view\n - guide/glossary#view-hierarchy\n - guide/hierarchical-dependency-injection\n - https://github.com/angular/angular/issues/new?template=3-docs-bug.md\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/dependency-injection-navtree.md?message=docs%3A%20請簡述你的修改...\n-->"}