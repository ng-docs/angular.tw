{"id":"guide/lifecycle-hooks","title":"Component Lifecycle","contents":"\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/lifecycle-hooks.md?message=docs%3A%20請簡述你的修改...\" aria-label=\"提供編輯建議\" title=\"提供編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"component-lifecycle\" translation-result=\"on\">元件的生命週期<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#component-lifecycle\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\">Component Lifecycle<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#component-lifecycle\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">當 Angular 例項化元件類並渲染元件檢視及其子檢視時，元件例項的生命週期就開始了。生命週期一直伴隨著變更檢測，Angular 會檢查資料繫結屬性何時發生變化，並按需更新檢視和元件例項。當 Angular 銷燬元件例項並從 DOM 中移除它渲染的範本時，生命週期就結束了。當 Angular 在執行過程中建立、更新和銷燬例項時，指令就有了類似的生命週期。</p><p translation-origin=\"off\">A component instance has a lifecycle that starts when Angular instantiates the component class and renders the component view along with its child views.\nThe lifecycle continues with change detection, as Angular checks to see when data-bound properties change, and updates both the view and the component instance as needed.\nThe lifecycle ends when Angular destroys the component instance and removes its rendered template from the DOM.\nDirectives have a similar lifecycle, as Angular creates, updates, and destroys instances in the course of execution.</p>\n\n<p translation-result=\"on\">你的應用可以使用<a href=\"guide/glossary#lifecycle-hook\" title=\"生命週期鉤子的定義\">生命週期鉤子方法</a>來觸發元件或指令生命週期中的關鍵事件，以初始化新例項，需要時啟動變更檢測，在變更檢測過程中響應更新，並在刪除例項之前進行清理。</p><p translation-origin=\"off\">Your application can use <a href=\"guide/glossary#lifecycle-hook\" title=\"Definition of lifecycle hook\">lifecycle hook methods</a> to tap into key events in the lifecycle of a component or directive to initialize new instances, initiate change detection when needed, respond to updates during change detection, and clean up before deletion of instances.</p>\n\n<h2 id=\"prerequisites\" translation-result=\"on\">前提條件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#prerequisites\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Prerequisites<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#prerequisites\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在使用生命週期鉤子之前，你應該對這些內容有一個基本的瞭解：</p><p translation-origin=\"off\">Before working with lifecycle hooks, you should have a basic understanding of the following:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"https://www.typescriptlang.org\">TypeScript 程式設計</a></p><p translation-origin=\"off\"><a href=\"https://www.typescriptlang.org\">TypeScript programming</a></p>\n\n</li>\n<li>\n<p translation-result=\"on\">Angular 應用設計基礎，就像 <a href=\"guide/architecture\" title=\"基礎應用設計概念簡介\">Angular 的基本概念</a>中所講的那樣</p><p translation-origin=\"off\">Angular app-design fundamentals, as described in <a href=\"guide/architecture\" title=\"Introduction to fundamental app-design concepts\">Angular Concepts</a></p>\n\n</li>\n</ul>\n<p><a id=\"hooks-overview\"></a></p>\n<h2 id=\"responding-to-lifecycle-events\" translation-result=\"on\">響應生命週期事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#responding-to-lifecycle-events\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Responding to lifecycle events<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#responding-to-lifecycle-events\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">可以透過實現一個或多個 Angular <code>core</code> 庫中定義的<em>生命週期鉤子</em>介面來響應元件或指令生命週期中的事件。這些鉤子讓你有機會在適當的時候對元件或指令例項進行操作，比如 Angular 建立、更新或銷燬這個例項時。</p><p translation-origin=\"off\">Respond to events in the lifecycle of a component or directive by implementing one or more of the <em>lifecycle hook</em> interfaces in the Angular <code>core</code> library.\nThe hooks give you the opportunity to act on a component or directive instance at the appropriate moment, as Angular creates, updates, or destroys that instance.</p>\n\n<p translation-result=\"on\">每個介面都有唯一的一個鉤子方法，它們的名字是由介面名再加上 <code>ng</code> 字首構成的。比如，<code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code> 介面的鉤子方法叫做 <code>ngOnInit()</code>。如果你在元件或指令類中實現了這個方法，Angular 就會在首次檢查完元件或指令的輸入屬性後，緊接著呼叫它。</p><p translation-origin=\"off\">Each interface defines the prototype for a single hook method, whose name is the interface name prefixed with <code>ng</code>.\nFor example, the <code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code> interface has a hook method named <code>ngOnInit()</code>.\nIf you implement this method in your component or directive class, Angular calls it shortly after checking the input properties for that component or directive for the first time.</p>\n\n<code-example header=\"peek-a-boo.directive.ts (excerpt)\" path=\"lifecycle-hooks/src/app/peek-a-boo.directive.ts\" region=\"ngOnInit\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[appPeekABoo]'})\nexport class PeekABooDirective implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private logger: LoggerService) { }\n\n  // implement <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>'s `ngOnInit` method\n  ngOnInit() {\n    this.logIt('<a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>');\n  }\n\n  logIt(msg: string) {\n    this.logger.log(`#${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">你不必實現所有生命週期鉤子，只要實現你需要的那些就可以了。</p><p translation-origin=\"off\">You don't have to implement all (or any) of the lifecycle hooks, just the ones you need.</p>\n\n<p><a id=\"hooks-purpose-timing\"></a></p>\n<h3 id=\"lifecycle-event-sequence\" translation-result=\"on\">生命週期的順序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-event-sequence\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Lifecycle event sequence<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-event-sequence\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當你的應用透過呼叫建構函式來例項化一個元件或指令時，Angular 就會呼叫那個在該例項生命週期的適當位置實現了的那些鉤子方法。</p><p translation-origin=\"off\">After your application instantiates a component or directive by calling its constructor, Angular calls the hook methods you have implemented at the appropriate point in the lifecycle of that instance.</p>\n\n<p translation-result=\"on\">Angular 會按以下順序執行鉤子方法。可以用它來執行以下型別的操作。</p><p translation-origin=\"off\">Angular executes hook methods in the following sequence.\nUse them to perform the following kinds of operations.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">鉤子方法</nt-wrapper><nt-wrapper translation-origin=\"off\">Hook method</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">用途</nt-wrapper><nt-wrapper translation-origin=\"off\">Purpose</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">時機</nt-wrapper><nt-wrapper translation-origin=\"off\">Timing</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><code>ngOnChanges()</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">當 Angular 設定或重新設定資料繫結的輸入屬性時響應。該方法接受當前和上一屬性值的 <code><a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a></code> 物件<br><div class=\"alert is-helpful\"><strong>注意</strong>：<br>這發生得比較頻繁，所以你在這裡執行的任何操作都會顯著影響效能。</div>欲知詳情，參閱本文件的<a href=\"guide/lifecycle-hooks#onchanges\">使用變更檢測鉤子</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Respond when Angular sets or resets data-bound input properties. The method receives a <code><a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a></code> object of current and previous property values. <br> <div class=\"alert is-helpful\"> <strong>NOTE</strong>: <br> This happens frequently, so any operation you perform here impacts performance significantly. </div> See details in <a href=\"guide/lifecycle-hooks#onchanges\">Using change detection hooks</a> in this document.</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">如果元件繫結過輸入屬性，那麼在 <code>ngOnInit()</code> 之前以及所繫結的一個或多個輸入屬性的值發生變化時都會呼叫。<br><div class=\"alert is-helpful\"><strong>注意</strong>：<br>如果你的元件沒有輸入屬性，或者你使用它時沒有提供任何輸入屬性，那麼框架就不會呼叫 <code>ngOnChanges()</code>。</div></nt-wrapper><nt-wrapper translation-origin=\"off\">Called before <code>ngOnInit()</code> (if the component has bound inputs) and whenever one or more data-bound input properties change. <br> <div class=\"alert is-helpful\"> <strong>NOTE</strong>: <br> If your component has no inputs or you use it without providing any inputs, the framework will not call <code>ngOnChanges()</code>. </div></nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>ngOnInit()</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在 Angular 第一次顯示資料繫結和設定指令/元件的輸入屬性之後，初始化指令/元件。欲知詳情，參閱本文件中的<a href=\"guide/lifecycle-hooks#oninit\">初始化元件或指令</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Initialize the directive or component after Angular first displays the data-bound properties and sets the directive or component's input properties. See details in <a href=\"guide/lifecycle-hooks#oninit\">Initializing a component or directive</a> in this document.</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在第一輪 <code>ngOnChanges()</code> 完成之後呼叫，只調用<strong>一次</strong>。而且即使沒有呼叫過 <code>ngOnChanges()</code>，也仍然會呼叫 <code>ngOnInit()</code>（比如當範本中沒有繫結任何輸入屬性時）。</nt-wrapper><nt-wrapper translation-origin=\"off\">Called once, after the first <code>ngOnChanges()</code>. <code>ngOnInit()</code> is still called even when <code>ngOnChanges()</code> is not (which is the case when there are no template-bound inputs).</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>ngDoCheck()</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">檢測，並在發生 Angular 無法或不願意自己檢測的變化時作出反應。欲知詳情和範例，參閱本文件中的<a href=\"guide/lifecycle-hooks#docheck\">自訂變更檢測</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Detect and act upon changes that Angular can't or won't detect on its own. See details and example in <a href=\"guide/lifecycle-hooks#docheck\">Defining custom change detection</a> in this document.</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">緊跟在每次執行變更檢測時的 <code>ngOnChanges()</code> 和 首次執行變更檢測時的 <code>ngOnInit()</code> 後呼叫。</nt-wrapper><nt-wrapper translation-origin=\"off\">Called immediately after <code>ngOnChanges()</code> on every change detection run, and immediately after <code>ngOnInit()</code> on the first run.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>ngAfterContentInit()</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">當 Angular 把外部內容投影進元件檢視或指令所在的檢視之後呼叫。<br> 欲知詳情和範例，參閱本文件中的<a href=\"guide/lifecycle-hooks#aftercontent\">響應內容中的變更</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Respond after Angular projects external content into the component's view, or into the view that a directive is in. <br> See details and example in <a href=\"guide/lifecycle-hooks#aftercontent\">Responding to changes in content</a> in this document.</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">第一次 <code>ngDoCheck()</code> 之後呼叫，只調用一次。</nt-wrapper><nt-wrapper translation-origin=\"off\">Called <em>once</em> after the first <code>ngDoCheck()</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>ngAfterContentChecked()</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">每當 Angular 檢查完被投影到元件或指令中的內容之後呼叫。<br>欲知詳情和範例，參閱本文件中的<a href=\"guide/lifecycle-hooks#aftercontent\">響應被投影內容的變更</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Respond after Angular checks the content projected into the directive or component. <br> See details and example in <a href=\"guide/lifecycle-hooks#aftercontent\">Responding to projected content changes</a> in this document.</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><code>ngAfterContentInit()</code> 和每次 <code>ngDoCheck()</code> 之後呼叫。</nt-wrapper><nt-wrapper translation-origin=\"off\">Called after <code>ngAfterContentInit()</code> and every subsequent <code>ngDoCheck()</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>ngAfterViewInit()</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">當 Angular 初始化完元件檢視及其子檢視或包含該指令的檢視之後呼叫。<br>欲知詳情和範例，參閱本文件中的<a href=\"guide/lifecycle-hooks#afterview\">響應檢視變更</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Respond after Angular initializes the component's views and child views, or the view that contains the directive. <br> See details and example in <a href=\"guide/lifecycle-hooks#afterview\">Responding to view changes</a> in this document.</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">第一次 <code>ngAfterContentChecked()</code> 之後呼叫，只調用一次。</nt-wrapper><nt-wrapper translation-origin=\"off\">Called <em>once</em> after the first <code>ngAfterContentChecked()</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>ngAfterViewChecked()</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">每當 Angular 做完元件檢視和子檢視或包含該指令的檢視的變更檢測之後呼叫。</nt-wrapper><nt-wrapper translation-origin=\"off\">Respond after Angular checks the component's views and child views, or the view that contains the directive.</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\"><code>ngAfterViewInit()</code> 和每次 <code>ngAfterContentChecked()</code> 之後呼叫。</nt-wrapper><nt-wrapper translation-origin=\"off\">Called after the <code>ngAfterViewInit()</code> and every subsequent <code>ngAfterContentChecked()</code>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><code>ngOnDestroy()</code></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">每當 Angular 每次銷燬指令/元件之前呼叫並清掃。在這兒反訂閱可觀察物件和分離事件處理器，以防記憶體洩漏。欲知詳情，參閱本文件中的<a href=\"guide/lifecycle-hooks#ondestroy\">在例項銷燬時進行清理</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Cleanup just before Angular destroys the directive or component. Unsubscribe Observables and detach event handlers to avoid memory leaks. See details in <a href=\"guide/lifecycle-hooks#ondestroy\">Cleaning up on instance destruction</a> in this document.</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在 Angular 銷燬指令或元件之前立即呼叫。</nt-wrapper><nt-wrapper translation-origin=\"off\">Called immediately before Angular destroys the directive or component.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p><a id=\"the-sample\"></a></p>\n<h3 id=\"lifecycle-example-set\" translation-result=\"on\">生命週期範例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-example-set\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Lifecycle example set<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-example-set\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><live-example></live-example>透過在受控於根元件 <code>AppComponent</code> 的一些元件上進行的一系列練習，示範了生命週期鉤子的運作方式。\n每一個例子中，<em>父</em>元件都扮演了<em>子</em>元件測試台的角色，以展示出一個或多個生命週期鉤子方法。</p><p translation-origin=\"off\">The <live-example></live-example> demonstrates the use of lifecycle hooks through a series of exercises presented as components under the control of the root <code>AppComponent</code>.\nIn each case a <em>parent</em> component serves as a test rig for a <em>child</em> component that illustrates one or more of the lifecycle hook methods.</p>\n\n<p translation-result=\"on\">下表列出了這些練習及其簡介。範例程式碼也用來闡明後續各節的一些特定任務。</p><p translation-origin=\"off\">The following table lists the exercises with brief descriptions.\nThe sample code is also used to illustrate specific tasks in the following sections.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">元件</nt-wrapper><nt-wrapper translation-origin=\"off\">Component</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#peek-a-boo\">Peek-a-boo</a></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">展示每個生命週期鉤子，每個鉤子方法都會在螢幕上顯示一條日誌。</nt-wrapper><nt-wrapper translation-origin=\"off\">Demonstrates every lifecycle hook. Each hook method writes to the on-screen log.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#spy\">Spy</a></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">展示瞭如何在自訂指令中使用生命週期鉤子。<code>SpyDirective</code> 實現了 <code>ngOnInit()</code> 和 <code>ngOnDestroy()</code> 鉤子，並且使用它們來觀察和彙報一個元素何時進入或離開當前檢視。</nt-wrapper><nt-wrapper translation-origin=\"off\">Shows how to use lifecycle hooks with a custom directive. The <code>SpyDirective</code> implements the <code>ngOnInit()</code> and <code>ngOnDestroy()</code> hooks, and uses them to watch and report when an element goes in or out of the current view.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#onchanges\">OnChanges</a></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">示範了每當元件的輸入屬性之一發生變化時，Angular 如何呼叫 <code>ngOnChanges()</code> 鉤子。並且示範瞭如何解釋傳給鉤子方法的 <code>changes</code> 物件。</nt-wrapper><nt-wrapper translation-origin=\"off\">Demonstrates how Angular calls the <code>ngOnChanges()</code> hook every time one of the component input properties changes, and shows how to interpret the <code>changes</code> object passed to the hook method.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#docheck\">DoCheck</a></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">實現了一個 <code>ngDoCheck()</code> 方法，透過它可以自訂變更檢測邏輯。監視該鉤子把哪些變更記錄到了日誌中，觀察 Angular 以什麼頻度呼叫這個鉤子。</nt-wrapper><nt-wrapper translation-origin=\"off\">Implements the <code>ngDoCheck()</code> method with custom change detection. Watch the hook post changes to a log to see how often Angular calls this hook.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#afterview\">AfterView</a></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">顯示 Angular 中的<a href=\"guide/glossary#view\" title=\"Definition of view.\">檢視</a>所指的是什麼。示範了 <code>ngAfterViewInit()</code> 和 <code>ngAfterViewChecked()</code> 鉤子。</nt-wrapper><nt-wrapper translation-origin=\"off\">Shows what Angular means by a <a href=\"guide/glossary#view\" title=\"Definition of view.\">view</a>. Demonstrates the <code>ngAfterViewInit()</code> and <code>ngAfterViewChecked()</code> hooks.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#aftercontent\">AfterContent</a></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">展示如何把外部內容投影進元件中，以及如何區分“投影進來的內容”和“元件的子檢視”。示範了 <code>ngAfterContentInit()</code> 和 <code>ngAfterContentChecked()</code> 鉤子。</nt-wrapper><nt-wrapper translation-origin=\"off\">Shows how to project external content into a component and how to distinguish projected content from a component's view children. Demonstrates the <code>ngAfterContentInit()</code> and <code>ngAfterContentChecked()</code> hooks.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><a href=\"guide/lifecycle-hooks#counter\">Counter</a></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">示範了一個元件和一個指令的組合，它們各自有自己的鉤子。</nt-wrapper><nt-wrapper translation-origin=\"off\">Demonstrates a combination of a component and a directive, each with its own hooks.</nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p><a id=\"oninit\"></a></p>\n<h2 id=\"initializing-a-component-or-directive\" translation-result=\"on\">初始化元件或指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#initializing-a-component-or-directive\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Initializing a component or directive<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#initializing-a-component-or-directive\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用 <code>ngOnInit()</code> 方法執行以下初始化任務。</p><p translation-origin=\"off\">Use the <code>ngOnInit()</code> method to perform the following initialization tasks.</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">初始化任務</nt-wrapper><nt-wrapper translation-origin=\"off\">Initialization tasks</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">詳情</nt-wrapper><nt-wrapper translation-origin=\"off\">Details</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在建構函式外部執行復雜的初始化</nt-wrapper><nt-wrapper translation-origin=\"off\">Perform complex initializations outside of the constructor</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">元件的構造應該既便宜又安全。比如，你不應該在元件建構函式中獲取資料。當在測試中建立元件時或者決定顯示它之前，你不應該擔心新元件會嘗試聯絡遠端伺服器。<br><code>ngOnInit()</code> 是元件獲取初始資料的好地方。比如，<a href=\"tutorial/tour-of-heroes/toh-pt4#oninit\">英雄之旅課程</a>。</nt-wrapper><nt-wrapper translation-origin=\"off\">Components should be cheap and safe to construct. You should not, for example, fetch data in a component constructor. You shouldn't worry that a new component will try to contact a remote server when created under test or before you decide to display it. <br> An <code>ngOnInit()</code> is a good place for a component to fetch its initial data. For an example, see the <a href=\"tutorial/tour-of-heroes/toh-pt4#oninit\">Tour of Heroes tutorial</a>.</nt-wrapper></td>\n</tr>\n\n<tr>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">在 Angular 設定好輸入屬性之後設定元件</nt-wrapper><nt-wrapper translation-origin=\"off\">Set up the component after Angular sets the input properties</nt-wrapper></td>\n<td align=\"left\"><nt-wrapper translation-result=\"on\">建構函式應該只把初始區域變數設定為簡單的值。<br> 請記住，只有<em>在構造完成之後</em>才會設定指令的資料繫結輸入屬性。如果要根據這些屬性對指令進行初始化，請在執行 <code>ngOnInit()</code> 時設定它們。<div class=\"alert is-helpful\"> <code>ngOnChanges()</code> 方法是你能存取這些屬性的第一次機會。Angular 會在呼叫 <code>ngOnInit()</code> 之前呼叫 <code>ngOnChanges()</code>，而且之後還會呼叫多次。但它只調用一次 <code>ngOnInit()</code>。</div></nt-wrapper><nt-wrapper translation-origin=\"off\">Constructors should do no more than set the initial local variables to simple values. <br> Keep in mind that a directive's data-bound input properties are not set until <em>after construction</em>. If you need to initialize the directive based on those properties, set them when <code>ngOnInit()</code> runs. <div class=\"alert is-helpful\"> The <code>ngOnChanges()</code> method is your first opportunity to access those properties. Angular calls <code>ngOnChanges()</code> before <code>ngOnInit()</code>, but also many times after that. It only calls <code>ngOnInit()</code> once. </div></nt-wrapper></td>\n</tr>\n\n</tbody>\n</table>\n<p><a id=\"ondestroy\"></a></p>\n<h2 id=\"cleaning-up-on-instance-destruction\" translation-result=\"on\">在例項銷燬時進行清理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#cleaning-up-on-instance-destruction\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Cleaning up on instance destruction<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#cleaning-up-on-instance-destruction\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 提供了幾種方法以便在例項被銷燬時進行清理。</p><p translation-origin=\"off\">Angular provides several ways to clean up when an instance is destroyed.</p>\n\n<h3 id=\"ngondestroy\"><code>ngOnDestroy</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#ngondestroy\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">你可以把清理邏輯放進 <code>ngOnDestroy()</code> 中，這個邏輯就必然會在 Angular 銷燬該指令之前執行。</p><p translation-origin=\"off\">You can put cleanup logic in <code>ngOnDestroy()</code>, the logic that must run before Angular destroys the directive.</p>\n\n<p translation-result=\"on\">這裡是釋放資源的地方，這些資源不會自動被垃圾回收。如果你不這樣做，就存在記憶體洩漏的風險。</p><p translation-origin=\"off\">This is the place to free resources that won't be garbage-collected automatically.\nYou risk memory leaks if you neglect to do so.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">取消訂閱可觀察物件和 DOM 事件。</p><p translation-origin=\"off\">Unsubscribe from Observables and DOM events</p>\n\n</li>\n<li>\n<p translation-result=\"on\">停止 interval 計時器。</p><p translation-origin=\"off\">Stop interval timers</p>\n\n</li>\n<li>\n<p translation-result=\"on\">反註冊該指令在全域或應用服務中註冊過的所有回呼(Callback)。</p><p translation-origin=\"off\">Unregister all callbacks that the directive registered with global or application services</p>\n\n</li>\n</ul>\n<p translation-result=\"on\"><code>ngOnDestroy()</code> 方法也可以用來通知應用程式的其它部分，該元件即將消失。</p><p translation-origin=\"off\">The <code>ngOnDestroy()</code> method is also the time to notify another part of the application that the component is going away.</p>\n\n<h3 id=\"destroyref\">DestroyRef<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#destroyref\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">除了 <code>ngOnDestroy()</code> 之外，你還可以注入 Angular 的 <code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code>，並向它註冊將在閉包上下文被銷燬時呼叫的回呼(Callback)函式。這在建構需要清理的可複用實用工具時很有用。</p><p translation-origin=\"off\">In addition to to <code>ngOnDestroy()</code>, you can inject Angular's <code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code> and register callback functions to be called when the enclosing context is destroyed. This can be useful for building reusable utilities that require cleanup.</p>\n\n<p translation-result=\"on\">使用 <code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code> 註冊回呼(Callback)：</p><p translation-origin=\"off\">Register a callback with the <code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code>:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>(...)\nclass Counter {\n  count = 0;\n  constructor() {\n\t\t// Start a timer to increment the counter every second.\n\t\tconst id = setInterval(() =&gt; this.count++, 1000);\n\n\t\t// Stop the timer when the component is destroyed.\n\t\tconst destroyRef = inject(<a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a>);\n\t\tdestroyRef.onDestroy(() =&gt; clearInterval(id));\n\t}\n}\n</code-example>\n<p translation-result=\"on\">與 <code>ngOnDestroy</code> 一樣，<code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code> 可以在任何 Angular 服務、指令、元件或管道中使用。</p><p translation-origin=\"off\">Like <code>ngOnDestroy</code>, <code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code> works in any Angular service, directive, component, or pipe.</p>\n\n<h3 id=\"takeuntildestroyed\"><code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#takeuntildestroyed\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"alert is-important\">\n<p translation-result=\"on\"><code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code> 函式已經提供了<a href=\"/guide/releases#developer-preview\">開發者預覽版</a>。你已經可以嘗試使用了，但在穩定之前可能會發生變化。</p><p translation-origin=\"off\"><code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code> is available for <a href=\"/guide/releases#developer-preview\">developer preview</a>. It's ready for you to try, but it might change before it is stable.</p>\n\n</div>\n<p translation-result=\"on\">在元件或指令中使用 RxJS Observables 時，你可能希望在元件或指令被銷燬時完成（complete）任何可觀察物件。Angular 的 <code>@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a></code> 套件提供了一個運運算元 <code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code> 來簡化這個常見任務：</p><p translation-origin=\"off\">When using RxJS Observables in components or directives, you may want to complete any observables when the component or directive is destroyed. Angular's <code>@angular/core/<a href=\"api/core/rxjs-interop\" class=\"code-anchor\">rxjs-interop</a></code> package provides an operator, <code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code>, to simplify this common task:</p>\n\n<code-example language=\"ts\">\ndata$ = http.get('...').pipe(<a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a>());\n</code-example>\n<p translation-result=\"on\">預設情況下，必須在注入上下文中呼叫 <code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code> 以便它能存取 <code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code>。如果注入上下文不可用，你可以顯式提供 <code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code>。</p><p translation-origin=\"off\">By default, <code><a href=\"api/core/rxjs-interop/takeUntilDestroyed\" class=\"code-anchor\">takeUntilDestroyed</a></code> must be called in an injection context so that it can access <code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code>. If an injection context isn't available, you can explicitly provide a <code><a href=\"api/core/DestroyRef\" class=\"code-anchor\">DestroyRef</a></code>.</p>\n\n<h2 id=\"general-examples\" translation-result=\"on\">一般性例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#general-examples\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">General examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#general-examples\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">下面的例子展示了各個生命週期事件的呼叫順序和相對頻率，以及如何在元件和指令中單獨使用或同時使用這些鉤子。</p><p translation-origin=\"off\">The following examples demonstrate the call sequence and relative frequency of the various lifecycle events, and how the hooks can be used separately or together for components and directives.</p>\n\n<p><a id=\"peek-a-boo\"></a></p>\n<h3 id=\"sequence-and-frequency-of-all-lifecycle-events\" translation-result=\"on\">所有生命週期事件的順序和頻率<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#sequence-and-frequency-of-all-lifecycle-events\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Sequence and frequency of all lifecycle events<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#sequence-and-frequency-of-all-lifecycle-events\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">為了展示 Angular 如何以預期的順序呼叫鉤子，<code>PeekABooComponent</code> 示範了一個元件中的所有鉤子。</p><p translation-origin=\"off\">To show how Angular calls the hooks in the expected order, the <code>PeekABooComponent</code> demonstrates all of the hooks in one component.</p>\n\n<p translation-result=\"on\">實際上，你很少會（幾乎永遠不會）像這個示範中一樣實現所有這些介面。</p><p translation-origin=\"off\">In practice you would rarely, if ever, implement all of the interfaces the way this demo does.</p>\n\n<p translation-result=\"on\">下列快照反映了使用者單擊 <em>Create...</em> 按鈕，然後單擊 <em>Destroy...</em> 按鈕後的日誌狀態。</p><p translation-origin=\"off\">The following snapshot reflects the state of the log after the user clicked the <strong>Create…</strong> button and then the <strong>Destroy…</strong> button.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Peek-a-boo\" src=\"generated/images/guide/lifecycle-hooks/peek-a-boo.png\" width=\"425\" height=\"564\">\n</div>\n<p translation-result=\"on\">日誌資訊的日誌和所規定的鉤子呼叫順序是一致的：</p><p translation-origin=\"off\">The sequence of log messages follows the prescribed hook calling order:</p>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">鉤子順序</nt-wrapper><nt-wrapper translation-origin=\"off\">Hook order</nt-wrapper></th>\n<th align=\"left\"><nt-wrapper translation-result=\"on\">日誌資訊</nt-wrapper><nt-wrapper translation-origin=\"off\">Log message</nt-wrapper></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\"><code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\"><code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\"><code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\"><code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\"><code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\"><code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\"><code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code></td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\"><code><a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a></code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">注意，該日誌確認了在建立期間那些輸入屬性(這裡是 <code>name</code> 屬性)沒有被賦值。這些輸入屬性要等到 <code>onInit()</code> 中才可用，以便做進一步的初始化。</p><p translation-origin=\"off\">Notice that the log confirms that input properties (the <code>name</code> property in this case) have no assigned values at construction.\nThe input properties are available to the <code>onInit()</code> method for further initialization.</p>\n\n</div>\n<p translation-result=\"on\">如果使用者點選<em>Update Hero</em>按鈕，就會看到另一個 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> 和至少兩組 <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code>、<code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code> 和 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code> 鉤子。注意，這三種鉤子被觸發了<em>很多次</em>，所以讓它們的邏輯儘可能保持精簡是非常重要的！。</p><p translation-origin=\"off\">Had the user clicked the <em>Update Hero</em> button, the log would show another <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> and two more triplets of <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code>, <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code>, and <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code>.\nNotice that these three hooks fire <em>often</em>, so it is important to keep their logic as lean as possible.</p>\n\n<p><a id=\"spy\"></a></p>\n<h3 id=\"use-directives-to-watch-the-dom\" translation-result=\"on\">使用指令來監視 DOM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#use-directives-to-watch-the-dom\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Use directives to watch the DOM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#use-directives-to-watch-the-dom\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">這個 <code>Spy</code> 例子示範瞭如何在指令和元件中使用鉤子方法。<code>SpyDirective</code> 實現了兩個鉤子 <code>ngOnInit()</code> 和 <code>ngOnDestroy()</code>，以便發現被監視的元素什麼時候位於當前檢視中。</p><p translation-origin=\"off\">The <code>Spy</code> example demonstrates how to use the hook method for directives as well as components.\nThe <code>SpyDirective</code> implements two hooks, <code>ngOnInit()</code> and <code>ngOnDestroy()</code>, to discover when a watched element is in the current view.</p>\n\n<p translation-result=\"on\">這個範本將 <code>SpyDirective</code> 應用到由父元件 <code>SpyComponent</code> 管理的 <code><a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 內的 <code>&lt;div&gt;</code> 中。</p><p translation-origin=\"off\">This template applies the <code>SpyDirective</code> to a <code>&lt;div&gt;</code> in the <code><a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> <em>hero</em> repeater managed by the parent <code>SpyComponent</code>.</p>\n\n<p translation-result=\"on\">該例子不執行任何初始化或清理工作。它只是透過記錄指令本身的例項化時間和銷燬時間來追蹤元素在檢視中的出現和消失。</p><p translation-origin=\"off\">The example does not perform any initialization or clean-up.\nIt just tracks the appearance and disappearance of an element in the view by recording when the directive itself is instantiated and destroyed.</p>\n\n<p translation-result=\"on\">像這樣的間諜指令可以深入瞭解你無法直接修改的 DOM 物件。你無法觸及內建 <code>&lt;div&gt;</code> 的實現，也無法修改第三方元件。但你有了一個選項來用指令監視這些元素。</p><p translation-origin=\"off\">A spy directive like this can provide insight into a DOM object that you cannot change directly.\nYou can't access the implementation of a built-in <code>&lt;div&gt;</code>, or modify a third party component.\nYou do have the option to watch these elements with a directive.</p>\n\n<p translation-result=\"on\">這個指令定義了 <code>ngOnInit()</code> 和 <code>ngOnDestroy()</code> 鉤子，它透過一個注入進來的 <code>LoggerService</code> 把訊息記錄到父元件中去。</p><p translation-origin=\"off\">The directive defines <code>ngOnInit()</code> and <code>ngOnDestroy()</code> hooks\nthat log messages to the parent using an injected <code>LoggerService</code>.</p>\n\n<code-example header=\"src/app/spy.directive.ts\" path=\"lifecycle-hooks/src/app/spy.directive.ts\" region=\"spy-directive\">\nlet nextId = 1;\n\n// Spy on any element to which it is applied.\n// Usage: &lt;div appSpy&gt;...&lt;/div&gt;\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[appSpy]'})\nexport class SpyDirective implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n  private id = nextId++;\n\n  constructor(private logger: LoggerService) { }\n\n  ngOnInit() {\n    this.logger.log(`Spy #${this.id} onInit`);\n  }\n\n  ngOnDestroy() {\n    this.logger.log(`Spy #${this.id} onDestroy`);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">你可以把這個偵探指令寫到任何內建元素或元件元素上，以觀察它何時被初始化和銷燬。\n下面是把它附加到用來重複顯示英雄資料的這個 <code>&lt;p&gt;</code> 上。</p><p translation-origin=\"off\">Apply the spy to any built-in or component element, and see that it is initialized and destroyed at the same time as that element.\nHere it is attached to the repeated hero <code>&lt;p&gt;</code>:</p>\n\n<code-example header=\"src/app/spy.component.html\" path=\"lifecycle-hooks/src/app/spy.component.html\" region=\"template\">\n&lt;p *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" appSpy&gt;\n  {{hero}}\n&lt;/p&gt;\n\n</code-example>\n<p translation-result=\"on\">每個“偵探”的建立和銷燬都可以標出英雄所在的那個 <code>&lt;p&gt;</code> 元素的出現和消失。\n新增一個英雄就會產生一個新的英雄 <code>&lt;p&gt;</code> 元素。偵探的 <code>ngOnInit()</code> 記錄下了這個事件。</p><p translation-origin=\"off\">Each spy's creation and destruction marks the appearance and disappearance of the attached hero <code>&lt;p&gt;</code> with an entry in the <em>Hook Log</em>.\nAdding a hero results in a new hero <code>&lt;p&gt;</code>.\nThe spy's <code>ngOnInit()</code> logs that event.</p>\n\n<p translation-result=\"on\"><em>Reset</em> 按鈕清除了這個 <code>heroes</code> 列表。\nAngular 從 DOM 中移除了所有英雄的 <code>&lt;p&gt;</code> 元素，並且同時銷燬了附加在這些 <code>&lt;p&gt;</code> 元素上的偵探指令。\n偵探的 <code>ngOnDestroy()</code> 方法彙報了它自己的臨終時刻。</p><p translation-origin=\"off\">The <em>Reset</em> button clears the <code>heroes</code> list.\nAngular removes all hero <code>&lt;p&gt;</code> elements from the DOM and destroys their spy directives at the same time.\nThe spy's <code>ngOnDestroy()</code> method reports its last moments.</p>\n\n<p><a id=\"counter\"></a></p>\n<h3 id=\"use-component-and-directive-hooks-together\" translation-result=\"on\">同時使用元件和指令的鉤子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#use-component-and-directive-hooks-together\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Use component and directive hooks together<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#use-component-and-directive-hooks-together\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在這個例子中，<code>CounterComponent</code> 使用了 <code>ngOnChanges()</code> 方法，以便在每次父元件遞增其輸入屬性 <code>counter</code> 時記錄一次變更。</p><p translation-origin=\"off\">In this example, a <code>CounterComponent</code> uses the <code>ngOnChanges()</code> method to log a change every time the parent component increments its input <code>counter</code> property.</p>\n\n<p translation-result=\"on\">這個例子將前例中的 <code>SpyDirective</code> 用於 <code>CounterComponent</code> 的日誌，以便監視這些日誌條目的建立和銷燬。</p><p translation-origin=\"off\">This example applies the <code>SpyDirective</code> from the previous example to the <code>CounterComponent</code> log, to watch the creation and destruction of log entries.</p>\n\n<p><a id=\"onchanges\"></a></p>\n<h2 id=\"using-change-detection-hooks\" translation-result=\"on\">使用變更檢測鉤子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#using-change-detection-hooks\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Using change detection hooks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#using-change-detection-hooks\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">一旦檢測到該元件或指令的<strong><em>輸入屬性</em></strong>發生了變化，Angular 就會呼叫它的 <code>ngOnChanges()</code> 方法。這個 <em>onChanges</em> 範例透過監控 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a>()</code> 鉤子示範了這一點。</p><p translation-origin=\"off\">Angular calls the <code>ngOnChanges()</code> method of a component or directive whenever it detects changes to the  <strong><em>input properties</em></strong>.\nThe <em>onChanges</em> example demonstrates this by monitoring the <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a>()</code> hook.</p>\n\n<code-example header=\"on-changes.component.ts (excerpt)\" path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"ng-on-changes\">\nngOnChanges(changes: <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a>) {\n  for (const propName in changes) {\n    const chng = changes[propName];\n    const cur  = JSON.stringify(chng.currentValue);\n    const prev = JSON.stringify(chng.previousValue);\n    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\"><code>ngOnChanges()</code> 方法獲取了一個物件，它把每個發生變化的屬性名都對映到了一個<a href=\"api/core/SimpleChange\">SimpleChange</a>物件，該物件中有屬性的當前值和前一個值。這個鉤子會在這些發生了變化的屬性上進行迭代，並記錄它們。</p><p translation-origin=\"off\">The <code>ngOnChanges()</code> method takes an object that maps each changed property name to a <a href=\"api/core/SimpleChange\">SimpleChange</a> object holding the current and previous property values.\nThis hook iterates over the changed properties and logs them.</p>\n\n<p translation-result=\"on\">這個例子中的 <code>OnChangesComponent</code> 元件有兩個輸入屬性：<code>hero</code> 和 <code>power</code>。</p><p translation-origin=\"off\">The example component, <code>OnChangesComponent</code>, has two input properties: <code>hero</code> and <code>power</code>.</p>\n\n<code-example header=\"src/app/on-changes.component.ts\" path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"inputs\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() power = '';\n\n</code-example>\n<p translation-result=\"on\">宿主 <code>OnChangesParentComponent</code> 綁定了它們，就像這樣。</p><p translation-origin=\"off\">The host <code>OnChangesParentComponent</code> binds to them as follows.</p>\n\n<code-example header=\"src/app/on-changes-parent.component.html\" path=\"lifecycle-hooks/src/app/on-changes-parent.component.html\" region=\"on-changes\">\n&lt;on-changes [hero]=\"hero\" [power]=\"power\"&gt;&lt;/on-changes&gt;\n\n</code-example>\n<p translation-result=\"on\">下面是此例子中的當使用者做出更改時的操作示範。</p><p translation-origin=\"off\">Here's the sample in action as the user makes changes.</p>\n\n<div class=\"lightbox\">\n<img alt=\"OnChanges\" src=\"generated/images/guide/lifecycle-hooks/on-changes-anim.gif\" width=\"632\" height=\"512\">\n</div>\n<p translation-result=\"on\">日誌條目把 <em>power</em> 屬性的變化顯示為字串。但請注意，<code>ngOnChanges()</code> 方法不會捕獲對 <code>hero.name</code> 更改。這是因為只有當輸入屬性的值發生變化時，Angular 才會呼叫該鉤子。在這種情況下，<code>hero</code> 是輸入屬性，<code>hero</code> 屬性的值是<em>對 hero 物件</em>的<em>參考</em>。當它自己的 <code>name</code> 屬性的值發生變化時，物件參考並沒有改變。</p><p translation-origin=\"off\">The log entries appear as the string value of the <em>power</em> property changes.\nNotice, however, that the <code>ngOnChanges()</code> method does not catch changes to <code>hero.name</code>.\nThis is because Angular calls the hook only when the value of the input property changes.\nIn this case, <code>hero</code> is the input property, and the value of the <code>hero</code> property is the <em>reference to the hero object</em>.\nThe object reference did not change when the value of its own <code>name</code> property changed.</p>\n\n<p><a id=\"afterview\"></a></p>\n<h3 id=\"responding-to-view-changes\" translation-result=\"on\">響應檢視的變更<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#responding-to-view-changes\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Responding to view changes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#responding-to-view-changes\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">當 Angular 在變更檢測期間遍歷<a href=\"guide/glossary#view-hierarchy\" title=\"檢視層次結構定義的定義\">檢視樹</a>時，需要確保子元件中的某個變更不會嘗試更改其父元件中的屬性。因為<a href=\"guide/glossary#unidirectional-data-flow\" title=\"定義\">單向資料流</a>的工作原理就是這樣的，這樣的更改將無法正常渲染。</p><p translation-origin=\"off\">As Angular traverses the <a href=\"guide/glossary#view-hierarchy\" title=\"Definition of view hierarchy definition\">view hierarchy</a> during change detection, it needs to be sure that a change in a child does not attempt to cause a change in its own parent.\nSuch a change would not be rendered properly, because of how <a href=\"guide/glossary#unidirectional-data-flow\" title=\"Definition\">unidirectional data flow</a> works.</p>\n\n<p translation-result=\"on\">如果你需要做一個與預期資料流反方向的修改，就必須觸發一個新的變更檢測週期，以允許渲染這種變更。這些例子說明了如何安全地做出這些改變。</p><p translation-origin=\"off\">If you need to make a change that inverts the expected data flow, you must trigger a new change detection cycle to allow that change to be rendered.\nThe examples illustrate how to make such changes safely.</p>\n\n<p translation-result=\"on\"><em>AfterView</em> 例子展示了 <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>()</code> 和 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> 鉤子，Angular 會在每次建立了元件的子檢視後呼叫它們。</p><p translation-origin=\"off\">The <em>AfterView</em> sample explores the <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>()</code> and <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> hooks that Angular calls <em>after</em> it creates a component's child views.</p>\n\n<p translation-result=\"on\">下面是一個子檢視，它用來把英雄的名字顯示在一個 <code>&lt;input&gt;</code> 中：</p><p translation-origin=\"off\">Here's a child view that displays a hero's name in an <code>&lt;input&gt;</code>:</p>\n\n<code-example header=\"ChildViewComponent\" path=\"lifecycle-hooks/src/app/child-view.component.ts\" region=\"child-view\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child-view',\n  template: `\n    &lt;label for=\"hero-name\"&gt;Hero name: &lt;/label&gt;\n    &lt;input type=\"text\" id=\"hero-name\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\"&gt;\n  `\n})\nexport class ChildViewComponent {\n  hero = 'Magneta';\n}\n\n</code-example>\n<p translation-result=\"on\"><code>AfterViewComponent</code> 把這個子檢視顯示<em>在它的範本中</em>：</p><p translation-origin=\"off\">The <code>AfterViewComponent</code> displays this child view <em>within its template</em>:</p>\n\n<code-example header=\"AfterViewComponent (template)\" path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"template\">\ntemplate: `\n  &lt;div&gt;child view begins&lt;/div&gt;\n    &lt;app-child-view&gt;&lt;/app-child-view&gt;\n  &lt;div&gt;child view ends&lt;/div&gt;\n`\n\n</code-example>\n<p translation-result=\"on\">下列鉤子基於<em>子檢視中</em>的每一次資料變更採取行動，它只能透過帶<a href=\"api/core/ViewChild\"><code>@ViewChild</code></a>裝飾器的屬性來存取子檢視。</p><p translation-origin=\"off\">The following hooks take action based on changing values <em>within the child view</em>, which can only be reached by querying for the child view using the property decorated with <a href=\"api/core/ViewChild\"><code>@ViewChild</code></a>.</p>\n\n<code-example header=\"AfterViewComponent (class excerpts)\" path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"hooks\">\nexport class AfterViewComponent implements  <a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>, <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n  private prevHero = '';\n\n  // <a href=\"api/core/Query\" class=\"code-anchor\">Query</a> for a VIEW child of type `ChildViewComponent`\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(ChildViewComponent) viewChild!: ChildViewComponent;\n\n  ngAfterViewInit() {\n    // viewChild is set after the view has been initialized\n    this.logIt('<a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterViewChecked() {\n    // viewChild is updated after the view has been checked\n    if (this.prevHero === this.viewChild.hero) {\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a> (no change)');\n    } else {\n      this.prevHero = this.viewChild.hero;\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<p><a id=\"wait-a-tick\"></a></p>\n<h4 id=\"wait-before-updating-the-view\" translation-result=\"on\">在更新檢視之前等待<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#wait-before-updating-the-view\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Wait before updating the view<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#wait-before-updating-the-view\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在這個例子中，當英雄名字超過 10 個字元時，<code>doSomething()</code> 方法會更新螢幕，但在更新 <code>comment</code> 之前會等一個節拍（tick）。</p><p translation-origin=\"off\">In this example, the <code>doSomething()</code> method updates the screen when the hero name exceeds 10 characters, but waits a tick before updating <code>comment</code>.</p>\n\n<code-example header=\"AfterViewComponent (doSomething)\" path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"do-something\">\n// This surrogate for real business logic sets the `comment`\nprivate doSomething() {\n  const c = this.viewChild.hero.length &gt; 10 ? \"That's a long name\" : '';\n  if (c !== this.comment) {\n    // Wait a <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> because the component's view has already been checked\n    this.logger.tick_then(() =&gt; this.comment = c);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">在元件的檢視合成完之後，就會觸發 <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>()</code> 和 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> 鉤子。如果你修改了這段程式碼，讓這個鉤子立即修改該元件的資料繫結屬性 <code>comment</code>，你就會發現 Angular 丟擲一個錯誤。</p><p translation-origin=\"off\">Both the <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>()</code> and <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> hooks fire after the component's view is composed.\nIf you modify the code so that the hook updates the component's data-bound <code>comment</code> property immediately, you can see that Angular throws an error.</p>\n\n<p translation-result=\"on\"><code>LoggerService.tick_then()</code> 陳述式把日誌的更新工作推遲了一個瀏覽器 JavaScript 週期，也就觸發了一個新的變更檢測週期。</p><p translation-origin=\"off\">The <code>LoggerService.tick_then()</code> statement postpones the log update for one turn of the browser's JavaScript cycle, which triggers a new change-detection cycle.</p>\n\n<h4 id=\"write-lean-hook-methods-to-avoid-performance-problems\" translation-result=\"on\">編寫精簡的鉤子方法來避免效能問題<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#write-lean-hook-methods-to-avoid-performance-problems\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Write lean hook methods to avoid performance problems<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#write-lean-hook-methods-to-avoid-performance-problems\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">當你執行 <em>AfterView</em> 範例時，請注意當沒有發生任何需要注意的變化時，Angular 仍然會頻繁的呼叫 <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code>。要非常小心你放到這些方法中的邏輯或計算量。</p><p translation-origin=\"off\">When you run the <em>AfterView</em> sample, notice how frequently Angular calls <code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> - often when there are no changes of interest.\nBe careful about how much logic or computation you put into one of these methods.</p>\n\n<div class=\"lightbox\">\n<img alt=\"AfterView\" src=\"generated/images/guide/lifecycle-hooks/after-view-anim.gif\" width=\"520\" height=\"532\">\n</div>\n<p><a id=\"aftercontent\"></a>\n<a id=\"aftercontent-hooks\"></a></p>\n<p><a id=\"content-projection\"></a></p>\n<h3 id=\"responding-to-projected-content-changes\" translation-result=\"on\">響應被投影內容的變更<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#responding-to-projected-content-changes\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\">Responding to projected content changes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#responding-to-projected-content-changes\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><em>內容投影</em>是從元件外部匯入 HTML 內容，並把它插入在元件範本中指定位置上的一種途徑。可以在目標中透過查詢下列結構來認出內容投影。</p><p translation-origin=\"off\"><em>Content projection</em> is a way to import HTML content from outside the component and insert that content  into the component's template in a designated spot.\nIdentify content projection in a template by looking for the following constructs.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">元素標籤中間的 HTML</p><p translation-origin=\"off\">HTML between component element tags</p>\n\n</li>\n<li>\n<p translation-result=\"on\">元件範本中的 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 標籤</p><p translation-origin=\"off\">The presence of <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> tags in the component's template</p>\n\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">AngularJS 的開發者把這種技術叫做 <em>transclusion</em>。</p><p translation-origin=\"off\">AngularJS developers know this technique as <em>transclusion</em>.</p>\n\n</div>\n<p translation-result=\"on\">這個 <em>AfterContent</em> 例子探索了 <code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>()</code> 和 <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>()</code> 鉤子。Angular 會在把外部內容投影進該元件時呼叫它們。</p><p translation-origin=\"off\">The <em>AfterContent</em> sample explores the <code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>()</code> and <code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>()</code> hooks that Angular calls <em>after</em> Angular projects external content into the component.</p>\n\n<p translation-result=\"on\">對比<a href=\"guide/lifecycle-hooks#afterview\">前面的 AfterView</a> 例子考慮這個變化。\n這次不再透過範本來把子檢視包含進來，而是改為從 <code>AfterContentComponent</code> 的父元件中匯入它。下面是父元件的範本：</p><p translation-origin=\"off\">Consider this variation on the <a href=\"guide/lifecycle-hooks#afterview\">previous <em>AfterView</em></a> example.\nThis time, instead of including the child view within the template, it imports the content from the <code>AfterContentComponent</code> hook's parent.\nThe following is the parent's template.</p>\n\n<code-example header=\"AfterContentParentComponent (template excerpt)\" path=\"lifecycle-hooks/src/app/after-content-parent.component.ts\" region=\"parent-template\">\n`&lt;after-content&gt;\n  &lt;app-child&gt;&lt;/app-child&gt;\n&lt;/after-content&gt;`\n\n</code-example>\n<p translation-result=\"on\">注意，<code>&lt;app-child&gt;</code> 標籤被包含在 <code>&lt;after-content&gt;</code> 標籤中。永遠不要在元件標籤的內部放任何內容 —— <em>除非你想把這些內容投影進這個元件中</em>。</p><p translation-origin=\"off\">Notice that the <code>&lt;app-child&gt;</code> tag is tucked between the <code>&lt;after-content&gt;</code> tags.\nNever put content between a component's element tags <em>unless you intend to project that content into the component</em>.</p>\n\n<p translation-result=\"on\">現在來看該元件的範本。</p><p translation-origin=\"off\">Now look at the component's template.</p>\n\n<code-example header=\"AfterContentComponent (template)\" path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"template\">\ntemplate: `\n  &lt;div&gt;projected content begins&lt;/div&gt;\n    &lt;ng-content&gt;&lt;/ng-content&gt;\n  &lt;div&gt;projected content ends&lt;/div&gt;\n`\n\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> 標籤是外來內容的<em>佔位符</em>。它告訴 Angular 在哪裡插入這些外來內容。在這裡，被投影進去的內容就是來自父元件的 <code>&lt;app-child&gt;</code> 標籤。</p><p translation-origin=\"off\">The <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&lt;ng-content&gt;</a></code> tag is a <em>placeholder</em> for the external content.\nIt tells Angular where to insert that content.\nIn this case, the projected content is the <code>&lt;app-child&gt;</code> from the parent.</p>\n\n<div class=\"lightbox\">\n<img alt=\"Projected Content\" src=\"generated/images/guide/lifecycle-hooks/projected-child-view.png\" width=\"230\" height=\"89\">\n</div>\n<h4 id=\"using-aftercontent-hooks\" translation-result=\"on\">使用 AfterContent 鉤子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#using-aftercontent-hooks\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\">Using AfterContent hooks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#using-aftercontent-hooks\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><em>AfterContent</em> 鉤子和 <em>AfterView</em> 相似。關鍵的不同點是子元件的型別不同。</p><p translation-origin=\"off\"><em>AfterContent</em> hooks are similar to the <em>AfterView</em> hooks.\nThe key difference is in the child component.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><em>AfterView</em> 鉤子所關心的是 <code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code>，這些子元件的元素標籤會出現在該元件的範本<em>裡面</em></p><p translation-origin=\"off\">The <em>AfterView</em> hooks concern <code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code>, the child components whose element tags appear <em>within</em> the component's template</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><em>AfterContent</em> 鉤子所關心的是 <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>，這些子元件被 Angular 投影進該元件中</p><p translation-origin=\"off\">The <em>AfterContent</em> hooks concern <code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>, the child components that Angular projected into the component</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">下列 <em>AfterContent</em> 鉤子基於<em>子級內容</em>中值的變化而採取相應的行動，它只能透過帶有<a href=\"api/core/ContentChild\"><code>@ContentChild</code></a>裝飾器的屬性來查詢到“子級內容”。</p><p translation-origin=\"off\">The following <em>AfterContent</em> hooks take action based on changing values in a <em>content child</em>, which can only be reached by querying for them using the property decorated with <a href=\"api/core/ContentChild\"><code>@ContentChild</code></a>.</p>\n\n<code-example header=\"AfterContentComponent (class excerpts)\" path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"hooks\">\nexport class AfterContentComponent implements <a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>, <a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a> {\n  private prevHero = '';\n  comment = '';\n\n  // <a href=\"api/core/Query\" class=\"code-anchor\">Query</a> for a CONTENT child of type `ChildComponent`\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(ChildComponent) contentChild!: ChildComponent;\n\n  ngAfterContentInit() {\n    // contentChild is set after the content has been initialized\n    this.logIt('<a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterContentChecked() {\n    // contentChild is updated after the content has been checked\n    if (this.prevHero === this.contentChild.hero) {\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a> (no change)');\n    } else {\n      this.prevHero = this.contentChild.hero;\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<p><a id=\"no-unidirectional-flow-worries\"></a></p>\n<div class=\"callout is-helpful\">\n<header ng-should-translate=\"\" translation-result=\"on\">不需要等待內容更新</header><header ng-should-translate=\"\" translation-origin=\"off\">No need to wait for content updates</header>\n\n<p translation-result=\"on\">該元件的 <code>doSomething()</code> 方法會立即更新該元件的資料繫結屬性 <code>comment</code>。而無需<a href=\"guide/lifecycle-hooks#wait-a-tick\" title=\"延遲更新\">延遲更新以確保正確渲染</a>。</p><p translation-origin=\"off\">This component's <code>doSomething()</code> method updates the component's data-bound <code>comment</code> property immediately.\nThere's no need to <a href=\"guide/lifecycle-hooks#wait-a-tick\" title=\"Delaying updates\">delay the update to ensure proper rendering</a>.</p>\n\n<p translation-result=\"on\">Angular 在呼叫 <em>AfterView</em> 鉤子之前，就已呼叫完所有的 <em>AfterContent</em> 鉤子。在完成該元件檢視的合成<em>之前</em>，Angular 就已經完成了所投影內容的合成工作。<code>AfterContent...</code> 和 <code>AfterView...</code> 鉤子之間有一個小的時間窗，允許你修改宿主檢視。</p><p translation-origin=\"off\">Angular calls both <em>AfterContent</em> hooks before calling either of the <em>AfterView</em> hooks.\nAngular completes composition of the projected content <em>before</em> finishing the composition of this component's view.\nThere is a small window between the <code>AfterContent...</code> and <code>AfterView...</code> hooks that lets you modify the host view.</p>\n\n</div>\n<p><a id=\"docheck\"></a></p>\n<h2 id=\"defining-custom-change-detection\" translation-result=\"on\">自訂變更檢測邏輯<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#defining-custom-change-detection\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\">Defining custom change detection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#defining-custom-change-detection\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要監控 <code>ngOnChanges()</code> 無法捕獲的變更，你可以實現自己的變更檢查邏輯，比如 <em>DoCheck</em> 的例子。這個例子展示了你如何使用 <code>ngDoCheck()</code> 鉤子來檢測和處理 Angular 自己沒有捕捉到的變化。</p><p translation-origin=\"off\">To monitor changes that occur where <code>ngOnChanges()</code> won't catch them, implement your own change check, as shown in the <em>DoCheck</em> example.\nThis example shows how to use the <code>ngDoCheck()</code> hook to detect and act upon changes that Angular doesn't catch on its own.</p>\n\n<p translation-result=\"on\"><em>DoCheck</em> 範例使用下面的 <code>ngDoCheck()</code> 鉤子擴充了 <em>OnChanges</em> 範例：</p><p translation-origin=\"off\">The <em>DoCheck</em> sample extends the <em>OnChanges</em> sample with the following <code>ngDoCheck()</code> hook:</p>\n\n<code-example header=\"DoCheckComponent (ngDoCheck)\" path=\"lifecycle-hooks/src/app/do-check.component.ts\" region=\"ng-do-check\">\nngDoCheck() {\n\n  if (this.hero.name !== this.oldHeroName) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"`);\n    this.oldHeroName = this.hero.name;\n  }\n\n  if (this.power !== this.oldPower) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Power changed to \"${this.power}\" from \"${this.oldPower}\"`);\n    this.oldPower = this.power;\n  }\n\n  if (this.changeDetected) {\n      this.noChangeCount = 0;\n  } else {\n      // log that hook was called when there was no relevant change.\n      const count = this.noChangeCount += 1;\n      const noChangeMsg = `<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a> called ${count}x when no change to hero or power`;\n      if (count === 1) {\n        // add new \"no change\" message\n        this.changeLog.push(noChangeMsg);\n      } else {\n        // update last \"no change\" message\n        this.changeLog[this.changeLog.length - 1] = noChangeMsg;\n      }\n  }\n\n  this.changeDetected = false;\n}\n\n</code-example>\n<p translation-result=\"on\">這段程式碼會檢查某些<em>感興趣的值</em>，捕獲並把它們當前的狀態和之前的進行比較。當 <code>hero</code> 或 <code>power</code> 沒有實質性變化時，它就會在日誌中寫一條特殊的資訊，這樣你就能看到 <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>()</code> 被呼叫的頻率。其結果很有啟發性。</p><p translation-origin=\"off\">This code inspects certain <em>values of interest</em>, capturing and comparing their current state against previous values.\nIt writes a special message to the log when there are no substantive changes to the <code>hero</code> or the <code>power</code> so you can see how often <code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>()</code> is called.\nThe results are illuminating.</p>\n\n<div class=\"lightbox\">\n<img alt=\"DoCheck\" src=\"generated/images/guide/lifecycle-hooks/do-check-anim.gif\" width=\"632\" height=\"588\">\n</div>\n<p translation-result=\"on\">雖然 <code>ngDoCheck()</code> 鉤子可以檢測出英雄的 <code>name</code> 何時發生了變化，但卻非常昂貴。無論變化發生在何處，<em>每個</em>變化檢測週期<em>都會</em>以很大的頻率呼叫這個鉤子。在使用者可以執行任何操作之前，本例中已經呼叫了二十多次。</p><p translation-origin=\"off\">While the <code>ngDoCheck()</code> hook can detect when the hero's <code>name</code> has changed, it is an expensive hook.\nThis hook is called with enormous frequency —after <em>every</em> change detection cycle no matter where the change occurred.\nIt's called over twenty times in this example before the user can do anything.</p>\n\n<p translation-result=\"on\">這些初始化檢查大部分都是由 Angular 首次<em>在頁面的其它地方</em>渲染<em>不相關的資料</em>觸發的。只要把游標移動到另一個 <code>&lt;input&gt;</code> 就會觸發一次呼叫。其中的少數呼叫揭示了相關資料的實際變化情況。如果使用這個鉤子，那麼你的實現必須非常輕量級，否則會損害使用者體驗。</p><p translation-origin=\"off\">Most of these initial checks are triggered by Angular's first rendering of <em>unrelated data elsewhere on the page</em>.\nJust moving the cursor into another <code>&lt;input&gt;</code> triggers a call.\nRelatively few calls reveal actual changes to pertinent data.\nIf you use this hook, your implementation must be extremely lightweight or the user experience suffers.</p>\n\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最後複查時間：2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/ChangeDetectorRef\n - api/core/Component\n - api/core/Directive\n - api/core/DoCheck\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - errors/NG0100\n - guide/architecture-components\n - guide/architecture-next-steps\n - guide/component-interaction\n - guide/example-apps-list\n - guide/glossary\n - guide/inputs-outputs\n - guide/lightweight-injection-tokens\n - guide/module-types\n - guide/testing-components-basics\n - guide/testing-components-scenarios\n - guide/upgrade\n - tutorial/tour-of-heroes/toh-pt4\n - tutorial/tour-of-heroes/toh-pt5\n-->\n<!-- links from this doc:\n - /guide/releases#developer-preview\n - api/common/NgFor\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/DestroyRef\n - api/core/Directive\n - api/core/DoCheck\n - api/core/Input\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/Query\n - api/core/SimpleChange\n - api/core/SimpleChanges\n - api/core/ViewChild\n - api/core/ViewChildren\n - api/core/ng-content\n - api/core/rxjs-interop\n - api/core/rxjs-interop/takeUntilDestroyed\n - api/core/testing/tick\n - api/forms/NgModel\n - guide/architecture\n - guide/glossary#lifecycle-hook\n - guide/glossary#unidirectional-data-flow\n - guide/glossary#view\n - guide/glossary#view-hierarchy\n - guide/lifecycle-hooks#aftercontent\n - guide/lifecycle-hooks#afterview\n - guide/lifecycle-hooks#cleaning-up-on-instance-destruction\n - guide/lifecycle-hooks#component-lifecycle\n - guide/lifecycle-hooks#counter\n - guide/lifecycle-hooks#defining-custom-change-detection\n - guide/lifecycle-hooks#destroyref\n - guide/lifecycle-hooks#docheck\n - guide/lifecycle-hooks#general-examples\n - guide/lifecycle-hooks#initializing-a-component-or-directive\n - guide/lifecycle-hooks#lifecycle-event-sequence\n - guide/lifecycle-hooks#lifecycle-example-set\n - guide/lifecycle-hooks#ngondestroy\n - guide/lifecycle-hooks#onchanges\n - guide/lifecycle-hooks#ondestroy\n - guide/lifecycle-hooks#oninit\n - guide/lifecycle-hooks#peek-a-boo\n - guide/lifecycle-hooks#prerequisites\n - guide/lifecycle-hooks#responding-to-lifecycle-events\n - guide/lifecycle-hooks#responding-to-projected-content-changes\n - guide/lifecycle-hooks#responding-to-view-changes\n - guide/lifecycle-hooks#sequence-and-frequency-of-all-lifecycle-events\n - guide/lifecycle-hooks#spy\n - guide/lifecycle-hooks#takeuntildestroyed\n - guide/lifecycle-hooks#use-component-and-directive-hooks-together\n - guide/lifecycle-hooks#use-directives-to-watch-the-dom\n - guide/lifecycle-hooks#using-aftercontent-hooks\n - guide/lifecycle-hooks#using-change-detection-hooks\n - guide/lifecycle-hooks#wait-a-tick\n - guide/lifecycle-hooks#wait-before-updating-the-view\n - guide/lifecycle-hooks#write-lean-hook-methods-to-avoid-performance-problems\n - guide/lifecycle-hooks#一般性例子\n - guide/lifecycle-hooks#使用-aftercontent-鉤子\n - guide/lifecycle-hooks#使用變更檢測鉤子\n - guide/lifecycle-hooks#使用指令來監視-dom\n - guide/lifecycle-hooks#初始化元件或指令\n - guide/lifecycle-hooks#前提條件\n - guide/lifecycle-hooks#同時使用元件和指令的鉤子\n - guide/lifecycle-hooks#響應生命週期事件\n - guide/lifecycle-hooks#響應被投影內容的變更\n - guide/lifecycle-hooks#響應檢視的變更\n - guide/lifecycle-hooks#在例項銷燬時進行清理\n - guide/lifecycle-hooks#在更新檢視之前等待\n - guide/lifecycle-hooks#所有生命週期事件的順序和頻率\n - guide/lifecycle-hooks#生命週期的順序\n - guide/lifecycle-hooks#生命週期範例\n - guide/lifecycle-hooks#元件的生命週期\n - guide/lifecycle-hooks#編寫精簡的鉤子方法來避免效能問題\n - guide/lifecycle-hooks#自訂變更檢測邏輯\n - tutorial/tour-of-heroes/toh-pt4#oninit\n - https://github.com/ng-docs/angular-cn/edit/cn/aio/content/guide/lifecycle-hooks.md?message=docs%3A%20請簡述你的修改...\n - https://www.typescriptlang.org\n-->"}